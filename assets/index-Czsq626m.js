(function () {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const a of document.querySelectorAll('link[rel="modulepreload"]')) n(a);
  new MutationObserver((a) => {
    for (const r of a)
      if (r.type === "childList")
        for (const l of r.addedNodes)
          l.tagName === "LINK" && l.rel === "modulepreload" && n(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function e(a) {
    const r = {};
    return (
      a.integrity && (r.integrity = a.integrity),
      a.referrerPolicy && (r.referrerPolicy = a.referrerPolicy),
      a.crossOrigin === "use-credentials"
        ? (r.credentials = "include")
        : a.crossOrigin === "anonymous"
        ? (r.credentials = "omit")
        : (r.credentials = "same-origin"),
      r
    );
  }
  function n(a) {
    if (a.ep) return;
    a.ep = !0;
    const r = e(a);
    fetch(a.href, r);
  }
})();
function CA(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default")
    ? i.default
    : i;
}
var $1 = { exports: {} },
  Mm = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var eE;
function WD() {
  if (eE) return Mm;
  eE = 1;
  var i = Symbol.for("react.transitional.element"),
    t = Symbol.for("react.fragment");
  function e(n, a, r) {
    var l = null;
    if (
      (r !== void 0 && (l = "" + r),
      a.key !== void 0 && (l = "" + a.key),
      "key" in a)
    ) {
      r = {};
      for (var u in a) u !== "key" && (r[u] = a[u]);
    } else r = a;
    return (
      (a = r.ref),
      { $$typeof: i, type: n, key: l, ref: a !== void 0 ? a : null, props: r }
    );
  }
  return (Mm.Fragment = t), (Mm.jsx = e), (Mm.jsxs = e), Mm;
}
var nE;
function k2() {
  return nE || ((nE = 1), ($1.exports = WD())), $1.exports;
}
var O = k2(),
  t_ = { exports: {} },
  An = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var iE;
function YD() {
  if (iE) return An;
  iE = 1;
  var i = Symbol.for("react.transitional.element"),
    t = Symbol.for("react.portal"),
    e = Symbol.for("react.fragment"),
    n = Symbol.for("react.strict_mode"),
    a = Symbol.for("react.profiler"),
    r = Symbol.for("react.consumer"),
    l = Symbol.for("react.context"),
    u = Symbol.for("react.forward_ref"),
    h = Symbol.for("react.suspense"),
    p = Symbol.for("react.memo"),
    m = Symbol.for("react.lazy"),
    v = Symbol.iterator;
  function x(X) {
    return X === null || typeof X != "object"
      ? null
      : ((X = (v && X[v]) || X["@@iterator"]),
        typeof X == "function" ? X : null);
  }
  var _ = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    M = Object.assign,
    C = {};
  function E(X, ft, At) {
    (this.props = X),
      (this.context = ft),
      (this.refs = C),
      (this.updater = At || _);
  }
  (E.prototype.isReactComponent = {}),
    (E.prototype.setState = function (X, ft) {
      if (typeof X != "object" && typeof X != "function" && X != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, X, ft, "setState");
    }),
    (E.prototype.forceUpdate = function (X) {
      this.updater.enqueueForceUpdate(this, X, "forceUpdate");
    });
  function S() {}
  S.prototype = E.prototype;
  function R(X, ft, At) {
    (this.props = X),
      (this.context = ft),
      (this.refs = C),
      (this.updater = At || _);
  }
  var B = (R.prototype = new S());
  (B.constructor = R), M(B, E.prototype), (B.isPureReactComponent = !0);
  var D = Array.isArray,
    I = { H: null, A: null, T: null, S: null, V: null },
    P = Object.prototype.hasOwnProperty;
  function V(X, ft, At, Rt, ht, It) {
    return (
      (At = It.ref),
      {
        $$typeof: i,
        type: X,
        key: ft,
        ref: At !== void 0 ? At : null,
        props: It,
      }
    );
  }
  function F(X, ft) {
    return V(X.type, ft, void 0, void 0, void 0, X.props);
  }
  function N(X) {
    return typeof X == "object" && X !== null && X.$$typeof === i;
  }
  function L(X) {
    var ft = { "=": "=0", ":": "=2" };
    return (
      "$" +
      X.replace(/[=:]/g, function (At) {
        return ft[At];
      })
    );
  }
  var Y = /\/+/g;
  function ct(X, ft) {
    return typeof X == "object" && X !== null && X.key != null
      ? L("" + X.key)
      : ft.toString(36);
  }
  function nt() {}
  function dt(X) {
    switch (X.status) {
      case "fulfilled":
        return X.value;
      case "rejected":
        throw X.reason;
      default:
        switch (
          (typeof X.status == "string"
            ? X.then(nt, nt)
            : ((X.status = "pending"),
              X.then(
                function (ft) {
                  X.status === "pending" &&
                    ((X.status = "fulfilled"), (X.value = ft));
                },
                function (ft) {
                  X.status === "pending" &&
                    ((X.status = "rejected"), (X.reason = ft));
                }
              )),
          X.status)
        ) {
          case "fulfilled":
            return X.value;
          case "rejected":
            throw X.reason;
        }
    }
    throw X;
  }
  function pt(X, ft, At, Rt, ht) {
    var It = typeof X;
    (It === "undefined" || It === "boolean") && (X = null);
    var Pt = !1;
    if (X === null) Pt = !0;
    else
      switch (It) {
        case "bigint":
        case "string":
        case "number":
          Pt = !0;
          break;
        case "object":
          switch (X.$$typeof) {
            case i:
            case t:
              Pt = !0;
              break;
            case m:
              return (Pt = X._init), pt(Pt(X._payload), ft, At, Rt, ht);
          }
      }
    if (Pt)
      return (
        (ht = ht(X)),
        (Pt = Rt === "" ? "." + ct(X, 0) : Rt),
        D(ht)
          ? ((At = ""),
            Pt != null && (At = Pt.replace(Y, "$&/") + "/"),
            pt(ht, ft, At, "", function (Fe) {
              return Fe;
            }))
          : ht != null &&
            (N(ht) &&
              (ht = F(
                ht,
                At +
                  (ht.key == null || (X && X.key === ht.key)
                    ? ""
                    : ("" + ht.key).replace(Y, "$&/") + "/") +
                  Pt
              )),
            ft.push(ht)),
        1
      );
    Pt = 0;
    var re = Rt === "" ? "." : Rt + ":";
    if (D(X))
      for (var ie = 0; ie < X.length; ie++)
        (Rt = X[ie]), (It = re + ct(Rt, ie)), (Pt += pt(Rt, ft, At, It, ht));
    else if (((ie = x(X)), typeof ie == "function"))
      for (X = ie.call(X), ie = 0; !(Rt = X.next()).done; )
        (Rt = Rt.value),
          (It = re + ct(Rt, ie++)),
          (Pt += pt(Rt, ft, At, It, ht));
    else if (It === "object") {
      if (typeof X.then == "function") return pt(dt(X), ft, At, Rt, ht);
      throw (
        ((ft = String(X)),
        Error(
          "Objects are not valid as a React child (found: " +
            (ft === "[object Object]"
              ? "object with keys {" + Object.keys(X).join(", ") + "}"
              : ft) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    }
    return Pt;
  }
  function j(X, ft, At) {
    if (X == null) return X;
    var Rt = [],
      ht = 0;
    return (
      pt(X, Rt, "", "", function (It) {
        return ft.call(At, It, ht++);
      }),
      Rt
    );
  }
  function Q(X) {
    if (X._status === -1) {
      var ft = X._result;
      (ft = ft()),
        ft.then(
          function (At) {
            (X._status === 0 || X._status === -1) &&
              ((X._status = 1), (X._result = At));
          },
          function (At) {
            (X._status === 0 || X._status === -1) &&
              ((X._status = 2), (X._result = At));
          }
        ),
        X._status === -1 && ((X._status = 0), (X._result = ft));
    }
    if (X._status === 1) return X._result.default;
    throw X._result;
  }
  var et =
    typeof reportError == "function"
      ? reportError
      : function (X) {
          if (
            typeof window == "object" &&
            typeof window.ErrorEvent == "function"
          ) {
            var ft = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof X == "object" &&
                X !== null &&
                typeof X.message == "string"
                  ? String(X.message)
                  : String(X),
              error: X,
            });
            if (!window.dispatchEvent(ft)) return;
          } else if (
            typeof process == "object" &&
            typeof process.emit == "function"
          ) {
            process.emit("uncaughtException", X);
            return;
          }
          console.error(X);
        };
  function xt() {}
  return (
    (An.Children = {
      map: j,
      forEach: function (X, ft, At) {
        j(
          X,
          function () {
            ft.apply(this, arguments);
          },
          At
        );
      },
      count: function (X) {
        var ft = 0;
        return (
          j(X, function () {
            ft++;
          }),
          ft
        );
      },
      toArray: function (X) {
        return (
          j(X, function (ft) {
            return ft;
          }) || []
        );
      },
      only: function (X) {
        if (!N(X))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return X;
      },
    }),
    (An.Component = E),
    (An.Fragment = e),
    (An.Profiler = a),
    (An.PureComponent = R),
    (An.StrictMode = n),
    (An.Suspense = h),
    (An.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = I),
    (An.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (X) {
        return I.H.useMemoCache(X);
      },
    }),
    (An.cache = function (X) {
      return function () {
        return X.apply(null, arguments);
      };
    }),
    (An.cloneElement = function (X, ft, At) {
      if (X == null)
        throw Error(
          "The argument must be a React element, but you passed " + X + "."
        );
      var Rt = M({}, X.props),
        ht = X.key,
        It = void 0;
      if (ft != null)
        for (Pt in (ft.ref !== void 0 && (It = void 0),
        ft.key !== void 0 && (ht = "" + ft.key),
        ft))
          !P.call(ft, Pt) ||
            Pt === "key" ||
            Pt === "__self" ||
            Pt === "__source" ||
            (Pt === "ref" && ft.ref === void 0) ||
            (Rt[Pt] = ft[Pt]);
      var Pt = arguments.length - 2;
      if (Pt === 1) Rt.children = At;
      else if (1 < Pt) {
        for (var re = Array(Pt), ie = 0; ie < Pt; ie++)
          re[ie] = arguments[ie + 2];
        Rt.children = re;
      }
      return V(X.type, ht, void 0, void 0, It, Rt);
    }),
    (An.createContext = function (X) {
      return (
        (X = {
          $$typeof: l,
          _currentValue: X,
          _currentValue2: X,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        }),
        (X.Provider = X),
        (X.Consumer = { $$typeof: r, _context: X }),
        X
      );
    }),
    (An.createElement = function (X, ft, At) {
      var Rt,
        ht = {},
        It = null;
      if (ft != null)
        for (Rt in (ft.key !== void 0 && (It = "" + ft.key), ft))
          P.call(ft, Rt) &&
            Rt !== "key" &&
            Rt !== "__self" &&
            Rt !== "__source" &&
            (ht[Rt] = ft[Rt]);
      var Pt = arguments.length - 2;
      if (Pt === 1) ht.children = At;
      else if (1 < Pt) {
        for (var re = Array(Pt), ie = 0; ie < Pt; ie++)
          re[ie] = arguments[ie + 2];
        ht.children = re;
      }
      if (X && X.defaultProps)
        for (Rt in ((Pt = X.defaultProps), Pt))
          ht[Rt] === void 0 && (ht[Rt] = Pt[Rt]);
      return V(X, It, void 0, void 0, null, ht);
    }),
    (An.createRef = function () {
      return { current: null };
    }),
    (An.forwardRef = function (X) {
      return { $$typeof: u, render: X };
    }),
    (An.isValidElement = N),
    (An.lazy = function (X) {
      return { $$typeof: m, _payload: { _status: -1, _result: X }, _init: Q };
    }),
    (An.memo = function (X, ft) {
      return { $$typeof: p, type: X, compare: ft === void 0 ? null : ft };
    }),
    (An.startTransition = function (X) {
      var ft = I.T,
        At = {};
      I.T = At;
      try {
        var Rt = X(),
          ht = I.S;
        ht !== null && ht(At, Rt),
          typeof Rt == "object" &&
            Rt !== null &&
            typeof Rt.then == "function" &&
            Rt.then(xt, et);
      } catch (It) {
        et(It);
      } finally {
        I.T = ft;
      }
    }),
    (An.unstable_useCacheRefresh = function () {
      return I.H.useCacheRefresh();
    }),
    (An.use = function (X) {
      return I.H.use(X);
    }),
    (An.useActionState = function (X, ft, At) {
      return I.H.useActionState(X, ft, At);
    }),
    (An.useCallback = function (X, ft) {
      return I.H.useCallback(X, ft);
    }),
    (An.useContext = function (X) {
      return I.H.useContext(X);
    }),
    (An.useDebugValue = function () {}),
    (An.useDeferredValue = function (X, ft) {
      return I.H.useDeferredValue(X, ft);
    }),
    (An.useEffect = function (X, ft, At) {
      var Rt = I.H;
      if (typeof At == "function")
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return Rt.useEffect(X, ft);
    }),
    (An.useId = function () {
      return I.H.useId();
    }),
    (An.useImperativeHandle = function (X, ft, At) {
      return I.H.useImperativeHandle(X, ft, At);
    }),
    (An.useInsertionEffect = function (X, ft) {
      return I.H.useInsertionEffect(X, ft);
    }),
    (An.useLayoutEffect = function (X, ft) {
      return I.H.useLayoutEffect(X, ft);
    }),
    (An.useMemo = function (X, ft) {
      return I.H.useMemo(X, ft);
    }),
    (An.useOptimistic = function (X, ft) {
      return I.H.useOptimistic(X, ft);
    }),
    (An.useReducer = function (X, ft, At) {
      return I.H.useReducer(X, ft, At);
    }),
    (An.useRef = function (X) {
      return I.H.useRef(X);
    }),
    (An.useState = function (X) {
      return I.H.useState(X);
    }),
    (An.useSyncExternalStore = function (X, ft, At) {
      return I.H.useSyncExternalStore(X, ft, At);
    }),
    (An.useTransition = function () {
      return I.H.useTransition();
    }),
    (An.version = "19.1.0"),
    An
  );
}
var aE;
function nh() {
  return aE || ((aE = 1), (t_.exports = YD())), t_.exports;
}
var bt = nh();
const RA = CA(bt);
var e_ = { exports: {} },
  Em = {},
  n_ = { exports: {} },
  i_ = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var sE;
function qD() {
  return (
    sE ||
      ((sE = 1),
      (function (i) {
        function t(j, Q) {
          var et = j.length;
          j.push(Q);
          t: for (; 0 < et; ) {
            var xt = (et - 1) >>> 1,
              X = j[xt];
            if (0 < a(X, Q)) (j[xt] = Q), (j[et] = X), (et = xt);
            else break t;
          }
        }
        function e(j) {
          return j.length === 0 ? null : j[0];
        }
        function n(j) {
          if (j.length === 0) return null;
          var Q = j[0],
            et = j.pop();
          if (et !== Q) {
            j[0] = et;
            t: for (var xt = 0, X = j.length, ft = X >>> 1; xt < ft; ) {
              var At = 2 * (xt + 1) - 1,
                Rt = j[At],
                ht = At + 1,
                It = j[ht];
              if (0 > a(Rt, et))
                ht < X && 0 > a(It, Rt)
                  ? ((j[xt] = It), (j[ht] = et), (xt = ht))
                  : ((j[xt] = Rt), (j[At] = et), (xt = At));
              else if (ht < X && 0 > a(It, et))
                (j[xt] = It), (j[ht] = et), (xt = ht);
              else break t;
            }
          }
          return Q;
        }
        function a(j, Q) {
          var et = j.sortIndex - Q.sortIndex;
          return et !== 0 ? et : j.id - Q.id;
        }
        if (
          ((i.unstable_now = void 0),
          typeof performance == "object" &&
            typeof performance.now == "function")
        ) {
          var r = performance;
          i.unstable_now = function () {
            return r.now();
          };
        } else {
          var l = Date,
            u = l.now();
          i.unstable_now = function () {
            return l.now() - u;
          };
        }
        var h = [],
          p = [],
          m = 1,
          v = null,
          x = 3,
          _ = !1,
          M = !1,
          C = !1,
          E = !1,
          S = typeof setTimeout == "function" ? setTimeout : null,
          R = typeof clearTimeout == "function" ? clearTimeout : null,
          B = typeof setImmediate < "u" ? setImmediate : null;
        function D(j) {
          for (var Q = e(p); Q !== null; ) {
            if (Q.callback === null) n(p);
            else if (Q.startTime <= j)
              n(p), (Q.sortIndex = Q.expirationTime), t(h, Q);
            else break;
            Q = e(p);
          }
        }
        function I(j) {
          if (((C = !1), D(j), !M))
            if (e(h) !== null) (M = !0), P || ((P = !0), ct());
            else {
              var Q = e(p);
              Q !== null && pt(I, Q.startTime - j);
            }
        }
        var P = !1,
          V = -1,
          F = 5,
          N = -1;
        function L() {
          return E ? !0 : !(i.unstable_now() - N < F);
        }
        function Y() {
          if (((E = !1), P)) {
            var j = i.unstable_now();
            N = j;
            var Q = !0;
            try {
              t: {
                (M = !1), C && ((C = !1), R(V), (V = -1)), (_ = !0);
                var et = x;
                try {
                  e: {
                    for (
                      D(j), v = e(h);
                      v !== null && !(v.expirationTime > j && L());

                    ) {
                      var xt = v.callback;
                      if (typeof xt == "function") {
                        (v.callback = null), (x = v.priorityLevel);
                        var X = xt(v.expirationTime <= j);
                        if (((j = i.unstable_now()), typeof X == "function")) {
                          (v.callback = X), D(j), (Q = !0);
                          break e;
                        }
                        v === e(h) && n(h), D(j);
                      } else n(h);
                      v = e(h);
                    }
                    if (v !== null) Q = !0;
                    else {
                      var ft = e(p);
                      ft !== null && pt(I, ft.startTime - j), (Q = !1);
                    }
                  }
                  break t;
                } finally {
                  (v = null), (x = et), (_ = !1);
                }
                Q = void 0;
              }
            } finally {
              Q ? ct() : (P = !1);
            }
          }
        }
        var ct;
        if (typeof B == "function")
          ct = function () {
            B(Y);
          };
        else if (typeof MessageChannel < "u") {
          var nt = new MessageChannel(),
            dt = nt.port2;
          (nt.port1.onmessage = Y),
            (ct = function () {
              dt.postMessage(null);
            });
        } else
          ct = function () {
            S(Y, 0);
          };
        function pt(j, Q) {
          V = S(function () {
            j(i.unstable_now());
          }, Q);
        }
        (i.unstable_IdlePriority = 5),
          (i.unstable_ImmediatePriority = 1),
          (i.unstable_LowPriority = 4),
          (i.unstable_NormalPriority = 3),
          (i.unstable_Profiling = null),
          (i.unstable_UserBlockingPriority = 2),
          (i.unstable_cancelCallback = function (j) {
            j.callback = null;
          }),
          (i.unstable_forceFrameRate = function (j) {
            0 > j || 125 < j
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (F = 0 < j ? Math.floor(1e3 / j) : 5);
          }),
          (i.unstable_getCurrentPriorityLevel = function () {
            return x;
          }),
          (i.unstable_next = function (j) {
            switch (x) {
              case 1:
              case 2:
              case 3:
                var Q = 3;
                break;
              default:
                Q = x;
            }
            var et = x;
            x = Q;
            try {
              return j();
            } finally {
              x = et;
            }
          }),
          (i.unstable_requestPaint = function () {
            E = !0;
          }),
          (i.unstable_runWithPriority = function (j, Q) {
            switch (j) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                j = 3;
            }
            var et = x;
            x = j;
            try {
              return Q();
            } finally {
              x = et;
            }
          }),
          (i.unstable_scheduleCallback = function (j, Q, et) {
            var xt = i.unstable_now();
            switch (
              (typeof et == "object" && et !== null
                ? ((et = et.delay),
                  (et = typeof et == "number" && 0 < et ? xt + et : xt))
                : (et = xt),
              j)
            ) {
              case 1:
                var X = -1;
                break;
              case 2:
                X = 250;
                break;
              case 5:
                X = 1073741823;
                break;
              case 4:
                X = 1e4;
                break;
              default:
                X = 5e3;
            }
            return (
              (X = et + X),
              (j = {
                id: m++,
                callback: Q,
                priorityLevel: j,
                startTime: et,
                expirationTime: X,
                sortIndex: -1,
              }),
              et > xt
                ? ((j.sortIndex = et),
                  t(p, j),
                  e(h) === null &&
                    j === e(p) &&
                    (C ? (R(V), (V = -1)) : (C = !0), pt(I, et - xt)))
                : ((j.sortIndex = X),
                  t(h, j),
                  M || _ || ((M = !0), P || ((P = !0), ct()))),
              j
            );
          }),
          (i.unstable_shouldYield = L),
          (i.unstable_wrapCallback = function (j) {
            var Q = x;
            return function () {
              var et = x;
              x = Q;
              try {
                return j.apply(this, arguments);
              } finally {
                x = et;
              }
            };
          });
      })(i_)),
    i_
  );
}
var rE;
function KD() {
  return rE || ((rE = 1), (n_.exports = qD())), n_.exports;
}
var a_ = { exports: {} },
  Qa = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var oE;
function JD() {
  if (oE) return Qa;
  oE = 1;
  var i = nh();
  function t(h) {
    var p = "https://react.dev/errors/" + h;
    if (1 < arguments.length) {
      p += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        p += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return (
      "Minified React error #" +
      h +
      "; visit " +
      p +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function e() {}
  var n = {
      d: {
        f: e,
        r: function () {
          throw Error(t(522));
        },
        D: e,
        C: e,
        L: e,
        m: e,
        X: e,
        S: e,
        M: e,
      },
      p: 0,
      findDOMNode: null,
    },
    a = Symbol.for("react.portal");
  function r(h, p, m) {
    var v =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: a,
      key: v == null ? null : "" + v,
      children: h,
      containerInfo: p,
      implementation: m,
    };
  }
  var l = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(h, p) {
    if (h === "font") return "";
    if (typeof p == "string") return p === "use-credentials" ? p : "";
  }
  return (
    (Qa.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = n),
    (Qa.createPortal = function (h, p) {
      var m =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!p || (p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11))
        throw Error(t(299));
      return r(h, p, null, m);
    }),
    (Qa.flushSync = function (h) {
      var p = l.T,
        m = n.p;
      try {
        if (((l.T = null), (n.p = 2), h)) return h();
      } finally {
        (l.T = p), (n.p = m), n.d.f();
      }
    }),
    (Qa.preconnect = function (h, p) {
      typeof h == "string" &&
        (p
          ? ((p = p.crossOrigin),
            (p =
              typeof p == "string"
                ? p === "use-credentials"
                  ? p
                  : ""
                : void 0))
          : (p = null),
        n.d.C(h, p));
    }),
    (Qa.prefetchDNS = function (h) {
      typeof h == "string" && n.d.D(h);
    }),
    (Qa.preinit = function (h, p) {
      if (typeof h == "string" && p && typeof p.as == "string") {
        var m = p.as,
          v = u(m, p.crossOrigin),
          x = typeof p.integrity == "string" ? p.integrity : void 0,
          _ = typeof p.fetchPriority == "string" ? p.fetchPriority : void 0;
        m === "style"
          ? n.d.S(h, typeof p.precedence == "string" ? p.precedence : void 0, {
              crossOrigin: v,
              integrity: x,
              fetchPriority: _,
            })
          : m === "script" &&
            n.d.X(h, {
              crossOrigin: v,
              integrity: x,
              fetchPriority: _,
              nonce: typeof p.nonce == "string" ? p.nonce : void 0,
            });
      }
    }),
    (Qa.preinitModule = function (h, p) {
      if (typeof h == "string")
        if (typeof p == "object" && p !== null) {
          if (p.as == null || p.as === "script") {
            var m = u(p.as, p.crossOrigin);
            n.d.M(h, {
              crossOrigin: m,
              integrity: typeof p.integrity == "string" ? p.integrity : void 0,
              nonce: typeof p.nonce == "string" ? p.nonce : void 0,
            });
          }
        } else p == null && n.d.M(h);
    }),
    (Qa.preload = function (h, p) {
      if (
        typeof h == "string" &&
        typeof p == "object" &&
        p !== null &&
        typeof p.as == "string"
      ) {
        var m = p.as,
          v = u(m, p.crossOrigin);
        n.d.L(h, m, {
          crossOrigin: v,
          integrity: typeof p.integrity == "string" ? p.integrity : void 0,
          nonce: typeof p.nonce == "string" ? p.nonce : void 0,
          type: typeof p.type == "string" ? p.type : void 0,
          fetchPriority:
            typeof p.fetchPriority == "string" ? p.fetchPriority : void 0,
          referrerPolicy:
            typeof p.referrerPolicy == "string" ? p.referrerPolicy : void 0,
          imageSrcSet:
            typeof p.imageSrcSet == "string" ? p.imageSrcSet : void 0,
          imageSizes: typeof p.imageSizes == "string" ? p.imageSizes : void 0,
          media: typeof p.media == "string" ? p.media : void 0,
        });
      }
    }),
    (Qa.preloadModule = function (h, p) {
      if (typeof h == "string")
        if (p) {
          var m = u(p.as, p.crossOrigin);
          n.d.m(h, {
            as: typeof p.as == "string" && p.as !== "script" ? p.as : void 0,
            crossOrigin: m,
            integrity: typeof p.integrity == "string" ? p.integrity : void 0,
          });
        } else n.d.m(h);
    }),
    (Qa.requestFormReset = function (h) {
      n.d.r(h);
    }),
    (Qa.unstable_batchedUpdates = function (h, p) {
      return h(p);
    }),
    (Qa.useFormState = function (h, p, m) {
      return l.H.useFormState(h, p, m);
    }),
    (Qa.useFormStatus = function () {
      return l.H.useHostTransitionStatus();
    }),
    (Qa.version = "19.1.0"),
    Qa
  );
}
var lE;
function ZD() {
  if (lE) return a_.exports;
  lE = 1;
  function i() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i);
      } catch (t) {
        console.error(t);
      }
  }
  return i(), (a_.exports = JD()), a_.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cE;
function QD() {
  if (cE) return Em;
  cE = 1;
  var i = KD(),
    t = nh(),
    e = ZD();
  function n(s) {
    var o = "https://react.dev/errors/" + s;
    if (1 < arguments.length) {
      o += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var d = 2; d < arguments.length; d++)
        o += "&args[]=" + encodeURIComponent(arguments[d]);
    }
    return (
      "Minified React error #" +
      s +
      "; visit " +
      o +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function a(s) {
    return !(!s || (s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11));
  }
  function r(s) {
    var o = s,
      d = s;
    if (s.alternate) for (; o.return; ) o = o.return;
    else {
      s = o;
      do (o = s), (o.flags & 4098) !== 0 && (d = o.return), (s = o.return);
      while (s);
    }
    return o.tag === 3 ? d : null;
  }
  function l(s) {
    if (s.tag === 13) {
      var o = s.memoizedState;
      if (
        (o === null && ((s = s.alternate), s !== null && (o = s.memoizedState)),
        o !== null)
      )
        return o.dehydrated;
    }
    return null;
  }
  function u(s) {
    if (r(s) !== s) throw Error(n(188));
  }
  function h(s) {
    var o = s.alternate;
    if (!o) {
      if (((o = r(s)), o === null)) throw Error(n(188));
      return o !== s ? null : s;
    }
    for (var d = s, g = o; ; ) {
      var b = d.return;
      if (b === null) break;
      var T = b.alternate;
      if (T === null) {
        if (((g = b.return), g !== null)) {
          d = g;
          continue;
        }
        break;
      }
      if (b.child === T.child) {
        for (T = b.child; T; ) {
          if (T === d) return u(b), s;
          if (T === g) return u(b), o;
          T = T.sibling;
        }
        throw Error(n(188));
      }
      if (d.return !== g.return) (d = b), (g = T);
      else {
        for (var z = !1, W = b.child; W; ) {
          if (W === d) {
            (z = !0), (d = b), (g = T);
            break;
          }
          if (W === g) {
            (z = !0), (g = b), (d = T);
            break;
          }
          W = W.sibling;
        }
        if (!z) {
          for (W = T.child; W; ) {
            if (W === d) {
              (z = !0), (d = T), (g = b);
              break;
            }
            if (W === g) {
              (z = !0), (g = T), (d = b);
              break;
            }
            W = W.sibling;
          }
          if (!z) throw Error(n(189));
        }
      }
      if (d.alternate !== g) throw Error(n(190));
    }
    if (d.tag !== 3) throw Error(n(188));
    return d.stateNode.current === d ? s : o;
  }
  function p(s) {
    var o = s.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return s;
    for (s = s.child; s !== null; ) {
      if (((o = p(s)), o !== null)) return o;
      s = s.sibling;
    }
    return null;
  }
  var m = Object.assign,
    v = Symbol.for("react.element"),
    x = Symbol.for("react.transitional.element"),
    _ = Symbol.for("react.portal"),
    M = Symbol.for("react.fragment"),
    C = Symbol.for("react.strict_mode"),
    E = Symbol.for("react.profiler"),
    S = Symbol.for("react.provider"),
    R = Symbol.for("react.consumer"),
    B = Symbol.for("react.context"),
    D = Symbol.for("react.forward_ref"),
    I = Symbol.for("react.suspense"),
    P = Symbol.for("react.suspense_list"),
    V = Symbol.for("react.memo"),
    F = Symbol.for("react.lazy"),
    N = Symbol.for("react.activity"),
    L = Symbol.for("react.memo_cache_sentinel"),
    Y = Symbol.iterator;
  function ct(s) {
    return s === null || typeof s != "object"
      ? null
      : ((s = (Y && s[Y]) || s["@@iterator"]),
        typeof s == "function" ? s : null);
  }
  var nt = Symbol.for("react.client.reference");
  function dt(s) {
    if (s == null) return null;
    if (typeof s == "function")
      return s.$$typeof === nt ? null : s.displayName || s.name || null;
    if (typeof s == "string") return s;
    switch (s) {
      case M:
        return "Fragment";
      case E:
        return "Profiler";
      case C:
        return "StrictMode";
      case I:
        return "Suspense";
      case P:
        return "SuspenseList";
      case N:
        return "Activity";
    }
    if (typeof s == "object")
      switch (s.$$typeof) {
        case _:
          return "Portal";
        case B:
          return (s.displayName || "Context") + ".Provider";
        case R:
          return (s._context.displayName || "Context") + ".Consumer";
        case D:
          var o = s.render;
          return (
            (s = s.displayName),
            s ||
              ((s = o.displayName || o.name || ""),
              (s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef")),
            s
          );
        case V:
          return (
            (o = s.displayName || null), o !== null ? o : dt(s.type) || "Memo"
          );
        case F:
          (o = s._payload), (s = s._init);
          try {
            return dt(s(o));
          } catch {}
      }
    return null;
  }
  var pt = Array.isArray,
    j = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    Q = e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    et = { pending: !1, data: null, method: null, action: null },
    xt = [],
    X = -1;
  function ft(s) {
    return { current: s };
  }
  function At(s) {
    0 > X || ((s.current = xt[X]), (xt[X] = null), X--);
  }
  function Rt(s, o) {
    X++, (xt[X] = s.current), (s.current = o);
  }
  var ht = ft(null),
    It = ft(null),
    Pt = ft(null),
    re = ft(null);
  function ie(s, o) {
    switch ((Rt(Pt, o), Rt(It, s), Rt(ht, null), o.nodeType)) {
      case 9:
      case 11:
        s = (s = o.documentElement) && (s = s.namespaceURI) ? RM(s) : 0;
        break;
      default:
        if (((s = o.tagName), (o = o.namespaceURI)))
          (o = RM(o)), (s = BM(o, s));
        else
          switch (s) {
            case "svg":
              s = 1;
              break;
            case "math":
              s = 2;
              break;
            default:
              s = 0;
          }
    }
    At(ht), Rt(ht, s);
  }
  function Fe() {
    At(ht), At(It), At(Pt);
  }
  function Ae(s) {
    s.memoizedState !== null && Rt(re, s);
    var o = ht.current,
      d = BM(o, s.type);
    o !== d && (Rt(It, s), Rt(ht, d));
  }
  function De(s) {
    It.current === s && (At(ht), At(It)),
      re.current === s && (At(re), (xm._currentValue = et));
  }
  var je = Object.prototype.hasOwnProperty,
    Ue = i.unstable_scheduleCallback,
    J = i.unstable_cancelCallback,
    le = i.unstable_shouldYield,
    se = i.unstable_requestPaint,
    $t = i.unstable_now,
    kt = i.unstable_getCurrentPriorityLevel,
    ye = i.unstable_ImmediatePriority,
    te = i.unstable_UserBlockingPriority,
    pe = i.unstable_NormalPriority,
    Ye = i.unstable_LowPriority,
    $ = i.unstable_IdlePriority,
    k = i.log,
    Mt = i.unstable_setDisableYieldValue,
    Ft = null,
    Gt = null;
  function zt(s) {
    if (
      (typeof k == "function" && Mt(s),
      Gt && typeof Gt.setStrictMode == "function")
    )
      try {
        Gt.setStrictMode(Ft, s);
      } catch {}
  }
  var me = Math.clz32 ? Math.clz32 : Ce,
    de = Math.log,
    we = Math.LN2;
  function Ce(s) {
    return (s >>>= 0), s === 0 ? 32 : (31 - ((de(s) / we) | 0)) | 0;
  }
  var jt = 256,
    ce = 4194304;
  function Re(s) {
    var o = s & 42;
    if (o !== 0) return o;
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return s & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return s;
    }
  }
  function it(s, o, d) {
    var g = s.pendingLanes;
    if (g === 0) return 0;
    var b = 0,
      T = s.suspendedLanes,
      z = s.pingedLanes;
    s = s.warmLanes;
    var W = g & 134217727;
    return (
      W !== 0
        ? ((g = W & ~T),
          g !== 0
            ? (b = Re(g))
            : ((z &= W),
              z !== 0
                ? (b = Re(z))
                : d || ((d = W & ~s), d !== 0 && (b = Re(d)))))
        : ((W = g & ~T),
          W !== 0
            ? (b = Re(W))
            : z !== 0
            ? (b = Re(z))
            : d || ((d = g & ~s), d !== 0 && (b = Re(d)))),
      b === 0
        ? 0
        : o !== 0 &&
          o !== b &&
          (o & T) === 0 &&
          ((T = b & -b),
          (d = o & -o),
          T >= d || (T === 32 && (d & 4194048) !== 0))
        ? o
        : b
    );
  }
  function yt(s, o) {
    return (s.pendingLanes & ~(s.suspendedLanes & ~s.pingedLanes) & o) === 0;
  }
  function Qt(s, o) {
    switch (s) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return o + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function st() {
    var s = jt;
    return (jt <<= 1), (jt & 4194048) === 0 && (jt = 256), s;
  }
  function Et() {
    var s = ce;
    return (ce <<= 1), (ce & 62914560) === 0 && (ce = 4194304), s;
  }
  function qt(s) {
    for (var o = [], d = 0; 31 > d; d++) o.push(s);
    return o;
  }
  function ge(s, o) {
    (s.pendingLanes |= o),
      o !== 268435456 &&
        ((s.suspendedLanes = 0), (s.pingedLanes = 0), (s.warmLanes = 0));
  }
  function oe(s, o, d, g, b, T) {
    var z = s.pendingLanes;
    (s.pendingLanes = d),
      (s.suspendedLanes = 0),
      (s.pingedLanes = 0),
      (s.warmLanes = 0),
      (s.expiredLanes &= d),
      (s.entangledLanes &= d),
      (s.errorRecoveryDisabledLanes &= d),
      (s.shellSuspendCounter = 0);
    var W = s.entanglements,
      at = s.expirationTimes,
      Ct = s.hiddenUpdates;
    for (d = z & ~d; 0 < d; ) {
      var Wt = 31 - me(d),
        ne = 1 << Wt;
      (W[Wt] = 0), (at[Wt] = -1);
      var Ot = Ct[Wt];
      if (Ot !== null)
        for (Ct[Wt] = null, Wt = 0; Wt < Ot.length; Wt++) {
          var Nt = Ot[Wt];
          Nt !== null && (Nt.lane &= -536870913);
        }
      d &= ~ne;
    }
    g !== 0 && Kt(s, g, 0),
      T !== 0 && b === 0 && s.tag !== 0 && (s.suspendedLanes |= T & ~(z & ~o));
  }
  function Kt(s, o, d) {
    (s.pendingLanes |= o), (s.suspendedLanes &= ~o);
    var g = 31 - me(o);
    (s.entangledLanes |= o),
      (s.entanglements[g] = s.entanglements[g] | 1073741824 | (d & 4194090));
  }
  function be(s, o) {
    var d = (s.entangledLanes |= o);
    for (s = s.entanglements; d; ) {
      var g = 31 - me(d),
        b = 1 << g;
      (b & o) | (s[g] & o) && (s[g] |= o), (d &= ~b);
    }
  }
  function Le(s) {
    switch (s) {
      case 2:
        s = 1;
        break;
      case 8:
        s = 4;
        break;
      case 32:
        s = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        s = 128;
        break;
      case 268435456:
        s = 134217728;
        break;
      default:
        s = 0;
    }
    return s;
  }
  function mn(s) {
    return (
      (s &= -s),
      2 < s ? (8 < s ? ((s & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
    );
  }
  function ln() {
    var s = Q.p;
    return s !== 0 ? s : ((s = window.event), s === void 0 ? 32 : KM(s.type));
  }
  function yi(s, o) {
    var d = Q.p;
    try {
      return (Q.p = s), o();
    } finally {
      Q.p = d;
    }
  }
  var si = Math.random().toString(36).slice(2),
    xi = "__reactFiber$" + si,
    Ci = "__reactProps$" + si,
    Ri = "__reactContainer$" + si,
    ya = "__reactEvents$" + si,
    Ws = "__reactListeners$" + si,
    sa = "__reactHandles$" + si,
    Ke = "__reactResources$" + si,
    ka = "__reactMarker$" + si;
  function Vn(s) {
    delete s[xi], delete s[Ci], delete s[ya], delete s[Ws], delete s[sa];
  }
  function G(s) {
    var o = s[xi];
    if (o) return o;
    for (var d = s.parentNode; d; ) {
      if ((o = d[Ri] || d[xi])) {
        if (
          ((d = o.alternate),
          o.child !== null || (d !== null && d.child !== null))
        )
          for (s = NM(s); s !== null; ) {
            if ((d = s[xi])) return d;
            s = NM(s);
          }
        return o;
      }
      (s = d), (d = s.parentNode);
    }
    return null;
  }
  function K(s) {
    if ((s = s[xi] || s[Ri])) {
      var o = s.tag;
      if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3)
        return s;
    }
    return null;
  }
  function ut(s) {
    var o = s.tag;
    if (o === 5 || o === 26 || o === 27 || o === 6) return s.stateNode;
    throw Error(n(33));
  }
  function Bt(s) {
    var o = s[Ke];
    return (
      o ||
        (o = s[Ke] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() }),
      o
    );
  }
  function Ut(s) {
    s[ka] = !0;
  }
  var Ht = new Set(),
    ue = {};
  function ae(s, o) {
    H(s, o), H(s + "Capture", o);
  }
  function H(s, o) {
    for (ue[s] = o, s = 0; s < o.length; s++) Ht.add(o[s]);
  }
  var tt = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ),
    rt = {},
    ot = {};
  function gt(s) {
    return je.call(ot, s)
      ? !0
      : je.call(rt, s)
      ? !1
      : tt.test(s)
      ? (ot[s] = !0)
      : ((rt[s] = !0), !1);
  }
  function wt(s, o, d) {
    if (gt(o))
      if (d === null) s.removeAttribute(o);
      else {
        switch (typeof d) {
          case "undefined":
          case "function":
          case "symbol":
            s.removeAttribute(o);
            return;
          case "boolean":
            var g = o.toLowerCase().slice(0, 5);
            if (g !== "data-" && g !== "aria-") {
              s.removeAttribute(o);
              return;
            }
        }
        s.setAttribute(o, "" + d);
      }
  }
  function Vt(s, o, d) {
    if (d === null) s.removeAttribute(o);
    else {
      switch (typeof d) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          s.removeAttribute(o);
          return;
      }
      s.setAttribute(o, "" + d);
    }
  }
  function Jt(s, o, d, g) {
    if (g === null) s.removeAttribute(d);
    else {
      switch (typeof g) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          s.removeAttribute(d);
          return;
      }
      s.setAttributeNS(o, d, "" + g);
    }
  }
  var ee, xe;
  function ve(s) {
    if (ee === void 0)
      try {
        throw Error();
      } catch (d) {
        var o = d.stack.trim().match(/\n( *(at )?)/);
        (ee = (o && o[1]) || ""),
          (xe =
            -1 <
            d.stack.indexOf(`
    at`)
              ? " (<anonymous>)"
              : -1 < d.stack.indexOf("@")
              ? "@unknown:0:0"
              : "");
      }
    return (
      `
` +
      ee +
      s +
      xe
    );
  }
  var _e = !1;
  function He(s, o) {
    if (!s || _e) return "";
    _e = !0;
    var d = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var g = {
        DetermineComponentFrameRoot: function () {
          try {
            if (o) {
              var ne = function () {
                throw Error();
              };
              if (
                (Object.defineProperty(ne.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(ne, []);
                } catch (Nt) {
                  var Ot = Nt;
                }
                Reflect.construct(s, [], ne);
              } else {
                try {
                  ne.call();
                } catch (Nt) {
                  Ot = Nt;
                }
                s.call(ne.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Nt) {
                Ot = Nt;
              }
              (ne = s()) &&
                typeof ne.catch == "function" &&
                ne.catch(function () {});
            }
          } catch (Nt) {
            if (Nt && Ot && typeof Nt.stack == "string")
              return [Nt.stack, Ot.stack];
          }
          return [null, null];
        },
      };
      g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var b = Object.getOwnPropertyDescriptor(
        g.DetermineComponentFrameRoot,
        "name"
      );
      b &&
        b.configurable &&
        Object.defineProperty(g.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot",
        });
      var T = g.DetermineComponentFrameRoot(),
        z = T[0],
        W = T[1];
      if (z && W) {
        var at = z.split(`
`),
          Ct = W.split(`
`);
        for (
          b = g = 0;
          g < at.length && !at[g].includes("DetermineComponentFrameRoot");

        )
          g++;
        for (
          ;
          b < Ct.length && !Ct[b].includes("DetermineComponentFrameRoot");

        )
          b++;
        if (g === at.length || b === Ct.length)
          for (
            g = at.length - 1, b = Ct.length - 1;
            1 <= g && 0 <= b && at[g] !== Ct[b];

          )
            b--;
        for (; 1 <= g && 0 <= b; g--, b--)
          if (at[g] !== Ct[b]) {
            if (g !== 1 || b !== 1)
              do
                if ((g--, b--, 0 > b || at[g] !== Ct[b])) {
                  var Wt =
                    `
` + at[g].replace(" at new ", " at ");
                  return (
                    s.displayName &&
                      Wt.includes("<anonymous>") &&
                      (Wt = Wt.replace("<anonymous>", s.displayName)),
                    Wt
                  );
                }
              while (1 <= g && 0 <= b);
            break;
          }
      }
    } finally {
      (_e = !1), (Error.prepareStackTrace = d);
    }
    return (d = s ? s.displayName || s.name : "") ? ve(d) : "";
  }
  function ze(s) {
    switch (s.tag) {
      case 26:
      case 27:
      case 5:
        return ve(s.type);
      case 16:
        return ve("Lazy");
      case 13:
        return ve("Suspense");
      case 19:
        return ve("SuspenseList");
      case 0:
      case 15:
        return He(s.type, !1);
      case 11:
        return He(s.type.render, !1);
      case 1:
        return He(s.type, !0);
      case 31:
        return ve("Activity");
      default:
        return "";
    }
  }
  function Mn(s) {
    try {
      var o = "";
      do (o += ze(s)), (s = s.return);
      while (s);
      return o;
    } catch (d) {
      return (
        `
Error generating stack: ` +
        d.message +
        `
` +
        d.stack
      );
    }
  }
  function Oe(s) {
    switch (typeof s) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return s;
      case "object":
        return s;
      default:
        return "";
    }
  }
  function Ve(s) {
    var o = s.type;
    return (
      (s = s.nodeName) &&
      s.toLowerCase() === "input" &&
      (o === "checkbox" || o === "radio")
    );
  }
  function Ne(s) {
    var o = Ve(s) ? "checked" : "value",
      d = Object.getOwnPropertyDescriptor(s.constructor.prototype, o),
      g = "" + s[o];
    if (
      !s.hasOwnProperty(o) &&
      typeof d < "u" &&
      typeof d.get == "function" &&
      typeof d.set == "function"
    ) {
      var b = d.get,
        T = d.set;
      return (
        Object.defineProperty(s, o, {
          configurable: !0,
          get: function () {
            return b.call(this);
          },
          set: function (z) {
            (g = "" + z), T.call(this, z);
          },
        }),
        Object.defineProperty(s, o, { enumerable: d.enumerable }),
        {
          getValue: function () {
            return g;
          },
          setValue: function (z) {
            g = "" + z;
          },
          stopTracking: function () {
            (s._valueTracker = null), delete s[o];
          },
        }
      );
    }
  }
  function Yn(s) {
    s._valueTracker || (s._valueTracker = Ne(s));
  }
  function en(s) {
    if (!s) return !1;
    var o = s._valueTracker;
    if (!o) return !0;
    var d = o.getValue(),
      g = "";
    return (
      s && (g = Ve(s) ? (s.checked ? "true" : "false") : s.value),
      (s = g),
      s !== d ? (o.setValue(s), !0) : !1
    );
  }
  function on(s) {
    if (
      ((s = s || (typeof document < "u" ? document : void 0)), typeof s > "u")
    )
      return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  var Qn = /[\n"\\]/g;
  function qe(s) {
    return s.replace(Qn, function (o) {
      return "\\" + o.charCodeAt(0).toString(16) + " ";
    });
  }
  function xn(s, o, d, g, b, T, z, W) {
    (s.name = ""),
      z != null &&
      typeof z != "function" &&
      typeof z != "symbol" &&
      typeof z != "boolean"
        ? (s.type = z)
        : s.removeAttribute("type"),
      o != null
        ? z === "number"
          ? ((o === 0 && s.value === "") || s.value != o) &&
            (s.value = "" + Oe(o))
          : s.value !== "" + Oe(o) && (s.value = "" + Oe(o))
        : (z !== "submit" && z !== "reset") || s.removeAttribute("value"),
      o != null
        ? fi(s, z, Oe(o))
        : d != null
        ? fi(s, z, Oe(d))
        : g != null && s.removeAttribute("value"),
      b == null && T != null && (s.defaultChecked = !!T),
      b != null &&
        (s.checked = b && typeof b != "function" && typeof b != "symbol"),
      W != null &&
      typeof W != "function" &&
      typeof W != "symbol" &&
      typeof W != "boolean"
        ? (s.name = "" + Oe(W))
        : s.removeAttribute("name");
  }
  function gn(s, o, d, g, b, T, z, W) {
    if (
      (T != null &&
        typeof T != "function" &&
        typeof T != "symbol" &&
        typeof T != "boolean" &&
        (s.type = T),
      o != null || d != null)
    ) {
      if (!((T !== "submit" && T !== "reset") || o != null)) return;
      (d = d != null ? "" + Oe(d) : ""),
        (o = o != null ? "" + Oe(o) : d),
        W || o === s.value || (s.value = o),
        (s.defaultValue = o);
    }
    (g = g ?? b),
      (g = typeof g != "function" && typeof g != "symbol" && !!g),
      (s.checked = W ? s.checked : !!g),
      (s.defaultChecked = !!g),
      z != null &&
        typeof z != "function" &&
        typeof z != "symbol" &&
        typeof z != "boolean" &&
        (s.name = z);
  }
  function fi(s, o, d) {
    (o === "number" && on(s.ownerDocument) === s) ||
      s.defaultValue === "" + d ||
      (s.defaultValue = "" + d);
  }
  function Un(s, o, d, g) {
    if (((s = s.options), o)) {
      o = {};
      for (var b = 0; b < d.length; b++) o["$" + d[b]] = !0;
      for (d = 0; d < s.length; d++)
        (b = o.hasOwnProperty("$" + s[d].value)),
          s[d].selected !== b && (s[d].selected = b),
          b && g && (s[d].defaultSelected = !0);
    } else {
      for (d = "" + Oe(d), o = null, b = 0; b < s.length; b++) {
        if (s[b].value === d) {
          (s[b].selected = !0), g && (s[b].defaultSelected = !0);
          return;
        }
        o !== null || s[b].disabled || (o = s[b]);
      }
      o !== null && (o.selected = !0);
    }
  }
  function $n(s, o, d) {
    if (
      o != null &&
      ((o = "" + Oe(o)), o !== s.value && (s.value = o), d == null)
    ) {
      s.defaultValue !== o && (s.defaultValue = o);
      return;
    }
    s.defaultValue = d != null ? "" + Oe(d) : "";
  }
  function Zi(s, o, d, g) {
    if (o == null) {
      if (g != null) {
        if (d != null) throw Error(n(92));
        if (pt(g)) {
          if (1 < g.length) throw Error(n(93));
          g = g[0];
        }
        d = g;
      }
      d == null && (d = ""), (o = d);
    }
    (d = Oe(o)),
      (s.defaultValue = d),
      (g = s.textContent),
      g === d && g !== "" && g !== null && (s.value = g);
  }
  function Ca(s, o) {
    if (o) {
      var d = s.firstChild;
      if (d && d === s.lastChild && d.nodeType === 3) {
        d.nodeValue = o;
        return;
      }
    }
    s.textContent = o;
  }
  var ur = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Au(s, o, d) {
    var g = o.indexOf("--") === 0;
    d == null || typeof d == "boolean" || d === ""
      ? g
        ? s.setProperty(o, "")
        : o === "float"
        ? (s.cssFloat = "")
        : (s[o] = "")
      : g
      ? s.setProperty(o, d)
      : typeof d != "number" || d === 0 || ur.has(o)
      ? o === "float"
        ? (s.cssFloat = d)
        : (s[o] = ("" + d).trim())
      : (s[o] = d + "px");
  }
  function Su(s, o, d) {
    if (o != null && typeof o != "object") throw Error(n(62));
    if (((s = s.style), d != null)) {
      for (var g in d)
        !d.hasOwnProperty(g) ||
          (o != null && o.hasOwnProperty(g)) ||
          (g.indexOf("--") === 0
            ? s.setProperty(g, "")
            : g === "float"
            ? (s.cssFloat = "")
            : (s[g] = ""));
      for (var b in o)
        (g = o[b]), o.hasOwnProperty(b) && d[b] !== g && Au(s, b, g);
    } else for (var T in o) o.hasOwnProperty(T) && Au(s, T, o[T]);
  }
  function oh(s) {
    if (s.indexOf("-") === -1) return !1;
    switch (s) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var fp = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"],
    ]),
    Z0 =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Mu(s) {
    return Z0.test("" + s)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : s;
  }
  var lh = null;
  function ch(s) {
    return (
      (s = s.target || s.srcElement || window),
      s.correspondingUseElement && (s = s.correspondingUseElement),
      s.nodeType === 3 ? s.parentNode : s
    );
  }
  var Mo = null,
    gl = null;
  function hp(s) {
    var o = K(s);
    if (o && (s = o.stateNode)) {
      var d = s[Ci] || null;
      t: switch (((s = o.stateNode), o.type)) {
        case "input":
          if (
            (xn(
              s,
              d.value,
              d.defaultValue,
              d.defaultValue,
              d.checked,
              d.defaultChecked,
              d.type,
              d.name
            ),
            (o = d.name),
            d.type === "radio" && o != null)
          ) {
            for (d = s; d.parentNode; ) d = d.parentNode;
            for (
              d = d.querySelectorAll(
                'input[name="' + qe("" + o) + '"][type="radio"]'
              ),
                o = 0;
              o < d.length;
              o++
            ) {
              var g = d[o];
              if (g !== s && g.form === s.form) {
                var b = g[Ci] || null;
                if (!b) throw Error(n(90));
                xn(
                  g,
                  b.value,
                  b.defaultValue,
                  b.defaultValue,
                  b.checked,
                  b.defaultChecked,
                  b.type,
                  b.name
                );
              }
            }
            for (o = 0; o < d.length; o++)
              (g = d[o]), g.form === s.form && en(g);
          }
          break t;
        case "textarea":
          $n(s, d.value, d.defaultValue);
          break t;
        case "select":
          (o = d.value), o != null && Un(s, !!d.multiple, o, !1);
      }
    }
  }
  var Eu = !1;
  function dp(s, o, d) {
    if (Eu) return s(o, d);
    Eu = !0;
    try {
      var g = s(o);
      return g;
    } finally {
      if (
        ((Eu = !1),
        (Mo !== null || gl !== null) &&
          (Tr(), Mo && ((o = Mo), (s = gl), (gl = Mo = null), hp(o), s)))
      )
        for (o = 0; o < s.length; o++) hp(s[o]);
    }
  }
  function ac(s, o) {
    var d = s.stateNode;
    if (d === null) return null;
    var g = d[Ci] || null;
    if (g === null) return null;
    d = g[o];
    t: switch (o) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (g = !g.disabled) ||
          ((s = s.type),
          (g = !(
            s === "button" ||
            s === "input" ||
            s === "select" ||
            s === "textarea"
          ))),
          (s = !g);
        break t;
      default:
        s = !1;
    }
    if (s) return null;
    if (d && typeof d != "function") throw Error(n(231, o, typeof d));
    return d;
  }
  var fr = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    Tu = !1;
  if (fr)
    try {
      var sc = {};
      Object.defineProperty(sc, "passive", {
        get: function () {
          Tu = !0;
        },
      }),
        window.addEventListener("test", sc, sc),
        window.removeEventListener("test", sc, sc);
    } catch {
      Tu = !1;
    }
  var Gr = null,
    pp = null,
    uh = null;
  function mp() {
    if (uh) return uh;
    var s,
      o = pp,
      d = o.length,
      g,
      b = "value" in Gr ? Gr.value : Gr.textContent,
      T = b.length;
    for (s = 0; s < d && o[s] === b[s]; s++);
    var z = d - s;
    for (g = 1; g <= z && o[d - g] === b[T - g]; g++);
    return (uh = b.slice(s, 1 < g ? 1 - g : void 0));
  }
  function Eo(s) {
    var o = s.keyCode;
    return (
      "charCode" in s
        ? ((s = s.charCode), s === 0 && o === 13 && (s = 13))
        : (s = o),
      s === 10 && (s = 13),
      32 <= s || s === 13 ? s : 0
    );
  }
  function rc() {
    return !0;
  }
  function wu() {
    return !1;
  }
  function Ra(s) {
    function o(d, g, b, T, z) {
      (this._reactName = d),
        (this._targetInst = b),
        (this.type = g),
        (this.nativeEvent = T),
        (this.target = z),
        (this.currentTarget = null);
      for (var W in s)
        s.hasOwnProperty(W) && ((d = s[W]), (this[W] = d ? d(T) : T[W]));
      return (
        (this.isDefaultPrevented = (
          T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1
        )
          ? rc
          : wu),
        (this.isPropagationStopped = wu),
        this
      );
    }
    return (
      m(o.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var d = this.nativeEvent;
          d &&
            (d.preventDefault
              ? d.preventDefault()
              : typeof d.returnValue != "unknown" && (d.returnValue = !1),
            (this.isDefaultPrevented = rc));
        },
        stopPropagation: function () {
          var d = this.nativeEvent;
          d &&
            (d.stopPropagation
              ? d.stopPropagation()
              : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0),
            (this.isPropagationStopped = rc));
        },
        persist: function () {},
        isPersistent: rc,
      }),
      o
    );
  }
  var To = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (s) {
        return s.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    oc = Ra(To),
    lc = m({}, To, { view: 0, detail: 0 }),
    Q0 = Ra(lc),
    Vr,
    cc,
    uc,
    fc = m({}, lc, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Ru,
      button: 0,
      buttons: 0,
      relatedTarget: function (s) {
        return s.relatedTarget === void 0
          ? s.fromElement === s.srcElement
            ? s.toElement
            : s.fromElement
          : s.relatedTarget;
      },
      movementX: function (s) {
        return "movementX" in s
          ? s.movementX
          : (s !== uc &&
              (uc && s.type === "mousemove"
                ? ((Vr = s.screenX - uc.screenX), (cc = s.screenY - uc.screenY))
                : (cc = Vr = 0),
              (uc = s)),
            Vr);
      },
      movementY: function (s) {
        return "movementY" in s ? s.movementY : cc;
      },
    }),
    gp = Ra(fc),
    $0 = m({}, fc, { dataTransfer: 0 }),
    v1 = Ra($0),
    ra = m({}, lc, { relatedTarget: 0 }),
    fh = Ra(ra),
    tg = m({}, To, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    eg = Ra(tg),
    ng = m({}, To, {
      clipboardData: function (s) {
        return "clipboardData" in s ? s.clipboardData : window.clipboardData;
      },
    }),
    ig = Ra(ng),
    Cu = m({}, To, { data: 0 }),
    hh = Ra(Cu),
    ag = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    sg = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    rg = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function vp(s) {
    var o = this.nativeEvent;
    return o.getModifierState
      ? o.getModifierState(s)
      : (s = rg[s])
      ? !!o[s]
      : !1;
  }
  function Ru() {
    return vp;
  }
  var og = m({}, lc, {
      key: function (s) {
        if (s.key) {
          var o = ag[s.key] || s.key;
          if (o !== "Unidentified") return o;
        }
        return s.type === "keypress"
          ? ((s = Eo(s)), s === 13 ? "Enter" : String.fromCharCode(s))
          : s.type === "keydown" || s.type === "keyup"
          ? sg[s.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Ru,
      charCode: function (s) {
        return s.type === "keypress" ? Eo(s) : 0;
      },
      keyCode: function (s) {
        return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
      },
      which: function (s) {
        return s.type === "keypress"
          ? Eo(s)
          : s.type === "keydown" || s.type === "keyup"
          ? s.keyCode
          : 0;
      },
    }),
    yp = Ra(og),
    xp = m({}, fc, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    dh = Ra(xp),
    lg = m({}, lc, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Ru,
    }),
    _p = Ra(lg),
    cg = m({}, To, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    kr = Ra(cg),
    bp = m({}, fc, {
      deltaX: function (s) {
        return "deltaX" in s
          ? s.deltaX
          : "wheelDeltaX" in s
          ? -s.wheelDeltaX
          : 0;
      },
      deltaY: function (s) {
        return "deltaY" in s
          ? s.deltaY
          : "wheelDeltaY" in s
          ? -s.wheelDeltaY
          : "wheelDelta" in s
          ? -s.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    y1 = Ra(bp),
    ug = m({}, To, { newState: 0, oldState: 0 }),
    wo = Ra(ug),
    jr = [9, 13, 27, 32],
    Bu = fr && "CompositionEvent" in window,
    vl = null;
  fr && "documentMode" in document && (vl = document.documentMode);
  var Du = fr && "TextEvent" in window && !vl,
    Uu = fr && (!Bu || (vl && 8 < vl && 11 >= vl)),
    Co = " ",
    oa = !1;
  function Ou(s, o) {
    switch (s) {
      case "keyup":
        return jr.indexOf(o.keyCode) !== -1;
      case "keydown":
        return o.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Ap(s) {
    return (s = s.detail), typeof s == "object" && "data" in s ? s.data : null;
  }
  var Ro = !1;
  function Nu(s, o) {
    switch (s) {
      case "compositionend":
        return Ap(o);
      case "keypress":
        return o.which !== 32 ? null : ((oa = !0), Co);
      case "textInput":
        return (s = o.data), s === Co && oa ? null : s;
      default:
        return null;
    }
  }
  function Sp(s, o) {
    if (Ro)
      return s === "compositionend" || (!Bu && Ou(s, o))
        ? ((s = mp()), (uh = pp = Gr = null), (Ro = !1), s)
        : null;
    switch (s) {
      case "paste":
        return null;
      case "keypress":
        if (!(o.ctrlKey || o.altKey || o.metaKey) || (o.ctrlKey && o.altKey)) {
          if (o.char && 1 < o.char.length) return o.char;
          if (o.which) return String.fromCharCode(o.which);
        }
        return null;
      case "compositionend":
        return Uu && o.locale !== "ko" ? null : o.data;
      default:
        return null;
    }
  }
  var ph = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function Mp(s) {
    var o = s && s.nodeName && s.nodeName.toLowerCase();
    return o === "input" ? !!ph[s.type] : o === "textarea";
  }
  function ja(s, o, d, g) {
    Mo ? (gl ? gl.push(g) : (gl = [g])) : (Mo = g),
      (o = cv(o, "onChange")),
      0 < o.length &&
        ((d = new oc("onChange", "change", null, d, g)),
        s.push({ event: d, listeners: o }));
  }
  var hc = null,
    yl = null;
  function fg(s) {
    MM(s, 0);
  }
  function Lu(s) {
    var o = ut(s);
    if (en(o)) return s;
  }
  function mh(s, o) {
    if (s === "change") return o;
  }
  var gh = !1;
  if (fr) {
    var vh;
    if (fr) {
      var dc = "oninput" in document;
      if (!dc) {
        var pc = document.createElement("div");
        pc.setAttribute("oninput", "return;"),
          (dc = typeof pc.oninput == "function");
      }
      vh = dc;
    } else vh = !1;
    gh = vh && (!document.documentMode || 9 < document.documentMode);
  }
  function pi() {
    hc && (hc.detachEvent("onpropertychange", hg), (yl = hc = null));
  }
  function hg(s) {
    if (s.propertyName === "value" && Lu(yl)) {
      var o = [];
      ja(o, yl, s, ch(s)), dp(fg, o);
    }
  }
  function x1(s, o, d) {
    s === "focusin"
      ? (pi(), (hc = o), (yl = d), hc.attachEvent("onpropertychange", hg))
      : s === "focusout" && pi();
  }
  function dg(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown")
      return Lu(yl);
  }
  function Iu(s, o) {
    if (s === "click") return Lu(o);
  }
  function Bo(s, o) {
    if (s === "input" || s === "change") return Lu(o);
  }
  function pg(s, o) {
    return (s === o && (s !== 0 || 1 / s === 1 / o)) || (s !== s && o !== o);
  }
  var Xa = typeof Object.is == "function" ? Object.is : pg;
  function Ys(s, o) {
    if (Xa(s, o)) return !0;
    if (
      typeof s != "object" ||
      s === null ||
      typeof o != "object" ||
      o === null
    )
      return !1;
    var d = Object.keys(s),
      g = Object.keys(o);
    if (d.length !== g.length) return !1;
    for (g = 0; g < d.length; g++) {
      var b = d[g];
      if (!je.call(o, b) || !Xa(s[b], o[b])) return !1;
    }
    return !0;
  }
  function Wa(s) {
    for (; s && s.firstChild; ) s = s.firstChild;
    return s;
  }
  function Ep(s, o) {
    var d = Wa(s);
    s = 0;
    for (var g; d; ) {
      if (d.nodeType === 3) {
        if (((g = s + d.textContent.length), s <= o && g >= o))
          return { node: d, offset: o - s };
        s = g;
      }
      t: {
        for (; d; ) {
          if (d.nextSibling) {
            d = d.nextSibling;
            break t;
          }
          d = d.parentNode;
        }
        d = void 0;
      }
      d = Wa(d);
    }
  }
  function Tp(s, o) {
    return s && o
      ? s === o
        ? !0
        : s && s.nodeType === 3
        ? !1
        : o && o.nodeType === 3
        ? Tp(s, o.parentNode)
        : "contains" in s
        ? s.contains(o)
        : s.compareDocumentPosition
        ? !!(s.compareDocumentPosition(o) & 16)
        : !1
      : !1;
  }
  function wp(s) {
    s =
      s != null &&
      s.ownerDocument != null &&
      s.ownerDocument.defaultView != null
        ? s.ownerDocument.defaultView
        : window;
    for (var o = on(s.document); o instanceof s.HTMLIFrameElement; ) {
      try {
        var d = typeof o.contentWindow.location.href == "string";
      } catch {
        d = !1;
      }
      if (d) s = o.contentWindow;
      else break;
      o = on(s.document);
    }
    return o;
  }
  function Pu(s) {
    var o = s && s.nodeName && s.nodeName.toLowerCase();
    return (
      o &&
      ((o === "input" &&
        (s.type === "text" ||
          s.type === "search" ||
          s.type === "tel" ||
          s.type === "url" ||
          s.type === "password")) ||
        o === "textarea" ||
        s.contentEditable === "true")
    );
  }
  var Cp = fr && "documentMode" in document && 11 >= document.documentMode,
    Xr = null,
    yh = null,
    zu = null,
    xh = !1;
  function Rp(s, o, d) {
    var g =
      d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument;
    xh ||
      Xr == null ||
      Xr !== on(g) ||
      ((g = Xr),
      "selectionStart" in g && Pu(g)
        ? (g = { start: g.selectionStart, end: g.selectionEnd })
        : ((g = (
            (g.ownerDocument && g.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (g = {
            anchorNode: g.anchorNode,
            anchorOffset: g.anchorOffset,
            focusNode: g.focusNode,
            focusOffset: g.focusOffset,
          })),
      (zu && Ys(zu, g)) ||
        ((zu = g),
        (g = cv(yh, "onSelect")),
        0 < g.length &&
          ((o = new oc("onSelect", "select", null, o, d)),
          s.push({ event: o, listeners: g }),
          (o.target = Xr))));
  }
  function la(s, o) {
    var d = {};
    return (
      (d[s.toLowerCase()] = o.toLowerCase()),
      (d["Webkit" + s] = "webkit" + o),
      (d["Moz" + s] = "moz" + o),
      d
    );
  }
  var Do = {
      animationend: la("Animation", "AnimationEnd"),
      animationiteration: la("Animation", "AnimationIteration"),
      animationstart: la("Animation", "AnimationStart"),
      transitionrun: la("Transition", "TransitionRun"),
      transitionstart: la("Transition", "TransitionStart"),
      transitioncancel: la("Transition", "TransitionCancel"),
      transitionend: la("Transition", "TransitionEnd"),
    },
    _h = {},
    mg = {};
  fr &&
    ((mg = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete Do.animationend.animation,
      delete Do.animationiteration.animation,
      delete Do.animationstart.animation),
    "TransitionEvent" in window || delete Do.transitionend.transition);
  function Wr(s) {
    if (_h[s]) return _h[s];
    if (!Do[s]) return s;
    var o = Do[s],
      d;
    for (d in o) if (o.hasOwnProperty(d) && d in mg) return (_h[s] = o[d]);
    return s;
  }
  var Ba = Wr("animationend"),
    Bp = Wr("animationiteration"),
    Ya = Wr("animationstart"),
    gg = Wr("transitionrun"),
    Yr = Wr("transitionstart"),
    mc = Wr("transitioncancel"),
    qr = Wr("transitionend"),
    bh = new Map(),
    Fu =
      "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  Fu.push("scrollEnd");
  function Qi(s, o) {
    bh.set(s, o), ae(o, [s]);
  }
  var Dp = new WeakMap();
  function ca(s, o) {
    if (typeof s == "object" && s !== null) {
      var d = Dp.get(s);
      return d !== void 0
        ? d
        : ((o = { value: s, source: o, stack: Mn(o) }), Dp.set(s, o), o);
    }
    return { value: s, source: o, stack: Mn(o) };
  }
  var xa = [],
    Ts = 0,
    Ah = 0;
  function Hu() {
    for (var s = Ts, o = (Ah = Ts = 0); o < s; ) {
      var d = xa[o];
      xa[o++] = null;
      var g = xa[o];
      xa[o++] = null;
      var b = xa[o];
      xa[o++] = null;
      var T = xa[o];
      if (((xa[o++] = null), g !== null && b !== null)) {
        var z = g.pending;
        z === null ? (b.next = b) : ((b.next = z.next), (z.next = b)),
          (g.pending = b);
      }
      T !== 0 && Up(d, b, T);
    }
  }
  function Uo(s, o, d, g) {
    (xa[Ts++] = s),
      (xa[Ts++] = o),
      (xa[Ts++] = d),
      (xa[Ts++] = g),
      (Ah |= g),
      (s.lanes |= g),
      (s = s.alternate),
      s !== null && (s.lanes |= g);
  }
  function Sh(s, o, d, g) {
    return Uo(s, o, d, g), gc(s);
  }
  function Kr(s, o) {
    return Uo(s, null, null, o), gc(s);
  }
  function Up(s, o, d) {
    s.lanes |= d;
    var g = s.alternate;
    g !== null && (g.lanes |= d);
    for (var b = !1, T = s.return; T !== null; )
      (T.childLanes |= d),
        (g = T.alternate),
        g !== null && (g.childLanes |= d),
        T.tag === 22 &&
          ((s = T.stateNode), s === null || s._visibility & 1 || (b = !0)),
        (s = T),
        (T = T.return);
    return s.tag === 3
      ? ((T = s.stateNode),
        b &&
          o !== null &&
          ((b = 31 - me(d)),
          (s = T.hiddenUpdates),
          (g = s[b]),
          g === null ? (s[b] = [o]) : g.push(o),
          (o.lane = d | 536870912)),
        T)
      : null;
  }
  function gc(s) {
    if (50 < Er) throw ((Er = 0), (Il = null), Error(n(185)));
    for (var o = s.return; o !== null; ) (s = o), (o = s.return);
    return s.tag === 3 ? s.stateNode : null;
  }
  var Oo = {};
  function Op(s, o, d, g) {
    (this.tag = s),
      (this.key = d),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = o),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = g),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function qa(s, o, d, g) {
    return new Op(s, o, d, g);
  }
  function Gu(s) {
    return (s = s.prototype), !(!s || !s.isReactComponent);
  }
  function Bi(s, o) {
    var d = s.alternate;
    return (
      d === null
        ? ((d = qa(s.tag, o, s.key, s.mode)),
          (d.elementType = s.elementType),
          (d.type = s.type),
          (d.stateNode = s.stateNode),
          (d.alternate = s),
          (s.alternate = d))
        : ((d.pendingProps = o),
          (d.type = s.type),
          (d.flags = 0),
          (d.subtreeFlags = 0),
          (d.deletions = null)),
      (d.flags = s.flags & 65011712),
      (d.childLanes = s.childLanes),
      (d.lanes = s.lanes),
      (d.child = s.child),
      (d.memoizedProps = s.memoizedProps),
      (d.memoizedState = s.memoizedState),
      (d.updateQueue = s.updateQueue),
      (o = s.dependencies),
      (d.dependencies =
        o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }),
      (d.sibling = s.sibling),
      (d.index = s.index),
      (d.ref = s.ref),
      (d.refCleanup = s.refCleanup),
      d
    );
  }
  function Np(s, o) {
    s.flags &= 65011714;
    var d = s.alternate;
    return (
      d === null
        ? ((s.childLanes = 0),
          (s.lanes = o),
          (s.child = null),
          (s.subtreeFlags = 0),
          (s.memoizedProps = null),
          (s.memoizedState = null),
          (s.updateQueue = null),
          (s.dependencies = null),
          (s.stateNode = null))
        : ((s.childLanes = d.childLanes),
          (s.lanes = d.lanes),
          (s.child = d.child),
          (s.subtreeFlags = 0),
          (s.deletions = null),
          (s.memoizedProps = d.memoizedProps),
          (s.memoizedState = d.memoizedState),
          (s.updateQueue = d.updateQueue),
          (s.type = d.type),
          (o = d.dependencies),
          (s.dependencies =
            o === null
              ? null
              : { lanes: o.lanes, firstContext: o.firstContext })),
      s
    );
  }
  function $i(s, o, d, g, b, T) {
    var z = 0;
    if (((g = s), typeof s == "function")) Gu(s) && (z = 1);
    else if (typeof s == "string")
      z = OD(s, d, ht.current)
        ? 26
        : s === "html" || s === "head" || s === "body"
        ? 27
        : 5;
    else
      t: switch (s) {
        case N:
          return (s = qa(31, d, o, b)), (s.elementType = N), (s.lanes = T), s;
        case M:
          return No(d.children, b, T, o);
        case C:
          (z = 8), (b |= 24);
          break;
        case E:
          return (
            (s = qa(12, d, o, b | 2)), (s.elementType = E), (s.lanes = T), s
          );
        case I:
          return (s = qa(13, d, o, b)), (s.elementType = I), (s.lanes = T), s;
        case P:
          return (s = qa(19, d, o, b)), (s.elementType = P), (s.lanes = T), s;
        default:
          if (typeof s == "object" && s !== null)
            switch (s.$$typeof) {
              case S:
              case B:
                z = 10;
                break t;
              case R:
                z = 9;
                break t;
              case D:
                z = 11;
                break t;
              case V:
                z = 14;
                break t;
              case F:
                (z = 16), (g = null);
                break t;
            }
          (z = 29),
            (d = Error(n(130, s === null ? "null" : typeof s, ""))),
            (g = null);
      }
    return (
      (o = qa(z, d, o, b)), (o.elementType = s), (o.type = g), (o.lanes = T), o
    );
  }
  function No(s, o, d, g) {
    return (s = qa(7, s, g, o)), (s.lanes = d), s;
  }
  function Vu(s, o, d) {
    return (s = qa(6, s, null, o)), (s.lanes = d), s;
  }
  function Mh(s, o, d) {
    return (
      (o = qa(4, s.children !== null ? s.children : [], s.key, o)),
      (o.lanes = d),
      (o.stateNode = {
        containerInfo: s.containerInfo,
        pendingChildren: null,
        implementation: s.implementation,
      }),
      o
    );
  }
  var vc = [],
    Ka = 0,
    ku = null,
    yc = 0,
    ua = [],
    as = 0,
    Lo = null,
    hr = 1,
    dr = "";
  function Jr(s, o) {
    (vc[Ka++] = yc), (vc[Ka++] = ku), (ku = s), (yc = o);
  }
  function Eh(s, o, d) {
    (ua[as++] = hr), (ua[as++] = dr), (ua[as++] = Lo), (Lo = s);
    var g = hr;
    s = dr;
    var b = 32 - me(g) - 1;
    (g &= ~(1 << b)), (d += 1);
    var T = 32 - me(o) + b;
    if (30 < T) {
      var z = b - (b % 5);
      (T = (g & ((1 << z) - 1)).toString(32)),
        (g >>= z),
        (b -= z),
        (hr = (1 << (32 - me(o) + b)) | (d << b) | g),
        (dr = T + s);
    } else (hr = (1 << T) | (d << b) | g), (dr = s);
  }
  function Lp(s) {
    s.return !== null && (Jr(s, 1), Eh(s, 1, 0));
  }
  function Ip(s) {
    for (; s === ku; )
      (ku = vc[--Ka]), (vc[Ka] = null), (yc = vc[--Ka]), (vc[Ka] = null);
    for (; s === Lo; )
      (Lo = ua[--as]),
        (ua[as] = null),
        (dr = ua[--as]),
        (ua[as] = null),
        (hr = ua[--as]),
        (ua[as] = null);
  }
  var Da = null,
    mi = null,
    Pn = !1,
    ws = null,
    ss = !1,
    Th = Error(n(519));
  function Io(s) {
    var o = Error(n(418, ""));
    throw (xl(ca(o, s)), Th);
  }
  function vg(s) {
    var o = s.stateNode,
      d = s.type,
      g = s.memoizedProps;
    switch (((o[xi] = s), (o[Ci] = g), d)) {
      case "dialog":
        Rn("cancel", o), Rn("close", o);
        break;
      case "iframe":
      case "object":
      case "embed":
        Rn("load", o);
        break;
      case "video":
      case "audio":
        for (d = 0; d < dm.length; d++) Rn(dm[d], o);
        break;
      case "source":
        Rn("error", o);
        break;
      case "img":
      case "image":
      case "link":
        Rn("error", o), Rn("load", o);
        break;
      case "details":
        Rn("toggle", o);
        break;
      case "input":
        Rn("invalid", o),
          gn(
            o,
            g.value,
            g.defaultValue,
            g.checked,
            g.defaultChecked,
            g.type,
            g.name,
            !0
          ),
          Yn(o);
        break;
      case "select":
        Rn("invalid", o);
        break;
      case "textarea":
        Rn("invalid", o), Zi(o, g.value, g.defaultValue, g.children), Yn(o);
    }
    (d = g.children),
      (typeof d != "string" && typeof d != "number" && typeof d != "bigint") ||
      o.textContent === "" + d ||
      g.suppressHydrationWarning === !0 ||
      CM(o.textContent, d)
        ? (g.popover != null && (Rn("beforetoggle", o), Rn("toggle", o)),
          g.onScroll != null && Rn("scroll", o),
          g.onScrollEnd != null && Rn("scrollend", o),
          g.onClick != null && (o.onclick = uv),
          (o = !0))
        : (o = !1),
      o || Io(s);
  }
  function Pp(s) {
    for (Da = s.return; Da; )
      switch (Da.tag) {
        case 5:
        case 13:
          ss = !1;
          return;
        case 27:
        case 3:
          ss = !0;
          return;
        default:
          Da = Da.return;
      }
  }
  function qs(s) {
    if (s !== Da) return !1;
    if (!Pn) return Pp(s), (Pn = !0), !1;
    var o = s.tag,
      d;
    if (
      ((d = o !== 3 && o !== 27) &&
        ((d = o === 5) &&
          ((d = s.type),
          (d =
            !(d !== "form" && d !== "button") || F1(s.type, s.memoizedProps))),
        (d = !d)),
      d && mi && Io(s),
      Pp(s),
      o === 13)
    ) {
      if (((s = s.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
        throw Error(n(317));
      t: {
        for (s = s.nextSibling, o = 0; s; ) {
          if (s.nodeType === 8)
            if (((d = s.data), d === "/$")) {
              if (o === 0) {
                mi = uo(s.nextSibling);
                break t;
              }
              o--;
            } else (d !== "$" && d !== "$!" && d !== "$?") || o++;
          s = s.nextSibling;
        }
        mi = null;
      }
    } else
      o === 27
        ? ((o = mi), kc(s.type) ? ((s = k1), (k1 = null), (mi = s)) : (mi = o))
        : (mi = Da ? uo(s.stateNode.nextSibling) : null);
    return !0;
  }
  function xc() {
    (mi = Da = null), (Pn = !1);
  }
  function kn() {
    var s = ws;
    return (
      s !== null &&
        (Ze === null ? (Ze = s) : Ze.push.apply(Ze, s), (ws = null)),
      s
    );
  }
  function xl(s) {
    ws === null ? (ws = [s]) : ws.push(s);
  }
  var zp = ft(null),
    Po = null,
    Zr = null;
  function zo(s, o, d) {
    Rt(zp, o._currentValue), (o._currentValue = d);
  }
  function Qr(s) {
    (s._currentValue = zp.current), At(zp);
  }
  function Fp(s, o, d) {
    for (; s !== null; ) {
      var g = s.alternate;
      if (
        ((s.childLanes & o) !== o
          ? ((s.childLanes |= o), g !== null && (g.childLanes |= o))
          : g !== null && (g.childLanes & o) !== o && (g.childLanes |= o),
        s === d)
      )
        break;
      s = s.return;
    }
  }
  function ju(s, o, d, g) {
    var b = s.child;
    for (b !== null && (b.return = s); b !== null; ) {
      var T = b.dependencies;
      if (T !== null) {
        var z = b.child;
        T = T.firstContext;
        t: for (; T !== null; ) {
          var W = T;
          T = b;
          for (var at = 0; at < o.length; at++)
            if (W.context === o[at]) {
              (T.lanes |= d),
                (W = T.alternate),
                W !== null && (W.lanes |= d),
                Fp(T.return, d, s),
                g || (z = null);
              break t;
            }
          T = W.next;
        }
      } else if (b.tag === 18) {
        if (((z = b.return), z === null)) throw Error(n(341));
        (z.lanes |= d),
          (T = z.alternate),
          T !== null && (T.lanes |= d),
          Fp(z, d, s),
          (z = null);
      } else z = b.child;
      if (z !== null) z.return = b;
      else
        for (z = b; z !== null; ) {
          if (z === s) {
            z = null;
            break;
          }
          if (((b = z.sibling), b !== null)) {
            (b.return = z.return), (z = b);
            break;
          }
          z = z.return;
        }
      b = z;
    }
  }
  function Cs(s, o, d, g) {
    s = null;
    for (var b = o, T = !1; b !== null; ) {
      if (!T) {
        if ((b.flags & 524288) !== 0) T = !0;
        else if ((b.flags & 262144) !== 0) break;
      }
      if (b.tag === 10) {
        var z = b.alternate;
        if (z === null) throw Error(n(387));
        if (((z = z.memoizedProps), z !== null)) {
          var W = b.type;
          Xa(b.pendingProps.value, z.value) ||
            (s !== null ? s.push(W) : (s = [W]));
        }
      } else if (b === re.current) {
        if (((z = b.alternate), z === null)) throw Error(n(387));
        z.memoizedState.memoizedState !== b.memoizedState.memoizedState &&
          (s !== null ? s.push(xm) : (s = [xm]));
      }
      b = b.return;
    }
    s !== null && ju(o, s, d, g), (o.flags |= 262144);
  }
  function Xu(s) {
    for (s = s.firstContext; s !== null; ) {
      if (!Xa(s.context._currentValue, s.memoizedValue)) return !0;
      s = s.next;
    }
    return !1;
  }
  function pr(s) {
    (Po = s),
      (Zr = null),
      (s = s.dependencies),
      s !== null && (s.firstContext = null);
  }
  function _i(s) {
    return wh(Po, s);
  }
  function Wu(s, o) {
    return Po === null && pr(s), wh(s, o);
  }
  function wh(s, o) {
    var d = o._currentValue;
    if (((o = { context: o, memoizedValue: d, next: null }), Zr === null)) {
      if (s === null) throw Error(n(308));
      (Zr = o),
        (s.dependencies = { lanes: 0, firstContext: o }),
        (s.flags |= 524288);
    } else Zr = Zr.next = o;
    return d;
  }
  var Hp =
      typeof AbortController < "u"
        ? AbortController
        : function () {
            var s = [],
              o = (this.signal = {
                aborted: !1,
                addEventListener: function (d, g) {
                  s.push(g);
                },
              });
            this.abort = function () {
              (o.aborted = !0),
                s.forEach(function (d) {
                  return d();
                });
            };
          },
    _1 = i.unstable_scheduleCallback,
    yg = i.unstable_NormalPriority,
    zi = {
      $$typeof: B,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
    };
  function Ch() {
    return { controller: new Hp(), data: new Map(), refCount: 0 };
  }
  function _c(s) {
    s.refCount--,
      s.refCount === 0 &&
        _1(yg, function () {
          s.controller.abort();
        });
  }
  var bc = null,
    Yu = 0,
    fn = 0,
    Ac = null;
  function rs(s, o) {
    if (bc === null) {
      var d = (bc = []);
      (Yu = 0),
        (fn = B1()),
        (Ac = {
          status: "pending",
          value: void 0,
          then: function (g) {
            d.push(g);
          },
        });
    }
    return Yu++, o.then(Rh, Rh), o;
  }
  function Rh() {
    if (--Yu === 0 && bc !== null) {
      Ac !== null && (Ac.status = "fulfilled");
      var s = bc;
      (bc = null), (fn = 0), (Ac = null);
      for (var o = 0; o < s.length; o++) (0, s[o])();
    }
  }
  function b1(s, o) {
    var d = [],
      g = {
        status: "pending",
        value: null,
        reason: null,
        then: function (b) {
          d.push(b);
        },
      };
    return (
      s.then(
        function () {
          (g.status = "fulfilled"), (g.value = o);
          for (var b = 0; b < d.length; b++) (0, d[b])(o);
        },
        function (b) {
          for (g.status = "rejected", g.reason = b, b = 0; b < d.length; b++)
            (0, d[b])(void 0);
        }
      ),
      g
    );
  }
  var qu = j.S;
  j.S = function (s, o) {
    typeof o == "object" &&
      o !== null &&
      typeof o.then == "function" &&
      rs(s, o),
      qu !== null && qu(s, o);
  };
  var Rs = ft(null);
  function Fo() {
    var s = Rs.current;
    return s !== null ? s : cn.pooledCache;
  }
  function Ku(s, o) {
    o === null ? Rt(Rs, Rs.current) : Rt(Rs, o.pool);
  }
  function Bh() {
    var s = Fo();
    return s === null ? null : { parent: zi._currentValue, pool: s };
  }
  var Ju = Error(n(460)),
    Gp = Error(n(474)),
    Ks = Error(n(542)),
    Zu = { then: function () {} };
  function Dh(s) {
    return (s = s.status), s === "fulfilled" || s === "rejected";
  }
  function Sc() {}
  function Uh(s, o, d) {
    switch (
      ((d = s[d]),
      d === void 0 ? s.push(o) : d !== o && (o.then(Sc, Sc), (o = d)),
      o.status)
    ) {
      case "fulfilled":
        return o.value;
      case "rejected":
        throw ((s = o.reason), xg(s), s);
      default:
        if (typeof o.status == "string") o.then(Sc, Sc);
        else {
          if (((s = cn), s !== null && 100 < s.shellSuspendCounter))
            throw Error(n(482));
          (s = o),
            (s.status = "pending"),
            s.then(
              function (g) {
                if (o.status === "pending") {
                  var b = o;
                  (b.status = "fulfilled"), (b.value = g);
                }
              },
              function (g) {
                if (o.status === "pending") {
                  var b = o;
                  (b.status = "rejected"), (b.reason = g);
                }
              }
            );
        }
        switch (o.status) {
          case "fulfilled":
            return o.value;
          case "rejected":
            throw ((s = o.reason), xg(s), s);
        }
        throw ((Bs = o), Ju);
    }
  }
  var Bs = null;
  function Vp() {
    if (Bs === null) throw Error(n(459));
    var s = Bs;
    return (Bs = null), s;
  }
  function xg(s) {
    if (s === Ju || s === Ks) throw Error(n(483));
  }
  var $r = !1;
  function kp(s) {
    s.updateQueue = {
      baseState: s.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null,
    };
  }
  function nn(s, o) {
    (s = s.updateQueue),
      o.updateQueue === s &&
        (o.updateQueue = {
          baseState: s.baseState,
          firstBaseUpdate: s.firstBaseUpdate,
          lastBaseUpdate: s.lastBaseUpdate,
          shared: s.shared,
          callbacks: null,
        });
  }
  function mr(s) {
    return { lane: s, tag: 0, payload: null, callback: null, next: null };
  }
  function to(s, o, d) {
    var g = s.updateQueue;
    if (g === null) return null;
    if (((g = g.shared), (jn & 2) !== 0)) {
      var b = g.pending;
      return (
        b === null ? (o.next = o) : ((o.next = b.next), (b.next = o)),
        (g.pending = o),
        (o = gc(s)),
        Up(s, null, d),
        o
      );
    }
    return Uo(s, g, o, d), gc(s);
  }
  function _l(s, o, d) {
    if (
      ((o = o.updateQueue), o !== null && ((o = o.shared), (d & 4194048) !== 0))
    ) {
      var g = o.lanes;
      (g &= s.pendingLanes), (d |= g), (o.lanes = d), be(s, d);
    }
  }
  function Mc(s, o) {
    var d = s.updateQueue,
      g = s.alternate;
    if (g !== null && ((g = g.updateQueue), d === g)) {
      var b = null,
        T = null;
      if (((d = d.firstBaseUpdate), d !== null)) {
        do {
          var z = {
            lane: d.lane,
            tag: d.tag,
            payload: d.payload,
            callback: null,
            next: null,
          };
          T === null ? (b = T = z) : (T = T.next = z), (d = d.next);
        } while (d !== null);
        T === null ? (b = T = o) : (T = T.next = o);
      } else b = T = o;
      (d = {
        baseState: g.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: T,
        shared: g.shared,
        callbacks: g.callbacks,
      }),
        (s.updateQueue = d);
      return;
    }
    (s = d.lastBaseUpdate),
      s === null ? (d.firstBaseUpdate = o) : (s.next = o),
      (d.lastBaseUpdate = o);
  }
  var jp = !1;
  function Qu() {
    if (jp) {
      var s = Ac;
      if (s !== null) throw s;
    }
  }
  function Ec(s, o, d, g) {
    jp = !1;
    var b = s.updateQueue;
    $r = !1;
    var T = b.firstBaseUpdate,
      z = b.lastBaseUpdate,
      W = b.shared.pending;
    if (W !== null) {
      b.shared.pending = null;
      var at = W,
        Ct = at.next;
      (at.next = null), z === null ? (T = Ct) : (z.next = Ct), (z = at);
      var Wt = s.alternate;
      Wt !== null &&
        ((Wt = Wt.updateQueue),
        (W = Wt.lastBaseUpdate),
        W !== z &&
          (W === null ? (Wt.firstBaseUpdate = Ct) : (W.next = Ct),
          (Wt.lastBaseUpdate = at)));
    }
    if (T !== null) {
      var ne = b.baseState;
      (z = 0), (Wt = Ct = at = null), (W = T);
      do {
        var Ot = W.lane & -536870913,
          Nt = Ot !== W.lane;
        if (Nt ? (We & Ot) === Ot : (g & Ot) === Ot) {
          Ot !== 0 && Ot === fn && (jp = !0),
            Wt !== null &&
              (Wt = Wt.next =
                {
                  lane: 0,
                  tag: W.tag,
                  payload: W.payload,
                  callback: null,
                  next: null,
                });
          t: {
            var sn = s,
              $e = W;
            Ot = o;
            var ui = d;
            switch ($e.tag) {
              case 1:
                if (((sn = $e.payload), typeof sn == "function")) {
                  ne = sn.call(ui, ne, Ot);
                  break t;
                }
                ne = sn;
                break t;
              case 3:
                sn.flags = (sn.flags & -65537) | 128;
              case 0:
                if (
                  ((sn = $e.payload),
                  (Ot = typeof sn == "function" ? sn.call(ui, ne, Ot) : sn),
                  Ot == null)
                )
                  break t;
                ne = m({}, ne, Ot);
                break t;
              case 2:
                $r = !0;
            }
          }
          (Ot = W.callback),
            Ot !== null &&
              ((s.flags |= 64),
              Nt && (s.flags |= 8192),
              (Nt = b.callbacks),
              Nt === null ? (b.callbacks = [Ot]) : Nt.push(Ot));
        } else
          (Nt = {
            lane: Ot,
            tag: W.tag,
            payload: W.payload,
            callback: W.callback,
            next: null,
          }),
            Wt === null ? ((Ct = Wt = Nt), (at = ne)) : (Wt = Wt.next = Nt),
            (z |= Ot);
        if (((W = W.next), W === null)) {
          if (((W = b.shared.pending), W === null)) break;
          (Nt = W),
            (W = Nt.next),
            (Nt.next = null),
            (b.lastBaseUpdate = Nt),
            (b.shared.pending = null);
        }
      } while (!0);
      Wt === null && (at = ne),
        (b.baseState = at),
        (b.firstBaseUpdate = Ct),
        (b.lastBaseUpdate = Wt),
        T === null && (b.shared.lanes = 0),
        (ir |= z),
        (s.lanes = z),
        (s.memoizedState = ne);
    }
  }
  function Tc(s, o) {
    if (typeof s != "function") throw Error(n(191, s));
    s.call(o);
  }
  function _g(s, o) {
    var d = s.callbacks;
    if (d !== null)
      for (s.callbacks = null, s = 0; s < d.length; s++) Tc(d[s], o);
  }
  var wc = ft(null),
    Oh = ft(0);
  function bg(s, o) {
    (s = Is), Rt(Oh, s), Rt(wc, o), (Is = s | o.baseLanes);
  }
  function Xp() {
    Rt(Oh, Is), Rt(wc, wc.current);
  }
  function $u() {
    (Is = Oh.current), At(wc), At(Oh);
  }
  var eo = 0,
    hn = null,
    qn = null,
    Fi = null,
    Nh = !1,
    Ho = !1,
    Ua = !1,
    ki = 0,
    Ds = 0,
    fa = null,
    Ag = 0;
  function Di() {
    throw Error(n(321));
  }
  function _a(s, o) {
    if (o === null) return !1;
    for (var d = 0; d < o.length && d < s.length; d++)
      if (!Xa(s[d], o[d])) return !1;
    return !0;
  }
  function no(s, o, d, g, b, T) {
    return (
      (eo = T),
      (hn = o),
      (o.memoizedState = null),
      (o.updateQueue = null),
      (o.lanes = 0),
      (j.H = s === null || s.memoizedState === null ? kh : om),
      (Ua = !1),
      (T = d(g, b)),
      (Ua = !1),
      Ho && (T = Mg(o, d, g, b)),
      Sg(s),
      T
    );
  }
  function Sg(s) {
    j.H = nf;
    var o = qn !== null && qn.next !== null;
    if (((eo = 0), (Fi = qn = hn = null), (Nh = !1), (Ds = 0), (fa = null), o))
      throw Error(n(300));
    s === null ||
      ta ||
      ((s = s.dependencies), s !== null && Xu(s) && (ta = !0));
  }
  function Mg(s, o, d, g) {
    hn = s;
    var b = 0;
    do {
      if ((Ho && (fa = null), (Ds = 0), (Ho = !1), 25 <= b))
        throw Error(n(301));
      if (((b += 1), (Fi = qn = null), s.updateQueue != null)) {
        var T = s.updateQueue;
        (T.lastEffect = null),
          (T.events = null),
          (T.stores = null),
          T.memoCache != null && (T.memoCache.index = 0);
      }
      (j.H = Jg), (T = o(d, g));
    } while (Ho);
    return T;
  }
  function A1() {
    var s = j.H,
      o = s.useState()[0];
    return (
      (o = typeof o.then == "function" ? Js(o) : o),
      (s = s.useState()[0]),
      (qn !== null ? qn.memoizedState : null) !== s && (hn.flags |= 1024),
      o
    );
  }
  function Wp() {
    var s = ki !== 0;
    return (ki = 0), s;
  }
  function Lh(s, o, d) {
    (o.updateQueue = s.updateQueue), (o.flags &= -2053), (s.lanes &= ~d);
  }
  function Yp(s) {
    if (Nh) {
      for (s = s.memoizedState; s !== null; ) {
        var o = s.queue;
        o !== null && (o.pending = null), (s = s.next);
      }
      Nh = !1;
    }
    (eo = 0), (Fi = qn = hn = null), (Ho = !1), (Ds = ki = 0), (fa = null);
  }
  function Oa() {
    var s = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Fi === null ? (hn.memoizedState = Fi = s) : (Fi = Fi.next = s), Fi;
  }
  function Hi() {
    if (qn === null) {
      var s = hn.alternate;
      s = s !== null ? s.memoizedState : null;
    } else s = qn.next;
    var o = Fi === null ? hn.memoizedState : Fi.next;
    if (o !== null) (Fi = o), (qn = s);
    else {
      if (s === null)
        throw hn.alternate === null ? Error(n(467)) : Error(n(310));
      (qn = s),
        (s = {
          memoizedState: qn.memoizedState,
          baseState: qn.baseState,
          baseQueue: qn.baseQueue,
          queue: qn.queue,
          next: null,
        }),
        Fi === null ? (hn.memoizedState = Fi = s) : (Fi = Fi.next = s);
    }
    return Fi;
  }
  function Go() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Js(s) {
    var o = Ds;
    return (
      (Ds += 1),
      fa === null && (fa = []),
      (s = Uh(fa, s, o)),
      (o = hn),
      (Fi === null ? o.memoizedState : Fi.next) === null &&
        ((o = o.alternate),
        (j.H = o === null || o.memoizedState === null ? kh : om)),
      s
    );
  }
  function Ih(s) {
    if (s !== null && typeof s == "object") {
      if (typeof s.then == "function") return Js(s);
      if (s.$$typeof === B) return _i(s);
    }
    throw Error(n(438, String(s)));
  }
  function qp(s) {
    var o = null,
      d = hn.updateQueue;
    if ((d !== null && (o = d.memoCache), o == null)) {
      var g = hn.alternate;
      g !== null &&
        ((g = g.updateQueue),
        g !== null &&
          ((g = g.memoCache),
          g != null &&
            (o = {
              data: g.data.map(function (b) {
                return b.slice();
              }),
              index: 0,
            })));
    }
    if (
      (o == null && (o = { data: [], index: 0 }),
      d === null && ((d = Go()), (hn.updateQueue = d)),
      (d.memoCache = o),
      (d = o.data[o.index]),
      d === void 0)
    )
      for (d = o.data[o.index] = Array(s), g = 0; g < s; g++) d[g] = L;
    return o.index++, d;
  }
  function io(s, o) {
    return typeof o == "function" ? o(s) : o;
  }
  function Vo(s) {
    var o = Hi();
    return Kp(o, qn, s);
  }
  function Kp(s, o, d) {
    var g = s.queue;
    if (g === null) throw Error(n(311));
    g.lastRenderedReducer = d;
    var b = s.baseQueue,
      T = g.pending;
    if (T !== null) {
      if (b !== null) {
        var z = b.next;
        (b.next = T.next), (T.next = z);
      }
      (o.baseQueue = b = T), (g.pending = null);
    }
    if (((T = s.baseState), b === null)) s.memoizedState = T;
    else {
      o = b.next;
      var W = (z = null),
        at = null,
        Ct = o,
        Wt = !1;
      do {
        var ne = Ct.lane & -536870913;
        if (ne !== Ct.lane ? (We & ne) === ne : (eo & ne) === ne) {
          var Ot = Ct.revertLane;
          if (Ot === 0)
            at !== null &&
              (at = at.next =
                {
                  lane: 0,
                  revertLane: 0,
                  action: Ct.action,
                  hasEagerState: Ct.hasEagerState,
                  eagerState: Ct.eagerState,
                  next: null,
                }),
              ne === fn && (Wt = !0);
          else if ((eo & Ot) === Ot) {
            (Ct = Ct.next), Ot === fn && (Wt = !0);
            continue;
          } else
            (ne = {
              lane: 0,
              revertLane: Ct.revertLane,
              action: Ct.action,
              hasEagerState: Ct.hasEagerState,
              eagerState: Ct.eagerState,
              next: null,
            }),
              at === null ? ((W = at = ne), (z = T)) : (at = at.next = ne),
              (hn.lanes |= Ot),
              (ir |= Ot);
          (ne = Ct.action),
            Ua && d(T, ne),
            (T = Ct.hasEagerState ? Ct.eagerState : d(T, ne));
        } else
          (Ot = {
            lane: ne,
            revertLane: Ct.revertLane,
            action: Ct.action,
            hasEagerState: Ct.hasEagerState,
            eagerState: Ct.eagerState,
            next: null,
          }),
            at === null ? ((W = at = Ot), (z = T)) : (at = at.next = Ot),
            (hn.lanes |= ne),
            (ir |= ne);
        Ct = Ct.next;
      } while (Ct !== null && Ct !== o);
      if (
        (at === null ? (z = T) : (at.next = W),
        !Xa(T, s.memoizedState) && ((ta = !0), Wt && ((d = Ac), d !== null)))
      )
        throw d;
      (s.memoizedState = T),
        (s.baseState = z),
        (s.baseQueue = at),
        (g.lastRenderedState = T);
    }
    return b === null && (g.lanes = 0), [s.memoizedState, g.dispatch];
  }
  function Jp(s) {
    var o = Hi(),
      d = o.queue;
    if (d === null) throw Error(n(311));
    d.lastRenderedReducer = s;
    var g = d.dispatch,
      b = d.pending,
      T = o.memoizedState;
    if (b !== null) {
      d.pending = null;
      var z = (b = b.next);
      do (T = s(T, z.action)), (z = z.next);
      while (z !== b);
      Xa(T, o.memoizedState) || (ta = !0),
        (o.memoizedState = T),
        o.baseQueue === null && (o.baseState = T),
        (d.lastRenderedState = T);
    }
    return [T, g];
  }
  function Eg(s, o, d) {
    var g = hn,
      b = Hi(),
      T = Pn;
    if (T) {
      if (d === void 0) throw Error(n(407));
      d = d();
    } else d = o();
    var z = !Xa((qn || b).memoizedState, d);
    z && ((b.memoizedState = d), (ta = !0)), (b = b.queue);
    var W = wg.bind(null, g, b, s);
    if (
      (Bc(2048, 8, W, [s]),
      b.getSnapshot !== o || z || (Fi !== null && Fi.memoizedState.tag & 1))
    ) {
      if (
        ((g.flags |= 2048),
        Rc(9, tf(), Tg.bind(null, g, b, d, o), null),
        cn === null)
      )
        throw Error(n(349));
      T || (eo & 124) !== 0 || Cc(g, o, d);
    }
    return d;
  }
  function Cc(s, o, d) {
    (s.flags |= 16384),
      (s = { getSnapshot: o, value: d }),
      (o = hn.updateQueue),
      o === null
        ? ((o = Go()), (hn.updateQueue = o), (o.stores = [s]))
        : ((d = o.stores), d === null ? (o.stores = [s]) : d.push(s));
  }
  function Tg(s, o, d, g) {
    (o.value = d), (o.getSnapshot = g), Cg(o) && Rg(s);
  }
  function wg(s, o, d) {
    return d(function () {
      Cg(o) && Rg(s);
    });
  }
  function Cg(s) {
    var o = s.getSnapshot;
    s = s.value;
    try {
      var d = o();
      return !Xa(s, d);
    } catch {
      return !0;
    }
  }
  function Rg(s) {
    var o = Kr(s, 2);
    o !== null && Ia(o, s, 2);
  }
  function Zp(s) {
    var o = Oa();
    if (typeof s == "function") {
      var d = s;
      if (((s = d()), Ua)) {
        zt(!0);
        try {
          d();
        } finally {
          zt(!1);
        }
      }
    }
    return (
      (o.memoizedState = o.baseState = s),
      (o.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: io,
        lastRenderedState: s,
      }),
      o
    );
  }
  function Bg(s, o, d, g) {
    return (s.baseState = d), Kp(s, qn, typeof g == "function" ? g : io);
  }
  function S1(s, o, d, g, b) {
    if (Vh(s)) throw Error(n(485));
    if (((s = o.action), s !== null)) {
      var T = {
        payload: b,
        action: s,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function (z) {
          T.listeners.push(z);
        },
      };
      j.T !== null ? d(!0) : (T.isTransition = !1),
        g(T),
        (d = o.pending),
        d === null
          ? ((T.next = o.pending = T), Dg(o, T))
          : ((T.next = d.next), (o.pending = d.next = T));
    }
  }
  function Dg(s, o) {
    var d = o.action,
      g = o.payload,
      b = s.state;
    if (o.isTransition) {
      var T = j.T,
        z = {};
      j.T = z;
      try {
        var W = d(b, g),
          at = j.S;
        at !== null && at(z, W), Ug(s, o, W);
      } catch (Ct) {
        Qp(s, o, Ct);
      } finally {
        j.T = T;
      }
    } else
      try {
        (T = d(b, g)), Ug(s, o, T);
      } catch (Ct) {
        Qp(s, o, Ct);
      }
  }
  function Ug(s, o, d) {
    d !== null && typeof d == "object" && typeof d.then == "function"
      ? d.then(
          function (g) {
            Og(s, o, g);
          },
          function (g) {
            return Qp(s, o, g);
          }
        )
      : Og(s, o, d);
  }
  function Og(s, o, d) {
    (o.status = "fulfilled"),
      (o.value = d),
      Ng(o),
      (s.state = d),
      (o = s.pending),
      o !== null &&
        ((d = o.next),
        d === o ? (s.pending = null) : ((d = d.next), (o.next = d), Dg(s, d)));
  }
  function Qp(s, o, d) {
    var g = s.pending;
    if (((s.pending = null), g !== null)) {
      g = g.next;
      do (o.status = "rejected"), (o.reason = d), Ng(o), (o = o.next);
      while (o !== g);
    }
    s.action = null;
  }
  function Ng(s) {
    s = s.listeners;
    for (var o = 0; o < s.length; o++) (0, s[o])();
  }
  function $p(s, o) {
    return o;
  }
  function Lg(s, o) {
    if (Pn) {
      var d = cn.formState;
      if (d !== null) {
        t: {
          var g = hn;
          if (Pn) {
            if (mi) {
              e: {
                for (var b = mi, T = ss; b.nodeType !== 8; ) {
                  if (!T) {
                    b = null;
                    break e;
                  }
                  if (((b = uo(b.nextSibling)), b === null)) {
                    b = null;
                    break e;
                  }
                }
                (T = b.data), (b = T === "F!" || T === "F" ? b : null);
              }
              if (b) {
                (mi = uo(b.nextSibling)), (g = b.data === "F!");
                break t;
              }
            }
            Io(g);
          }
          g = !1;
        }
        g && (o = d[0]);
      }
    }
    return (
      (d = Oa()),
      (d.memoizedState = d.baseState = o),
      (g = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: $p,
        lastRenderedState: o,
      }),
      (d.queue = g),
      (d = qg.bind(null, hn, g)),
      (g.dispatch = d),
      (g = Zp(!1)),
      (T = Gh.bind(null, hn, !1, g.queue)),
      (g = Oa()),
      (b = { state: o, dispatch: null, action: s, pending: null }),
      (g.queue = b),
      (d = S1.bind(null, hn, b, T, d)),
      (b.dispatch = d),
      (g.memoizedState = s),
      [o, d, !1]
    );
  }
  function Ig(s) {
    var o = Hi();
    return Pg(o, qn, s);
  }
  function Pg(s, o, d) {
    if (
      ((o = Kp(s, o, $p)[0]),
      (s = Vo(io)[0]),
      typeof o == "object" && o !== null && typeof o.then == "function")
    )
      try {
        var g = Js(o);
      } catch (z) {
        throw z === Ju ? Ks : z;
      }
    else g = o;
    o = Hi();
    var b = o.queue,
      T = b.dispatch;
    return (
      d !== o.memoizedState &&
        ((hn.flags |= 2048), Rc(9, tf(), M1.bind(null, b, d), null)),
      [g, T, s]
    );
  }
  function M1(s, o) {
    s.action = o;
  }
  function zg(s) {
    var o = Hi(),
      d = qn;
    if (d !== null) return Pg(o, d, s);
    Hi(), (o = o.memoizedState), (d = Hi());
    var g = d.queue.dispatch;
    return (d.memoizedState = s), [o, g, !1];
  }
  function Rc(s, o, d, g) {
    return (
      (s = { tag: s, create: d, deps: g, inst: o, next: null }),
      (o = hn.updateQueue),
      o === null && ((o = Go()), (hn.updateQueue = o)),
      (d = o.lastEffect),
      d === null
        ? (o.lastEffect = s.next = s)
        : ((g = d.next), (d.next = s), (s.next = g), (o.lastEffect = s)),
      s
    );
  }
  function tf() {
    return { destroy: void 0, resource: void 0 };
  }
  function tm() {
    return Hi().memoizedState;
  }
  function Ph(s, o, d, g) {
    var b = Oa();
    (g = g === void 0 ? null : g),
      (hn.flags |= s),
      (b.memoizedState = Rc(1 | o, tf(), d, g));
  }
  function Bc(s, o, d, g) {
    var b = Hi();
    g = g === void 0 ? null : g;
    var T = b.memoizedState.inst;
    qn !== null && g !== null && _a(g, qn.memoizedState.deps)
      ? (b.memoizedState = Rc(o, T, d, g))
      : ((hn.flags |= s), (b.memoizedState = Rc(1 | o, T, d, g)));
  }
  function em(s, o) {
    Ph(8390656, 8, s, o);
  }
  function nm(s, o) {
    Bc(2048, 8, s, o);
  }
  function zh(s, o) {
    return Bc(4, 2, s, o);
  }
  function Fh(s, o) {
    return Bc(4, 4, s, o);
  }
  function Fg(s, o) {
    if (typeof o == "function") {
      s = s();
      var d = o(s);
      return function () {
        typeof d == "function" ? d() : o(null);
      };
    }
    if (o != null)
      return (
        (s = s()),
        (o.current = s),
        function () {
          o.current = null;
        }
      );
  }
  function Hg(s, o, d) {
    (d = d != null ? d.concat([s]) : null), Bc(4, 4, Fg.bind(null, o, s), d);
  }
  function im() {}
  function Gg(s, o) {
    var d = Hi();
    o = o === void 0 ? null : o;
    var g = d.memoizedState;
    return o !== null && _a(o, g[1]) ? g[0] : ((d.memoizedState = [s, o]), s);
  }
  function am(s, o) {
    var d = Hi();
    o = o === void 0 ? null : o;
    var g = d.memoizedState;
    if (o !== null && _a(o, g[1])) return g[0];
    if (((g = s()), Ua)) {
      zt(!0);
      try {
        s();
      } finally {
        zt(!1);
      }
    }
    return (d.memoizedState = [g, o]), g;
  }
  function Hh(s, o, d) {
    return d === void 0 || (eo & 1073741824) !== 0
      ? (s.memoizedState = o)
      : ((s.memoizedState = d), (s = td()), (hn.lanes |= s), (ir |= s), d);
  }
  function Vg(s, o, d, g) {
    return Xa(d, o)
      ? d
      : wc.current !== null
      ? ((s = Hh(s, d, g)), Xa(s, o) || (ta = !0), s)
      : (eo & 42) === 0
      ? ((ta = !0), (s.memoizedState = d))
      : ((s = td()), (hn.lanes |= s), (ir |= s), o);
  }
  function kg(s, o, d, g, b) {
    var T = Q.p;
    Q.p = T !== 0 && 8 > T ? T : 8;
    var z = j.T,
      W = {};
    (j.T = W), Gh(s, !1, o, d);
    try {
      var at = b(),
        Ct = j.S;
      if (
        (Ct !== null && Ct(W, at),
        at !== null && typeof at == "object" && typeof at.then == "function")
      ) {
        var Wt = b1(at, g);
        ef(s, o, Wt, Si(s));
      } else ef(s, o, g, Si(s));
    } catch (ne) {
      ef(s, o, { then: function () {}, status: "rejected", reason: ne }, Si());
    } finally {
      (Q.p = T), (j.T = z);
    }
  }
  function E1() {}
  function sm(s, o, d, g) {
    if (s.tag !== 5) throw Error(n(476));
    var b = jg(s).queue;
    kg(
      s,
      b,
      o,
      et,
      d === null
        ? E1
        : function () {
            return Xg(s), d(g);
          }
    );
  }
  function jg(s) {
    var o = s.memoizedState;
    if (o !== null) return o;
    o = {
      memoizedState: et,
      baseState: et,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: io,
        lastRenderedState: et,
      },
      next: null,
    };
    var d = {};
    return (
      (o.next = {
        memoizedState: d,
        baseState: d,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: io,
          lastRenderedState: d,
        },
        next: null,
      }),
      (s.memoizedState = o),
      (s = s.alternate),
      s !== null && (s.memoizedState = o),
      o
    );
  }
  function Xg(s) {
    var o = jg(s).next.queue;
    ef(s, o, {}, Si());
  }
  function rm() {
    return _i(xm);
  }
  function Wg() {
    return Hi().memoizedState;
  }
  function Yg() {
    return Hi().memoizedState;
  }
  function T1(s) {
    for (var o = s.return; o !== null; ) {
      switch (o.tag) {
        case 24:
        case 3:
          var d = Si();
          s = mr(d);
          var g = to(o, s, d);
          g !== null && (Ia(g, o, d), _l(g, o, d)),
            (o = { cache: Ch() }),
            (s.payload = o);
          return;
      }
      o = o.return;
    }
  }
  function w1(s, o, d) {
    var g = Si();
    (d = {
      lane: g,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      Vh(s)
        ? Kg(o, d)
        : ((d = Sh(s, o, d, g)), d !== null && (Ia(d, s, g), os(d, o, g)));
  }
  function qg(s, o, d) {
    var g = Si();
    ef(s, o, d, g);
  }
  function ef(s, o, d, g) {
    var b = {
      lane: g,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
    if (Vh(s)) Kg(o, b);
    else {
      var T = s.alternate;
      if (
        s.lanes === 0 &&
        (T === null || T.lanes === 0) &&
        ((T = o.lastRenderedReducer), T !== null)
      )
        try {
          var z = o.lastRenderedState,
            W = T(z, d);
          if (((b.hasEagerState = !0), (b.eagerState = W), Xa(W, z)))
            return Uo(s, o, b, 0), cn === null && Hu(), !1;
        } catch {
        } finally {
        }
      if (((d = Sh(s, o, b, g)), d !== null))
        return Ia(d, s, g), os(d, o, g), !0;
    }
    return !1;
  }
  function Gh(s, o, d, g) {
    if (
      ((g = {
        lane: 2,
        revertLane: B1(),
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      Vh(s))
    ) {
      if (o) throw Error(n(479));
    } else (o = Sh(s, d, g, 2)), o !== null && Ia(o, s, 2);
  }
  function Vh(s) {
    var o = s.alternate;
    return s === hn || (o !== null && o === hn);
  }
  function Kg(s, o) {
    Ho = Nh = !0;
    var d = s.pending;
    d === null ? (o.next = o) : ((o.next = d.next), (d.next = o)),
      (s.pending = o);
  }
  function os(s, o, d) {
    if ((d & 4194048) !== 0) {
      var g = o.lanes;
      (g &= s.pendingLanes), (d |= g), (o.lanes = d), be(s, d);
    }
  }
  var nf = {
      readContext: _i,
      use: Ih,
      useCallback: Di,
      useContext: Di,
      useEffect: Di,
      useImperativeHandle: Di,
      useLayoutEffect: Di,
      useInsertionEffect: Di,
      useMemo: Di,
      useReducer: Di,
      useRef: Di,
      useState: Di,
      useDebugValue: Di,
      useDeferredValue: Di,
      useTransition: Di,
      useSyncExternalStore: Di,
      useId: Di,
      useHostTransitionStatus: Di,
      useFormState: Di,
      useActionState: Di,
      useOptimistic: Di,
      useMemoCache: Di,
      useCacheRefresh: Di,
    },
    kh = {
      readContext: _i,
      use: Ih,
      useCallback: function (s, o) {
        return (Oa().memoizedState = [s, o === void 0 ? null : o]), s;
      },
      useContext: _i,
      useEffect: em,
      useImperativeHandle: function (s, o, d) {
        (d = d != null ? d.concat([s]) : null),
          Ph(4194308, 4, Fg.bind(null, o, s), d);
      },
      useLayoutEffect: function (s, o) {
        return Ph(4194308, 4, s, o);
      },
      useInsertionEffect: function (s, o) {
        Ph(4, 2, s, o);
      },
      useMemo: function (s, o) {
        var d = Oa();
        o = o === void 0 ? null : o;
        var g = s();
        if (Ua) {
          zt(!0);
          try {
            s();
          } finally {
            zt(!1);
          }
        }
        return (d.memoizedState = [g, o]), g;
      },
      useReducer: function (s, o, d) {
        var g = Oa();
        if (d !== void 0) {
          var b = d(o);
          if (Ua) {
            zt(!0);
            try {
              d(o);
            } finally {
              zt(!1);
            }
          }
        } else b = o;
        return (
          (g.memoizedState = g.baseState = b),
          (s = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: s,
            lastRenderedState: b,
          }),
          (g.queue = s),
          (s = s.dispatch = w1.bind(null, hn, s)),
          [g.memoizedState, s]
        );
      },
      useRef: function (s) {
        var o = Oa();
        return (s = { current: s }), (o.memoizedState = s);
      },
      useState: function (s) {
        s = Zp(s);
        var o = s.queue,
          d = qg.bind(null, hn, o);
        return (o.dispatch = d), [s.memoizedState, d];
      },
      useDebugValue: im,
      useDeferredValue: function (s, o) {
        var d = Oa();
        return Hh(d, s, o);
      },
      useTransition: function () {
        var s = Zp(!1);
        return (
          (s = kg.bind(null, hn, s.queue, !0, !1)),
          (Oa().memoizedState = s),
          [!1, s]
        );
      },
      useSyncExternalStore: function (s, o, d) {
        var g = hn,
          b = Oa();
        if (Pn) {
          if (d === void 0) throw Error(n(407));
          d = d();
        } else {
          if (((d = o()), cn === null)) throw Error(n(349));
          (We & 124) !== 0 || Cc(g, o, d);
        }
        b.memoizedState = d;
        var T = { value: d, getSnapshot: o };
        return (
          (b.queue = T),
          em(wg.bind(null, g, T, s), [s]),
          (g.flags |= 2048),
          Rc(9, tf(), Tg.bind(null, g, T, d, o), null),
          d
        );
      },
      useId: function () {
        var s = Oa(),
          o = cn.identifierPrefix;
        if (Pn) {
          var d = dr,
            g = hr;
          (d = (g & ~(1 << (32 - me(g) - 1))).toString(32) + d),
            (o = "" + o + "R" + d),
            (d = ki++),
            0 < d && (o += "H" + d.toString(32)),
            (o += "");
        } else (d = Ag++), (o = "" + o + "r" + d.toString(32) + "");
        return (s.memoizedState = o);
      },
      useHostTransitionStatus: rm,
      useFormState: Lg,
      useActionState: Lg,
      useOptimistic: function (s) {
        var o = Oa();
        o.memoizedState = o.baseState = s;
        var d = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null,
        };
        return (
          (o.queue = d),
          (o = Gh.bind(null, hn, !0, d)),
          (d.dispatch = o),
          [s, o]
        );
      },
      useMemoCache: qp,
      useCacheRefresh: function () {
        return (Oa().memoizedState = T1.bind(null, hn));
      },
    },
    om = {
      readContext: _i,
      use: Ih,
      useCallback: Gg,
      useContext: _i,
      useEffect: nm,
      useImperativeHandle: Hg,
      useInsertionEffect: zh,
      useLayoutEffect: Fh,
      useMemo: am,
      useReducer: Vo,
      useRef: tm,
      useState: function () {
        return Vo(io);
      },
      useDebugValue: im,
      useDeferredValue: function (s, o) {
        var d = Hi();
        return Vg(d, qn.memoizedState, s, o);
      },
      useTransition: function () {
        var s = Vo(io)[0],
          o = Hi().memoizedState;
        return [typeof s == "boolean" ? s : Js(s), o];
      },
      useSyncExternalStore: Eg,
      useId: Wg,
      useHostTransitionStatus: rm,
      useFormState: Ig,
      useActionState: Ig,
      useOptimistic: function (s, o) {
        var d = Hi();
        return Bg(d, qn, s, o);
      },
      useMemoCache: qp,
      useCacheRefresh: Yg,
    },
    Jg = {
      readContext: _i,
      use: Ih,
      useCallback: Gg,
      useContext: _i,
      useEffect: nm,
      useImperativeHandle: Hg,
      useInsertionEffect: zh,
      useLayoutEffect: Fh,
      useMemo: am,
      useReducer: Jp,
      useRef: tm,
      useState: function () {
        return Jp(io);
      },
      useDebugValue: im,
      useDeferredValue: function (s, o) {
        var d = Hi();
        return qn === null ? Hh(d, s, o) : Vg(d, qn.memoizedState, s, o);
      },
      useTransition: function () {
        var s = Jp(io)[0],
          o = Hi().memoizedState;
        return [typeof s == "boolean" ? s : Js(s), o];
      },
      useSyncExternalStore: Eg,
      useId: Wg,
      useHostTransitionStatus: rm,
      useFormState: zg,
      useActionState: zg,
      useOptimistic: function (s, o) {
        var d = Hi();
        return qn !== null
          ? Bg(d, qn, s, o)
          : ((d.baseState = s), [s, d.queue.dispatch]);
      },
      useMemoCache: qp,
      useCacheRefresh: Yg,
    },
    bl = null,
    af = 0;
  function sf(s) {
    var o = af;
    return (af += 1), bl === null && (bl = []), Uh(bl, s, o);
  }
  function Dc(s, o) {
    (o = o.props.ref), (s.ref = o !== void 0 ? o : null);
  }
  function jh(s, o) {
    throw o.$$typeof === v
      ? Error(n(525))
      : ((s = Object.prototype.toString.call(o)),
        Error(
          n(
            31,
            s === "[object Object]"
              ? "object with keys {" + Object.keys(o).join(", ") + "}"
              : s
          )
        ));
  }
  function Zg(s) {
    var o = s._init;
    return o(s._payload);
  }
  function Qg(s) {
    function o(_t, vt) {
      if (s) {
        var Tt = _t.deletions;
        Tt === null ? ((_t.deletions = [vt]), (_t.flags |= 16)) : Tt.push(vt);
      }
    }
    function d(_t, vt) {
      if (!s) return null;
      for (; vt !== null; ) o(_t, vt), (vt = vt.sibling);
      return null;
    }
    function g(_t) {
      for (var vt = new Map(); _t !== null; )
        _t.key !== null ? vt.set(_t.key, _t) : vt.set(_t.index, _t),
          (_t = _t.sibling);
      return vt;
    }
    function b(_t, vt) {
      return (_t = Bi(_t, vt)), (_t.index = 0), (_t.sibling = null), _t;
    }
    function T(_t, vt, Tt) {
      return (
        (_t.index = Tt),
        s
          ? ((Tt = _t.alternate),
            Tt !== null
              ? ((Tt = Tt.index), Tt < vt ? ((_t.flags |= 67108866), vt) : Tt)
              : ((_t.flags |= 67108866), vt))
          : ((_t.flags |= 1048576), vt)
      );
    }
    function z(_t) {
      return s && _t.alternate === null && (_t.flags |= 67108866), _t;
    }
    function W(_t, vt, Tt, Zt) {
      return vt === null || vt.tag !== 6
        ? ((vt = Vu(Tt, _t.mode, Zt)), (vt.return = _t), vt)
        : ((vt = b(vt, Tt)), (vt.return = _t), vt);
    }
    function at(_t, vt, Tt, Zt) {
      var Ie = Tt.type;
      return Ie === M
        ? Wt(_t, vt, Tt.props.children, Zt, Tt.key)
        : vt !== null &&
          (vt.elementType === Ie ||
            (typeof Ie == "object" &&
              Ie !== null &&
              Ie.$$typeof === F &&
              Zg(Ie) === vt.type))
        ? ((vt = b(vt, Tt.props)), Dc(vt, Tt), (vt.return = _t), vt)
        : ((vt = $i(Tt.type, Tt.key, Tt.props, null, _t.mode, Zt)),
          Dc(vt, Tt),
          (vt.return = _t),
          vt);
    }
    function Ct(_t, vt, Tt, Zt) {
      return vt === null ||
        vt.tag !== 4 ||
        vt.stateNode.containerInfo !== Tt.containerInfo ||
        vt.stateNode.implementation !== Tt.implementation
        ? ((vt = Mh(Tt, _t.mode, Zt)), (vt.return = _t), vt)
        : ((vt = b(vt, Tt.children || [])), (vt.return = _t), vt);
    }
    function Wt(_t, vt, Tt, Zt, Ie) {
      return vt === null || vt.tag !== 7
        ? ((vt = No(Tt, _t.mode, Zt, Ie)), (vt.return = _t), vt)
        : ((vt = b(vt, Tt)), (vt.return = _t), vt);
    }
    function ne(_t, vt, Tt) {
      if (
        (typeof vt == "string" && vt !== "") ||
        typeof vt == "number" ||
        typeof vt == "bigint"
      )
        return (vt = Vu("" + vt, _t.mode, Tt)), (vt.return = _t), vt;
      if (typeof vt == "object" && vt !== null) {
        switch (vt.$$typeof) {
          case x:
            return (
              (Tt = $i(vt.type, vt.key, vt.props, null, _t.mode, Tt)),
              Dc(Tt, vt),
              (Tt.return = _t),
              Tt
            );
          case _:
            return (vt = Mh(vt, _t.mode, Tt)), (vt.return = _t), vt;
          case F:
            var Zt = vt._init;
            return (vt = Zt(vt._payload)), ne(_t, vt, Tt);
        }
        if (pt(vt) || ct(vt))
          return (vt = No(vt, _t.mode, Tt, null)), (vt.return = _t), vt;
        if (typeof vt.then == "function") return ne(_t, sf(vt), Tt);
        if (vt.$$typeof === B) return ne(_t, Wu(_t, vt), Tt);
        jh(_t, vt);
      }
      return null;
    }
    function Ot(_t, vt, Tt, Zt) {
      var Ie = vt !== null ? vt.key : null;
      if (
        (typeof Tt == "string" && Tt !== "") ||
        typeof Tt == "number" ||
        typeof Tt == "bigint"
      )
        return Ie !== null ? null : W(_t, vt, "" + Tt, Zt);
      if (typeof Tt == "object" && Tt !== null) {
        switch (Tt.$$typeof) {
          case x:
            return Tt.key === Ie ? at(_t, vt, Tt, Zt) : null;
          case _:
            return Tt.key === Ie ? Ct(_t, vt, Tt, Zt) : null;
          case F:
            return (Ie = Tt._init), (Tt = Ie(Tt._payload)), Ot(_t, vt, Tt, Zt);
        }
        if (pt(Tt) || ct(Tt))
          return Ie !== null ? null : Wt(_t, vt, Tt, Zt, null);
        if (typeof Tt.then == "function") return Ot(_t, vt, sf(Tt), Zt);
        if (Tt.$$typeof === B) return Ot(_t, vt, Wu(_t, Tt), Zt);
        jh(_t, Tt);
      }
      return null;
    }
    function Nt(_t, vt, Tt, Zt, Ie) {
      if (
        (typeof Zt == "string" && Zt !== "") ||
        typeof Zt == "number" ||
        typeof Zt == "bigint"
      )
        return (_t = _t.get(Tt) || null), W(vt, _t, "" + Zt, Ie);
      if (typeof Zt == "object" && Zt !== null) {
        switch (Zt.$$typeof) {
          case x:
            return (
              (_t = _t.get(Zt.key === null ? Tt : Zt.key) || null),
              at(vt, _t, Zt, Ie)
            );
          case _:
            return (
              (_t = _t.get(Zt.key === null ? Tt : Zt.key) || null),
              Ct(vt, _t, Zt, Ie)
            );
          case F:
            var Cn = Zt._init;
            return (Zt = Cn(Zt._payload)), Nt(_t, vt, Tt, Zt, Ie);
        }
        if (pt(Zt) || ct(Zt))
          return (_t = _t.get(Tt) || null), Wt(vt, _t, Zt, Ie, null);
        if (typeof Zt.then == "function") return Nt(_t, vt, Tt, sf(Zt), Ie);
        if (Zt.$$typeof === B) return Nt(_t, vt, Tt, Wu(vt, Zt), Ie);
        jh(vt, Zt);
      }
      return null;
    }
    function sn(_t, vt, Tt, Zt) {
      for (
        var Ie = null, Cn = null, ke = vt, tn = (vt = 0), Sa = null;
        ke !== null && tn < Tt.length;
        tn++
      ) {
        ke.index > tn ? ((Sa = ke), (ke = null)) : (Sa = ke.sibling);
        var Wn = Ot(_t, ke, Tt[tn], Zt);
        if (Wn === null) {
          ke === null && (ke = Sa);
          break;
        }
        s && ke && Wn.alternate === null && o(_t, ke),
          (vt = T(Wn, vt, tn)),
          Cn === null ? (Ie = Wn) : (Cn.sibling = Wn),
          (Cn = Wn),
          (ke = Sa);
      }
      if (tn === Tt.length) return d(_t, ke), Pn && Jr(_t, tn), Ie;
      if (ke === null) {
        for (; tn < Tt.length; tn++)
          (ke = ne(_t, Tt[tn], Zt)),
            ke !== null &&
              ((vt = T(ke, vt, tn)),
              Cn === null ? (Ie = ke) : (Cn.sibling = ke),
              (Cn = ke));
        return Pn && Jr(_t, tn), Ie;
      }
      for (ke = g(ke); tn < Tt.length; tn++)
        (Sa = Nt(ke, _t, tn, Tt[tn], Zt)),
          Sa !== null &&
            (s &&
              Sa.alternate !== null &&
              ke.delete(Sa.key === null ? tn : Sa.key),
            (vt = T(Sa, vt, tn)),
            Cn === null ? (Ie = Sa) : (Cn.sibling = Sa),
            (Cn = Sa));
      return (
        s &&
          ke.forEach(function (qc) {
            return o(_t, qc);
          }),
        Pn && Jr(_t, tn),
        Ie
      );
    }
    function $e(_t, vt, Tt, Zt) {
      if (Tt == null) throw Error(n(151));
      for (
        var Ie = null,
          Cn = null,
          ke = vt,
          tn = (vt = 0),
          Sa = null,
          Wn = Tt.next();
        ke !== null && !Wn.done;
        tn++, Wn = Tt.next()
      ) {
        ke.index > tn ? ((Sa = ke), (ke = null)) : (Sa = ke.sibling);
        var qc = Ot(_t, ke, Wn.value, Zt);
        if (qc === null) {
          ke === null && (ke = Sa);
          break;
        }
        s && ke && qc.alternate === null && o(_t, ke),
          (vt = T(qc, vt, tn)),
          Cn === null ? (Ie = qc) : (Cn.sibling = qc),
          (Cn = qc),
          (ke = Sa);
      }
      if (Wn.done) return d(_t, ke), Pn && Jr(_t, tn), Ie;
      if (ke === null) {
        for (; !Wn.done; tn++, Wn = Tt.next())
          (Wn = ne(_t, Wn.value, Zt)),
            Wn !== null &&
              ((vt = T(Wn, vt, tn)),
              Cn === null ? (Ie = Wn) : (Cn.sibling = Wn),
              (Cn = Wn));
        return Pn && Jr(_t, tn), Ie;
      }
      for (ke = g(ke); !Wn.done; tn++, Wn = Tt.next())
        (Wn = Nt(ke, _t, tn, Wn.value, Zt)),
          Wn !== null &&
            (s &&
              Wn.alternate !== null &&
              ke.delete(Wn.key === null ? tn : Wn.key),
            (vt = T(Wn, vt, tn)),
            Cn === null ? (Ie = Wn) : (Cn.sibling = Wn),
            (Cn = Wn));
      return (
        s &&
          ke.forEach(function (XD) {
            return o(_t, XD);
          }),
        Pn && Jr(_t, tn),
        Ie
      );
    }
    function ui(_t, vt, Tt, Zt) {
      if (
        (typeof Tt == "object" &&
          Tt !== null &&
          Tt.type === M &&
          Tt.key === null &&
          (Tt = Tt.props.children),
        typeof Tt == "object" && Tt !== null)
      ) {
        switch (Tt.$$typeof) {
          case x:
            t: {
              for (var Ie = Tt.key; vt !== null; ) {
                if (vt.key === Ie) {
                  if (((Ie = Tt.type), Ie === M)) {
                    if (vt.tag === 7) {
                      d(_t, vt.sibling),
                        (Zt = b(vt, Tt.props.children)),
                        (Zt.return = _t),
                        (_t = Zt);
                      break t;
                    }
                  } else if (
                    vt.elementType === Ie ||
                    (typeof Ie == "object" &&
                      Ie !== null &&
                      Ie.$$typeof === F &&
                      Zg(Ie) === vt.type)
                  ) {
                    d(_t, vt.sibling),
                      (Zt = b(vt, Tt.props)),
                      Dc(Zt, Tt),
                      (Zt.return = _t),
                      (_t = Zt);
                    break t;
                  }
                  d(_t, vt);
                  break;
                } else o(_t, vt);
                vt = vt.sibling;
              }
              Tt.type === M
                ? ((Zt = No(Tt.props.children, _t.mode, Zt, Tt.key)),
                  (Zt.return = _t),
                  (_t = Zt))
                : ((Zt = $i(Tt.type, Tt.key, Tt.props, null, _t.mode, Zt)),
                  Dc(Zt, Tt),
                  (Zt.return = _t),
                  (_t = Zt));
            }
            return z(_t);
          case _:
            t: {
              for (Ie = Tt.key; vt !== null; ) {
                if (vt.key === Ie)
                  if (
                    vt.tag === 4 &&
                    vt.stateNode.containerInfo === Tt.containerInfo &&
                    vt.stateNode.implementation === Tt.implementation
                  ) {
                    d(_t, vt.sibling),
                      (Zt = b(vt, Tt.children || [])),
                      (Zt.return = _t),
                      (_t = Zt);
                    break t;
                  } else {
                    d(_t, vt);
                    break;
                  }
                else o(_t, vt);
                vt = vt.sibling;
              }
              (Zt = Mh(Tt, _t.mode, Zt)), (Zt.return = _t), (_t = Zt);
            }
            return z(_t);
          case F:
            return (Ie = Tt._init), (Tt = Ie(Tt._payload)), ui(_t, vt, Tt, Zt);
        }
        if (pt(Tt)) return sn(_t, vt, Tt, Zt);
        if (ct(Tt)) {
          if (((Ie = ct(Tt)), typeof Ie != "function")) throw Error(n(150));
          return (Tt = Ie.call(Tt)), $e(_t, vt, Tt, Zt);
        }
        if (typeof Tt.then == "function") return ui(_t, vt, sf(Tt), Zt);
        if (Tt.$$typeof === B) return ui(_t, vt, Wu(_t, Tt), Zt);
        jh(_t, Tt);
      }
      return (typeof Tt == "string" && Tt !== "") ||
        typeof Tt == "number" ||
        typeof Tt == "bigint"
        ? ((Tt = "" + Tt),
          vt !== null && vt.tag === 6
            ? (d(_t, vt.sibling), (Zt = b(vt, Tt)), (Zt.return = _t), (_t = Zt))
            : (d(_t, vt),
              (Zt = Vu(Tt, _t.mode, Zt)),
              (Zt.return = _t),
              (_t = Zt)),
          z(_t))
        : d(_t, vt);
    }
    return function (_t, vt, Tt, Zt) {
      try {
        af = 0;
        var Ie = ui(_t, vt, Tt, Zt);
        return (bl = null), Ie;
      } catch (ke) {
        if (ke === Ju || ke === Ks) throw ke;
        var Cn = qa(29, ke, null, _t.mode);
        return (Cn.lanes = Zt), (Cn.return = _t), Cn;
      } finally {
      }
    };
  }
  var Al = Qg(!0),
    $g = Qg(!1),
    ti = ft(null),
    Zs = null;
  function ko(s) {
    var o = s.alternate;
    Rt(Ui, Ui.current & 1),
      Rt(ti, s),
      Zs === null &&
        (o === null || wc.current !== null || o.memoizedState !== null) &&
        (Zs = s);
  }
  function tv(s) {
    if (s.tag === 22) {
      if ((Rt(Ui, Ui.current), Rt(ti, s), Zs === null)) {
        var o = s.alternate;
        o !== null && o.memoizedState !== null && (Zs = s);
      }
    } else jo();
  }
  function jo() {
    Rt(Ui, Ui.current), Rt(ti, ti.current);
  }
  function gr(s) {
    At(ti), Zs === s && (Zs = null), At(Ui);
  }
  var Ui = ft(0);
  function ao(s) {
    for (var o = s; o !== null; ) {
      if (o.tag === 13) {
        var d = o.memoizedState;
        if (
          d !== null &&
          ((d = d.dehydrated), d === null || d.data === "$?" || V1(d))
        )
          return o;
      } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
        if ((o.flags & 128) !== 0) return o;
      } else if (o.child !== null) {
        (o.child.return = o), (o = o.child);
        continue;
      }
      if (o === s) break;
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === s) return null;
        o = o.return;
      }
      (o.sibling.return = o.return), (o = o.sibling);
    }
    return null;
  }
  function Xo(s, o, d, g) {
    (o = s.memoizedState),
      (d = d(g, o)),
      (d = d == null ? o : m({}, o, d)),
      (s.memoizedState = d),
      s.lanes === 0 && (s.updateQueue.baseState = d);
  }
  var Na = {
    enqueueSetState: function (s, o, d) {
      s = s._reactInternals;
      var g = Si(),
        b = mr(g);
      (b.payload = o),
        d != null && (b.callback = d),
        (o = to(s, b, g)),
        o !== null && (Ia(o, s, g), _l(o, s, g));
    },
    enqueueReplaceState: function (s, o, d) {
      s = s._reactInternals;
      var g = Si(),
        b = mr(g);
      (b.tag = 1),
        (b.payload = o),
        d != null && (b.callback = d),
        (o = to(s, b, g)),
        o !== null && (Ia(o, s, g), _l(o, s, g));
    },
    enqueueForceUpdate: function (s, o) {
      s = s._reactInternals;
      var d = Si(),
        g = mr(d);
      (g.tag = 2),
        o != null && (g.callback = o),
        (o = to(s, g, d)),
        o !== null && (Ia(o, s, d), _l(o, s, d));
    },
  };
  function ev(s, o, d, g, b, T, z) {
    return (
      (s = s.stateNode),
      typeof s.shouldComponentUpdate == "function"
        ? s.shouldComponentUpdate(g, T, z)
        : o.prototype && o.prototype.isPureReactComponent
        ? !Ys(d, g) || !Ys(b, T)
        : !0
    );
  }
  function nv(s, o, d, g) {
    (s = o.state),
      typeof o.componentWillReceiveProps == "function" &&
        o.componentWillReceiveProps(d, g),
      typeof o.UNSAFE_componentWillReceiveProps == "function" &&
        o.UNSAFE_componentWillReceiveProps(d, g),
      o.state !== s && Na.enqueueReplaceState(o, o.state, null);
  }
  function vr(s, o) {
    var d = o;
    if ("ref" in o) {
      d = {};
      for (var g in o) g !== "ref" && (d[g] = o[g]);
    }
    if ((s = s.defaultProps)) {
      d === o && (d = m({}, d));
      for (var b in s) d[b] === void 0 && (d[b] = s[b]);
    }
    return d;
  }
  var Sl =
    typeof reportError == "function"
      ? reportError
      : function (s) {
          if (
            typeof window == "object" &&
            typeof window.ErrorEvent == "function"
          ) {
            var o = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof s == "object" &&
                s !== null &&
                typeof s.message == "string"
                  ? String(s.message)
                  : String(s),
              error: s,
            });
            if (!window.dispatchEvent(o)) return;
          } else if (
            typeof process == "object" &&
            typeof process.emit == "function"
          ) {
            process.emit("uncaughtException", s);
            return;
          }
          console.error(s);
        };
  function rf(s) {
    Sl(s);
  }
  function Xh(s) {
    console.error(s);
  }
  function iv(s) {
    Sl(s);
  }
  function Wh(s, o) {
    try {
      var d = s.onUncaughtError;
      d(o.value, { componentStack: o.stack });
    } catch (g) {
      setTimeout(function () {
        throw g;
      });
    }
  }
  function Us(s, o, d) {
    try {
      var g = s.onCaughtError;
      g(d.value, {
        componentStack: d.stack,
        errorBoundary: o.tag === 1 ? o.stateNode : null,
      });
    } catch (b) {
      setTimeout(function () {
        throw b;
      });
    }
  }
  function Yh(s, o, d) {
    return (
      (d = mr(d)),
      (d.tag = 3),
      (d.payload = { element: null }),
      (d.callback = function () {
        Wh(s, o);
      }),
      d
    );
  }
  function av(s) {
    return (s = mr(s)), (s.tag = 3), s;
  }
  function qh(s, o, d, g) {
    var b = d.type.getDerivedStateFromError;
    if (typeof b == "function") {
      var T = g.value;
      (s.payload = function () {
        return b(T);
      }),
        (s.callback = function () {
          Us(o, d, g);
        });
    }
    var z = d.stateNode;
    z !== null &&
      typeof z.componentDidCatch == "function" &&
      (s.callback = function () {
        Us(o, d, g),
          typeof b != "function" &&
            (ms === null ? (ms = new Set([this])) : ms.add(this));
        var W = g.stack;
        this.componentDidCatch(g.value, {
          componentStack: W !== null ? W : "",
        });
      });
  }
  function C1(s, o, d, g, b) {
    if (
      ((d.flags |= 32768),
      g !== null && typeof g == "object" && typeof g.then == "function")
    ) {
      if (
        ((o = d.alternate),
        o !== null && Cs(o, d, b, !0),
        (d = ti.current),
        d !== null)
      ) {
        switch (d.tag) {
          case 13:
            return (
              Zs === null ? c() : d.alternate === null && hi === 0 && (hi = 3),
              (d.flags &= -257),
              (d.flags |= 65536),
              (d.lanes = b),
              g === Zu
                ? (d.flags |= 16384)
                : ((o = d.updateQueue),
                  o === null ? (d.updateQueue = new Set([g])) : o.add(g),
                  Lt(s, g, b)),
              !1
            );
          case 22:
            return (
              (d.flags |= 65536),
              g === Zu
                ? (d.flags |= 16384)
                : ((o = d.updateQueue),
                  o === null
                    ? ((o = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([g]),
                      }),
                      (d.updateQueue = o))
                    : ((d = o.retryQueue),
                      d === null ? (o.retryQueue = new Set([g])) : d.add(g)),
                  Lt(s, g, b)),
              !1
            );
        }
        throw Error(n(435, d.tag));
      }
      return Lt(s, g, b), c(), !1;
    }
    if (Pn)
      return (
        (o = ti.current),
        o !== null
          ? ((o.flags & 65536) === 0 && (o.flags |= 256),
            (o.flags |= 65536),
            (o.lanes = b),
            g !== Th && ((s = Error(n(422), { cause: g })), xl(ca(s, d))))
          : (g !== Th && ((o = Error(n(423), { cause: g })), xl(ca(o, d))),
            (s = s.current.alternate),
            (s.flags |= 65536),
            (b &= -b),
            (s.lanes |= b),
            (g = ca(g, d)),
            (b = Yh(s.stateNode, g, b)),
            Mc(s, b),
            hi !== 4 && (hi = 2)),
        !1
      );
    var T = Error(n(520), { cause: g });
    if (
      ((T = ca(T, d)),
      Xn === null ? (Xn = [T]) : Xn.push(T),
      hi !== 4 && (hi = 2),
      o === null)
    )
      return !0;
    (g = ca(g, d)), (d = o);
    do {
      switch (d.tag) {
        case 3:
          return (
            (d.flags |= 65536),
            (s = b & -b),
            (d.lanes |= s),
            (s = Yh(d.stateNode, g, s)),
            Mc(d, s),
            !1
          );
        case 1:
          if (
            ((o = d.type),
            (T = d.stateNode),
            (d.flags & 128) === 0 &&
              (typeof o.getDerivedStateFromError == "function" ||
                (T !== null &&
                  typeof T.componentDidCatch == "function" &&
                  (ms === null || !ms.has(T)))))
          )
            return (
              (d.flags |= 65536),
              (b &= -b),
              (d.lanes |= b),
              (b = av(b)),
              qh(b, s, d, g),
              Mc(d, b),
              !1
            );
      }
      d = d.return;
    } while (d !== null);
    return !1;
  }
  var sv = Error(n(461)),
    ta = !1;
  function Oi(s, o, d, g) {
    o.child = s === null ? $g(o, null, d, g) : Al(o, s.child, d, g);
  }
  function Ja(s, o, d, g, b) {
    d = d.render;
    var T = o.ref;
    if ("ref" in g) {
      var z = {};
      for (var W in g) W !== "ref" && (z[W] = g[W]);
    } else z = g;
    return (
      pr(o),
      (g = no(s, o, d, z, T, b)),
      (W = Wp()),
      s !== null && !ta
        ? (Lh(s, o, b), ea(s, o, b))
        : (Pn && W && Lp(o), (o.flags |= 1), Oi(s, o, g, b), o.child)
    );
  }
  function Za(s, o, d, g, b) {
    if (s === null) {
      var T = d.type;
      return typeof T == "function" &&
        !Gu(T) &&
        T.defaultProps === void 0 &&
        d.compare === null
        ? ((o.tag = 15), (o.type = T), lm(s, o, T, g, b))
        : ((s = $i(d.type, null, g, o, o.mode, b)),
          (s.ref = o.ref),
          (s.return = o),
          (o.child = s));
    }
    if (((T = s.child), !of(s, b))) {
      var z = T.memoizedProps;
      if (
        ((d = d.compare), (d = d !== null ? d : Ys), d(z, g) && s.ref === o.ref)
      )
        return ea(s, o, b);
    }
    return (
      (o.flags |= 1),
      (s = Bi(T, g)),
      (s.ref = o.ref),
      (s.return = o),
      (o.child = s)
    );
  }
  function lm(s, o, d, g, b) {
    if (s !== null) {
      var T = s.memoizedProps;
      if (Ys(T, g) && s.ref === o.ref)
        if (((ta = !1), (o.pendingProps = g = T), of(s, b)))
          (s.flags & 131072) !== 0 && (ta = !0);
        else return (o.lanes = s.lanes), ea(s, o, b);
    }
    return Uc(s, o, d, g, b);
  }
  function Ml(s, o, d) {
    var g = o.pendingProps,
      b = g.children,
      T = s !== null ? s.memoizedState : null;
    if (g.mode === "hidden") {
      if ((o.flags & 128) !== 0) {
        if (((g = T !== null ? T.baseLanes | d : d), s !== null)) {
          for (b = o.child = s.child, T = 0; b !== null; )
            (T = T | b.lanes | b.childLanes), (b = b.sibling);
          o.childLanes = T & ~g;
        } else (o.childLanes = 0), (o.child = null);
        return El(s, o, g, d);
      }
      if ((d & 536870912) !== 0)
        (o.memoizedState = { baseLanes: 0, cachePool: null }),
          s !== null && Ku(o, T !== null ? T.cachePool : null),
          T !== null ? bg(o, T) : Xp(),
          tv(o);
      else
        return (
          (o.lanes = o.childLanes = 536870912),
          El(s, o, T !== null ? T.baseLanes | d : d, d)
        );
    } else
      T !== null
        ? (Ku(o, T.cachePool), bg(o, T), jo(), (o.memoizedState = null))
        : (s !== null && Ku(o, null), Xp(), jo());
    return Oi(s, o, b, d), o.child;
  }
  function El(s, o, d, g) {
    var b = Fo();
    return (
      (b = b === null ? null : { parent: zi._currentValue, pool: b }),
      (o.memoizedState = { baseLanes: d, cachePool: b }),
      s !== null && Ku(o, null),
      Xp(),
      tv(o),
      s !== null && Cs(s, o, g, !0),
      null
    );
  }
  function Tl(s, o) {
    var d = o.ref;
    if (d === null) s !== null && s.ref !== null && (o.flags |= 4194816);
    else {
      if (typeof d != "function" && typeof d != "object") throw Error(n(284));
      (s === null || s.ref !== d) && (o.flags |= 4194816);
    }
  }
  function Uc(s, o, d, g, b) {
    return (
      pr(o),
      (d = no(s, o, d, g, void 0, b)),
      (g = Wp()),
      s !== null && !ta
        ? (Lh(s, o, b), ea(s, o, b))
        : (Pn && g && Lp(o), (o.flags |= 1), Oi(s, o, d, b), o.child)
    );
  }
  function ls(s, o, d, g, b, T) {
    return (
      pr(o),
      (o.updateQueue = null),
      (d = Mg(o, g, d, b)),
      Sg(s),
      (g = Wp()),
      s !== null && !ta
        ? (Lh(s, o, T), ea(s, o, T))
        : (Pn && g && Lp(o), (o.flags |= 1), Oi(s, o, d, T), o.child)
    );
  }
  function cs(s, o, d, g, b) {
    if ((pr(o), o.stateNode === null)) {
      var T = Oo,
        z = d.contextType;
      typeof z == "object" && z !== null && (T = _i(z)),
        (T = new d(g, T)),
        (o.memoizedState =
          T.state !== null && T.state !== void 0 ? T.state : null),
        (T.updater = Na),
        (o.stateNode = T),
        (T._reactInternals = o),
        (T = o.stateNode),
        (T.props = g),
        (T.state = o.memoizedState),
        (T.refs = {}),
        kp(o),
        (z = d.contextType),
        (T.context = typeof z == "object" && z !== null ? _i(z) : Oo),
        (T.state = o.memoizedState),
        (z = d.getDerivedStateFromProps),
        typeof z == "function" && (Xo(o, d, z, g), (T.state = o.memoizedState)),
        typeof d.getDerivedStateFromProps == "function" ||
          typeof T.getSnapshotBeforeUpdate == "function" ||
          (typeof T.UNSAFE_componentWillMount != "function" &&
            typeof T.componentWillMount != "function") ||
          ((z = T.state),
          typeof T.componentWillMount == "function" && T.componentWillMount(),
          typeof T.UNSAFE_componentWillMount == "function" &&
            T.UNSAFE_componentWillMount(),
          z !== T.state && Na.enqueueReplaceState(T, T.state, null),
          Ec(o, g, T, b),
          Qu(),
          (T.state = o.memoizedState)),
        typeof T.componentDidMount == "function" && (o.flags |= 4194308),
        (g = !0);
    } else if (s === null) {
      T = o.stateNode;
      var W = o.memoizedProps,
        at = vr(d, W);
      T.props = at;
      var Ct = T.context,
        Wt = d.contextType;
      (z = Oo), typeof Wt == "object" && Wt !== null && (z = _i(Wt));
      var ne = d.getDerivedStateFromProps;
      (Wt =
        typeof ne == "function" ||
        typeof T.getSnapshotBeforeUpdate == "function"),
        (W = o.pendingProps !== W),
        Wt ||
          (typeof T.UNSAFE_componentWillReceiveProps != "function" &&
            typeof T.componentWillReceiveProps != "function") ||
          ((W || Ct !== z) && nv(o, T, g, z)),
        ($r = !1);
      var Ot = o.memoizedState;
      (T.state = Ot),
        Ec(o, g, T, b),
        Qu(),
        (Ct = o.memoizedState),
        W || Ot !== Ct || $r
          ? (typeof ne == "function" &&
              (Xo(o, d, ne, g), (Ct = o.memoizedState)),
            (at = $r || ev(o, d, at, g, Ot, Ct, z))
              ? (Wt ||
                  (typeof T.UNSAFE_componentWillMount != "function" &&
                    typeof T.componentWillMount != "function") ||
                  (typeof T.componentWillMount == "function" &&
                    T.componentWillMount(),
                  typeof T.UNSAFE_componentWillMount == "function" &&
                    T.UNSAFE_componentWillMount()),
                typeof T.componentDidMount == "function" &&
                  (o.flags |= 4194308))
              : (typeof T.componentDidMount == "function" &&
                  (o.flags |= 4194308),
                (o.memoizedProps = g),
                (o.memoizedState = Ct)),
            (T.props = g),
            (T.state = Ct),
            (T.context = z),
            (g = at))
          : (typeof T.componentDidMount == "function" && (o.flags |= 4194308),
            (g = !1));
    } else {
      (T = o.stateNode),
        nn(s, o),
        (z = o.memoizedProps),
        (Wt = vr(d, z)),
        (T.props = Wt),
        (ne = o.pendingProps),
        (Ot = T.context),
        (Ct = d.contextType),
        (at = Oo),
        typeof Ct == "object" && Ct !== null && (at = _i(Ct)),
        (W = d.getDerivedStateFromProps),
        (Ct =
          typeof W == "function" ||
          typeof T.getSnapshotBeforeUpdate == "function") ||
          (typeof T.UNSAFE_componentWillReceiveProps != "function" &&
            typeof T.componentWillReceiveProps != "function") ||
          ((z !== ne || Ot !== at) && nv(o, T, g, at)),
        ($r = !1),
        (Ot = o.memoizedState),
        (T.state = Ot),
        Ec(o, g, T, b),
        Qu();
      var Nt = o.memoizedState;
      z !== ne ||
      Ot !== Nt ||
      $r ||
      (s !== null && s.dependencies !== null && Xu(s.dependencies))
        ? (typeof W == "function" && (Xo(o, d, W, g), (Nt = o.memoizedState)),
          (Wt =
            $r ||
            ev(o, d, Wt, g, Ot, Nt, at) ||
            (s !== null && s.dependencies !== null && Xu(s.dependencies)))
            ? (Ct ||
                (typeof T.UNSAFE_componentWillUpdate != "function" &&
                  typeof T.componentWillUpdate != "function") ||
                (typeof T.componentWillUpdate == "function" &&
                  T.componentWillUpdate(g, Nt, at),
                typeof T.UNSAFE_componentWillUpdate == "function" &&
                  T.UNSAFE_componentWillUpdate(g, Nt, at)),
              typeof T.componentDidUpdate == "function" && (o.flags |= 4),
              typeof T.getSnapshotBeforeUpdate == "function" &&
                (o.flags |= 1024))
            : (typeof T.componentDidUpdate != "function" ||
                (z === s.memoizedProps && Ot === s.memoizedState) ||
                (o.flags |= 4),
              typeof T.getSnapshotBeforeUpdate != "function" ||
                (z === s.memoizedProps && Ot === s.memoizedState) ||
                (o.flags |= 1024),
              (o.memoizedProps = g),
              (o.memoizedState = Nt)),
          (T.props = g),
          (T.state = Nt),
          (T.context = at),
          (g = Wt))
        : (typeof T.componentDidUpdate != "function" ||
            (z === s.memoizedProps && Ot === s.memoizedState) ||
            (o.flags |= 4),
          typeof T.getSnapshotBeforeUpdate != "function" ||
            (z === s.memoizedProps && Ot === s.memoizedState) ||
            (o.flags |= 1024),
          (g = !1));
    }
    return (
      (T = g),
      Tl(s, o),
      (g = (o.flags & 128) !== 0),
      T || g
        ? ((T = o.stateNode),
          (d =
            g && typeof d.getDerivedStateFromError != "function"
              ? null
              : T.render()),
          (o.flags |= 1),
          s !== null && g
            ? ((o.child = Al(o, s.child, null, b)),
              (o.child = Al(o, null, d, b)))
            : Oi(s, o, d, b),
          (o.memoizedState = T.state),
          (s = o.child))
        : (s = ea(s, o, b)),
      s
    );
  }
  function Wo(s, o, d, g) {
    return xc(), (o.flags |= 256), Oi(s, o, d, g), o.child;
  }
  var Qs = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null,
  };
  function $s(s) {
    return { baseLanes: s, cachePool: Bh() };
  }
  function ji(s, o, d) {
    return (s = s !== null ? s.childLanes & ~d : 0), o && (s |= Ps), s;
  }
  function Oc(s, o, d) {
    var g = o.pendingProps,
      b = !1,
      T = (o.flags & 128) !== 0,
      z;
    if (
      ((z = T) ||
        (z =
          s !== null && s.memoizedState === null ? !1 : (Ui.current & 2) !== 0),
      z && ((b = !0), (o.flags &= -129)),
      (z = (o.flags & 32) !== 0),
      (o.flags &= -33),
      s === null)
    ) {
      if (Pn) {
        if ((b ? ko(o) : jo(), Pn)) {
          var W = mi,
            at;
          if ((at = W)) {
            t: {
              for (at = W, W = ss; at.nodeType !== 8; ) {
                if (!W) {
                  W = null;
                  break t;
                }
                if (((at = uo(at.nextSibling)), at === null)) {
                  W = null;
                  break t;
                }
              }
              W = at;
            }
            W !== null
              ? ((o.memoizedState = {
                  dehydrated: W,
                  treeContext: Lo !== null ? { id: hr, overflow: dr } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (at = qa(18, null, null, 0)),
                (at.stateNode = W),
                (at.return = o),
                (o.child = at),
                (Da = o),
                (mi = null),
                (at = !0))
              : (at = !1);
          }
          at || Io(o);
        }
        if (
          ((W = o.memoizedState),
          W !== null && ((W = W.dehydrated), W !== null))
        )
          return V1(W) ? (o.lanes = 32) : (o.lanes = 536870912), null;
        gr(o);
      }
      return (
        (W = g.children),
        (g = g.fallback),
        b
          ? (jo(),
            (b = o.mode),
            (W = wl({ mode: "hidden", children: W }, b)),
            (g = No(g, b, d, null)),
            (W.return = o),
            (g.return = o),
            (W.sibling = g),
            (o.child = W),
            (b = o.child),
            (b.memoizedState = $s(d)),
            (b.childLanes = ji(s, z, d)),
            (o.memoizedState = Qs),
            g)
          : (ko(o), yr(o, W))
      );
    }
    if (
      ((at = s.memoizedState), at !== null && ((W = at.dehydrated), W !== null))
    ) {
      if (T)
        o.flags & 256
          ? (ko(o), (o.flags &= -257), (o = ha(s, o, d)))
          : o.memoizedState !== null
          ? (jo(), (o.child = s.child), (o.flags |= 128), (o = null))
          : (jo(),
            (b = g.fallback),
            (W = o.mode),
            (g = wl({ mode: "visible", children: g.children }, W)),
            (b = No(b, W, d, null)),
            (b.flags |= 2),
            (g.return = o),
            (b.return = o),
            (g.sibling = b),
            (o.child = g),
            Al(o, s.child, null, d),
            (g = o.child),
            (g.memoizedState = $s(d)),
            (g.childLanes = ji(s, z, d)),
            (o.memoizedState = Qs),
            (o = b));
      else if ((ko(o), V1(W))) {
        if (((z = W.nextSibling && W.nextSibling.dataset), z)) var Ct = z.dgst;
        (z = Ct),
          (g = Error(n(419))),
          (g.stack = ""),
          (g.digest = z),
          xl({ value: g, source: null, stack: null }),
          (o = ha(s, o, d));
      } else if (
        (ta || Cs(s, o, d, !1), (z = (d & s.childLanes) !== 0), ta || z)
      ) {
        if (
          ((z = cn),
          z !== null &&
            ((g = d & -d),
            (g = (g & 42) !== 0 ? 1 : Le(g)),
            (g = (g & (z.suspendedLanes | d)) !== 0 ? 0 : g),
            g !== 0 && g !== at.retryLane))
        )
          throw ((at.retryLane = g), Kr(s, g), Ia(z, s, g), sv);
        W.data === "$?" || c(), (o = ha(s, o, d));
      } else
        W.data === "$?"
          ? ((o.flags |= 192), (o.child = s.child), (o = null))
          : ((s = at.treeContext),
            (mi = uo(W.nextSibling)),
            (Da = o),
            (Pn = !0),
            (ws = null),
            (ss = !1),
            s !== null &&
              ((ua[as++] = hr),
              (ua[as++] = dr),
              (ua[as++] = Lo),
              (hr = s.id),
              (dr = s.overflow),
              (Lo = o)),
            (o = yr(o, g.children)),
            (o.flags |= 4096));
      return o;
    }
    return b
      ? (jo(),
        (b = g.fallback),
        (W = o.mode),
        (at = s.child),
        (Ct = at.sibling),
        (g = Bi(at, { mode: "hidden", children: g.children })),
        (g.subtreeFlags = at.subtreeFlags & 65011712),
        Ct !== null
          ? (b = Bi(Ct, b))
          : ((b = No(b, W, d, null)), (b.flags |= 2)),
        (b.return = o),
        (g.return = o),
        (g.sibling = b),
        (o.child = g),
        (g = b),
        (b = o.child),
        (W = s.child.memoizedState),
        W === null
          ? (W = $s(d))
          : ((at = W.cachePool),
            at !== null
              ? ((Ct = zi._currentValue),
                (at = at.parent !== Ct ? { parent: Ct, pool: Ct } : at))
              : (at = Bh()),
            (W = { baseLanes: W.baseLanes | d, cachePool: at })),
        (b.memoizedState = W),
        (b.childLanes = ji(s, z, d)),
        (o.memoizedState = Qs),
        g)
      : (ko(o),
        (d = s.child),
        (s = d.sibling),
        (d = Bi(d, { mode: "visible", children: g.children })),
        (d.return = o),
        (d.sibling = null),
        s !== null &&
          ((z = o.deletions),
          z === null ? ((o.deletions = [s]), (o.flags |= 16)) : z.push(s)),
        (o.child = d),
        (o.memoizedState = null),
        d);
  }
  function yr(s, o) {
    return (
      (o = wl({ mode: "visible", children: o }, s.mode)),
      (o.return = s),
      (s.child = o)
    );
  }
  function wl(s, o) {
    return (
      (s = qa(22, s, null, o)),
      (s.lanes = 0),
      (s.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
      }),
      s
    );
  }
  function ha(s, o, d) {
    return (
      Al(o, s.child, null, d),
      (s = yr(o, o.pendingProps.children)),
      (s.flags |= 2),
      (o.memoizedState = null),
      s
    );
  }
  function da(s, o, d) {
    s.lanes |= o;
    var g = s.alternate;
    g !== null && (g.lanes |= o), Fp(s.return, o, d);
  }
  function On(s, o, d, g, b) {
    var T = s.memoizedState;
    T === null
      ? (s.memoizedState = {
          isBackwards: o,
          rendering: null,
          renderingStartTime: 0,
          last: g,
          tail: d,
          tailMode: b,
        })
      : ((T.isBackwards = o),
        (T.rendering = null),
        (T.renderingStartTime = 0),
        (T.last = g),
        (T.tail = d),
        (T.tailMode = b));
  }
  function Os(s, o, d) {
    var g = o.pendingProps,
      b = g.revealOrder,
      T = g.tail;
    if ((Oi(s, o, g.children, d), (g = Ui.current), (g & 2) !== 0))
      (g = (g & 1) | 2), (o.flags |= 128);
    else {
      if (s !== null && (s.flags & 128) !== 0)
        t: for (s = o.child; s !== null; ) {
          if (s.tag === 13) s.memoizedState !== null && da(s, d, o);
          else if (s.tag === 19) da(s, d, o);
          else if (s.child !== null) {
            (s.child.return = s), (s = s.child);
            continue;
          }
          if (s === o) break t;
          for (; s.sibling === null; ) {
            if (s.return === null || s.return === o) break t;
            s = s.return;
          }
          (s.sibling.return = s.return), (s = s.sibling);
        }
      g &= 1;
    }
    switch ((Rt(Ui, g), b)) {
      case "forwards":
        for (d = o.child, b = null; d !== null; )
          (s = d.alternate),
            s !== null && ao(s) === null && (b = d),
            (d = d.sibling);
        (d = b),
          d === null
            ? ((b = o.child), (o.child = null))
            : ((b = d.sibling), (d.sibling = null)),
          On(o, !1, b, d, T);
        break;
      case "backwards":
        for (d = null, b = o.child, o.child = null; b !== null; ) {
          if (((s = b.alternate), s !== null && ao(s) === null)) {
            o.child = b;
            break;
          }
          (s = b.sibling), (b.sibling = d), (d = b), (b = s);
        }
        On(o, !0, d, null, T);
        break;
      case "together":
        On(o, !1, null, null, void 0);
        break;
      default:
        o.memoizedState = null;
    }
    return o.child;
  }
  function ea(s, o, d) {
    if (
      (s !== null && (o.dependencies = s.dependencies),
      (ir |= o.lanes),
      (d & o.childLanes) === 0)
    )
      if (s !== null) {
        if ((Cs(s, o, d, !1), (d & o.childLanes) === 0)) return null;
      } else return null;
    if (s !== null && o.child !== s.child) throw Error(n(153));
    if (o.child !== null) {
      for (
        s = o.child, d = Bi(s, s.pendingProps), o.child = d, d.return = o;
        s.sibling !== null;

      )
        (s = s.sibling),
          (d = d.sibling = Bi(s, s.pendingProps)),
          (d.return = o);
      d.sibling = null;
    }
    return o.child;
  }
  function of(s, o) {
    return (s.lanes & o) !== 0
      ? !0
      : ((s = s.dependencies), !!(s !== null && Xu(s)));
  }
  function Ns(s, o, d) {
    switch (o.tag) {
      case 3:
        ie(o, o.stateNode.containerInfo),
          zo(o, zi, s.memoizedState.cache),
          xc();
        break;
      case 27:
      case 5:
        Ae(o);
        break;
      case 4:
        ie(o, o.stateNode.containerInfo);
        break;
      case 10:
        zo(o, o.type, o.memoizedProps.value);
        break;
      case 13:
        var g = o.memoizedState;
        if (g !== null)
          return g.dehydrated !== null
            ? (ko(o), (o.flags |= 128), null)
            : (d & o.child.childLanes) !== 0
            ? Oc(s, o, d)
            : (ko(o), (s = ea(s, o, d)), s !== null ? s.sibling : null);
        ko(o);
        break;
      case 19:
        var b = (s.flags & 128) !== 0;
        if (
          ((g = (d & o.childLanes) !== 0),
          g || (Cs(s, o, d, !1), (g = (d & o.childLanes) !== 0)),
          b)
        ) {
          if (g) return Os(s, o, d);
          o.flags |= 128;
        }
        if (
          ((b = o.memoizedState),
          b !== null &&
            ((b.rendering = null), (b.tail = null), (b.lastEffect = null)),
          Rt(Ui, Ui.current),
          g)
        )
          break;
        return null;
      case 22:
      case 23:
        return (o.lanes = 0), Ml(s, o, d);
      case 24:
        zo(o, zi, s.memoizedState.cache);
    }
    return ea(s, o, d);
  }
  function Cl(s, o, d) {
    if (s !== null)
      if (s.memoizedProps !== o.pendingProps) ta = !0;
      else {
        if (!of(s, d) && (o.flags & 128) === 0) return (ta = !1), Ns(s, o, d);
        ta = (s.flags & 131072) !== 0;
      }
    else (ta = !1), Pn && (o.flags & 1048576) !== 0 && Eh(o, yc, o.index);
    switch (((o.lanes = 0), o.tag)) {
      case 16:
        t: {
          s = o.pendingProps;
          var g = o.elementType,
            b = g._init;
          if (((g = b(g._payload)), (o.type = g), typeof g == "function"))
            Gu(g)
              ? ((s = vr(g, s)), (o.tag = 1), (o = cs(null, o, g, s, d)))
              : ((o.tag = 0), (o = Uc(null, o, g, s, d)));
          else {
            if (g != null) {
              if (((b = g.$$typeof), b === D)) {
                (o.tag = 11), (o = Ja(null, o, g, s, d));
                break t;
              } else if (b === V) {
                (o.tag = 14), (o = Za(null, o, g, s, d));
                break t;
              }
            }
            throw ((o = dt(g) || g), Error(n(306, o, "")));
          }
        }
        return o;
      case 0:
        return Uc(s, o, o.type, o.pendingProps, d);
      case 1:
        return (g = o.type), (b = vr(g, o.pendingProps)), cs(s, o, g, b, d);
      case 3:
        t: {
          if ((ie(o, o.stateNode.containerInfo), s === null))
            throw Error(n(387));
          g = o.pendingProps;
          var T = o.memoizedState;
          (b = T.element), nn(s, o), Ec(o, g, null, d);
          var z = o.memoizedState;
          if (
            ((g = z.cache),
            zo(o, zi, g),
            g !== T.cache && ju(o, [zi], d, !0),
            Qu(),
            (g = z.element),
            T.isDehydrated)
          )
            if (
              ((T = { element: g, isDehydrated: !1, cache: z.cache }),
              (o.updateQueue.baseState = T),
              (o.memoizedState = T),
              o.flags & 256)
            ) {
              o = Wo(s, o, g, d);
              break t;
            } else if (g !== b) {
              (b = ca(Error(n(424)), o)), xl(b), (o = Wo(s, o, g, d));
              break t;
            } else {
              switch (((s = o.stateNode.containerInfo), s.nodeType)) {
                case 9:
                  s = s.body;
                  break;
                default:
                  s = s.nodeName === "HTML" ? s.ownerDocument.body : s;
              }
              for (
                mi = uo(s.firstChild),
                  Da = o,
                  Pn = !0,
                  ws = null,
                  ss = !0,
                  d = $g(o, null, g, d),
                  o.child = d;
                d;

              )
                (d.flags = (d.flags & -3) | 4096), (d = d.sibling);
            }
          else {
            if ((xc(), g === b)) {
              o = ea(s, o, d);
              break t;
            }
            Oi(s, o, g, d);
          }
          o = o.child;
        }
        return o;
      case 26:
        return (
          Tl(s, o),
          s === null
            ? (d = zM(o.type, null, o.pendingProps, null))
              ? (o.memoizedState = d)
              : Pn ||
                ((d = o.type),
                (s = o.pendingProps),
                (g = fv(Pt.current).createElement(d)),
                (g[xi] = o),
                (g[Ci] = s),
                Pa(g, d, s),
                Ut(g),
                (o.stateNode = g))
            : (o.memoizedState = zM(
                o.type,
                s.memoizedProps,
                o.pendingProps,
                s.memoizedState
              )),
          null
        );
      case 27:
        return (
          Ae(o),
          s === null &&
            Pn &&
            ((g = o.stateNode = LM(o.type, o.pendingProps, Pt.current)),
            (Da = o),
            (ss = !0),
            (b = mi),
            kc(o.type) ? ((k1 = b), (mi = uo(g.firstChild))) : (mi = b)),
          Oi(s, o, o.pendingProps.children, d),
          Tl(s, o),
          s === null && (o.flags |= 4194304),
          o.child
        );
      case 5:
        return (
          s === null &&
            Pn &&
            ((b = g = mi) &&
              ((g = _D(g, o.type, o.pendingProps, ss)),
              g !== null
                ? ((o.stateNode = g),
                  (Da = o),
                  (mi = uo(g.firstChild)),
                  (ss = !1),
                  (b = !0))
                : (b = !1)),
            b || Io(o)),
          Ae(o),
          (b = o.type),
          (T = o.pendingProps),
          (z = s !== null ? s.memoizedProps : null),
          (g = T.children),
          F1(b, T) ? (g = null) : z !== null && F1(b, z) && (o.flags |= 32),
          o.memoizedState !== null &&
            ((b = no(s, o, A1, null, null, d)), (xm._currentValue = b)),
          Tl(s, o),
          Oi(s, o, g, d),
          o.child
        );
      case 6:
        return (
          s === null &&
            Pn &&
            ((s = d = mi) &&
              ((d = bD(d, o.pendingProps, ss)),
              d !== null
                ? ((o.stateNode = d), (Da = o), (mi = null), (s = !0))
                : (s = !1)),
            s || Io(o)),
          null
        );
      case 13:
        return Oc(s, o, d);
      case 4:
        return (
          ie(o, o.stateNode.containerInfo),
          (g = o.pendingProps),
          s === null ? (o.child = Al(o, null, g, d)) : Oi(s, o, g, d),
          o.child
        );
      case 11:
        return Ja(s, o, o.type, o.pendingProps, d);
      case 7:
        return Oi(s, o, o.pendingProps, d), o.child;
      case 8:
        return Oi(s, o, o.pendingProps.children, d), o.child;
      case 12:
        return Oi(s, o, o.pendingProps.children, d), o.child;
      case 10:
        return (
          (g = o.pendingProps),
          zo(o, o.type, g.value),
          Oi(s, o, g.children, d),
          o.child
        );
      case 9:
        return (
          (b = o.type._context),
          (g = o.pendingProps.children),
          pr(o),
          (b = _i(b)),
          (g = g(b)),
          (o.flags |= 1),
          Oi(s, o, g, d),
          o.child
        );
      case 14:
        return Za(s, o, o.type, o.pendingProps, d);
      case 15:
        return lm(s, o, o.type, o.pendingProps, d);
      case 19:
        return Os(s, o, d);
      case 31:
        return (
          (g = o.pendingProps),
          (d = o.mode),
          (g = { mode: g.mode, children: g.children }),
          s === null
            ? ((d = wl(g, d)),
              (d.ref = o.ref),
              (o.child = d),
              (d.return = o),
              (o = d))
            : ((d = Bi(s.child, g)),
              (d.ref = o.ref),
              (o.child = d),
              (d.return = o),
              (o = d)),
          o
        );
      case 22:
        return Ml(s, o, d);
      case 24:
        return (
          pr(o),
          (g = _i(zi)),
          s === null
            ? ((b = Fo()),
              b === null &&
                ((b = cn),
                (T = Ch()),
                (b.pooledCache = T),
                T.refCount++,
                T !== null && (b.pooledCacheLanes |= d),
                (b = T)),
              (o.memoizedState = { parent: g, cache: b }),
              kp(o),
              zo(o, zi, b))
            : ((s.lanes & d) !== 0 && (nn(s, o), Ec(o, null, null, d), Qu()),
              (b = s.memoizedState),
              (T = o.memoizedState),
              b.parent !== g
                ? ((b = { parent: g, cache: g }),
                  (o.memoizedState = b),
                  o.lanes === 0 &&
                    (o.memoizedState = o.updateQueue.baseState = b),
                  zo(o, zi, g))
                : ((g = T.cache),
                  zo(o, zi, g),
                  g !== b.cache && ju(o, [zi], d, !0))),
          Oi(s, o, o.pendingProps.children, d),
          o.child
        );
      case 29:
        throw o.pendingProps;
    }
    throw Error(n(156, o.tag));
  }
  function tr(s) {
    s.flags |= 4;
  }
  function lf(s, o) {
    if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0)
      s.flags &= -16777217;
    else if (((s.flags |= 16777216), !kM(o))) {
      if (
        ((o = ti.current),
        o !== null &&
          ((We & 4194048) === We
            ? Zs !== null
            : ((We & 62914560) !== We && (We & 536870912) === 0) || o !== Zs))
      )
        throw ((Bs = Zu), Gp);
      s.flags |= 8192;
    }
  }
  function so(s, o) {
    o !== null && (s.flags |= 4),
      s.flags & 16384 &&
        ((o = s.tag !== 22 ? Et() : 536870912), (s.lanes |= o), (Ln |= o));
  }
  function Rl(s, o) {
    if (!Pn)
      switch (s.tailMode) {
        case "hidden":
          o = s.tail;
          for (var d = null; o !== null; )
            o.alternate !== null && (d = o), (o = o.sibling);
          d === null ? (s.tail = null) : (d.sibling = null);
          break;
        case "collapsed":
          d = s.tail;
          for (var g = null; d !== null; )
            d.alternate !== null && (g = d), (d = d.sibling);
          g === null
            ? o || s.tail === null
              ? (s.tail = null)
              : (s.tail.sibling = null)
            : (g.sibling = null);
      }
  }
  function ri(s) {
    var o = s.alternate !== null && s.alternate.child === s.child,
      d = 0,
      g = 0;
    if (o)
      for (var b = s.child; b !== null; )
        (d |= b.lanes | b.childLanes),
          (g |= b.subtreeFlags & 65011712),
          (g |= b.flags & 65011712),
          (b.return = s),
          (b = b.sibling);
    else
      for (b = s.child; b !== null; )
        (d |= b.lanes | b.childLanes),
          (g |= b.subtreeFlags),
          (g |= b.flags),
          (b.return = s),
          (b = b.sibling);
    return (s.subtreeFlags |= g), (s.childLanes = d), o;
  }
  function cm(s, o, d) {
    var g = o.pendingProps;
    switch ((Ip(o), o.tag)) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ri(o), null;
      case 1:
        return ri(o), null;
      case 3:
        return (
          (d = o.stateNode),
          (g = null),
          s !== null && (g = s.memoizedState.cache),
          o.memoizedState.cache !== g && (o.flags |= 2048),
          Qr(zi),
          Fe(),
          d.pendingContext &&
            ((d.context = d.pendingContext), (d.pendingContext = null)),
          (s === null || s.child === null) &&
            (qs(o)
              ? tr(o)
              : s === null ||
                (s.memoizedState.isDehydrated && (o.flags & 256) === 0) ||
                ((o.flags |= 1024), kn())),
          ri(o),
          null
        );
      case 26:
        return (
          (d = o.memoizedState),
          s === null
            ? (tr(o),
              d !== null ? (ri(o), lf(o, d)) : (ri(o), (o.flags &= -16777217)))
            : d
            ? d !== s.memoizedState
              ? (tr(o), ri(o), lf(o, d))
              : (ri(o), (o.flags &= -16777217))
            : (s.memoizedProps !== g && tr(o), ri(o), (o.flags &= -16777217)),
          null
        );
      case 27:
        De(o), (d = Pt.current);
        var b = o.type;
        if (s !== null && o.stateNode != null) s.memoizedProps !== g && tr(o);
        else {
          if (!g) {
            if (o.stateNode === null) throw Error(n(166));
            return ri(o), null;
          }
          (s = ht.current),
            qs(o) ? vg(o) : ((s = LM(b, g, d)), (o.stateNode = s), tr(o));
        }
        return ri(o), null;
      case 5:
        if ((De(o), (d = o.type), s !== null && o.stateNode != null))
          s.memoizedProps !== g && tr(o);
        else {
          if (!g) {
            if (o.stateNode === null) throw Error(n(166));
            return ri(o), null;
          }
          if (((s = ht.current), qs(o))) vg(o);
          else {
            switch (((b = fv(Pt.current)), s)) {
              case 1:
                s = b.createElementNS("http://www.w3.org/2000/svg", d);
                break;
              case 2:
                s = b.createElementNS("http://www.w3.org/1998/Math/MathML", d);
                break;
              default:
                switch (d) {
                  case "svg":
                    s = b.createElementNS("http://www.w3.org/2000/svg", d);
                    break;
                  case "math":
                    s = b.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      d
                    );
                    break;
                  case "script":
                    (s = b.createElement("div")),
                      (s.innerHTML = "<script></script>"),
                      (s = s.removeChild(s.firstChild));
                    break;
                  case "select":
                    (s =
                      typeof g.is == "string"
                        ? b.createElement("select", { is: g.is })
                        : b.createElement("select")),
                      g.multiple
                        ? (s.multiple = !0)
                        : g.size && (s.size = g.size);
                    break;
                  default:
                    s =
                      typeof g.is == "string"
                        ? b.createElement(d, { is: g.is })
                        : b.createElement(d);
                }
            }
            (s[xi] = o), (s[Ci] = g);
            t: for (b = o.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6) s.appendChild(b.stateNode);
              else if (b.tag !== 4 && b.tag !== 27 && b.child !== null) {
                (b.child.return = b), (b = b.child);
                continue;
              }
              if (b === o) break t;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === o) break t;
                b = b.return;
              }
              (b.sibling.return = b.return), (b = b.sibling);
            }
            o.stateNode = s;
            t: switch ((Pa(s, d, g), d)) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                s = !!g.autoFocus;
                break t;
              case "img":
                s = !0;
                break t;
              default:
                s = !1;
            }
            s && tr(o);
          }
        }
        return ri(o), (o.flags &= -16777217), null;
      case 6:
        if (s && o.stateNode != null) s.memoizedProps !== g && tr(o);
        else {
          if (typeof g != "string" && o.stateNode === null) throw Error(n(166));
          if (((s = Pt.current), qs(o))) {
            if (
              ((s = o.stateNode),
              (d = o.memoizedProps),
              (g = null),
              (b = Da),
              b !== null)
            )
              switch (b.tag) {
                case 27:
                case 5:
                  g = b.memoizedProps;
              }
            (s[xi] = o),
              (s = !!(
                s.nodeValue === d ||
                (g !== null && g.suppressHydrationWarning === !0) ||
                CM(s.nodeValue, d)
              )),
              s || Io(o);
          } else (s = fv(s).createTextNode(g)), (s[xi] = o), (o.stateNode = s);
        }
        return ri(o), null;
      case 13:
        if (
          ((g = o.memoizedState),
          s === null ||
            (s.memoizedState !== null && s.memoizedState.dehydrated !== null))
        ) {
          if (((b = qs(o)), g !== null && g.dehydrated !== null)) {
            if (s === null) {
              if (!b) throw Error(n(318));
              if (
                ((b = o.memoizedState),
                (b = b !== null ? b.dehydrated : null),
                !b)
              )
                throw Error(n(317));
              b[xi] = o;
            } else
              xc(),
                (o.flags & 128) === 0 && (o.memoizedState = null),
                (o.flags |= 4);
            ri(o), (b = !1);
          } else
            (b = kn()),
              s !== null &&
                s.memoizedState !== null &&
                (s.memoizedState.hydrationErrors = b),
              (b = !0);
          if (!b) return o.flags & 256 ? (gr(o), o) : (gr(o), null);
        }
        if ((gr(o), (o.flags & 128) !== 0)) return (o.lanes = d), o;
        if (
          ((d = g !== null), (s = s !== null && s.memoizedState !== null), d)
        ) {
          (g = o.child),
            (b = null),
            g.alternate !== null &&
              g.alternate.memoizedState !== null &&
              g.alternate.memoizedState.cachePool !== null &&
              (b = g.alternate.memoizedState.cachePool.pool);
          var T = null;
          g.memoizedState !== null &&
            g.memoizedState.cachePool !== null &&
            (T = g.memoizedState.cachePool.pool),
            T !== b && (g.flags |= 2048);
        }
        return (
          d !== s && d && (o.child.flags |= 8192),
          so(o, o.updateQueue),
          ri(o),
          null
        );
      case 4:
        return Fe(), s === null && N1(o.stateNode.containerInfo), ri(o), null;
      case 10:
        return Qr(o.type), ri(o), null;
      case 19:
        if ((At(Ui), (b = o.memoizedState), b === null)) return ri(o), null;
        if (((g = (o.flags & 128) !== 0), (T = b.rendering), T === null))
          if (g) Rl(b, !1);
          else {
            if (hi !== 0 || (s !== null && (s.flags & 128) !== 0))
              for (s = o.child; s !== null; ) {
                if (((T = ao(s)), T !== null)) {
                  for (
                    o.flags |= 128,
                      Rl(b, !1),
                      s = T.updateQueue,
                      o.updateQueue = s,
                      so(o, s),
                      o.subtreeFlags = 0,
                      s = d,
                      d = o.child;
                    d !== null;

                  )
                    Np(d, s), (d = d.sibling);
                  return Rt(Ui, (Ui.current & 1) | 2), o.child;
                }
                s = s.sibling;
              }
            b.tail !== null &&
              $t() > ba &&
              ((o.flags |= 128), (g = !0), Rl(b, !1), (o.lanes = 4194304));
          }
        else {
          if (!g)
            if (((s = ao(T)), s !== null)) {
              if (
                ((o.flags |= 128),
                (g = !0),
                (s = s.updateQueue),
                (o.updateQueue = s),
                so(o, s),
                Rl(b, !0),
                b.tail === null &&
                  b.tailMode === "hidden" &&
                  !T.alternate &&
                  !Pn)
              )
                return ri(o), null;
            } else
              2 * $t() - b.renderingStartTime > ba &&
                d !== 536870912 &&
                ((o.flags |= 128), (g = !0), Rl(b, !1), (o.lanes = 4194304));
          b.isBackwards
            ? ((T.sibling = o.child), (o.child = T))
            : ((s = b.last),
              s !== null ? (s.sibling = T) : (o.child = T),
              (b.last = T));
        }
        return b.tail !== null
          ? ((o = b.tail),
            (b.rendering = o),
            (b.tail = o.sibling),
            (b.renderingStartTime = $t()),
            (o.sibling = null),
            (s = Ui.current),
            Rt(Ui, g ? (s & 1) | 2 : s & 1),
            o)
          : (ri(o), null);
      case 22:
      case 23:
        return (
          gr(o),
          $u(),
          (g = o.memoizedState !== null),
          s !== null
            ? (s.memoizedState !== null) !== g && (o.flags |= 8192)
            : g && (o.flags |= 8192),
          g
            ? (d & 536870912) !== 0 &&
              (o.flags & 128) === 0 &&
              (ri(o), o.subtreeFlags & 6 && (o.flags |= 8192))
            : ri(o),
          (d = o.updateQueue),
          d !== null && so(o, d.retryQueue),
          (d = null),
          s !== null &&
            s.memoizedState !== null &&
            s.memoizedState.cachePool !== null &&
            (d = s.memoizedState.cachePool.pool),
          (g = null),
          o.memoizedState !== null &&
            o.memoizedState.cachePool !== null &&
            (g = o.memoizedState.cachePool.pool),
          g !== d && (o.flags |= 2048),
          s !== null && At(Rs),
          null
        );
      case 24:
        return (
          (d = null),
          s !== null && (d = s.memoizedState.cache),
          o.memoizedState.cache !== d && (o.flags |= 2048),
          Qr(zi),
          ri(o),
          null
        );
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(n(156, o.tag));
  }
  function Nc(s, o) {
    switch ((Ip(o), o.tag)) {
      case 1:
        return (
          (s = o.flags), s & 65536 ? ((o.flags = (s & -65537) | 128), o) : null
        );
      case 3:
        return (
          Qr(zi),
          Fe(),
          (s = o.flags),
          (s & 65536) !== 0 && (s & 128) === 0
            ? ((o.flags = (s & -65537) | 128), o)
            : null
        );
      case 26:
      case 27:
      case 5:
        return De(o), null;
      case 13:
        if (
          (gr(o), (s = o.memoizedState), s !== null && s.dehydrated !== null)
        ) {
          if (o.alternate === null) throw Error(n(340));
          xc();
        }
        return (
          (s = o.flags), s & 65536 ? ((o.flags = (s & -65537) | 128), o) : null
        );
      case 19:
        return At(Ui), null;
      case 4:
        return Fe(), null;
      case 10:
        return Qr(o.type), null;
      case 22:
      case 23:
        return (
          gr(o),
          $u(),
          s !== null && At(Rs),
          (s = o.flags),
          s & 65536 ? ((o.flags = (s & -65537) | 128), o) : null
        );
      case 24:
        return Qr(zi), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Lc(s, o) {
    switch ((Ip(o), o.tag)) {
      case 3:
        Qr(zi), Fe();
        break;
      case 26:
      case 27:
      case 5:
        De(o);
        break;
      case 4:
        Fe();
        break;
      case 13:
        gr(o);
        break;
      case 19:
        At(Ui);
        break;
      case 10:
        Qr(o.type);
        break;
      case 22:
      case 23:
        gr(o), $u(), s !== null && At(Rs);
        break;
      case 24:
        Qr(zi);
    }
  }
  function Bl(s, o) {
    try {
      var d = o.updateQueue,
        g = d !== null ? d.lastEffect : null;
      if (g !== null) {
        var b = g.next;
        d = b;
        do {
          if ((d.tag & s) === s) {
            g = void 0;
            var T = d.create,
              z = d.inst;
            (g = T()), (z.destroy = g);
          }
          d = d.next;
        } while (d !== b);
      }
    } catch (W) {
      mt(o, o.return, W);
    }
  }
  function us(s, o, d) {
    try {
      var g = o.updateQueue,
        b = g !== null ? g.lastEffect : null;
      if (b !== null) {
        var T = b.next;
        g = T;
        do {
          if ((g.tag & s) === s) {
            var z = g.inst,
              W = z.destroy;
            if (W !== void 0) {
              (z.destroy = void 0), (b = o);
              var at = d,
                Ct = W;
              try {
                Ct();
              } catch (Wt) {
                mt(b, at, Wt);
              }
            }
          }
          g = g.next;
        } while (g !== T);
      }
    } catch (Wt) {
      mt(o, o.return, Wt);
    }
  }
  function Dl(s) {
    var o = s.updateQueue;
    if (o !== null) {
      var d = s.stateNode;
      try {
        _g(o, d);
      } catch (g) {
        mt(s, s.return, g);
      }
    }
  }
  function ro(s, o, d) {
    (d.props = vr(s.type, s.memoizedProps)), (d.state = s.memoizedState);
    try {
      d.componentWillUnmount();
    } catch (g) {
      mt(s, o, g);
    }
  }
  function Ul(s, o) {
    try {
      var d = s.ref;
      if (d !== null) {
        switch (s.tag) {
          case 26:
          case 27:
          case 5:
            var g = s.stateNode;
            break;
          case 30:
            g = s.stateNode;
            break;
          default:
            g = s.stateNode;
        }
        typeof d == "function" ? (s.refCleanup = d(g)) : (d.current = g);
      }
    } catch (b) {
      mt(s, o, b);
    }
  }
  function xr(s, o) {
    var d = s.ref,
      g = s.refCleanup;
    if (d !== null)
      if (typeof g == "function")
        try {
          g();
        } catch (b) {
          mt(s, o, b);
        } finally {
          (s.refCleanup = null),
            (s = s.alternate),
            s != null && (s.refCleanup = null);
        }
      else if (typeof d == "function")
        try {
          d(null);
        } catch (b) {
          mt(s, o, b);
        }
      else d.current = null;
  }
  function Ic(s) {
    var o = s.type,
      d = s.memoizedProps,
      g = s.stateNode;
    try {
      t: switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && g.focus();
          break t;
        case "img":
          d.src ? (g.src = d.src) : d.srcSet && (g.srcset = d.srcSet);
      }
    } catch (b) {
      mt(s, s.return, b);
    }
  }
  function cf(s, o, d) {
    try {
      var g = s.stateNode;
      mD(g, s.type, d, o), (g[Ci] = o);
    } catch (b) {
      mt(s, s.return, b);
    }
  }
  function uf(s) {
    return (
      s.tag === 5 ||
      s.tag === 3 ||
      s.tag === 26 ||
      (s.tag === 27 && kc(s.type)) ||
      s.tag === 4
    );
  }
  function Yo(s) {
    t: for (;;) {
      for (; s.sibling === null; ) {
        if (s.return === null || uf(s.return)) return null;
        s = s.return;
      }
      for (
        s.sibling.return = s.return, s = s.sibling;
        s.tag !== 5 && s.tag !== 6 && s.tag !== 18;

      ) {
        if (
          (s.tag === 27 && kc(s.type)) ||
          s.flags & 2 ||
          s.child === null ||
          s.tag === 4
        )
          continue t;
        (s.child.return = s), (s = s.child);
      }
      if (!(s.flags & 2)) return s.stateNode;
    }
  }
  function qo(s, o, d) {
    var g = s.tag;
    if (g === 5 || g === 6)
      (s = s.stateNode),
        o
          ? (d.nodeType === 9
              ? d.body
              : d.nodeName === "HTML"
              ? d.ownerDocument.body
              : d
            ).insertBefore(s, o)
          : ((o =
              d.nodeType === 9
                ? d.body
                : d.nodeName === "HTML"
                ? d.ownerDocument.body
                : d),
            o.appendChild(s),
            (d = d._reactRootContainer),
            d != null || o.onclick !== null || (o.onclick = uv));
    else if (
      g !== 4 &&
      (g === 27 && kc(s.type) && ((d = s.stateNode), (o = null)),
      (s = s.child),
      s !== null)
    )
      for (qo(s, o, d), s = s.sibling; s !== null; )
        qo(s, o, d), (s = s.sibling);
  }
  function Ko(s, o, d) {
    var g = s.tag;
    if (g === 5 || g === 6)
      (s = s.stateNode), o ? d.insertBefore(s, o) : d.appendChild(s);
    else if (
      g !== 4 &&
      (g === 27 && kc(s.type) && (d = s.stateNode), (s = s.child), s !== null)
    )
      for (Ko(s, o, d), s = s.sibling; s !== null; )
        Ko(s, o, d), (s = s.sibling);
  }
  function Jo(s) {
    var o = s.stateNode,
      d = s.memoizedProps;
    try {
      for (var g = s.type, b = o.attributes; b.length; )
        o.removeAttributeNode(b[0]);
      Pa(o, g, d), (o[xi] = s), (o[Ci] = d);
    } catch (T) {
      mt(s, s.return, T);
    }
  }
  var _r = !1,
    oi = !1,
    Pc = !1,
    fs = typeof WeakSet == "function" ? WeakSet : Set,
    ei = null;
  function Xi(s, o) {
    if (((s = s.containerInfo), (P1 = vv), (s = wp(s)), Pu(s))) {
      if ("selectionStart" in s)
        var d = { start: s.selectionStart, end: s.selectionEnd };
      else
        t: {
          d = ((d = s.ownerDocument) && d.defaultView) || window;
          var g = d.getSelection && d.getSelection();
          if (g && g.rangeCount !== 0) {
            d = g.anchorNode;
            var b = g.anchorOffset,
              T = g.focusNode;
            g = g.focusOffset;
            try {
              d.nodeType, T.nodeType;
            } catch {
              d = null;
              break t;
            }
            var z = 0,
              W = -1,
              at = -1,
              Ct = 0,
              Wt = 0,
              ne = s,
              Ot = null;
            e: for (;;) {
              for (
                var Nt;
                ne !== d || (b !== 0 && ne.nodeType !== 3) || (W = z + b),
                  ne !== T || (g !== 0 && ne.nodeType !== 3) || (at = z + g),
                  ne.nodeType === 3 && (z += ne.nodeValue.length),
                  (Nt = ne.firstChild) !== null;

              )
                (Ot = ne), (ne = Nt);
              for (;;) {
                if (ne === s) break e;
                if (
                  (Ot === d && ++Ct === b && (W = z),
                  Ot === T && ++Wt === g && (at = z),
                  (Nt = ne.nextSibling) !== null)
                )
                  break;
                (ne = Ot), (Ot = ne.parentNode);
              }
              ne = Nt;
            }
            d = W === -1 || at === -1 ? null : { start: W, end: at };
          } else d = null;
        }
      d = d || { start: 0, end: 0 };
    } else d = null;
    for (
      z1 = { focusedElem: s, selectionRange: d }, vv = !1, ei = o;
      ei !== null;

    )
      if (
        ((o = ei), (s = o.child), (o.subtreeFlags & 1024) !== 0 && s !== null)
      )
        (s.return = o), (ei = s);
      else
        for (; ei !== null; ) {
          switch (((o = ei), (T = o.alternate), (s = o.flags), o.tag)) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((s & 1024) !== 0 && T !== null) {
                (s = void 0),
                  (d = o),
                  (b = T.memoizedProps),
                  (T = T.memoizedState),
                  (g = d.stateNode);
                try {
                  var sn = vr(d.type, b, d.elementType === d.type);
                  (s = g.getSnapshotBeforeUpdate(sn, T)),
                    (g.__reactInternalSnapshotBeforeUpdate = s);
                } catch ($e) {
                  mt(d, d.return, $e);
                }
              }
              break;
            case 3:
              if ((s & 1024) !== 0) {
                if (
                  ((s = o.stateNode.containerInfo), (d = s.nodeType), d === 9)
                )
                  G1(s);
                else if (d === 1)
                  switch (s.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      G1(s);
                      break;
                    default:
                      s.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((s & 1024) !== 0) throw Error(n(163));
          }
          if (((s = o.sibling), s !== null)) {
            (s.return = o.return), (ei = s);
            break;
          }
          ei = o.return;
        }
  }
  function oo(s, o, d) {
    var g = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        La(s, d), g & 4 && Bl(5, d);
        break;
      case 1:
        if ((La(s, d), g & 4))
          if (((s = d.stateNode), o === null))
            try {
              s.componentDidMount();
            } catch (z) {
              mt(d, d.return, z);
            }
          else {
            var b = vr(d.type, o.memoizedProps);
            o = o.memoizedState;
            try {
              s.componentDidUpdate(b, o, s.__reactInternalSnapshotBeforeUpdate);
            } catch (z) {
              mt(d, d.return, z);
            }
          }
        g & 64 && Dl(d), g & 512 && Ul(d, d.return);
        break;
      case 3:
        if ((La(s, d), g & 64 && ((s = d.updateQueue), s !== null))) {
          if (((o = null), d.child !== null))
            switch (d.child.tag) {
              case 27:
              case 5:
                o = d.child.stateNode;
                break;
              case 1:
                o = d.child.stateNode;
            }
          try {
            _g(s, o);
          } catch (z) {
            mt(d, d.return, z);
          }
        }
        break;
      case 27:
        o === null && g & 4 && Jo(d);
      case 26:
      case 5:
        La(s, d), o === null && g & 4 && Ic(d), g & 512 && Ul(d, d.return);
        break;
      case 12:
        La(s, d);
        break;
      case 13:
        La(s, d),
          g & 4 && Zo(s, d),
          g & 64 &&
            ((s = d.memoizedState),
            s !== null &&
              ((s = s.dehydrated),
              s !== null && ((d = di.bind(null, d)), AD(s, d))));
        break;
      case 22:
        if (((g = d.memoizedState !== null || _r), !g)) {
          (o = (o !== null && o.memoizedState !== null) || oi), (b = _r);
          var T = oi;
          (_r = g),
            (oi = o) && !T ? br(s, d, (d.subtreeFlags & 8772) !== 0) : La(s, d),
            (_r = b),
            (oi = T);
        }
        break;
      case 30:
        break;
      default:
        La(s, d);
    }
  }
  function _n(s) {
    var o = s.alternate;
    o !== null && ((s.alternate = null), _n(o)),
      (s.child = null),
      (s.deletions = null),
      (s.sibling = null),
      s.tag === 5 && ((o = s.stateNode), o !== null && Vn(o)),
      (s.stateNode = null),
      (s.return = null),
      (s.dependencies = null),
      (s.memoizedProps = null),
      (s.memoizedState = null),
      (s.pendingProps = null),
      (s.stateNode = null),
      (s.updateQueue = null);
  }
  var Je = null,
    Nn = !1;
  function Ls(s, o, d) {
    for (d = d.child; d !== null; ) Ol(s, o, d), (d = d.sibling);
  }
  function Ol(s, o, d) {
    if (Gt && typeof Gt.onCommitFiberUnmount == "function")
      try {
        Gt.onCommitFiberUnmount(Ft, d);
      } catch {}
    switch (d.tag) {
      case 26:
        oi || xr(d, o),
          Ls(s, o, d),
          d.memoizedState
            ? d.memoizedState.count--
            : d.stateNode && ((d = d.stateNode), d.parentNode.removeChild(d));
        break;
      case 27:
        oi || xr(d, o);
        var g = Je,
          b = Nn;
        kc(d.type) && ((Je = d.stateNode), (Nn = !1)),
          Ls(s, o, d),
          mm(d.stateNode),
          (Je = g),
          (Nn = b);
        break;
      case 5:
        oi || xr(d, o);
      case 6:
        if (
          ((g = Je),
          (b = Nn),
          (Je = null),
          Ls(s, o, d),
          (Je = g),
          (Nn = b),
          Je !== null)
        )
          if (Nn)
            try {
              (Je.nodeType === 9
                ? Je.body
                : Je.nodeName === "HTML"
                ? Je.ownerDocument.body
                : Je
              ).removeChild(d.stateNode);
            } catch (T) {
              mt(d, o, T);
            }
          else
            try {
              Je.removeChild(d.stateNode);
            } catch (T) {
              mt(d, o, T);
            }
        break;
      case 18:
        Je !== null &&
          (Nn
            ? ((s = Je),
              OM(
                s.nodeType === 9
                  ? s.body
                  : s.nodeName === "HTML"
                  ? s.ownerDocument.body
                  : s,
                d.stateNode
              ),
              Sm(s))
            : OM(Je, d.stateNode));
        break;
      case 4:
        (g = Je),
          (b = Nn),
          (Je = d.stateNode.containerInfo),
          (Nn = !0),
          Ls(s, o, d),
          (Je = g),
          (Nn = b);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        oi || us(2, d, o), oi || us(4, d, o), Ls(s, o, d);
        break;
      case 1:
        oi ||
          (xr(d, o),
          (g = d.stateNode),
          typeof g.componentWillUnmount == "function" && ro(d, o, g)),
          Ls(s, o, d);
        break;
      case 21:
        Ls(s, o, d);
        break;
      case 22:
        (oi = (g = oi) || d.memoizedState !== null), Ls(s, o, d), (oi = g);
        break;
      default:
        Ls(s, o, d);
    }
  }
  function Zo(s, o) {
    if (
      o.memoizedState === null &&
      ((s = o.alternate),
      s !== null &&
        ((s = s.memoizedState), s !== null && ((s = s.dehydrated), s !== null)))
    )
      try {
        Sm(s);
      } catch (d) {
        mt(o, o.return, d);
      }
  }
  function Kh(s) {
    switch (s.tag) {
      case 13:
      case 19:
        var o = s.stateNode;
        return o === null && (o = s.stateNode = new fs()), o;
      case 22:
        return (
          (s = s.stateNode),
          (o = s._retryCache),
          o === null && (o = s._retryCache = new fs()),
          o
        );
      default:
        throw Error(n(435, s.tag));
    }
  }
  function Nl(s, o) {
    var d = Kh(s);
    o.forEach(function (g) {
      var b = an.bind(null, s, g);
      d.has(g) || (d.add(g), g.then(b, b));
    });
  }
  function na(s, o) {
    var d = o.deletions;
    if (d !== null)
      for (var g = 0; g < d.length; g++) {
        var b = d[g],
          T = s,
          z = o,
          W = z;
        t: for (; W !== null; ) {
          switch (W.tag) {
            case 27:
              if (kc(W.type)) {
                (Je = W.stateNode), (Nn = !1);
                break t;
              }
              break;
            case 5:
              (Je = W.stateNode), (Nn = !1);
              break t;
            case 3:
            case 4:
              (Je = W.stateNode.containerInfo), (Nn = !0);
              break t;
          }
          W = W.return;
        }
        if (Je === null) throw Error(n(160));
        Ol(T, z, b),
          (Je = null),
          (Nn = !1),
          (T = b.alternate),
          T !== null && (T.return = null),
          (b.return = null);
      }
    if (o.subtreeFlags & 13878)
      for (o = o.child; o !== null; ) Jh(o, s), (o = o.sibling);
  }
  var er = null;
  function Jh(s, o) {
    var d = s.alternate,
      g = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        na(o, s),
          bi(s),
          g & 4 && (us(3, s, s.return), Bl(3, s), us(5, s, s.return));
        break;
      case 1:
        na(o, s),
          bi(s),
          g & 512 && (oi || d === null || xr(d, d.return)),
          g & 64 &&
            _r &&
            ((s = s.updateQueue),
            s !== null &&
              ((g = s.callbacks),
              g !== null &&
                ((d = s.shared.hiddenCallbacks),
                (s.shared.hiddenCallbacks = d === null ? g : d.concat(g)))));
        break;
      case 26:
        var b = er;
        if (
          (na(o, s),
          bi(s),
          g & 512 && (oi || d === null || xr(d, d.return)),
          g & 4)
        ) {
          var T = d !== null ? d.memoizedState : null;
          if (((g = s.memoizedState), d === null))
            if (g === null)
              if (s.stateNode === null) {
                t: {
                  (g = s.type),
                    (d = s.memoizedProps),
                    (b = b.ownerDocument || b);
                  e: switch (g) {
                    case "title":
                      (T = b.getElementsByTagName("title")[0]),
                        (!T ||
                          T[ka] ||
                          T[xi] ||
                          T.namespaceURI === "http://www.w3.org/2000/svg" ||
                          T.hasAttribute("itemprop")) &&
                          ((T = b.createElement(g)),
                          b.head.insertBefore(
                            T,
                            b.querySelector("head > title")
                          )),
                        Pa(T, g, d),
                        (T[xi] = s),
                        Ut(T),
                        (g = T);
                      break t;
                    case "link":
                      var z = GM("link", "href", b).get(g + (d.href || ""));
                      if (z) {
                        for (var W = 0; W < z.length; W++)
                          if (
                            ((T = z[W]),
                            T.getAttribute("href") ===
                              (d.href == null || d.href === ""
                                ? null
                                : d.href) &&
                              T.getAttribute("rel") ===
                                (d.rel == null ? null : d.rel) &&
                              T.getAttribute("title") ===
                                (d.title == null ? null : d.title) &&
                              T.getAttribute("crossorigin") ===
                                (d.crossOrigin == null ? null : d.crossOrigin))
                          ) {
                            z.splice(W, 1);
                            break e;
                          }
                      }
                      (T = b.createElement(g)),
                        Pa(T, g, d),
                        b.head.appendChild(T);
                      break;
                    case "meta":
                      if (
                        (z = GM("meta", "content", b).get(
                          g + (d.content || "")
                        ))
                      ) {
                        for (W = 0; W < z.length; W++)
                          if (
                            ((T = z[W]),
                            T.getAttribute("content") ===
                              (d.content == null ? null : "" + d.content) &&
                              T.getAttribute("name") ===
                                (d.name == null ? null : d.name) &&
                              T.getAttribute("property") ===
                                (d.property == null ? null : d.property) &&
                              T.getAttribute("http-equiv") ===
                                (d.httpEquiv == null ? null : d.httpEquiv) &&
                              T.getAttribute("charset") ===
                                (d.charSet == null ? null : d.charSet))
                          ) {
                            z.splice(W, 1);
                            break e;
                          }
                      }
                      (T = b.createElement(g)),
                        Pa(T, g, d),
                        b.head.appendChild(T);
                      break;
                    default:
                      throw Error(n(468, g));
                  }
                  (T[xi] = s), Ut(T), (g = T);
                }
                s.stateNode = g;
              } else VM(b, s.type, s.stateNode);
            else s.stateNode = HM(b, g, s.memoizedProps);
          else
            T !== g
              ? (T === null
                  ? d.stateNode !== null &&
                    ((d = d.stateNode), d.parentNode.removeChild(d))
                  : T.count--,
                g === null
                  ? VM(b, s.type, s.stateNode)
                  : HM(b, g, s.memoizedProps))
              : g === null &&
                s.stateNode !== null &&
                cf(s, s.memoizedProps, d.memoizedProps);
        }
        break;
      case 27:
        na(o, s),
          bi(s),
          g & 512 && (oi || d === null || xr(d, d.return)),
          d !== null && g & 4 && cf(s, s.memoizedProps, d.memoizedProps);
        break;
      case 5:
        if (
          (na(o, s),
          bi(s),
          g & 512 && (oi || d === null || xr(d, d.return)),
          s.flags & 32)
        ) {
          b = s.stateNode;
          try {
            Ca(b, "");
          } catch (Nt) {
            mt(s, s.return, Nt);
          }
        }
        g & 4 &&
          s.stateNode != null &&
          ((b = s.memoizedProps), cf(s, b, d !== null ? d.memoizedProps : b)),
          g & 1024 && (Pc = !0);
        break;
      case 6:
        if ((na(o, s), bi(s), g & 4)) {
          if (s.stateNode === null) throw Error(n(162));
          (g = s.memoizedProps), (d = s.stateNode);
          try {
            d.nodeValue = g;
          } catch (Nt) {
            mt(s, s.return, Nt);
          }
        }
        break;
      case 3:
        if (
          ((pv = null),
          (b = er),
          (er = hv(o.containerInfo)),
          na(o, s),
          (er = b),
          bi(s),
          g & 4 && d !== null && d.memoizedState.isDehydrated)
        )
          try {
            Sm(o.containerInfo);
          } catch (Nt) {
            mt(s, s.return, Nt);
          }
        Pc && ((Pc = !1), Qo(s));
        break;
      case 4:
        (g = er),
          (er = hv(s.stateNode.containerInfo)),
          na(o, s),
          bi(s),
          (er = g);
        break;
      case 12:
        na(o, s), bi(s);
        break;
      case 13:
        na(o, s),
          bi(s),
          s.child.flags & 8192 &&
            (s.memoizedState !== null) !=
              (d !== null && d.memoizedState !== null) &&
            (Jn = $t()),
          g & 4 &&
            ((g = s.updateQueue),
            g !== null && ((s.updateQueue = null), Nl(s, g)));
        break;
      case 22:
        b = s.memoizedState !== null;
        var at = d !== null && d.memoizedState !== null,
          Ct = _r,
          Wt = oi;
        if (
          ((_r = Ct || b),
          (oi = Wt || at),
          na(o, s),
          (oi = Wt),
          (_r = Ct),
          bi(s),
          g & 8192)
        )
          t: for (
            o = s.stateNode,
              o._visibility = b ? o._visibility & -2 : o._visibility | 1,
              b && (d === null || at || _r || oi || hs(s)),
              d = null,
              o = s;
            ;

          ) {
            if (o.tag === 5 || o.tag === 26) {
              if (d === null) {
                at = d = o;
                try {
                  if (((T = at.stateNode), b))
                    (z = T.style),
                      typeof z.setProperty == "function"
                        ? z.setProperty("display", "none", "important")
                        : (z.display = "none");
                  else {
                    W = at.stateNode;
                    var ne = at.memoizedProps.style,
                      Ot =
                        ne != null && ne.hasOwnProperty("display")
                          ? ne.display
                          : null;
                    W.style.display =
                      Ot == null || typeof Ot == "boolean"
                        ? ""
                        : ("" + Ot).trim();
                  }
                } catch (Nt) {
                  mt(at, at.return, Nt);
                }
              }
            } else if (o.tag === 6) {
              if (d === null) {
                at = o;
                try {
                  at.stateNode.nodeValue = b ? "" : at.memoizedProps;
                } catch (Nt) {
                  mt(at, at.return, Nt);
                }
              }
            } else if (
              ((o.tag !== 22 && o.tag !== 23) ||
                o.memoizedState === null ||
                o === s) &&
              o.child !== null
            ) {
              (o.child.return = o), (o = o.child);
              continue;
            }
            if (o === s) break t;
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === s) break t;
              d === o && (d = null), (o = o.return);
            }
            d === o && (d = null),
              (o.sibling.return = o.return),
              (o = o.sibling);
          }
        g & 4 &&
          ((g = s.updateQueue),
          g !== null &&
            ((d = g.retryQueue),
            d !== null && ((g.retryQueue = null), Nl(s, d))));
        break;
      case 19:
        na(o, s),
          bi(s),
          g & 4 &&
            ((g = s.updateQueue),
            g !== null && ((s.updateQueue = null), Nl(s, g)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        na(o, s), bi(s);
    }
  }
  function bi(s) {
    var o = s.flags;
    if (o & 2) {
      try {
        for (var d, g = s.return; g !== null; ) {
          if (uf(g)) {
            d = g;
            break;
          }
          g = g.return;
        }
        if (d == null) throw Error(n(160));
        switch (d.tag) {
          case 27:
            var b = d.stateNode,
              T = Yo(s);
            Ko(s, T, b);
            break;
          case 5:
            var z = d.stateNode;
            d.flags & 32 && (Ca(z, ""), (d.flags &= -33));
            var W = Yo(s);
            Ko(s, W, z);
            break;
          case 3:
          case 4:
            var at = d.stateNode.containerInfo,
              Ct = Yo(s);
            qo(s, Ct, at);
            break;
          default:
            throw Error(n(161));
        }
      } catch (Wt) {
        mt(s, s.return, Wt);
      }
      s.flags &= -3;
    }
    o & 4096 && (s.flags &= -4097);
  }
  function Qo(s) {
    if (s.subtreeFlags & 1024)
      for (s = s.child; s !== null; ) {
        var o = s;
        Qo(o),
          o.tag === 5 && o.flags & 1024 && o.stateNode.reset(),
          (s = s.sibling);
      }
  }
  function La(s, o) {
    if (o.subtreeFlags & 8772)
      for (o = o.child; o !== null; ) oo(s, o.alternate, o), (o = o.sibling);
  }
  function hs(s) {
    for (s = s.child; s !== null; ) {
      var o = s;
      switch (o.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          us(4, o, o.return), hs(o);
          break;
        case 1:
          xr(o, o.return);
          var d = o.stateNode;
          typeof d.componentWillUnmount == "function" && ro(o, o.return, d),
            hs(o);
          break;
        case 27:
          mm(o.stateNode);
        case 26:
        case 5:
          xr(o, o.return), hs(o);
          break;
        case 22:
          o.memoizedState === null && hs(o);
          break;
        case 30:
          hs(o);
          break;
        default:
          hs(o);
      }
      s = s.sibling;
    }
  }
  function br(s, o, d) {
    for (d = d && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null; ) {
      var g = o.alternate,
        b = s,
        T = o,
        z = T.flags;
      switch (T.tag) {
        case 0:
        case 11:
        case 15:
          br(b, T, d), Bl(4, T);
          break;
        case 1:
          if (
            (br(b, T, d),
            (g = T),
            (b = g.stateNode),
            typeof b.componentDidMount == "function")
          )
            try {
              b.componentDidMount();
            } catch (Ct) {
              mt(g, g.return, Ct);
            }
          if (((g = T), (b = g.updateQueue), b !== null)) {
            var W = g.stateNode;
            try {
              var at = b.shared.hiddenCallbacks;
              if (at !== null)
                for (b.shared.hiddenCallbacks = null, b = 0; b < at.length; b++)
                  Tc(at[b], W);
            } catch (Ct) {
              mt(g, g.return, Ct);
            }
          }
          d && z & 64 && Dl(T), Ul(T, T.return);
          break;
        case 27:
          Jo(T);
        case 26:
        case 5:
          br(b, T, d), d && g === null && z & 4 && Ic(T), Ul(T, T.return);
          break;
        case 12:
          br(b, T, d);
          break;
        case 13:
          br(b, T, d), d && z & 4 && Zo(b, T);
          break;
        case 22:
          T.memoizedState === null && br(b, T, d), Ul(T, T.return);
          break;
        case 30:
          break;
        default:
          br(b, T, d);
      }
      o = o.sibling;
    }
  }
  function Zh(s, o) {
    var d = null;
    s !== null &&
      s.memoizedState !== null &&
      s.memoizedState.cachePool !== null &&
      (d = s.memoizedState.cachePool.pool),
      (s = null),
      o.memoizedState !== null &&
        o.memoizedState.cachePool !== null &&
        (s = o.memoizedState.cachePool.pool),
      s !== d && (s != null && s.refCount++, d != null && _c(d));
  }
  function Qh(s, o) {
    (s = null),
      o.alternate !== null && (s = o.alternate.memoizedState.cache),
      (o = o.memoizedState.cache),
      o !== s && (o.refCount++, s != null && _c(s));
  }
  function ni(s, o, d, g) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) $h(s, o, d, g), (o = o.sibling);
  }
  function $h(s, o, d, g) {
    var b = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        ni(s, o, d, g), b & 2048 && Bl(9, o);
        break;
      case 1:
        ni(s, o, d, g);
        break;
      case 3:
        ni(s, o, d, g),
          b & 2048 &&
            ((s = null),
            o.alternate !== null && (s = o.alternate.memoizedState.cache),
            (o = o.memoizedState.cache),
            o !== s && (o.refCount++, s != null && _c(s)));
        break;
      case 12:
        if (b & 2048) {
          ni(s, o, d, g), (s = o.stateNode);
          try {
            var T = o.memoizedProps,
              z = T.id,
              W = T.onPostCommit;
            typeof W == "function" &&
              W(
                z,
                o.alternate === null ? "mount" : "update",
                s.passiveEffectDuration,
                -0
              );
          } catch (at) {
            mt(o, o.return, at);
          }
        } else ni(s, o, d, g);
        break;
      case 13:
        ni(s, o, d, g);
        break;
      case 23:
        break;
      case 22:
        (T = o.stateNode),
          (z = o.alternate),
          o.memoizedState !== null
            ? T._visibility & 2
              ? ni(s, o, d, g)
              : nr(s, o)
            : T._visibility & 2
            ? ni(s, o, d, g)
            : ((T._visibility |= 2),
              lo(s, o, d, g, (o.subtreeFlags & 10256) !== 0)),
          b & 2048 && Zh(z, o);
        break;
      case 24:
        ni(s, o, d, g), b & 2048 && Qh(o.alternate, o);
        break;
      default:
        ni(s, o, d, g);
    }
  }
  function lo(s, o, d, g, b) {
    for (b = b && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null; ) {
      var T = s,
        z = o,
        W = d,
        at = g,
        Ct = z.flags;
      switch (z.tag) {
        case 0:
        case 11:
        case 15:
          lo(T, z, W, at, b), Bl(8, z);
          break;
        case 23:
          break;
        case 22:
          var Wt = z.stateNode;
          z.memoizedState !== null
            ? Wt._visibility & 2
              ? lo(T, z, W, at, b)
              : nr(T, z)
            : ((Wt._visibility |= 2), lo(T, z, W, at, b)),
            b && Ct & 2048 && Zh(z.alternate, z);
          break;
        case 24:
          lo(T, z, W, at, b), b && Ct & 2048 && Qh(z.alternate, z);
          break;
        default:
          lo(T, z, W, at, b);
      }
      o = o.sibling;
    }
  }
  function nr(s, o) {
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; ) {
        var d = s,
          g = o,
          b = g.flags;
        switch (g.tag) {
          case 22:
            nr(d, g), b & 2048 && Zh(g.alternate, g);
            break;
          case 24:
            nr(d, g), b & 2048 && Qh(g.alternate, g);
            break;
          default:
            nr(d, g);
        }
        o = o.sibling;
      }
  }
  var ds = 8192;
  function zc(s) {
    if (s.subtreeFlags & ds)
      for (s = s.child; s !== null; ) rv(s), (s = s.sibling);
  }
  function rv(s) {
    switch (s.tag) {
      case 26:
        zc(s),
          s.flags & ds &&
            s.memoizedState !== null &&
            LD(er, s.memoizedState, s.memoizedProps);
        break;
      case 5:
        zc(s);
        break;
      case 3:
      case 4:
        var o = er;
        (er = hv(s.stateNode.containerInfo)), zc(s), (er = o);
        break;
      case 22:
        s.memoizedState === null &&
          ((o = s.alternate),
          o !== null && o.memoizedState !== null
            ? ((o = ds), (ds = 16777216), zc(s), (ds = o))
            : zc(s));
        break;
      default:
        zc(s);
    }
  }
  function ov(s) {
    var o = s.alternate;
    if (o !== null && ((s = o.child), s !== null)) {
      o.child = null;
      do (o = s.sibling), (s.sibling = null), (s = o);
      while (s !== null);
    }
  }
  function li(s) {
    var o = s.deletions;
    if ((s.flags & 16) !== 0) {
      if (o !== null)
        for (var d = 0; d < o.length; d++) {
          var g = o[d];
          (ei = g), Sr(g, s);
        }
      ov(s);
    }
    if (s.subtreeFlags & 10256)
      for (s = s.child; s !== null; ) um(s), (s = s.sibling);
  }
  function um(s) {
    switch (s.tag) {
      case 0:
      case 11:
      case 15:
        li(s), s.flags & 2048 && us(9, s, s.return);
        break;
      case 3:
        li(s);
        break;
      case 12:
        li(s);
        break;
      case 22:
        var o = s.stateNode;
        s.memoizedState !== null &&
        o._visibility & 2 &&
        (s.return === null || s.return.tag !== 13)
          ? ((o._visibility &= -3), Ar(s))
          : li(s);
        break;
      default:
        li(s);
    }
  }
  function Ar(s) {
    var o = s.deletions;
    if ((s.flags & 16) !== 0) {
      if (o !== null)
        for (var d = 0; d < o.length; d++) {
          var g = o[d];
          (ei = g), Sr(g, s);
        }
      ov(s);
    }
    for (s = s.child; s !== null; ) {
      switch (((o = s), o.tag)) {
        case 0:
        case 11:
        case 15:
          us(8, o, o.return), Ar(o);
          break;
        case 22:
          (d = o.stateNode),
            d._visibility & 2 && ((d._visibility &= -3), Ar(o));
          break;
        default:
          Ar(o);
      }
      s = s.sibling;
    }
  }
  function Sr(s, o) {
    for (; ei !== null; ) {
      var d = ei;
      switch (d.tag) {
        case 0:
        case 11:
        case 15:
          us(8, d, o);
          break;
        case 23:
        case 22:
          if (d.memoizedState !== null && d.memoizedState.cachePool !== null) {
            var g = d.memoizedState.cachePool.pool;
            g != null && g.refCount++;
          }
          break;
        case 24:
          _c(d.memoizedState.cache);
      }
      if (((g = d.child), g !== null)) (g.return = d), (ei = g);
      else
        t: for (d = s; ei !== null; ) {
          g = ei;
          var b = g.sibling,
            T = g.return;
          if ((_n(g), g === d)) {
            ei = null;
            break t;
          }
          if (b !== null) {
            (b.return = T), (ei = b);
            break t;
          }
          ei = T;
        }
    }
  }
  var Ai = {
      getCacheForType: function (s) {
        var o = _i(zi),
          d = o.data.get(s);
        return d === void 0 && ((d = s()), o.data.set(s, d)), d;
      },
    },
    fm = typeof WeakMap == "function" ? WeakMap : Map,
    jn = 0,
    cn = null,
    En = null,
    We = 0,
    vn = 0,
    gi = null,
    ps = !1,
    Fc = !1,
    Hc = !1,
    Is = 0,
    hi = 0,
    ir = 0,
    Mr = 0,
    Ll = 0,
    Ps = 0,
    Ln = 0,
    Xn = null,
    Ze = null,
    wn = !1,
    Jn = 0,
    ba = 1 / 0,
    zs = null,
    ms = null,
    Wi = 0,
    Aa = null,
    ii = null,
    gs = 0,
    co = 0,
    ff = null,
    vs = null,
    Er = 0,
    Il = null;
  function Si() {
    if ((jn & 2) !== 0 && We !== 0) return We & -We;
    if (j.T !== null) {
      var s = fn;
      return s !== 0 ? s : B1();
    }
    return ln();
  }
  function td() {
    Ps === 0 && (Ps = (We & 536870912) === 0 || Pn ? st() : 536870912);
    var s = ti.current;
    return s !== null && (s.flags |= 32), Ps;
  }
  function Ia(s, o, d) {
    ((s === cn && (vn === 2 || vn === 9)) || s.cancelPendingCommit !== null) &&
      (tl(s, 0), ar(s, We, Ps, !1)),
      ge(s, d),
      ((jn & 2) === 0 || s !== cn) &&
        (s === cn &&
          ((jn & 2) === 0 && (Mr |= d), hi === 4 && ar(s, We, Ps, !1)),
        il(s));
  }
  function Gc(s, o, d) {
    if ((jn & 6) !== 0) throw Error(n(327));
    var g = (!d && (o & 124) === 0 && (o & s.expiredLanes) === 0) || yt(s, o),
      b = g ? A(s, o) : f(s, o, !0),
      T = g;
    do {
      if (b === 0) {
        Fc && !g && ar(s, o, 0, !1);
        break;
      } else {
        if (((d = s.current.alternate), T && !$o(d))) {
          (b = f(s, o, !1)), (T = !1);
          continue;
        }
        if (b === 2) {
          if (((T = o), s.errorRecoveryDisabledLanes & T)) var z = 0;
          else
            (z = s.pendingLanes & -536870913),
              (z = z !== 0 ? z : z & 536870912 ? 536870912 : 0);
          if (z !== 0) {
            o = z;
            t: {
              var W = s;
              b = Xn;
              var at = W.current.memoizedState.isDehydrated;
              if ((at && (tl(W, z).flags |= 256), (z = f(W, z, !1)), z !== 2)) {
                if (Hc && !at) {
                  (W.errorRecoveryDisabledLanes |= T), (Mr |= T), (b = 4);
                  break t;
                }
                (T = Ze),
                  (Ze = b),
                  T !== null && (Ze === null ? (Ze = T) : Ze.push.apply(Ze, T));
              }
              b = z;
            }
            if (((T = !1), b !== 2)) continue;
          }
        }
        if (b === 1) {
          tl(s, 0), ar(s, o, 0, !0);
          break;
        }
        t: {
          switch (((g = s), (T = b), T)) {
            case 0:
            case 1:
              throw Error(n(345));
            case 4:
              if ((o & 4194048) !== o) break;
            case 6:
              ar(g, o, Ps, !ps);
              break t;
            case 2:
              Ze = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(n(329));
          }
          if ((o & 62914560) === o && ((b = Jn + 300 - $t()), 10 < b)) {
            if ((ar(g, o, Ps, !ps), it(g, 0, !0) !== 0)) break t;
            g.timeoutHandle = DM(
              hf.bind(null, g, d, Ze, zs, wn, o, Ps, Mr, Ln, ps, T, 2, -0, 0),
              b
            );
            break t;
          }
          hf(g, d, Ze, zs, wn, o, Ps, Mr, Ln, ps, T, 0, -0, 0);
        }
      }
      break;
    } while (!0);
    il(s);
  }
  function hf(s, o, d, g, b, T, z, W, at, Ct, Wt, ne, Ot, Nt) {
    if (
      ((s.timeoutHandle = -1),
      (ne = o.subtreeFlags),
      (ne & 8192 || (ne & 16785408) === 16785408) &&
        ((ym = { stylesheets: null, count: 0, unsuspend: ND }),
        rv(o),
        (ne = ID()),
        ne !== null))
    ) {
      (s.cancelPendingCommit = ne(
        he.bind(null, s, o, T, d, g, b, z, W, at, Wt, 1, Ot, Nt)
      )),
        ar(s, T, z, !Ct);
      return;
    }
    he(s, o, T, d, g, b, z, W, at);
  }
  function $o(s) {
    for (var o = s; ; ) {
      var d = o.tag;
      if (
        (d === 0 || d === 11 || d === 15) &&
        o.flags & 16384 &&
        ((d = o.updateQueue), d !== null && ((d = d.stores), d !== null))
      )
        for (var g = 0; g < d.length; g++) {
          var b = d[g],
            T = b.getSnapshot;
          b = b.value;
          try {
            if (!Xa(T(), b)) return !1;
          } catch {
            return !1;
          }
        }
      if (((d = o.child), o.subtreeFlags & 16384 && d !== null))
        (d.return = o), (o = d);
      else {
        if (o === s) break;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === s) return !0;
          o = o.return;
        }
        (o.sibling.return = o.return), (o = o.sibling);
      }
    }
    return !0;
  }
  function ar(s, o, d, g) {
    (o &= ~Ll),
      (o &= ~Mr),
      (s.suspendedLanes |= o),
      (s.pingedLanes &= ~o),
      g && (s.warmLanes |= o),
      (g = s.expirationTimes);
    for (var b = o; 0 < b; ) {
      var T = 31 - me(b),
        z = 1 << T;
      (g[T] = -1), (b &= ~z);
    }
    d !== 0 && Kt(s, d, o);
  }
  function Tr() {
    return (jn & 6) === 0 ? (hm(0), !1) : !0;
  }
  function Pl() {
    if (En !== null) {
      if (vn === 0) var s = En.return;
      else (s = En), (Zr = Po = null), Yp(s), (bl = null), (af = 0), (s = En);
      for (; s !== null; ) Lc(s.alternate, s), (s = s.return);
      En = null;
    }
  }
  function tl(s, o) {
    var d = s.timeoutHandle;
    d !== -1 && ((s.timeoutHandle = -1), vD(d)),
      (d = s.cancelPendingCommit),
      d !== null && ((s.cancelPendingCommit = null), d()),
      Pl(),
      (cn = s),
      (En = d = Bi(s.current, null)),
      (We = o),
      (vn = 0),
      (gi = null),
      (ps = !1),
      (Fc = yt(s, o)),
      (Hc = !1),
      (Ln = Ps = Ll = Mr = ir = hi = 0),
      (Ze = Xn = null),
      (wn = !1),
      (o & 8) !== 0 && (o |= o & 32);
    var g = s.entangledLanes;
    if (g !== 0)
      for (s = s.entanglements, g &= o; 0 < g; ) {
        var b = 31 - me(g),
          T = 1 << b;
        (o |= s[b]), (g &= ~T);
      }
    return (Is = o), Hu(), d;
  }
  function ed(s, o) {
    (hn = null),
      (j.H = nf),
      o === Ju || o === Ks
        ? ((o = Vp()), (vn = 3))
        : o === Gp
        ? ((o = Vp()), (vn = 4))
        : (vn =
            o === sv
              ? 8
              : o !== null &&
                typeof o == "object" &&
                typeof o.then == "function"
              ? 6
              : 1),
      (gi = o),
      En === null && ((hi = 1), Wh(s, ca(o, s.current)));
  }
  function Vc() {
    var s = j.H;
    return (j.H = nf), s === null ? nf : s;
  }
  function nd() {
    var s = j.A;
    return (j.A = Ai), s;
  }
  function c() {
    (hi = 4),
      ps || ((We & 4194048) !== We && ti.current !== null) || (Fc = !0),
      ((ir & 134217727) === 0 && (Mr & 134217727) === 0) ||
        cn === null ||
        ar(cn, We, Ps, !1);
  }
  function f(s, o, d) {
    var g = jn;
    jn |= 2;
    var b = Vc(),
      T = nd();
    (cn !== s || We !== o) && ((zs = null), tl(s, o)), (o = !1);
    var z = hi;
    t: do
      try {
        if (vn !== 0 && En !== null) {
          var W = En,
            at = gi;
          switch (vn) {
            case 8:
              Pl(), (z = 6);
              break t;
            case 3:
            case 2:
            case 9:
            case 6:
              ti.current === null && (o = !0);
              var Ct = vn;
              if (((vn = 0), (gi = null), lt(s, W, at, Ct), d && Fc)) {
                z = 0;
                break t;
              }
              break;
            default:
              (Ct = vn), (vn = 0), (gi = null), lt(s, W, at, Ct);
          }
        }
        y(), (z = hi);
        break;
      } catch (Wt) {
        ed(s, Wt);
      }
    while (!0);
    return (
      o && s.shellSuspendCounter++,
      (Zr = Po = null),
      (jn = g),
      (j.H = b),
      (j.A = T),
      En === null && ((cn = null), (We = 0), Hu()),
      z
    );
  }
  function y() {
    for (; En !== null; ) U(En);
  }
  function A(s, o) {
    var d = jn;
    jn |= 2;
    var g = Vc(),
      b = nd();
    cn !== s || We !== o
      ? ((zs = null), (ba = $t() + 500), tl(s, o))
      : (Fc = yt(s, o));
    t: do
      try {
        if (vn !== 0 && En !== null) {
          o = En;
          var T = gi;
          e: switch (vn) {
            case 1:
              (vn = 0), (gi = null), lt(s, o, T, 1);
              break;
            case 2:
            case 9:
              if (Dh(T)) {
                (vn = 0), (gi = null), q(o);
                break;
              }
              (o = function () {
                (vn !== 2 && vn !== 9) || cn !== s || (vn = 7), il(s);
              }),
                T.then(o, o);
              break t;
            case 3:
              vn = 7;
              break t;
            case 4:
              vn = 5;
              break t;
            case 7:
              Dh(T)
                ? ((vn = 0), (gi = null), q(o))
                : ((vn = 0), (gi = null), lt(s, o, T, 7));
              break;
            case 5:
              var z = null;
              switch (En.tag) {
                case 26:
                  z = En.memoizedState;
                case 5:
                case 27:
                  var W = En;
                  if (!z || kM(z)) {
                    (vn = 0), (gi = null);
                    var at = W.sibling;
                    if (at !== null) En = at;
                    else {
                      var Ct = W.return;
                      Ct !== null ? ((En = Ct), St(Ct)) : (En = null);
                    }
                    break e;
                  }
              }
              (vn = 0), (gi = null), lt(s, o, T, 5);
              break;
            case 6:
              (vn = 0), (gi = null), lt(s, o, T, 6);
              break;
            case 8:
              Pl(), (hi = 6);
              break t;
            default:
              throw Error(n(462));
          }
        }
        w();
        break;
      } catch (Wt) {
        ed(s, Wt);
      }
    while (!0);
    return (
      (Zr = Po = null),
      (j.H = g),
      (j.A = b),
      (jn = d),
      En !== null ? 0 : ((cn = null), (We = 0), Hu(), hi)
    );
  }
  function w() {
    for (; En !== null && !le(); ) U(En);
  }
  function U(s) {
    var o = Cl(s.alternate, s, Is);
    (s.memoizedProps = s.pendingProps), o === null ? St(s) : (En = o);
  }
  function q(s) {
    var o = s,
      d = o.alternate;
    switch (o.tag) {
      case 15:
      case 0:
        o = ls(d, o, o.pendingProps, o.type, void 0, We);
        break;
      case 11:
        o = ls(d, o, o.pendingProps, o.type.render, o.ref, We);
        break;
      case 5:
        Yp(o);
      default:
        Lc(d, o), (o = En = Np(o, Is)), (o = Cl(d, o, Is));
    }
    (s.memoizedProps = s.pendingProps), o === null ? St(s) : (En = o);
  }
  function lt(s, o, d, g) {
    (Zr = Po = null), Yp(o), (bl = null), (af = 0);
    var b = o.return;
    try {
      if (C1(s, b, o, d, We)) {
        (hi = 1), Wh(s, ca(d, s.current)), (En = null);
        return;
      }
    } catch (T) {
      if (b !== null) throw ((En = b), T);
      (hi = 1), Wh(s, ca(d, s.current)), (En = null);
      return;
    }
    o.flags & 32768
      ? (Pn || g === 1
          ? (s = !0)
          : Fc || (We & 536870912) !== 0
          ? (s = !1)
          : ((ps = s = !0),
            (g === 2 || g === 9 || g === 3 || g === 6) &&
              ((g = ti.current),
              g !== null && g.tag === 13 && (g.flags |= 16384))),
        Xt(o, s))
      : St(o);
  }
  function St(s) {
    var o = s;
    do {
      if ((o.flags & 32768) !== 0) {
        Xt(o, ps);
        return;
      }
      s = o.return;
      var d = cm(o.alternate, o, Is);
      if (d !== null) {
        En = d;
        return;
      }
      if (((o = o.sibling), o !== null)) {
        En = o;
        return;
      }
      En = o = s;
    } while (o !== null);
    hi === 0 && (hi = 5);
  }
  function Xt(s, o) {
    do {
      var d = Nc(s.alternate, s);
      if (d !== null) {
        (d.flags &= 32767), (En = d);
        return;
      }
      if (
        ((d = s.return),
        d !== null &&
          ((d.flags |= 32768), (d.subtreeFlags = 0), (d.deletions = null)),
        !o && ((s = s.sibling), s !== null))
      ) {
        En = s;
        return;
      }
      En = s = d;
    } while (s !== null);
    (hi = 6), (En = null);
  }
  function he(s, o, d, g, b, T, z, W, at) {
    s.cancelPendingCommit = null;
    do el();
    while (Wi !== 0);
    if ((jn & 6) !== 0) throw Error(n(327));
    if (o !== null) {
      if (o === s.current) throw Error(n(177));
      if (
        ((T = o.lanes | o.childLanes),
        (T |= Ah),
        oe(s, d, T, z, W, at),
        s === cn && ((En = cn = null), (We = 0)),
        (ii = o),
        (Aa = s),
        (gs = d),
        (co = T),
        (ff = b),
        (vs = g),
        (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0
          ? ((s.callbackNode = null),
            (s.callbackPriority = 0),
            zn(pe, function () {
              return nl(), null;
            }))
          : ((s.callbackNode = null), (s.callbackPriority = 0)),
        (g = (o.flags & 13878) !== 0),
        (o.subtreeFlags & 13878) !== 0 || g)
      ) {
        (g = j.T), (j.T = null), (b = Q.p), (Q.p = 2), (z = jn), (jn |= 4);
        try {
          Xi(s, o, d);
        } finally {
          (jn = z), (Q.p = b), (j.T = g);
        }
      }
      (Wi = 1), Me(), Te(), un();
    }
  }
  function Me() {
    if (Wi === 1) {
      Wi = 0;
      var s = Aa,
        o = ii,
        d = (o.flags & 13878) !== 0;
      if ((o.subtreeFlags & 13878) !== 0 || d) {
        (d = j.T), (j.T = null);
        var g = Q.p;
        Q.p = 2;
        var b = jn;
        jn |= 4;
        try {
          Jh(o, s);
          var T = z1,
            z = wp(s.containerInfo),
            W = T.focusedElem,
            at = T.selectionRange;
          if (
            z !== W &&
            W &&
            W.ownerDocument &&
            Tp(W.ownerDocument.documentElement, W)
          ) {
            if (at !== null && Pu(W)) {
              var Ct = at.start,
                Wt = at.end;
              if ((Wt === void 0 && (Wt = Ct), "selectionStart" in W))
                (W.selectionStart = Ct),
                  (W.selectionEnd = Math.min(Wt, W.value.length));
              else {
                var ne = W.ownerDocument || document,
                  Ot = (ne && ne.defaultView) || window;
                if (Ot.getSelection) {
                  var Nt = Ot.getSelection(),
                    sn = W.textContent.length,
                    $e = Math.min(at.start, sn),
                    ui = at.end === void 0 ? $e : Math.min(at.end, sn);
                  !Nt.extend && $e > ui && ((z = ui), (ui = $e), ($e = z));
                  var _t = Ep(W, $e),
                    vt = Ep(W, ui);
                  if (
                    _t &&
                    vt &&
                    (Nt.rangeCount !== 1 ||
                      Nt.anchorNode !== _t.node ||
                      Nt.anchorOffset !== _t.offset ||
                      Nt.focusNode !== vt.node ||
                      Nt.focusOffset !== vt.offset)
                  ) {
                    var Tt = ne.createRange();
                    Tt.setStart(_t.node, _t.offset),
                      Nt.removeAllRanges(),
                      $e > ui
                        ? (Nt.addRange(Tt), Nt.extend(vt.node, vt.offset))
                        : (Tt.setEnd(vt.node, vt.offset), Nt.addRange(Tt));
                  }
                }
              }
            }
            for (ne = [], Nt = W; (Nt = Nt.parentNode); )
              Nt.nodeType === 1 &&
                ne.push({
                  element: Nt,
                  left: Nt.scrollLeft,
                  top: Nt.scrollTop,
                });
            for (
              typeof W.focus == "function" && W.focus(), W = 0;
              W < ne.length;
              W++
            ) {
              var Zt = ne[W];
              (Zt.element.scrollLeft = Zt.left),
                (Zt.element.scrollTop = Zt.top);
            }
          }
          (vv = !!P1), (z1 = P1 = null);
        } finally {
          (jn = b), (Q.p = g), (j.T = d);
        }
      }
      (s.current = o), (Wi = 2);
    }
  }
  function Te() {
    if (Wi === 2) {
      Wi = 0;
      var s = Aa,
        o = ii,
        d = (o.flags & 8772) !== 0;
      if ((o.subtreeFlags & 8772) !== 0 || d) {
        (d = j.T), (j.T = null);
        var g = Q.p;
        Q.p = 2;
        var b = jn;
        jn |= 4;
        try {
          oo(s, o.alternate, o);
        } finally {
          (jn = b), (Q.p = g), (j.T = d);
        }
      }
      Wi = 3;
    }
  }
  function un() {
    if (Wi === 4 || Wi === 3) {
      (Wi = 0), se();
      var s = Aa,
        o = ii,
        d = gs,
        g = vs;
      (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0
        ? (Wi = 5)
        : ((Wi = 0), (ii = Aa = null), ys(s, s.pendingLanes));
      var b = s.pendingLanes;
      if (
        (b === 0 && (ms = null),
        mn(d),
        (o = o.stateNode),
        Gt && typeof Gt.onCommitFiberRoot == "function")
      )
        try {
          Gt.onCommitFiberRoot(Ft, o, void 0, (o.current.flags & 128) === 128);
        } catch {}
      if (g !== null) {
        (o = j.T), (b = Q.p), (Q.p = 2), (j.T = null);
        try {
          for (var T = s.onRecoverableError, z = 0; z < g.length; z++) {
            var W = g[z];
            T(W.value, { componentStack: W.stack });
          }
        } finally {
          (j.T = o), (Q.p = b);
        }
      }
      (gs & 3) !== 0 && el(),
        il(s),
        (b = s.pendingLanes),
        (d & 4194090) !== 0 && (b & 42) !== 0
          ? s === Il
            ? Er++
            : ((Er = 0), (Il = s))
          : (Er = 0),
        hm(0);
    }
  }
  function ys(s, o) {
    (s.pooledCacheLanes &= o) === 0 &&
      ((o = s.pooledCache), o != null && ((s.pooledCache = null), _c(o)));
  }
  function el(s) {
    return Me(), Te(), un(), nl();
  }
  function nl() {
    if (Wi !== 5) return !1;
    var s = Aa,
      o = co;
    co = 0;
    var d = mn(gs),
      g = j.T,
      b = Q.p;
    try {
      (Q.p = 32 > d ? 32 : d), (j.T = null), (d = ff), (ff = null);
      var T = Aa,
        z = gs;
      if (((Wi = 0), (ii = Aa = null), (gs = 0), (jn & 6) !== 0))
        throw Error(n(331));
      var W = jn;
      if (
        ((jn |= 4),
        um(T.current),
        $h(T, T.current, z, d),
        (jn = W),
        hm(0, !1),
        Gt && typeof Gt.onPostCommitFiberRoot == "function")
      )
        try {
          Gt.onPostCommitFiberRoot(Ft, T);
        } catch {}
      return !0;
    } finally {
      (Q.p = b), (j.T = g), ys(s, o);
    }
  }
  function Dt(s, o, d) {
    (o = ca(d, o)),
      (o = Yh(s.stateNode, o, 2)),
      (s = to(s, o, 2)),
      s !== null && (ge(s, 2), il(s));
  }
  function mt(s, o, d) {
    if (s.tag === 3) Dt(s, s, d);
    else
      for (; o !== null; ) {
        if (o.tag === 3) {
          Dt(o, s, d);
          break;
        } else if (o.tag === 1) {
          var g = o.stateNode;
          if (
            typeof o.type.getDerivedStateFromError == "function" ||
            (typeof g.componentDidCatch == "function" &&
              (ms === null || !ms.has(g)))
          ) {
            (s = ca(d, s)),
              (d = av(2)),
              (g = to(o, d, 2)),
              g !== null && (qh(d, g, o, s), ge(g, 2), il(g));
            break;
          }
        }
        o = o.return;
      }
  }
  function Lt(s, o, d) {
    var g = s.pingCache;
    if (g === null) {
      g = s.pingCache = new fm();
      var b = new Set();
      g.set(o, b);
    } else (b = g.get(o)), b === void 0 && ((b = new Set()), g.set(o, b));
    b.has(d) ||
      ((Hc = !0), b.add(d), (s = fe.bind(null, s, o, d)), o.then(s, s));
  }
  function fe(s, o, d) {
    var g = s.pingCache;
    g !== null && g.delete(o),
      (s.pingedLanes |= s.suspendedLanes & d),
      (s.warmLanes &= ~d),
      cn === s &&
        (We & d) === d &&
        (hi === 4 || (hi === 3 && (We & 62914560) === We && 300 > $t() - Jn)
          ? (jn & 2) === 0 && tl(s, 0)
          : (Ll |= d),
        Ln === We && (Ln = 0)),
      il(s);
  }
  function Ge(s, o) {
    o === 0 && (o = Et()), (s = Kr(s, o)), s !== null && (ge(s, o), il(s));
  }
  function di(s) {
    var o = s.memoizedState,
      d = 0;
    o !== null && (d = o.retryLane), Ge(s, d);
  }
  function an(s, o) {
    var d = 0;
    switch (s.tag) {
      case 13:
        var g = s.stateNode,
          b = s.memoizedState;
        b !== null && (d = b.retryLane);
        break;
      case 19:
        g = s.stateNode;
        break;
      case 22:
        g = s.stateNode._retryCache;
        break;
      default:
        throw Error(n(314));
    }
    g !== null && g.delete(o), Ge(s, d);
  }
  function zn(s, o) {
    return Ue(s, o);
  }
  var Ni = null,
    Tn = null,
    wr = !1,
    id = !1,
    R1 = !1,
    df = 0;
  function il(s) {
    s !== Tn &&
      s.next === null &&
      (Tn === null ? (Ni = Tn = s) : (Tn = Tn.next = s)),
      (id = !0),
      wr || ((wr = !0), lD());
  }
  function hm(s, o) {
    if (!R1 && id) {
      R1 = !0;
      do
        for (var d = !1, g = Ni; g !== null; ) {
          if (s !== 0) {
            var b = g.pendingLanes;
            if (b === 0) var T = 0;
            else {
              var z = g.suspendedLanes,
                W = g.pingedLanes;
              (T = (1 << (31 - me(42 | s) + 1)) - 1),
                (T &= b & ~(z & ~W)),
                (T = T & 201326741 ? (T & 201326741) | 1 : T ? T | 2 : 0);
            }
            T !== 0 && ((d = !0), bM(g, T));
          } else
            (T = We),
              (T = it(
                g,
                g === cn ? T : 0,
                g.cancelPendingCommit !== null || g.timeoutHandle !== -1
              )),
              (T & 3) === 0 || yt(g, T) || ((d = !0), bM(g, T));
          g = g.next;
        }
      while (d);
      R1 = !1;
    }
  }
  function oD() {
    yM();
  }
  function yM() {
    id = wr = !1;
    var s = 0;
    df !== 0 && (gD() && (s = df), (df = 0));
    for (var o = $t(), d = null, g = Ni; g !== null; ) {
      var b = g.next,
        T = xM(g, o);
      T === 0
        ? ((g.next = null),
          d === null ? (Ni = b) : (d.next = b),
          b === null && (Tn = d))
        : ((d = g), (s !== 0 || (T & 3) !== 0) && (id = !0)),
        (g = b);
    }
    hm(s);
  }
  function xM(s, o) {
    for (
      var d = s.suspendedLanes,
        g = s.pingedLanes,
        b = s.expirationTimes,
        T = s.pendingLanes & -62914561;
      0 < T;

    ) {
      var z = 31 - me(T),
        W = 1 << z,
        at = b[z];
      at === -1
        ? ((W & d) === 0 || (W & g) !== 0) && (b[z] = Qt(W, o))
        : at <= o && (s.expiredLanes |= W),
        (T &= ~W);
    }
    if (
      ((o = cn),
      (d = We),
      (d = it(
        s,
        s === o ? d : 0,
        s.cancelPendingCommit !== null || s.timeoutHandle !== -1
      )),
      (g = s.callbackNode),
      d === 0 ||
        (s === o && (vn === 2 || vn === 9)) ||
        s.cancelPendingCommit !== null)
    )
      return (
        g !== null && g !== null && J(g),
        (s.callbackNode = null),
        (s.callbackPriority = 0)
      );
    if ((d & 3) === 0 || yt(s, d)) {
      if (((o = d & -d), o === s.callbackPriority)) return o;
      switch ((g !== null && J(g), mn(d))) {
        case 2:
        case 8:
          d = te;
          break;
        case 32:
          d = pe;
          break;
        case 268435456:
          d = $;
          break;
        default:
          d = pe;
      }
      return (
        (g = _M.bind(null, s)),
        (d = Ue(d, g)),
        (s.callbackPriority = o),
        (s.callbackNode = d),
        o
      );
    }
    return (
      g !== null && g !== null && J(g),
      (s.callbackPriority = 2),
      (s.callbackNode = null),
      2
    );
  }
  function _M(s, o) {
    if (Wi !== 0 && Wi !== 5)
      return (s.callbackNode = null), (s.callbackPriority = 0), null;
    var d = s.callbackNode;
    if (el() && s.callbackNode !== d) return null;
    var g = We;
    return (
      (g = it(
        s,
        s === cn ? g : 0,
        s.cancelPendingCommit !== null || s.timeoutHandle !== -1
      )),
      g === 0
        ? null
        : (Gc(s, g, o),
          xM(s, $t()),
          s.callbackNode != null && s.callbackNode === d
            ? _M.bind(null, s)
            : null)
    );
  }
  function bM(s, o) {
    if (el()) return null;
    Gc(s, o, !0);
  }
  function lD() {
    yD(function () {
      (jn & 6) !== 0 ? Ue(ye, oD) : yM();
    });
  }
  function B1() {
    return df === 0 && (df = st()), df;
  }
  function AM(s) {
    return s == null || typeof s == "symbol" || typeof s == "boolean"
      ? null
      : typeof s == "function"
      ? s
      : Mu("" + s);
  }
  function SM(s, o) {
    var d = o.ownerDocument.createElement("input");
    return (
      (d.name = o.name),
      (d.value = o.value),
      s.id && d.setAttribute("form", s.id),
      o.parentNode.insertBefore(d, o),
      (s = new FormData(s)),
      d.parentNode.removeChild(d),
      s
    );
  }
  function cD(s, o, d, g, b) {
    if (o === "submit" && d && d.stateNode === b) {
      var T = AM((b[Ci] || null).action),
        z = g.submitter;
      z &&
        ((o = (o = z[Ci] || null)
          ? AM(o.formAction)
          : z.getAttribute("formAction")),
        o !== null && ((T = o), (z = null)));
      var W = new oc("action", "action", null, g, b);
      s.push({
        event: W,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (g.defaultPrevented) {
                if (df !== 0) {
                  var at = z ? SM(b, z) : new FormData(b);
                  sm(
                    d,
                    { pending: !0, data: at, method: b.method, action: T },
                    null,
                    at
                  );
                }
              } else
                typeof T == "function" &&
                  (W.preventDefault(),
                  (at = z ? SM(b, z) : new FormData(b)),
                  sm(
                    d,
                    { pending: !0, data: at, method: b.method, action: T },
                    T,
                    at
                  ));
            },
            currentTarget: b,
          },
        ],
      });
    }
  }
  for (var D1 = 0; D1 < Fu.length; D1++) {
    var U1 = Fu[D1],
      uD = U1.toLowerCase(),
      fD = U1[0].toUpperCase() + U1.slice(1);
    Qi(uD, "on" + fD);
  }
  Qi(Ba, "onAnimationEnd"),
    Qi(Bp, "onAnimationIteration"),
    Qi(Ya, "onAnimationStart"),
    Qi("dblclick", "onDoubleClick"),
    Qi("focusin", "onFocus"),
    Qi("focusout", "onBlur"),
    Qi(gg, "onTransitionRun"),
    Qi(Yr, "onTransitionStart"),
    Qi(mc, "onTransitionCancel"),
    Qi(qr, "onTransitionEnd"),
    H("onMouseEnter", ["mouseout", "mouseover"]),
    H("onMouseLeave", ["mouseout", "mouseover"]),
    H("onPointerEnter", ["pointerout", "pointerover"]),
    H("onPointerLeave", ["pointerout", "pointerover"]),
    ae(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    ae(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    ae("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    ae(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    ae(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    ae(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var dm =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    hD = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle"
        .split(" ")
        .concat(dm)
    );
  function MM(s, o) {
    o = (o & 4) !== 0;
    for (var d = 0; d < s.length; d++) {
      var g = s[d],
        b = g.event;
      g = g.listeners;
      t: {
        var T = void 0;
        if (o)
          for (var z = g.length - 1; 0 <= z; z--) {
            var W = g[z],
              at = W.instance,
              Ct = W.currentTarget;
            if (((W = W.listener), at !== T && b.isPropagationStopped()))
              break t;
            (T = W), (b.currentTarget = Ct);
            try {
              T(b);
            } catch (Wt) {
              Sl(Wt);
            }
            (b.currentTarget = null), (T = at);
          }
        else
          for (z = 0; z < g.length; z++) {
            if (
              ((W = g[z]),
              (at = W.instance),
              (Ct = W.currentTarget),
              (W = W.listener),
              at !== T && b.isPropagationStopped())
            )
              break t;
            (T = W), (b.currentTarget = Ct);
            try {
              T(b);
            } catch (Wt) {
              Sl(Wt);
            }
            (b.currentTarget = null), (T = at);
          }
      }
    }
  }
  function Rn(s, o) {
    var d = o[ya];
    d === void 0 && (d = o[ya] = new Set());
    var g = s + "__bubble";
    d.has(g) || (EM(o, s, 2, !1), d.add(g));
  }
  function O1(s, o, d) {
    var g = 0;
    o && (g |= 4), EM(d, s, g, o);
  }
  var lv = "_reactListening" + Math.random().toString(36).slice(2);
  function N1(s) {
    if (!s[lv]) {
      (s[lv] = !0),
        Ht.forEach(function (d) {
          d !== "selectionchange" && (hD.has(d) || O1(d, !1, s), O1(d, !0, s));
        });
      var o = s.nodeType === 9 ? s : s.ownerDocument;
      o === null || o[lv] || ((o[lv] = !0), O1("selectionchange", !1, o));
    }
  }
  function EM(s, o, d, g) {
    switch (KM(o)) {
      case 2:
        var b = FD;
        break;
      case 8:
        b = HD;
        break;
      default:
        b = q1;
    }
    (d = b.bind(null, o, d, s)),
      (b = void 0),
      !Tu ||
        (o !== "touchstart" && o !== "touchmove" && o !== "wheel") ||
        (b = !0),
      g
        ? b !== void 0
          ? s.addEventListener(o, d, { capture: !0, passive: b })
          : s.addEventListener(o, d, !0)
        : b !== void 0
        ? s.addEventListener(o, d, { passive: b })
        : s.addEventListener(o, d, !1);
  }
  function L1(s, o, d, g, b) {
    var T = g;
    if ((o & 1) === 0 && (o & 2) === 0 && g !== null)
      t: for (;;) {
        if (g === null) return;
        var z = g.tag;
        if (z === 3 || z === 4) {
          var W = g.stateNode.containerInfo;
          if (W === b) break;
          if (z === 4)
            for (z = g.return; z !== null; ) {
              var at = z.tag;
              if ((at === 3 || at === 4) && z.stateNode.containerInfo === b)
                return;
              z = z.return;
            }
          for (; W !== null; ) {
            if (((z = G(W)), z === null)) return;
            if (
              ((at = z.tag), at === 5 || at === 6 || at === 26 || at === 27)
            ) {
              g = T = z;
              continue t;
            }
            W = W.parentNode;
          }
        }
        g = g.return;
      }
    dp(function () {
      var Ct = T,
        Wt = ch(d),
        ne = [];
      t: {
        var Ot = bh.get(s);
        if (Ot !== void 0) {
          var Nt = oc,
            sn = s;
          switch (s) {
            case "keypress":
              if (Eo(d) === 0) break t;
            case "keydown":
            case "keyup":
              Nt = yp;
              break;
            case "focusin":
              (sn = "focus"), (Nt = fh);
              break;
            case "focusout":
              (sn = "blur"), (Nt = fh);
              break;
            case "beforeblur":
            case "afterblur":
              Nt = fh;
              break;
            case "click":
              if (d.button === 2) break t;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Nt = gp;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Nt = v1;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Nt = _p;
              break;
            case Ba:
            case Bp:
            case Ya:
              Nt = eg;
              break;
            case qr:
              Nt = kr;
              break;
            case "scroll":
            case "scrollend":
              Nt = Q0;
              break;
            case "wheel":
              Nt = y1;
              break;
            case "copy":
            case "cut":
            case "paste":
              Nt = ig;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Nt = dh;
              break;
            case "toggle":
            case "beforetoggle":
              Nt = wo;
          }
          var $e = (o & 4) !== 0,
            ui = !$e && (s === "scroll" || s === "scrollend"),
            _t = $e ? (Ot !== null ? Ot + "Capture" : null) : Ot;
          $e = [];
          for (var vt = Ct, Tt; vt !== null; ) {
            var Zt = vt;
            if (
              ((Tt = Zt.stateNode),
              (Zt = Zt.tag),
              (Zt !== 5 && Zt !== 26 && Zt !== 27) ||
                Tt === null ||
                _t === null ||
                ((Zt = ac(vt, _t)), Zt != null && $e.push(pm(vt, Zt, Tt))),
              ui)
            )
              break;
            vt = vt.return;
          }
          0 < $e.length &&
            ((Ot = new Nt(Ot, sn, null, d, Wt)),
            ne.push({ event: Ot, listeners: $e }));
        }
      }
      if ((o & 7) === 0) {
        t: {
          if (
            ((Ot = s === "mouseover" || s === "pointerover"),
            (Nt = s === "mouseout" || s === "pointerout"),
            Ot &&
              d !== lh &&
              (sn = d.relatedTarget || d.fromElement) &&
              (G(sn) || sn[Ri]))
          )
            break t;
          if (
            (Nt || Ot) &&
            ((Ot =
              Wt.window === Wt
                ? Wt
                : (Ot = Wt.ownerDocument)
                ? Ot.defaultView || Ot.parentWindow
                : window),
            Nt
              ? ((sn = d.relatedTarget || d.toElement),
                (Nt = Ct),
                (sn = sn ? G(sn) : null),
                sn !== null &&
                  ((ui = r(sn)),
                  ($e = sn.tag),
                  sn !== ui || ($e !== 5 && $e !== 27 && $e !== 6)) &&
                  (sn = null))
              : ((Nt = null), (sn = Ct)),
            Nt !== sn)
          ) {
            if (
              (($e = gp),
              (Zt = "onMouseLeave"),
              (_t = "onMouseEnter"),
              (vt = "mouse"),
              (s === "pointerout" || s === "pointerover") &&
                (($e = dh),
                (Zt = "onPointerLeave"),
                (_t = "onPointerEnter"),
                (vt = "pointer")),
              (ui = Nt == null ? Ot : ut(Nt)),
              (Tt = sn == null ? Ot : ut(sn)),
              (Ot = new $e(Zt, vt + "leave", Nt, d, Wt)),
              (Ot.target = ui),
              (Ot.relatedTarget = Tt),
              (Zt = null),
              G(Wt) === Ct &&
                (($e = new $e(_t, vt + "enter", sn, d, Wt)),
                ($e.target = Tt),
                ($e.relatedTarget = ui),
                (Zt = $e)),
              (ui = Zt),
              Nt && sn)
            )
              e: {
                for ($e = Nt, _t = sn, vt = 0, Tt = $e; Tt; Tt = ad(Tt)) vt++;
                for (Tt = 0, Zt = _t; Zt; Zt = ad(Zt)) Tt++;
                for (; 0 < vt - Tt; ) ($e = ad($e)), vt--;
                for (; 0 < Tt - vt; ) (_t = ad(_t)), Tt--;
                for (; vt--; ) {
                  if ($e === _t || (_t !== null && $e === _t.alternate))
                    break e;
                  ($e = ad($e)), (_t = ad(_t));
                }
                $e = null;
              }
            else $e = null;
            Nt !== null && TM(ne, Ot, Nt, $e, !1),
              sn !== null && ui !== null && TM(ne, ui, sn, $e, !0);
          }
        }
        t: {
          if (
            ((Ot = Ct ? ut(Ct) : window),
            (Nt = Ot.nodeName && Ot.nodeName.toLowerCase()),
            Nt === "select" || (Nt === "input" && Ot.type === "file"))
          )
            var Ie = mh;
          else if (Mp(Ot))
            if (gh) Ie = Bo;
            else {
              Ie = dg;
              var Cn = x1;
            }
          else
            (Nt = Ot.nodeName),
              !Nt ||
              Nt.toLowerCase() !== "input" ||
              (Ot.type !== "checkbox" && Ot.type !== "radio")
                ? Ct && oh(Ct.elementType) && (Ie = mh)
                : (Ie = Iu);
          if (Ie && (Ie = Ie(s, Ct))) {
            ja(ne, Ie, d, Wt);
            break t;
          }
          Cn && Cn(s, Ot, Ct),
            s === "focusout" &&
              Ct &&
              Ot.type === "number" &&
              Ct.memoizedProps.value != null &&
              fi(Ot, "number", Ot.value);
        }
        switch (((Cn = Ct ? ut(Ct) : window), s)) {
          case "focusin":
            (Mp(Cn) || Cn.contentEditable === "true") &&
              ((Xr = Cn), (yh = Ct), (zu = null));
            break;
          case "focusout":
            zu = yh = Xr = null;
            break;
          case "mousedown":
            xh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (xh = !1), Rp(ne, d, Wt);
            break;
          case "selectionchange":
            if (Cp) break;
          case "keydown":
          case "keyup":
            Rp(ne, d, Wt);
        }
        var ke;
        if (Bu)
          t: {
            switch (s) {
              case "compositionstart":
                var tn = "onCompositionStart";
                break t;
              case "compositionend":
                tn = "onCompositionEnd";
                break t;
              case "compositionupdate":
                tn = "onCompositionUpdate";
                break t;
            }
            tn = void 0;
          }
        else
          Ro
            ? Ou(s, d) && (tn = "onCompositionEnd")
            : s === "keydown" &&
              d.keyCode === 229 &&
              (tn = "onCompositionStart");
        tn &&
          (Uu &&
            d.locale !== "ko" &&
            (Ro || tn !== "onCompositionStart"
              ? tn === "onCompositionEnd" && Ro && (ke = mp())
              : ((Gr = Wt),
                (pp = "value" in Gr ? Gr.value : Gr.textContent),
                (Ro = !0))),
          (Cn = cv(Ct, tn)),
          0 < Cn.length &&
            ((tn = new hh(tn, s, null, d, Wt)),
            ne.push({ event: tn, listeners: Cn }),
            ke
              ? (tn.data = ke)
              : ((ke = Ap(d)), ke !== null && (tn.data = ke)))),
          (ke = Du ? Nu(s, d) : Sp(s, d)) &&
            ((tn = cv(Ct, "onBeforeInput")),
            0 < tn.length &&
              ((Cn = new hh("onBeforeInput", "beforeinput", null, d, Wt)),
              ne.push({ event: Cn, listeners: tn }),
              (Cn.data = ke))),
          cD(ne, s, Ct, d, Wt);
      }
      MM(ne, o);
    });
  }
  function pm(s, o, d) {
    return { instance: s, listener: o, currentTarget: d };
  }
  function cv(s, o) {
    for (var d = o + "Capture", g = []; s !== null; ) {
      var b = s,
        T = b.stateNode;
      if (
        ((b = b.tag),
        (b !== 5 && b !== 26 && b !== 27) ||
          T === null ||
          ((b = ac(s, d)),
          b != null && g.unshift(pm(s, b, T)),
          (b = ac(s, o)),
          b != null && g.push(pm(s, b, T))),
        s.tag === 3)
      )
        return g;
      s = s.return;
    }
    return [];
  }
  function ad(s) {
    if (s === null) return null;
    do s = s.return;
    while (s && s.tag !== 5 && s.tag !== 27);
    return s || null;
  }
  function TM(s, o, d, g, b) {
    for (var T = o._reactName, z = []; d !== null && d !== g; ) {
      var W = d,
        at = W.alternate,
        Ct = W.stateNode;
      if (((W = W.tag), at !== null && at === g)) break;
      (W !== 5 && W !== 26 && W !== 27) ||
        Ct === null ||
        ((at = Ct),
        b
          ? ((Ct = ac(d, T)), Ct != null && z.unshift(pm(d, Ct, at)))
          : b || ((Ct = ac(d, T)), Ct != null && z.push(pm(d, Ct, at)))),
        (d = d.return);
    }
    z.length !== 0 && s.push({ event: o, listeners: z });
  }
  var dD = /\r\n?/g,
    pD = /\u0000|\uFFFD/g;
  function wM(s) {
    return (typeof s == "string" ? s : "" + s)
      .replace(
        dD,
        `
`
      )
      .replace(pD, "");
  }
  function CM(s, o) {
    return (o = wM(o)), wM(s) === o;
  }
  function uv() {}
  function ci(s, o, d, g, b, T) {
    switch (d) {
      case "children":
        typeof g == "string"
          ? o === "body" || (o === "textarea" && g === "") || Ca(s, g)
          : (typeof g == "number" || typeof g == "bigint") &&
            o !== "body" &&
            Ca(s, "" + g);
        break;
      case "className":
        Vt(s, "class", g);
        break;
      case "tabIndex":
        Vt(s, "tabindex", g);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Vt(s, d, g);
        break;
      case "style":
        Su(s, g, T);
        break;
      case "data":
        if (o !== "object") {
          Vt(s, "data", g);
          break;
        }
      case "src":
      case "href":
        if (g === "" && (o !== "a" || d !== "href")) {
          s.removeAttribute(d);
          break;
        }
        if (
          g == null ||
          typeof g == "function" ||
          typeof g == "symbol" ||
          typeof g == "boolean"
        ) {
          s.removeAttribute(d);
          break;
        }
        (g = Mu("" + g)), s.setAttribute(d, g);
        break;
      case "action":
      case "formAction":
        if (typeof g == "function") {
          s.setAttribute(
            d,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof T == "function" &&
            (d === "formAction"
              ? (o !== "input" && ci(s, o, "name", b.name, b, null),
                ci(s, o, "formEncType", b.formEncType, b, null),
                ci(s, o, "formMethod", b.formMethod, b, null),
                ci(s, o, "formTarget", b.formTarget, b, null))
              : (ci(s, o, "encType", b.encType, b, null),
                ci(s, o, "method", b.method, b, null),
                ci(s, o, "target", b.target, b, null)));
        if (g == null || typeof g == "symbol" || typeof g == "boolean") {
          s.removeAttribute(d);
          break;
        }
        (g = Mu("" + g)), s.setAttribute(d, g);
        break;
      case "onClick":
        g != null && (s.onclick = uv);
        break;
      case "onScroll":
        g != null && Rn("scroll", s);
        break;
      case "onScrollEnd":
        g != null && Rn("scrollend", s);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g)) throw Error(n(61));
          if (((d = g.__html), d != null)) {
            if (b.children != null) throw Error(n(60));
            s.innerHTML = d;
          }
        }
        break;
      case "multiple":
        s.multiple = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "muted":
        s.muted = g && typeof g != "function" && typeof g != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (
          g == null ||
          typeof g == "function" ||
          typeof g == "boolean" ||
          typeof g == "symbol"
        ) {
          s.removeAttribute("xlink:href");
          break;
        }
        (d = Mu("" + g)),
          s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", d);
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        g != null && typeof g != "function" && typeof g != "symbol"
          ? s.setAttribute(d, "" + g)
          : s.removeAttribute(d);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        g && typeof g != "function" && typeof g != "symbol"
          ? s.setAttribute(d, "")
          : s.removeAttribute(d);
        break;
      case "capture":
      case "download":
        g === !0
          ? s.setAttribute(d, "")
          : g !== !1 &&
            g != null &&
            typeof g != "function" &&
            typeof g != "symbol"
          ? s.setAttribute(d, g)
          : s.removeAttribute(d);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        g != null &&
        typeof g != "function" &&
        typeof g != "symbol" &&
        !isNaN(g) &&
        1 <= g
          ? s.setAttribute(d, g)
          : s.removeAttribute(d);
        break;
      case "rowSpan":
      case "start":
        g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g)
          ? s.removeAttribute(d)
          : s.setAttribute(d, g);
        break;
      case "popover":
        Rn("beforetoggle", s), Rn("toggle", s), wt(s, "popover", g);
        break;
      case "xlinkActuate":
        Jt(s, "http://www.w3.org/1999/xlink", "xlink:actuate", g);
        break;
      case "xlinkArcrole":
        Jt(s, "http://www.w3.org/1999/xlink", "xlink:arcrole", g);
        break;
      case "xlinkRole":
        Jt(s, "http://www.w3.org/1999/xlink", "xlink:role", g);
        break;
      case "xlinkShow":
        Jt(s, "http://www.w3.org/1999/xlink", "xlink:show", g);
        break;
      case "xlinkTitle":
        Jt(s, "http://www.w3.org/1999/xlink", "xlink:title", g);
        break;
      case "xlinkType":
        Jt(s, "http://www.w3.org/1999/xlink", "xlink:type", g);
        break;
      case "xmlBase":
        Jt(s, "http://www.w3.org/XML/1998/namespace", "xml:base", g);
        break;
      case "xmlLang":
        Jt(s, "http://www.w3.org/XML/1998/namespace", "xml:lang", g);
        break;
      case "xmlSpace":
        Jt(s, "http://www.w3.org/XML/1998/namespace", "xml:space", g);
        break;
      case "is":
        wt(s, "is", g);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < d.length) ||
          (d[0] !== "o" && d[0] !== "O") ||
          (d[1] !== "n" && d[1] !== "N")) &&
          ((d = fp.get(d) || d), wt(s, d, g));
    }
  }
  function I1(s, o, d, g, b, T) {
    switch (d) {
      case "style":
        Su(s, g, T);
        break;
      case "dangerouslySetInnerHTML":
        if (g != null) {
          if (typeof g != "object" || !("__html" in g)) throw Error(n(61));
          if (((d = g.__html), d != null)) {
            if (b.children != null) throw Error(n(60));
            s.innerHTML = d;
          }
        }
        break;
      case "children":
        typeof g == "string"
          ? Ca(s, g)
          : (typeof g == "number" || typeof g == "bigint") && Ca(s, "" + g);
        break;
      case "onScroll":
        g != null && Rn("scroll", s);
        break;
      case "onScrollEnd":
        g != null && Rn("scrollend", s);
        break;
      case "onClick":
        g != null && (s.onclick = uv);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!ue.hasOwnProperty(d))
          t: {
            if (
              d[0] === "o" &&
              d[1] === "n" &&
              ((b = d.endsWith("Capture")),
              (o = d.slice(2, b ? d.length - 7 : void 0)),
              (T = s[Ci] || null),
              (T = T != null ? T[d] : null),
              typeof T == "function" && s.removeEventListener(o, T, b),
              typeof g == "function")
            ) {
              typeof T != "function" &&
                T !== null &&
                (d in s
                  ? (s[d] = null)
                  : s.hasAttribute(d) && s.removeAttribute(d)),
                s.addEventListener(o, g, b);
              break t;
            }
            d in s
              ? (s[d] = g)
              : g === !0
              ? s.setAttribute(d, "")
              : wt(s, d, g);
          }
    }
  }
  function Pa(s, o, d) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Rn("error", s), Rn("load", s);
        var g = !1,
          b = !1,
          T;
        for (T in d)
          if (d.hasOwnProperty(T)) {
            var z = d[T];
            if (z != null)
              switch (T) {
                case "src":
                  g = !0;
                  break;
                case "srcSet":
                  b = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(n(137, o));
                default:
                  ci(s, o, T, z, d, null);
              }
          }
        b && ci(s, o, "srcSet", d.srcSet, d, null),
          g && ci(s, o, "src", d.src, d, null);
        return;
      case "input":
        Rn("invalid", s);
        var W = (T = z = b = null),
          at = null,
          Ct = null;
        for (g in d)
          if (d.hasOwnProperty(g)) {
            var Wt = d[g];
            if (Wt != null)
              switch (g) {
                case "name":
                  b = Wt;
                  break;
                case "type":
                  z = Wt;
                  break;
                case "checked":
                  at = Wt;
                  break;
                case "defaultChecked":
                  Ct = Wt;
                  break;
                case "value":
                  T = Wt;
                  break;
                case "defaultValue":
                  W = Wt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Wt != null) throw Error(n(137, o));
                  break;
                default:
                  ci(s, o, g, Wt, d, null);
              }
          }
        gn(s, T, W, at, Ct, z, b, !1), Yn(s);
        return;
      case "select":
        Rn("invalid", s), (g = z = T = null);
        for (b in d)
          if (d.hasOwnProperty(b) && ((W = d[b]), W != null))
            switch (b) {
              case "value":
                T = W;
                break;
              case "defaultValue":
                z = W;
                break;
              case "multiple":
                g = W;
              default:
                ci(s, o, b, W, d, null);
            }
        (o = T),
          (d = z),
          (s.multiple = !!g),
          o != null ? Un(s, !!g, o, !1) : d != null && Un(s, !!g, d, !0);
        return;
      case "textarea":
        Rn("invalid", s), (T = b = g = null);
        for (z in d)
          if (d.hasOwnProperty(z) && ((W = d[z]), W != null))
            switch (z) {
              case "value":
                g = W;
                break;
              case "defaultValue":
                b = W;
                break;
              case "children":
                T = W;
                break;
              case "dangerouslySetInnerHTML":
                if (W != null) throw Error(n(91));
                break;
              default:
                ci(s, o, z, W, d, null);
            }
        Zi(s, g, b, T), Yn(s);
        return;
      case "option":
        for (at in d)
          if (d.hasOwnProperty(at) && ((g = d[at]), g != null))
            switch (at) {
              case "selected":
                s.selected =
                  g && typeof g != "function" && typeof g != "symbol";
                break;
              default:
                ci(s, o, at, g, d, null);
            }
        return;
      case "dialog":
        Rn("beforetoggle", s), Rn("toggle", s), Rn("cancel", s), Rn("close", s);
        break;
      case "iframe":
      case "object":
        Rn("load", s);
        break;
      case "video":
      case "audio":
        for (g = 0; g < dm.length; g++) Rn(dm[g], s);
        break;
      case "image":
        Rn("error", s), Rn("load", s);
        break;
      case "details":
        Rn("toggle", s);
        break;
      case "embed":
      case "source":
      case "link":
        Rn("error", s), Rn("load", s);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Ct in d)
          if (d.hasOwnProperty(Ct) && ((g = d[Ct]), g != null))
            switch (Ct) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(n(137, o));
              default:
                ci(s, o, Ct, g, d, null);
            }
        return;
      default:
        if (oh(o)) {
          for (Wt in d)
            d.hasOwnProperty(Wt) &&
              ((g = d[Wt]), g !== void 0 && I1(s, o, Wt, g, d, void 0));
          return;
        }
    }
    for (W in d)
      d.hasOwnProperty(W) && ((g = d[W]), g != null && ci(s, o, W, g, d, null));
  }
  function mD(s, o, d, g) {
    switch (o) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var b = null,
          T = null,
          z = null,
          W = null,
          at = null,
          Ct = null,
          Wt = null;
        for (Nt in d) {
          var ne = d[Nt];
          if (d.hasOwnProperty(Nt) && ne != null)
            switch (Nt) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                at = ne;
              default:
                g.hasOwnProperty(Nt) || ci(s, o, Nt, null, g, ne);
            }
        }
        for (var Ot in g) {
          var Nt = g[Ot];
          if (
            ((ne = d[Ot]), g.hasOwnProperty(Ot) && (Nt != null || ne != null))
          )
            switch (Ot) {
              case "type":
                T = Nt;
                break;
              case "name":
                b = Nt;
                break;
              case "checked":
                Ct = Nt;
                break;
              case "defaultChecked":
                Wt = Nt;
                break;
              case "value":
                z = Nt;
                break;
              case "defaultValue":
                W = Nt;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Nt != null) throw Error(n(137, o));
                break;
              default:
                Nt !== ne && ci(s, o, Ot, Nt, g, ne);
            }
        }
        xn(s, z, W, at, Ct, Wt, T, b);
        return;
      case "select":
        Nt = z = W = Ot = null;
        for (T in d)
          if (((at = d[T]), d.hasOwnProperty(T) && at != null))
            switch (T) {
              case "value":
                break;
              case "multiple":
                Nt = at;
              default:
                g.hasOwnProperty(T) || ci(s, o, T, null, g, at);
            }
        for (b in g)
          if (
            ((T = g[b]),
            (at = d[b]),
            g.hasOwnProperty(b) && (T != null || at != null))
          )
            switch (b) {
              case "value":
                Ot = T;
                break;
              case "defaultValue":
                W = T;
                break;
              case "multiple":
                z = T;
              default:
                T !== at && ci(s, o, b, T, g, at);
            }
        (o = W),
          (d = z),
          (g = Nt),
          Ot != null
            ? Un(s, !!d, Ot, !1)
            : !!g != !!d &&
              (o != null ? Un(s, !!d, o, !0) : Un(s, !!d, d ? [] : "", !1));
        return;
      case "textarea":
        Nt = Ot = null;
        for (W in d)
          if (
            ((b = d[W]),
            d.hasOwnProperty(W) && b != null && !g.hasOwnProperty(W))
          )
            switch (W) {
              case "value":
                break;
              case "children":
                break;
              default:
                ci(s, o, W, null, g, b);
            }
        for (z in g)
          if (
            ((b = g[z]),
            (T = d[z]),
            g.hasOwnProperty(z) && (b != null || T != null))
          )
            switch (z) {
              case "value":
                Ot = b;
                break;
              case "defaultValue":
                Nt = b;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (b != null) throw Error(n(91));
                break;
              default:
                b !== T && ci(s, o, z, b, g, T);
            }
        $n(s, Ot, Nt);
        return;
      case "option":
        for (var sn in d)
          if (
            ((Ot = d[sn]),
            d.hasOwnProperty(sn) && Ot != null && !g.hasOwnProperty(sn))
          )
            switch (sn) {
              case "selected":
                s.selected = !1;
                break;
              default:
                ci(s, o, sn, null, g, Ot);
            }
        for (at in g)
          if (
            ((Ot = g[at]),
            (Nt = d[at]),
            g.hasOwnProperty(at) && Ot !== Nt && (Ot != null || Nt != null))
          )
            switch (at) {
              case "selected":
                s.selected =
                  Ot && typeof Ot != "function" && typeof Ot != "symbol";
                break;
              default:
                ci(s, o, at, Ot, g, Nt);
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var $e in d)
          (Ot = d[$e]),
            d.hasOwnProperty($e) &&
              Ot != null &&
              !g.hasOwnProperty($e) &&
              ci(s, o, $e, null, g, Ot);
        for (Ct in g)
          if (
            ((Ot = g[Ct]),
            (Nt = d[Ct]),
            g.hasOwnProperty(Ct) && Ot !== Nt && (Ot != null || Nt != null))
          )
            switch (Ct) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Ot != null) throw Error(n(137, o));
                break;
              default:
                ci(s, o, Ct, Ot, g, Nt);
            }
        return;
      default:
        if (oh(o)) {
          for (var ui in d)
            (Ot = d[ui]),
              d.hasOwnProperty(ui) &&
                Ot !== void 0 &&
                !g.hasOwnProperty(ui) &&
                I1(s, o, ui, void 0, g, Ot);
          for (Wt in g)
            (Ot = g[Wt]),
              (Nt = d[Wt]),
              !g.hasOwnProperty(Wt) ||
                Ot === Nt ||
                (Ot === void 0 && Nt === void 0) ||
                I1(s, o, Wt, Ot, g, Nt);
          return;
        }
    }
    for (var _t in d)
      (Ot = d[_t]),
        d.hasOwnProperty(_t) &&
          Ot != null &&
          !g.hasOwnProperty(_t) &&
          ci(s, o, _t, null, g, Ot);
    for (ne in g)
      (Ot = g[ne]),
        (Nt = d[ne]),
        !g.hasOwnProperty(ne) ||
          Ot === Nt ||
          (Ot == null && Nt == null) ||
          ci(s, o, ne, Ot, g, Nt);
  }
  var P1 = null,
    z1 = null;
  function fv(s) {
    return s.nodeType === 9 ? s : s.ownerDocument;
  }
  function RM(s) {
    switch (s) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function BM(s, o) {
    if (s === 0)
      switch (o) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return s === 1 && o === "foreignObject" ? 0 : s;
  }
  function F1(s, o) {
    return (
      s === "textarea" ||
      s === "noscript" ||
      typeof o.children == "string" ||
      typeof o.children == "number" ||
      typeof o.children == "bigint" ||
      (typeof o.dangerouslySetInnerHTML == "object" &&
        o.dangerouslySetInnerHTML !== null &&
        o.dangerouslySetInnerHTML.__html != null)
    );
  }
  var H1 = null;
  function gD() {
    var s = window.event;
    return s && s.type === "popstate"
      ? s === H1
        ? !1
        : ((H1 = s), !0)
      : ((H1 = null), !1);
  }
  var DM = typeof setTimeout == "function" ? setTimeout : void 0,
    vD = typeof clearTimeout == "function" ? clearTimeout : void 0,
    UM = typeof Promise == "function" ? Promise : void 0,
    yD =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof UM < "u"
        ? function (s) {
            return UM.resolve(null).then(s).catch(xD);
          }
        : DM;
  function xD(s) {
    setTimeout(function () {
      throw s;
    });
  }
  function kc(s) {
    return s === "head";
  }
  function OM(s, o) {
    var d = o,
      g = 0,
      b = 0;
    do {
      var T = d.nextSibling;
      if ((s.removeChild(d), T && T.nodeType === 8))
        if (((d = T.data), d === "/$")) {
          if (0 < g && 8 > g) {
            d = g;
            var z = s.ownerDocument;
            if ((d & 1 && mm(z.documentElement), d & 2 && mm(z.body), d & 4))
              for (d = z.head, mm(d), z = d.firstChild; z; ) {
                var W = z.nextSibling,
                  at = z.nodeName;
                z[ka] ||
                  at === "SCRIPT" ||
                  at === "STYLE" ||
                  (at === "LINK" && z.rel.toLowerCase() === "stylesheet") ||
                  d.removeChild(z),
                  (z = W);
              }
          }
          if (b === 0) {
            s.removeChild(T), Sm(o);
            return;
          }
          b--;
        } else
          d === "$" || d === "$?" || d === "$!"
            ? b++
            : (g = d.charCodeAt(0) - 48);
      else g = 0;
      d = T;
    } while (d);
    Sm(o);
  }
  function G1(s) {
    var o = s.firstChild;
    for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
      var d = o;
      switch (((o = o.nextSibling), d.nodeName)) {
        case "HTML":
        case "HEAD":
        case "BODY":
          G1(d), Vn(d);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (d.rel.toLowerCase() === "stylesheet") continue;
      }
      s.removeChild(d);
    }
  }
  function _D(s, o, d, g) {
    for (; s.nodeType === 1; ) {
      var b = d;
      if (s.nodeName.toLowerCase() !== o.toLowerCase()) {
        if (!g && (s.nodeName !== "INPUT" || s.type !== "hidden")) break;
      } else if (g) {
        if (!s[ka])
          switch (o) {
            case "meta":
              if (!s.hasAttribute("itemprop")) break;
              return s;
            case "link":
              if (
                ((T = s.getAttribute("rel")),
                T === "stylesheet" && s.hasAttribute("data-precedence"))
              )
                break;
              if (
                T !== b.rel ||
                s.getAttribute("href") !==
                  (b.href == null || b.href === "" ? null : b.href) ||
                s.getAttribute("crossorigin") !==
                  (b.crossOrigin == null ? null : b.crossOrigin) ||
                s.getAttribute("title") !== (b.title == null ? null : b.title)
              )
                break;
              return s;
            case "style":
              if (s.hasAttribute("data-precedence")) break;
              return s;
            case "script":
              if (
                ((T = s.getAttribute("src")),
                (T !== (b.src == null ? null : b.src) ||
                  s.getAttribute("type") !== (b.type == null ? null : b.type) ||
                  s.getAttribute("crossorigin") !==
                    (b.crossOrigin == null ? null : b.crossOrigin)) &&
                  T &&
                  s.hasAttribute("async") &&
                  !s.hasAttribute("itemprop"))
              )
                break;
              return s;
            default:
              return s;
          }
      } else if (o === "input" && s.type === "hidden") {
        var T = b.name == null ? null : "" + b.name;
        if (b.type === "hidden" && s.getAttribute("name") === T) return s;
      } else return s;
      if (((s = uo(s.nextSibling)), s === null)) break;
    }
    return null;
  }
  function bD(s, o, d) {
    if (o === "") return null;
    for (; s.nodeType !== 3; )
      if (
        ((s.nodeType !== 1 || s.nodeName !== "INPUT" || s.type !== "hidden") &&
          !d) ||
        ((s = uo(s.nextSibling)), s === null)
      )
        return null;
    return s;
  }
  function V1(s) {
    return (
      s.data === "$!" ||
      (s.data === "$?" && s.ownerDocument.readyState === "complete")
    );
  }
  function AD(s, o) {
    var d = s.ownerDocument;
    if (s.data !== "$?" || d.readyState === "complete") o();
    else {
      var g = function () {
        o(), d.removeEventListener("DOMContentLoaded", g);
      };
      d.addEventListener("DOMContentLoaded", g), (s._reactRetry = g);
    }
  }
  function uo(s) {
    for (; s != null; s = s.nextSibling) {
      var o = s.nodeType;
      if (o === 1 || o === 3) break;
      if (o === 8) {
        if (
          ((o = s.data),
          o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F")
        )
          break;
        if (o === "/$") return null;
      }
    }
    return s;
  }
  var k1 = null;
  function NM(s) {
    s = s.previousSibling;
    for (var o = 0; s; ) {
      if (s.nodeType === 8) {
        var d = s.data;
        if (d === "$" || d === "$!" || d === "$?") {
          if (o === 0) return s;
          o--;
        } else d === "/$" && o++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  function LM(s, o, d) {
    switch (((o = fv(d)), s)) {
      case "html":
        if (((s = o.documentElement), !s)) throw Error(n(452));
        return s;
      case "head":
        if (((s = o.head), !s)) throw Error(n(453));
        return s;
      case "body":
        if (((s = o.body), !s)) throw Error(n(454));
        return s;
      default:
        throw Error(n(451));
    }
  }
  function mm(s) {
    for (var o = s.attributes; o.length; ) s.removeAttributeNode(o[0]);
    Vn(s);
  }
  var Cr = new Map(),
    IM = new Set();
  function hv(s) {
    return typeof s.getRootNode == "function"
      ? s.getRootNode()
      : s.nodeType === 9
      ? s
      : s.ownerDocument;
  }
  var zl = Q.d;
  Q.d = { f: SD, r: MD, D: ED, C: TD, L: wD, m: CD, X: BD, S: RD, M: DD };
  function SD() {
    var s = zl.f(),
      o = Tr();
    return s || o;
  }
  function MD(s) {
    var o = K(s);
    o !== null && o.tag === 5 && o.type === "form" ? Xg(o) : zl.r(s);
  }
  var sd = typeof document > "u" ? null : document;
  function PM(s, o, d) {
    var g = sd;
    if (g && typeof o == "string" && o) {
      var b = qe(o);
      (b = 'link[rel="' + s + '"][href="' + b + '"]'),
        typeof d == "string" && (b += '[crossorigin="' + d + '"]'),
        IM.has(b) ||
          (IM.add(b),
          (s = { rel: s, crossOrigin: d, href: o }),
          g.querySelector(b) === null &&
            ((o = g.createElement("link")),
            Pa(o, "link", s),
            Ut(o),
            g.head.appendChild(o)));
    }
  }
  function ED(s) {
    zl.D(s), PM("dns-prefetch", s, null);
  }
  function TD(s, o) {
    zl.C(s, o), PM("preconnect", s, o);
  }
  function wD(s, o, d) {
    zl.L(s, o, d);
    var g = sd;
    if (g && s && o) {
      var b = 'link[rel="preload"][as="' + qe(o) + '"]';
      o === "image" && d && d.imageSrcSet
        ? ((b += '[imagesrcset="' + qe(d.imageSrcSet) + '"]'),
          typeof d.imageSizes == "string" &&
            (b += '[imagesizes="' + qe(d.imageSizes) + '"]'))
        : (b += '[href="' + qe(s) + '"]');
      var T = b;
      switch (o) {
        case "style":
          T = rd(s);
          break;
        case "script":
          T = od(s);
      }
      Cr.has(T) ||
        ((s = m(
          {
            rel: "preload",
            href: o === "image" && d && d.imageSrcSet ? void 0 : s,
            as: o,
          },
          d
        )),
        Cr.set(T, s),
        g.querySelector(b) !== null ||
          (o === "style" && g.querySelector(gm(T))) ||
          (o === "script" && g.querySelector(vm(T))) ||
          ((o = g.createElement("link")),
          Pa(o, "link", s),
          Ut(o),
          g.head.appendChild(o)));
    }
  }
  function CD(s, o) {
    zl.m(s, o);
    var d = sd;
    if (d && s) {
      var g = o && typeof o.as == "string" ? o.as : "script",
        b =
          'link[rel="modulepreload"][as="' + qe(g) + '"][href="' + qe(s) + '"]',
        T = b;
      switch (g) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          T = od(s);
      }
      if (
        !Cr.has(T) &&
        ((s = m({ rel: "modulepreload", href: s }, o)),
        Cr.set(T, s),
        d.querySelector(b) === null)
      ) {
        switch (g) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (d.querySelector(vm(T))) return;
        }
        (g = d.createElement("link")),
          Pa(g, "link", s),
          Ut(g),
          d.head.appendChild(g);
      }
    }
  }
  function RD(s, o, d) {
    zl.S(s, o, d);
    var g = sd;
    if (g && s) {
      var b = Bt(g).hoistableStyles,
        T = rd(s);
      o = o || "default";
      var z = b.get(T);
      if (!z) {
        var W = { loading: 0, preload: null };
        if ((z = g.querySelector(gm(T)))) W.loading = 5;
        else {
          (s = m({ rel: "stylesheet", href: s, "data-precedence": o }, d)),
            (d = Cr.get(T)) && j1(s, d);
          var at = (z = g.createElement("link"));
          Ut(at),
            Pa(at, "link", s),
            (at._p = new Promise(function (Ct, Wt) {
              (at.onload = Ct), (at.onerror = Wt);
            })),
            at.addEventListener("load", function () {
              W.loading |= 1;
            }),
            at.addEventListener("error", function () {
              W.loading |= 2;
            }),
            (W.loading |= 4),
            dv(z, o, g);
        }
        (z = { type: "stylesheet", instance: z, count: 1, state: W }),
          b.set(T, z);
      }
    }
  }
  function BD(s, o) {
    zl.X(s, o);
    var d = sd;
    if (d && s) {
      var g = Bt(d).hoistableScripts,
        b = od(s),
        T = g.get(b);
      T ||
        ((T = d.querySelector(vm(b))),
        T ||
          ((s = m({ src: s, async: !0 }, o)),
          (o = Cr.get(b)) && X1(s, o),
          (T = d.createElement("script")),
          Ut(T),
          Pa(T, "link", s),
          d.head.appendChild(T)),
        (T = { type: "script", instance: T, count: 1, state: null }),
        g.set(b, T));
    }
  }
  function DD(s, o) {
    zl.M(s, o);
    var d = sd;
    if (d && s) {
      var g = Bt(d).hoistableScripts,
        b = od(s),
        T = g.get(b);
      T ||
        ((T = d.querySelector(vm(b))),
        T ||
          ((s = m({ src: s, async: !0, type: "module" }, o)),
          (o = Cr.get(b)) && X1(s, o),
          (T = d.createElement("script")),
          Ut(T),
          Pa(T, "link", s),
          d.head.appendChild(T)),
        (T = { type: "script", instance: T, count: 1, state: null }),
        g.set(b, T));
    }
  }
  function zM(s, o, d, g) {
    var b = (b = Pt.current) ? hv(b) : null;
    if (!b) throw Error(n(446));
    switch (s) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof d.precedence == "string" && typeof d.href == "string"
          ? ((o = rd(d.href)),
            (d = Bt(b).hoistableStyles),
            (g = d.get(o)),
            g ||
              ((g = { type: "style", instance: null, count: 0, state: null }),
              d.set(o, g)),
            g)
          : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (
          d.rel === "stylesheet" &&
          typeof d.href == "string" &&
          typeof d.precedence == "string"
        ) {
          s = rd(d.href);
          var T = Bt(b).hoistableStyles,
            z = T.get(s);
          if (
            (z ||
              ((b = b.ownerDocument || b),
              (z = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              T.set(s, z),
              (T = b.querySelector(gm(s))) &&
                !T._p &&
                ((z.instance = T), (z.state.loading = 5)),
              Cr.has(s) ||
                ((d = {
                  rel: "preload",
                  as: "style",
                  href: d.href,
                  crossOrigin: d.crossOrigin,
                  integrity: d.integrity,
                  media: d.media,
                  hrefLang: d.hrefLang,
                  referrerPolicy: d.referrerPolicy,
                }),
                Cr.set(s, d),
                T || UD(b, s, d, z.state))),
            o && g === null)
          )
            throw Error(n(528, ""));
          return z;
        }
        if (o && g !== null) throw Error(n(529, ""));
        return null;
      case "script":
        return (
          (o = d.async),
          (d = d.src),
          typeof d == "string" &&
          o &&
          typeof o != "function" &&
          typeof o != "symbol"
            ? ((o = od(d)),
              (d = Bt(b).hoistableScripts),
              (g = d.get(o)),
              g ||
                ((g = {
                  type: "script",
                  instance: null,
                  count: 0,
                  state: null,
                }),
                d.set(o, g)),
              g)
            : { type: "void", instance: null, count: 0, state: null }
        );
      default:
        throw Error(n(444, s));
    }
  }
  function rd(s) {
    return 'href="' + qe(s) + '"';
  }
  function gm(s) {
    return 'link[rel="stylesheet"][' + s + "]";
  }
  function FM(s) {
    return m({}, s, { "data-precedence": s.precedence, precedence: null });
  }
  function UD(s, o, d, g) {
    s.querySelector('link[rel="preload"][as="style"][' + o + "]")
      ? (g.loading = 1)
      : ((o = s.createElement("link")),
        (g.preload = o),
        o.addEventListener("load", function () {
          return (g.loading |= 1);
        }),
        o.addEventListener("error", function () {
          return (g.loading |= 2);
        }),
        Pa(o, "link", d),
        Ut(o),
        s.head.appendChild(o));
  }
  function od(s) {
    return '[src="' + qe(s) + '"]';
  }
  function vm(s) {
    return "script[async]" + s;
  }
  function HM(s, o, d) {
    if ((o.count++, o.instance === null))
      switch (o.type) {
        case "style":
          var g = s.querySelector('style[data-href~="' + qe(d.href) + '"]');
          if (g) return (o.instance = g), Ut(g), g;
          var b = m({}, d, {
            "data-href": d.href,
            "data-precedence": d.precedence,
            href: null,
            precedence: null,
          });
          return (
            (g = (s.ownerDocument || s).createElement("style")),
            Ut(g),
            Pa(g, "style", b),
            dv(g, d.precedence, s),
            (o.instance = g)
          );
        case "stylesheet":
          b = rd(d.href);
          var T = s.querySelector(gm(b));
          if (T) return (o.state.loading |= 4), (o.instance = T), Ut(T), T;
          (g = FM(d)),
            (b = Cr.get(b)) && j1(g, b),
            (T = (s.ownerDocument || s).createElement("link")),
            Ut(T);
          var z = T;
          return (
            (z._p = new Promise(function (W, at) {
              (z.onload = W), (z.onerror = at);
            })),
            Pa(T, "link", g),
            (o.state.loading |= 4),
            dv(T, d.precedence, s),
            (o.instance = T)
          );
        case "script":
          return (
            (T = od(d.src)),
            (b = s.querySelector(vm(T)))
              ? ((o.instance = b), Ut(b), b)
              : ((g = d),
                (b = Cr.get(T)) && ((g = m({}, d)), X1(g, b)),
                (s = s.ownerDocument || s),
                (b = s.createElement("script")),
                Ut(b),
                Pa(b, "link", g),
                s.head.appendChild(b),
                (o.instance = b))
          );
        case "void":
          return null;
        default:
          throw Error(n(443, o.type));
      }
    else
      o.type === "stylesheet" &&
        (o.state.loading & 4) === 0 &&
        ((g = o.instance), (o.state.loading |= 4), dv(g, d.precedence, s));
    return o.instance;
  }
  function dv(s, o, d) {
    for (
      var g = d.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ),
        b = g.length ? g[g.length - 1] : null,
        T = b,
        z = 0;
      z < g.length;
      z++
    ) {
      var W = g[z];
      if (W.dataset.precedence === o) T = W;
      else if (T !== b) break;
    }
    T
      ? T.parentNode.insertBefore(s, T.nextSibling)
      : ((o = d.nodeType === 9 ? d.head : d), o.insertBefore(s, o.firstChild));
  }
  function j1(s, o) {
    s.crossOrigin == null && (s.crossOrigin = o.crossOrigin),
      s.referrerPolicy == null && (s.referrerPolicy = o.referrerPolicy),
      s.title == null && (s.title = o.title);
  }
  function X1(s, o) {
    s.crossOrigin == null && (s.crossOrigin = o.crossOrigin),
      s.referrerPolicy == null && (s.referrerPolicy = o.referrerPolicy),
      s.integrity == null && (s.integrity = o.integrity);
  }
  var pv = null;
  function GM(s, o, d) {
    if (pv === null) {
      var g = new Map(),
        b = (pv = new Map());
      b.set(d, g);
    } else (b = pv), (g = b.get(d)), g || ((g = new Map()), b.set(d, g));
    if (g.has(s)) return g;
    for (
      g.set(s, null), d = d.getElementsByTagName(s), b = 0;
      b < d.length;
      b++
    ) {
      var T = d[b];
      if (
        !(
          T[ka] ||
          T[xi] ||
          (s === "link" && T.getAttribute("rel") === "stylesheet")
        ) &&
        T.namespaceURI !== "http://www.w3.org/2000/svg"
      ) {
        var z = T.getAttribute(o) || "";
        z = s + z;
        var W = g.get(z);
        W ? W.push(T) : g.set(z, [T]);
      }
    }
    return g;
  }
  function VM(s, o, d) {
    (s = s.ownerDocument || s),
      s.head.insertBefore(
        d,
        o === "title" ? s.querySelector("head > title") : null
      );
  }
  function OD(s, o, d) {
    if (d === 1 || o.itemProp != null) return !1;
    switch (s) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (
          typeof o.precedence != "string" ||
          typeof o.href != "string" ||
          o.href === ""
        )
          break;
        return !0;
      case "link":
        if (
          typeof o.rel != "string" ||
          typeof o.href != "string" ||
          o.href === "" ||
          o.onLoad ||
          o.onError
        )
          break;
        switch (o.rel) {
          case "stylesheet":
            return (
              (s = o.disabled), typeof o.precedence == "string" && s == null
            );
          default:
            return !0;
        }
      case "script":
        if (
          o.async &&
          typeof o.async != "function" &&
          typeof o.async != "symbol" &&
          !o.onLoad &&
          !o.onError &&
          o.src &&
          typeof o.src == "string"
        )
          return !0;
    }
    return !1;
  }
  function kM(s) {
    return !(s.type === "stylesheet" && (s.state.loading & 3) === 0);
  }
  var ym = null;
  function ND() {}
  function LD(s, o, d) {
    if (ym === null) throw Error(n(475));
    var g = ym;
    if (
      o.type === "stylesheet" &&
      (typeof d.media != "string" || matchMedia(d.media).matches !== !1) &&
      (o.state.loading & 4) === 0
    ) {
      if (o.instance === null) {
        var b = rd(d.href),
          T = s.querySelector(gm(b));
        if (T) {
          (s = T._p),
            s !== null &&
              typeof s == "object" &&
              typeof s.then == "function" &&
              (g.count++, (g = mv.bind(g)), s.then(g, g)),
            (o.state.loading |= 4),
            (o.instance = T),
            Ut(T);
          return;
        }
        (T = s.ownerDocument || s),
          (d = FM(d)),
          (b = Cr.get(b)) && j1(d, b),
          (T = T.createElement("link")),
          Ut(T);
        var z = T;
        (z._p = new Promise(function (W, at) {
          (z.onload = W), (z.onerror = at);
        })),
          Pa(T, "link", d),
          (o.instance = T);
      }
      g.stylesheets === null && (g.stylesheets = new Map()),
        g.stylesheets.set(o, s),
        (s = o.state.preload) &&
          (o.state.loading & 3) === 0 &&
          (g.count++,
          (o = mv.bind(g)),
          s.addEventListener("load", o),
          s.addEventListener("error", o));
    }
  }
  function ID() {
    if (ym === null) throw Error(n(475));
    var s = ym;
    return (
      s.stylesheets && s.count === 0 && W1(s, s.stylesheets),
      0 < s.count
        ? function (o) {
            var d = setTimeout(function () {
              if ((s.stylesheets && W1(s, s.stylesheets), s.unsuspend)) {
                var g = s.unsuspend;
                (s.unsuspend = null), g();
              }
            }, 6e4);
            return (
              (s.unsuspend = o),
              function () {
                (s.unsuspend = null), clearTimeout(d);
              }
            );
          }
        : null
    );
  }
  function mv() {
    if ((this.count--, this.count === 0)) {
      if (this.stylesheets) W1(this, this.stylesheets);
      else if (this.unsuspend) {
        var s = this.unsuspend;
        (this.unsuspend = null), s();
      }
    }
  }
  var gv = null;
  function W1(s, o) {
    (s.stylesheets = null),
      s.unsuspend !== null &&
        (s.count++,
        (gv = new Map()),
        o.forEach(PD, s),
        (gv = null),
        mv.call(s));
  }
  function PD(s, o) {
    if (!(o.state.loading & 4)) {
      var d = gv.get(s);
      if (d) var g = d.get(null);
      else {
        (d = new Map()), gv.set(s, d);
        for (
          var b = s.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ),
            T = 0;
          T < b.length;
          T++
        ) {
          var z = b[T];
          (z.nodeName === "LINK" || z.getAttribute("media") !== "not all") &&
            (d.set(z.dataset.precedence, z), (g = z));
        }
        g && d.set(null, g);
      }
      (b = o.instance),
        (z = b.getAttribute("data-precedence")),
        (T = d.get(z) || g),
        T === g && d.set(null, b),
        d.set(z, b),
        this.count++,
        (g = mv.bind(this)),
        b.addEventListener("load", g),
        b.addEventListener("error", g),
        T
          ? T.parentNode.insertBefore(b, T.nextSibling)
          : ((s = s.nodeType === 9 ? s.head : s),
            s.insertBefore(b, s.firstChild)),
        (o.state.loading |= 4);
    }
  }
  var xm = {
    $$typeof: B,
    Provider: null,
    Consumer: null,
    _currentValue: et,
    _currentValue2: et,
    _threadCount: 0,
  };
  function zD(s, o, d, g, b, T, z, W) {
    (this.tag = 1),
      (this.containerInfo = s),
      (this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = qt(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = qt(0)),
      (this.hiddenUpdates = qt(null)),
      (this.identifierPrefix = g),
      (this.onUncaughtError = b),
      (this.onCaughtError = T),
      (this.onRecoverableError = z),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = W),
      (this.incompleteTransitions = new Map());
  }
  function jM(s, o, d, g, b, T, z, W, at, Ct, Wt, ne) {
    return (
      (s = new zD(s, o, d, z, W, at, Ct, ne)),
      (o = 1),
      T === !0 && (o |= 24),
      (T = qa(3, null, null, o)),
      (s.current = T),
      (T.stateNode = s),
      (o = Ch()),
      o.refCount++,
      (s.pooledCache = o),
      o.refCount++,
      (T.memoizedState = { element: g, isDehydrated: d, cache: o }),
      kp(T),
      s
    );
  }
  function XM(s) {
    return s ? ((s = Oo), s) : Oo;
  }
  function WM(s, o, d, g, b, T) {
    (b = XM(b)),
      g.context === null ? (g.context = b) : (g.pendingContext = b),
      (g = mr(o)),
      (g.payload = { element: d }),
      (T = T === void 0 ? null : T),
      T !== null && (g.callback = T),
      (d = to(s, g, o)),
      d !== null && (Ia(d, s, o), _l(d, s, o));
  }
  function YM(s, o) {
    if (((s = s.memoizedState), s !== null && s.dehydrated !== null)) {
      var d = s.retryLane;
      s.retryLane = d !== 0 && d < o ? d : o;
    }
  }
  function Y1(s, o) {
    YM(s, o), (s = s.alternate) && YM(s, o);
  }
  function qM(s) {
    if (s.tag === 13) {
      var o = Kr(s, 67108864);
      o !== null && Ia(o, s, 67108864), Y1(s, 67108864);
    }
  }
  var vv = !0;
  function FD(s, o, d, g) {
    var b = j.T;
    j.T = null;
    var T = Q.p;
    try {
      (Q.p = 2), q1(s, o, d, g);
    } finally {
      (Q.p = T), (j.T = b);
    }
  }
  function HD(s, o, d, g) {
    var b = j.T;
    j.T = null;
    var T = Q.p;
    try {
      (Q.p = 8), q1(s, o, d, g);
    } finally {
      (Q.p = T), (j.T = b);
    }
  }
  function q1(s, o, d, g) {
    if (vv) {
      var b = K1(g);
      if (b === null) L1(s, o, g, yv, d), JM(s, g);
      else if (VD(b, s, o, d, g)) g.stopPropagation();
      else if ((JM(s, g), o & 4 && -1 < GD.indexOf(s))) {
        for (; b !== null; ) {
          var T = K(b);
          if (T !== null)
            switch (T.tag) {
              case 3:
                if (((T = T.stateNode), T.current.memoizedState.isDehydrated)) {
                  var z = Re(T.pendingLanes);
                  if (z !== 0) {
                    var W = T;
                    for (W.pendingLanes |= 2, W.entangledLanes |= 2; z; ) {
                      var at = 1 << (31 - me(z));
                      (W.entanglements[1] |= at), (z &= ~at);
                    }
                    il(T), (jn & 6) === 0 && ((ba = $t() + 500), hm(0));
                  }
                }
                break;
              case 13:
                (W = Kr(T, 2)), W !== null && Ia(W, T, 2), Tr(), Y1(T, 2);
            }
          if (((T = K1(g)), T === null && L1(s, o, g, yv, d), T === b)) break;
          b = T;
        }
        b !== null && g.stopPropagation();
      } else L1(s, o, g, null, d);
    }
  }
  function K1(s) {
    return (s = ch(s)), J1(s);
  }
  var yv = null;
  function J1(s) {
    if (((yv = null), (s = G(s)), s !== null)) {
      var o = r(s);
      if (o === null) s = null;
      else {
        var d = o.tag;
        if (d === 13) {
          if (((s = l(o)), s !== null)) return s;
          s = null;
        } else if (d === 3) {
          if (o.stateNode.current.memoizedState.isDehydrated)
            return o.tag === 3 ? o.stateNode.containerInfo : null;
          s = null;
        } else o !== s && (s = null);
      }
    }
    return (yv = s), null;
  }
  function KM(s) {
    switch (s) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (kt()) {
          case ye:
            return 2;
          case te:
            return 8;
          case pe:
          case Ye:
            return 32;
          case $:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var Z1 = !1,
    jc = null,
    Xc = null,
    Wc = null,
    _m = new Map(),
    bm = new Map(),
    Yc = [],
    GD =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
  function JM(s, o) {
    switch (s) {
      case "focusin":
      case "focusout":
        jc = null;
        break;
      case "dragenter":
      case "dragleave":
        Xc = null;
        break;
      case "mouseover":
      case "mouseout":
        Wc = null;
        break;
      case "pointerover":
      case "pointerout":
        _m.delete(o.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        bm.delete(o.pointerId);
    }
  }
  function Am(s, o, d, g, b, T) {
    return s === null || s.nativeEvent !== T
      ? ((s = {
          blockedOn: o,
          domEventName: d,
          eventSystemFlags: g,
          nativeEvent: T,
          targetContainers: [b],
        }),
        o !== null && ((o = K(o)), o !== null && qM(o)),
        s)
      : ((s.eventSystemFlags |= g),
        (o = s.targetContainers),
        b !== null && o.indexOf(b) === -1 && o.push(b),
        s);
  }
  function VD(s, o, d, g, b) {
    switch (o) {
      case "focusin":
        return (jc = Am(jc, s, o, d, g, b)), !0;
      case "dragenter":
        return (Xc = Am(Xc, s, o, d, g, b)), !0;
      case "mouseover":
        return (Wc = Am(Wc, s, o, d, g, b)), !0;
      case "pointerover":
        var T = b.pointerId;
        return _m.set(T, Am(_m.get(T) || null, s, o, d, g, b)), !0;
      case "gotpointercapture":
        return (
          (T = b.pointerId), bm.set(T, Am(bm.get(T) || null, s, o, d, g, b)), !0
        );
    }
    return !1;
  }
  function ZM(s) {
    var o = G(s.target);
    if (o !== null) {
      var d = r(o);
      if (d !== null) {
        if (((o = d.tag), o === 13)) {
          if (((o = l(d)), o !== null)) {
            (s.blockedOn = o),
              yi(s.priority, function () {
                if (d.tag === 13) {
                  var g = Si();
                  g = Le(g);
                  var b = Kr(d, g);
                  b !== null && Ia(b, d, g), Y1(d, g);
                }
              });
            return;
          }
        } else if (o === 3 && d.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function xv(s) {
    if (s.blockedOn !== null) return !1;
    for (var o = s.targetContainers; 0 < o.length; ) {
      var d = K1(s.nativeEvent);
      if (d === null) {
        d = s.nativeEvent;
        var g = new d.constructor(d.type, d);
        (lh = g), d.target.dispatchEvent(g), (lh = null);
      } else return (o = K(d)), o !== null && qM(o), (s.blockedOn = d), !1;
      o.shift();
    }
    return !0;
  }
  function QM(s, o, d) {
    xv(s) && d.delete(o);
  }
  function kD() {
    (Z1 = !1),
      jc !== null && xv(jc) && (jc = null),
      Xc !== null && xv(Xc) && (Xc = null),
      Wc !== null && xv(Wc) && (Wc = null),
      _m.forEach(QM),
      bm.forEach(QM);
  }
  function _v(s, o) {
    s.blockedOn === o &&
      ((s.blockedOn = null),
      Z1 ||
        ((Z1 = !0),
        i.unstable_scheduleCallback(i.unstable_NormalPriority, kD)));
  }
  var bv = null;
  function $M(s) {
    bv !== s &&
      ((bv = s),
      i.unstable_scheduleCallback(i.unstable_NormalPriority, function () {
        bv === s && (bv = null);
        for (var o = 0; o < s.length; o += 3) {
          var d = s[o],
            g = s[o + 1],
            b = s[o + 2];
          if (typeof g != "function") {
            if (J1(g || d) === null) continue;
            break;
          }
          var T = K(d);
          T !== null &&
            (s.splice(o, 3),
            (o -= 3),
            sm(T, { pending: !0, data: b, method: d.method, action: g }, g, b));
        }
      }));
  }
  function Sm(s) {
    function o(at) {
      return _v(at, s);
    }
    jc !== null && _v(jc, s),
      Xc !== null && _v(Xc, s),
      Wc !== null && _v(Wc, s),
      _m.forEach(o),
      bm.forEach(o);
    for (var d = 0; d < Yc.length; d++) {
      var g = Yc[d];
      g.blockedOn === s && (g.blockedOn = null);
    }
    for (; 0 < Yc.length && ((d = Yc[0]), d.blockedOn === null); )
      ZM(d), d.blockedOn === null && Yc.shift();
    if (((d = (s.ownerDocument || s).$$reactFormReplay), d != null))
      for (g = 0; g < d.length; g += 3) {
        var b = d[g],
          T = d[g + 1],
          z = b[Ci] || null;
        if (typeof T == "function") z || $M(d);
        else if (z) {
          var W = null;
          if (T && T.hasAttribute("formAction")) {
            if (((b = T), (z = T[Ci] || null))) W = z.formAction;
            else if (J1(b) !== null) continue;
          } else W = z.action;
          typeof W == "function" ? (d[g + 1] = W) : (d.splice(g, 3), (g -= 3)),
            $M(d);
        }
      }
  }
  function Q1(s) {
    this._internalRoot = s;
  }
  (Av.prototype.render = Q1.prototype.render =
    function (s) {
      var o = this._internalRoot;
      if (o === null) throw Error(n(409));
      var d = o.current,
        g = Si();
      WM(d, g, s, o, null, null);
    }),
    (Av.prototype.unmount = Q1.prototype.unmount =
      function () {
        var s = this._internalRoot;
        if (s !== null) {
          this._internalRoot = null;
          var o = s.containerInfo;
          WM(s.current, 2, null, s, null, null), Tr(), (o[Ri] = null);
        }
      });
  function Av(s) {
    this._internalRoot = s;
  }
  Av.prototype.unstable_scheduleHydration = function (s) {
    if (s) {
      var o = ln();
      s = { blockedOn: null, target: s, priority: o };
      for (var d = 0; d < Yc.length && o !== 0 && o < Yc[d].priority; d++);
      Yc.splice(d, 0, s), d === 0 && ZM(s);
    }
  };
  var tE = t.version;
  if (tE !== "19.1.0") throw Error(n(527, tE, "19.1.0"));
  Q.findDOMNode = function (s) {
    var o = s._reactInternals;
    if (o === void 0)
      throw typeof s.render == "function"
        ? Error(n(188))
        : ((s = Object.keys(s).join(",")), Error(n(268, s)));
    return (
      (s = h(o)),
      (s = s !== null ? p(s) : null),
      (s = s === null ? null : s.stateNode),
      s
    );
  };
  var jD = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: j,
    reconcilerVersion: "19.1.0",
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Sv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Sv.isDisabled && Sv.supportsFiber)
      try {
        (Ft = Sv.inject(jD)), (Gt = Sv);
      } catch {}
  }
  return (
    (Em.createRoot = function (s, o) {
      if (!a(s)) throw Error(n(299));
      var d = !1,
        g = "",
        b = rf,
        T = Xh,
        z = iv,
        W = null;
      return (
        o != null &&
          (o.unstable_strictMode === !0 && (d = !0),
          o.identifierPrefix !== void 0 && (g = o.identifierPrefix),
          o.onUncaughtError !== void 0 && (b = o.onUncaughtError),
          o.onCaughtError !== void 0 && (T = o.onCaughtError),
          o.onRecoverableError !== void 0 && (z = o.onRecoverableError),
          o.unstable_transitionCallbacks !== void 0 &&
            (W = o.unstable_transitionCallbacks)),
        (o = jM(s, 1, !1, null, null, d, g, b, T, z, W, null)),
        (s[Ri] = o.current),
        N1(s),
        new Q1(o)
      );
    }),
    (Em.hydrateRoot = function (s, o, d) {
      if (!a(s)) throw Error(n(299));
      var g = !1,
        b = "",
        T = rf,
        z = Xh,
        W = iv,
        at = null,
        Ct = null;
      return (
        d != null &&
          (d.unstable_strictMode === !0 && (g = !0),
          d.identifierPrefix !== void 0 && (b = d.identifierPrefix),
          d.onUncaughtError !== void 0 && (T = d.onUncaughtError),
          d.onCaughtError !== void 0 && (z = d.onCaughtError),
          d.onRecoverableError !== void 0 && (W = d.onRecoverableError),
          d.unstable_transitionCallbacks !== void 0 &&
            (at = d.unstable_transitionCallbacks),
          d.formState !== void 0 && (Ct = d.formState)),
        (o = jM(s, 1, !0, o, d ?? null, g, b, T, z, W, at, Ct)),
        (o.context = XM(null)),
        (d = o.current),
        (g = Si()),
        (g = Le(g)),
        (b = mr(g)),
        (b.callback = null),
        to(d, b, g),
        (d = g),
        (o.current.lanes = d),
        ge(o, d),
        il(o),
        (s[Ri] = o.current),
        N1(s),
        new Av(o)
      );
    }),
    (Em.version = "19.1.0"),
    Em
  );
}
var uE;
function $D() {
  if (uE) return e_.exports;
  uE = 1;
  function i() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i);
      } catch (t) {
        console.error(t);
      }
  }
  return i(), (e_.exports = QD()), e_.exports;
}
var j2 = $D();
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const C0 = "177",
  Bf = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Df = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  X2 = 0,
  Nb = 1,
  W2 = 2,
  tU = 3,
  Y2 = 0,
  Ux = 1,
  Wm = 2,
  vo = 3,
  hl = 0,
  Ms = 1,
  or = 2,
  ol = 0,
  Xf = 1,
  Lb = 2,
  Ib = 3,
  Pb = 4,
  q2 = 5,
  su = 100,
  K2 = 101,
  J2 = 102,
  Z2 = 103,
  Q2 = 104,
  $2 = 200,
  tC = 201,
  eC = 202,
  nC = 203,
  Ny = 204,
  Ly = 205,
  iC = 206,
  aC = 207,
  sC = 208,
  rC = 209,
  oC = 210,
  lC = 211,
  cC = 212,
  uC = 213,
  fC = 214,
  Iy = 0,
  Py = 1,
  zy = 2,
  Jf = 3,
  Fy = 4,
  Hy = 5,
  Gy = 6,
  Vy = 7,
  R0 = 0,
  hC = 1,
  dC = 2,
  ll = 0,
  pC = 1,
  mC = 2,
  gC = 3,
  BA = 4,
  vC = 5,
  yC = 6,
  xC = 7,
  zb = "attached",
  _C = "detached",
  cu = 300,
  dl = 301,
  uu = 302,
  Vd = 303,
  l0 = 304,
  ip = 306,
  fu = 1e3,
  Ki = 1001,
  kd = 1002,
  Ta = 1003,
  Ox = 1004,
  eU = 1004,
  If = 1005,
  nU = 1005,
  Kn = 1006,
  Pd = 1007,
  iU = 1007,
  Nr = 1008,
  Fb = 1008,
  Es = 1009,
  Nx = 1010,
  Lx = 1011,
  jd = 1012,
  B0 = 1013,
  pl = 1014,
  Pi = 1015,
  Ea = 1016,
  Ix = 1017,
  Px = 1018,
  Xd = 1020,
  DA = 35902,
  UA = 1021,
  OA = 1022,
  Ji = 1023,
  Wd = 1026,
  Yd = 1027,
  D0 = 1028,
  U0 = 1029,
  NA = 1030,
  zx = 1031,
  aU = 1032,
  Fx = 1033,
  Ym = 33776,
  qm = 33777,
  Km = 33778,
  Jm = 33779,
  ky = 35840,
  jy = 35841,
  Xy = 35842,
  Wy = 35843,
  Yy = 36196,
  qy = 37492,
  Ky = 37496,
  Jy = 37808,
  Zy = 37809,
  Qy = 37810,
  $y = 37811,
  tx = 37812,
  ex = 37813,
  nx = 37814,
  ix = 37815,
  ax = 37816,
  sx = 37817,
  rx = 37818,
  ox = 37819,
  lx = 37820,
  cx = 37821,
  Zm = 36492,
  ux = 36494,
  fx = 36495,
  LA = 36283,
  hx = 36284,
  dx = 36285,
  px = 36286,
  bC = 2200,
  IA = 2201,
  AC = 2202,
  qd = 2300,
  Kd = 2301,
  Ey = 2302,
  Pf = 2400,
  zf = 2401,
  c0 = 2402,
  Hx = 2500,
  PA = 2501,
  SC = 0,
  zA = 1,
  mx = 2,
  MC = 3200,
  EC = 3201,
  sU = 3202,
  rU = 3203,
  vu = 0,
  TC = 1,
  ql = "",
  Fa = "srgb",
  bo = "srgb-linear",
  u0 = "linear",
  ai = "srgb",
  oU = 0,
  Uf = 7680,
  lU = 7681,
  cU = 7682,
  uU = 7683,
  fU = 34055,
  hU = 34056,
  dU = 5386,
  pU = 512,
  mU = 513,
  gU = 514,
  vU = 515,
  yU = 516,
  xU = 517,
  _U = 518,
  Hb = 519,
  wC = 512,
  CC = 513,
  RC = 514,
  FA = 515,
  BC = 516,
  DC = 517,
  UC = 518,
  OC = 519,
  f0 = 35044,
  bU = 35048,
  AU = 35040,
  SU = 35045,
  MU = 35049,
  EU = 35041,
  TU = 35046,
  wU = 35050,
  CU = 35042,
  RU = "100",
  Gb = "300 es",
  Lr = 2e3,
  h0 = 2001,
  BU = { COMPUTE: "compute", RENDER: "render" },
  DU = { PERSPECTIVE: "perspective", LINEAR: "linear", FLAT: "flat" },
  UU = {
    NORMAL: "normal",
    CENTROID: "centroid",
    SAMPLE: "sample",
    FLAT_FIRST: "flat first",
    FLAT_EITHER: "flat either",
  };
let ml = class {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }
  hasEventListener(t, e) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[t] !== void 0 && n[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    const n = this._listeners;
    if (n === void 0) return;
    const a = n[t];
    if (a !== void 0) {
      const r = a.indexOf(e);
      r !== -1 && a.splice(r, 1);
    }
  }
  dispatchEvent(t) {
    const e = this._listeners;
    if (e === void 0) return;
    const n = e[t.type];
    if (n !== void 0) {
      t.target = this;
      const a = n.slice(0);
      for (let r = 0, l = a.length; r < l; r++) a[r].call(this, t);
      t.target = null;
    }
  }
};
const $a = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let fE = 1234567;
const Wf = Math.PI / 180,
  Jd = 180 / Math.PI;
function lr() {
  const i = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    $a[i & 255] +
    $a[(i >> 8) & 255] +
    $a[(i >> 16) & 255] +
    $a[(i >> 24) & 255] +
    "-" +
    $a[t & 255] +
    $a[(t >> 8) & 255] +
    "-" +
    $a[((t >> 16) & 15) | 64] +
    $a[(t >> 24) & 255] +
    "-" +
    $a[(e & 63) | 128] +
    $a[(e >> 8) & 255] +
    "-" +
    $a[(e >> 16) & 255] +
    $a[(e >> 24) & 255] +
    $a[n & 255] +
    $a[(n >> 8) & 255] +
    $a[(n >> 16) & 255] +
    $a[(n >> 24) & 255]
  ).toLowerCase();
}
function dn(i, t, e) {
  return Math.max(t, Math.min(e, i));
}
function HA(i, t) {
  return ((i % t) + t) % t;
}
function OU(i, t, e, n, a) {
  return n + ((i - t) * (a - n)) / (e - t);
}
function NU(i, t, e) {
  return i !== t ? (e - i) / (t - i) : 0;
}
function Qm(i, t, e) {
  return (1 - e) * i + e * t;
}
function LU(i, t, e, n) {
  return Qm(i, t, 1 - Math.exp(-e * n));
}
function IU(i, t = 1) {
  return t - Math.abs(HA(i, t * 2) - t);
}
function PU(i, t, e) {
  return i <= t
    ? 0
    : i >= e
    ? 1
    : ((i = (i - t) / (e - t)), i * i * (3 - 2 * i));
}
function zU(i, t, e) {
  return i <= t
    ? 0
    : i >= e
    ? 1
    : ((i = (i - t) / (e - t)), i * i * i * (i * (i * 6 - 15) + 10));
}
function FU(i, t) {
  return i + Math.floor(Math.random() * (t - i + 1));
}
function HU(i, t) {
  return i + Math.random() * (t - i);
}
function GU(i) {
  return i * (0.5 - Math.random());
}
function VU(i) {
  i !== void 0 && (fE = i);
  let t = (fE += 1831565813);
  return (
    (t = Math.imul(t ^ (t >>> 15), t | 1)),
    (t ^= t + Math.imul(t ^ (t >>> 7), t | 61)),
    ((t ^ (t >>> 14)) >>> 0) / 4294967296
  );
}
function kU(i) {
  return i * Wf;
}
function jU(i) {
  return i * Jd;
}
function XU(i) {
  return (i & (i - 1)) === 0 && i !== 0;
}
function WU(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function YU(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function qU(i, t, e, n, a) {
  const r = Math.cos,
    l = Math.sin,
    u = r(e / 2),
    h = l(e / 2),
    p = r((t + n) / 2),
    m = l((t + n) / 2),
    v = r((t - n) / 2),
    x = l((t - n) / 2),
    _ = r((n - t) / 2),
    M = l((n - t) / 2);
  switch (a) {
    case "XYX":
      i.set(u * m, h * v, h * x, u * p);
      break;
    case "YZY":
      i.set(h * x, u * m, h * v, u * p);
      break;
    case "ZXZ":
      i.set(h * v, h * x, u * m, u * p);
      break;
    case "XZX":
      i.set(u * m, h * M, h * _, u * p);
      break;
    case "YXY":
      i.set(h * _, u * m, h * M, u * p);
      break;
    case "ZYZ":
      i.set(h * M, h * _, u * m, u * p);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          a
      );
  }
}
function As(i, t) {
  switch (t.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function bn(i, t) {
  switch (t.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const NC = {
  DEG2RAD: Wf,
  RAD2DEG: Jd,
  generateUUID: lr,
  clamp: dn,
  euclideanModulo: HA,
  mapLinear: OU,
  inverseLerp: NU,
  lerp: Qm,
  damp: LU,
  pingpong: IU,
  smoothstep: PU,
  smootherstep: zU,
  randInt: FU,
  randFloat: HU,
  randFloatSpread: GU,
  seededRandom: VU,
  degToRad: kU,
  radToDeg: jU,
  isPowerOfTwo: XU,
  ceilPowerOfTwo: WU,
  floorPowerOfTwo: YU,
  setQuaternionFromProperEuler: qU,
  normalize: bn,
  denormalize: As,
};
class Yt {
  constructor(t = 0, e = 0) {
    (Yt.prototype.isVector2 = !0), (this.x = t), (this.y = e);
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this;
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this;
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this;
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this;
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      a = t.elements;
    return (
      (this.x = a[0] * e + a[3] * n + a[6]),
      (this.y = a[1] * e + a[4] * n + a[7]),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
    );
  }
  clamp(t, e) {
    return (
      (this.x = dn(this.x, t.x, e.x)), (this.y = dn(this.y, t.y, e.y)), this
    );
  }
  clampScalar(t, e) {
    return (this.x = dn(this.x, t, e)), (this.y = dn(this.y, t, e)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, t, e));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(dn(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y;
    return e * e + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), t;
  }
  fromBufferAttribute(t, e) {
    return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
  }
  rotateAround(t, e) {
    const n = Math.cos(e),
      a = Math.sin(e),
      r = this.x - t.x,
      l = this.y - t.y;
    return (this.x = r * n - l * a + t.x), (this.y = r * a + l * n + t.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class pa {
  constructor(t = 0, e = 0, n = 0, a = 1) {
    (this.isQuaternion = !0),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = a);
  }
  static slerpFlat(t, e, n, a, r, l, u) {
    let h = n[a + 0],
      p = n[a + 1],
      m = n[a + 2],
      v = n[a + 3];
    const x = r[l + 0],
      _ = r[l + 1],
      M = r[l + 2],
      C = r[l + 3];
    if (u === 0) {
      (t[e + 0] = h), (t[e + 1] = p), (t[e + 2] = m), (t[e + 3] = v);
      return;
    }
    if (u === 1) {
      (t[e + 0] = x), (t[e + 1] = _), (t[e + 2] = M), (t[e + 3] = C);
      return;
    }
    if (v !== C || h !== x || p !== _ || m !== M) {
      let E = 1 - u;
      const S = h * x + p * _ + m * M + v * C,
        R = S >= 0 ? 1 : -1,
        B = 1 - S * S;
      if (B > Number.EPSILON) {
        const I = Math.sqrt(B),
          P = Math.atan2(I, S * R);
        (E = Math.sin(E * P) / I), (u = Math.sin(u * P) / I);
      }
      const D = u * R;
      if (
        ((h = h * E + x * D),
        (p = p * E + _ * D),
        (m = m * E + M * D),
        (v = v * E + C * D),
        E === 1 - u)
      ) {
        const I = 1 / Math.sqrt(h * h + p * p + m * m + v * v);
        (h *= I), (p *= I), (m *= I), (v *= I);
      }
    }
    (t[e] = h), (t[e + 1] = p), (t[e + 2] = m), (t[e + 3] = v);
  }
  static multiplyQuaternionsFlat(t, e, n, a, r, l) {
    const u = n[a],
      h = n[a + 1],
      p = n[a + 2],
      m = n[a + 3],
      v = r[l],
      x = r[l + 1],
      _ = r[l + 2],
      M = r[l + 3];
    return (
      (t[e] = u * M + m * v + h * _ - p * x),
      (t[e + 1] = h * M + m * x + p * v - u * _),
      (t[e + 2] = p * M + m * _ + u * x - h * v),
      (t[e + 3] = m * M - u * v - h * x - p * _),
      t
    );
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    (this._w = t), this._onChangeCallback();
  }
  set(t, e, n, a) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = a),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(t, e = !0) {
    const n = t._x,
      a = t._y,
      r = t._z,
      l = t._order,
      u = Math.cos,
      h = Math.sin,
      p = u(n / 2),
      m = u(a / 2),
      v = u(r / 2),
      x = h(n / 2),
      _ = h(a / 2),
      M = h(r / 2);
    switch (l) {
      case "XYZ":
        (this._x = x * m * v + p * _ * M),
          (this._y = p * _ * v - x * m * M),
          (this._z = p * m * M + x * _ * v),
          (this._w = p * m * v - x * _ * M);
        break;
      case "YXZ":
        (this._x = x * m * v + p * _ * M),
          (this._y = p * _ * v - x * m * M),
          (this._z = p * m * M - x * _ * v),
          (this._w = p * m * v + x * _ * M);
        break;
      case "ZXY":
        (this._x = x * m * v - p * _ * M),
          (this._y = p * _ * v + x * m * M),
          (this._z = p * m * M + x * _ * v),
          (this._w = p * m * v - x * _ * M);
        break;
      case "ZYX":
        (this._x = x * m * v - p * _ * M),
          (this._y = p * _ * v + x * m * M),
          (this._z = p * m * M - x * _ * v),
          (this._w = p * m * v + x * _ * M);
        break;
      case "YZX":
        (this._x = x * m * v + p * _ * M),
          (this._y = p * _ * v + x * m * M),
          (this._z = p * m * M - x * _ * v),
          (this._w = p * m * v - x * _ * M);
        break;
      case "XZY":
        (this._x = x * m * v - p * _ * M),
          (this._y = p * _ * v - x * m * M),
          (this._z = p * m * M + x * _ * v),
          (this._w = p * m * v + x * _ * M);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l
        );
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const n = e / 2,
      a = Math.sin(n);
    return (
      (this._x = t.x * a),
      (this._y = t.y * a),
      (this._z = t.z * a),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      n = e[0],
      a = e[4],
      r = e[8],
      l = e[1],
      u = e[5],
      h = e[9],
      p = e[2],
      m = e[6],
      v = e[10],
      x = n + u + v;
    if (x > 0) {
      const _ = 0.5 / Math.sqrt(x + 1);
      (this._w = 0.25 / _),
        (this._x = (m - h) * _),
        (this._y = (r - p) * _),
        (this._z = (l - a) * _);
    } else if (n > u && n > v) {
      const _ = 2 * Math.sqrt(1 + n - u - v);
      (this._w = (m - h) / _),
        (this._x = 0.25 * _),
        (this._y = (a + l) / _),
        (this._z = (r + p) / _);
    } else if (u > v) {
      const _ = 2 * Math.sqrt(1 + u - n - v);
      (this._w = (r - p) / _),
        (this._x = (a + l) / _),
        (this._y = 0.25 * _),
        (this._z = (h + m) / _);
    } else {
      const _ = 2 * Math.sqrt(1 + v - n - u);
      (this._w = (l - a) / _),
        (this._x = (r + p) / _),
        (this._y = (h + m) / _),
        (this._z = 0.25 * _);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(dn(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t);
    if (n === 0) return this;
    const a = Math.min(1, e / n);
    return this.slerp(t, a), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let t = this.length();
    return (
      t === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const n = t._x,
      a = t._y,
      r = t._z,
      l = t._w,
      u = e._x,
      h = e._y,
      p = e._z,
      m = e._w;
    return (
      (this._x = n * m + l * u + a * p - r * h),
      (this._y = a * m + l * h + r * u - n * p),
      (this._z = r * m + l * p + n * h - a * u),
      (this._w = l * m - n * u - a * h - r * p),
      this._onChangeCallback(),
      this
    );
  }
  slerp(t, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(t);
    const n = this._x,
      a = this._y,
      r = this._z,
      l = this._w;
    let u = l * t._w + n * t._x + a * t._y + r * t._z;
    if (
      (u < 0
        ? ((this._w = -t._w),
          (this._x = -t._x),
          (this._y = -t._y),
          (this._z = -t._z),
          (u = -u))
        : this.copy(t),
      u >= 1)
    )
      return (this._w = l), (this._x = n), (this._y = a), (this._z = r), this;
    const h = 1 - u * u;
    if (h <= Number.EPSILON) {
      const _ = 1 - e;
      return (
        (this._w = _ * l + e * this._w),
        (this._x = _ * n + e * this._x),
        (this._y = _ * a + e * this._y),
        (this._z = _ * r + e * this._z),
        this.normalize(),
        this
      );
    }
    const p = Math.sqrt(h),
      m = Math.atan2(p, u),
      v = Math.sin((1 - e) * m) / p,
      x = Math.sin(e * m) / p;
    return (
      (this._w = l * v + this._w * x),
      (this._x = n * v + this._x * x),
      (this._y = a * v + this._y * x),
      (this._z = r * v + this._z * x),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(t, e, n) {
    return this.copy(t).slerp(e, n);
  }
  random() {
    const t = 2 * Math.PI * Math.random(),
      e = 2 * Math.PI * Math.random(),
      n = Math.random(),
      a = Math.sqrt(1 - n),
      r = Math.sqrt(n);
    return this.set(
      a * Math.sin(t),
      a * Math.cos(t),
      r * Math.sin(e),
      r * Math.cos(e)
    );
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._w === this._w
    );
  }
  fromArray(t, e = 0) {
    return (
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._w),
      t
    );
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Z {
  constructor(t = 0, e = 0, n = 0) {
    (Z.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
  }
  set(t, e, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      this
    );
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
    );
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
    );
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this;
  }
  multiplyVectors(t, e) {
    return (
      (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
    );
  }
  applyEuler(t) {
    return this.applyQuaternion(hE.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(hE.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      a = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[3] * n + r[6] * a),
      (this.y = r[1] * e + r[4] * n + r[7] * a),
      (this.z = r[2] * e + r[5] * n + r[8] * a),
      this
    );
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      a = this.z,
      r = t.elements,
      l = 1 / (r[3] * e + r[7] * n + r[11] * a + r[15]);
    return (
      (this.x = (r[0] * e + r[4] * n + r[8] * a + r[12]) * l),
      (this.y = (r[1] * e + r[5] * n + r[9] * a + r[13]) * l),
      (this.z = (r[2] * e + r[6] * n + r[10] * a + r[14]) * l),
      this
    );
  }
  applyQuaternion(t) {
    const e = this.x,
      n = this.y,
      a = this.z,
      r = t.x,
      l = t.y,
      u = t.z,
      h = t.w,
      p = 2 * (l * a - u * n),
      m = 2 * (u * e - r * a),
      v = 2 * (r * n - l * e);
    return (
      (this.x = e + h * p + l * v - u * m),
      (this.y = n + h * m + u * p - r * v),
      (this.z = a + h * v + r * m - l * p),
      this
    );
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
      t.projectionMatrix
    );
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
      t.matrixWorld
    );
  }
  transformDirection(t) {
    const e = this.x,
      n = this.y,
      a = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[4] * n + r[8] * a),
      (this.y = r[1] * e + r[5] * n + r[9] * a),
      (this.z = r[2] * e + r[6] * n + r[10] * a),
      this.normalize()
    );
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = dn(this.x, t.x, e.x)),
      (this.y = dn(this.y, t.y, e.y)),
      (this.z = dn(this.z, t.z, e.z)),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = dn(this.x, t, e)),
      (this.y = dn(this.y, t, e)),
      (this.z = dn(this.z, t, e)),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, t, e));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    );
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      this
    );
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const n = t.x,
      a = t.y,
      r = t.z,
      l = e.x,
      u = e.y,
      h = e.z;
    return (
      (this.x = a * h - r * u),
      (this.y = r * l - n * h),
      (this.z = n * u - a * l),
      this
    );
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0) return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  }
  projectOnPlane(t) {
    return s_.copy(this).projectOnVector(t), this.sub(s_);
  }
  reflect(t) {
    return this.sub(s_.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(dn(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      a = this.z - t.z;
    return e * e + n * n + a * a;
  }
  manhattanDistanceTo(t) {
    return (
      Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    );
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, n) {
    const a = Math.sin(e) * t;
    return (
      (this.x = a * Math.sin(n)),
      (this.y = Math.cos(e) * t),
      (this.z = a * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, n) {
    return (
      (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
    );
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      n = this.setFromMatrixColumn(t, 1).length(),
      a = this.setFromMatrixColumn(t, 2).length();
    return (this.x = e), (this.y = n), (this.z = a), this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
  }
  setFromColor(t) {
    return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2,
      e = Math.random() * 2 - 1,
      n = Math.sqrt(1 - e * e);
    return (
      (this.x = n * Math.cos(t)), (this.y = e), (this.z = n * Math.sin(t)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const s_ = new Z(),
  hE = new pa();
class yn {
  constructor(t, e, n, a, r, l, u, h, p) {
    (yn.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      t !== void 0 && this.set(t, e, n, a, r, l, u, h, p);
  }
  set(t, e, n, a, r, l, u, h, p) {
    const m = this.elements;
    return (
      (m[0] = t),
      (m[1] = a),
      (m[2] = u),
      (m[3] = e),
      (m[4] = r),
      (m[5] = h),
      (m[6] = n),
      (m[7] = l),
      (m[8] = p),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      this
    );
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return (
      this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    );
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      a = e.elements,
      r = this.elements,
      l = n[0],
      u = n[3],
      h = n[6],
      p = n[1],
      m = n[4],
      v = n[7],
      x = n[2],
      _ = n[5],
      M = n[8],
      C = a[0],
      E = a[3],
      S = a[6],
      R = a[1],
      B = a[4],
      D = a[7],
      I = a[2],
      P = a[5],
      V = a[8];
    return (
      (r[0] = l * C + u * R + h * I),
      (r[3] = l * E + u * B + h * P),
      (r[6] = l * S + u * D + h * V),
      (r[1] = p * C + m * R + v * I),
      (r[4] = p * E + m * B + v * P),
      (r[7] = p * S + m * D + v * V),
      (r[2] = x * C + _ * R + M * I),
      (r[5] = x * E + _ * B + M * P),
      (r[8] = x * S + _ * D + M * V),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      a = t[2],
      r = t[3],
      l = t[4],
      u = t[5],
      h = t[6],
      p = t[7],
      m = t[8];
    return (
      e * l * m - e * u * p - n * r * m + n * u * h + a * r * p - a * l * h
    );
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      a = t[2],
      r = t[3],
      l = t[4],
      u = t[5],
      h = t[6],
      p = t[7],
      m = t[8],
      v = m * l - u * p,
      x = u * h - m * r,
      _ = p * r - l * h,
      M = e * v + n * x + a * _;
    if (M === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / M;
    return (
      (t[0] = v * C),
      (t[1] = (a * p - m * n) * C),
      (t[2] = (u * n - a * l) * C),
      (t[3] = x * C),
      (t[4] = (m * e - a * h) * C),
      (t[5] = (a * r - u * e) * C),
      (t[6] = _ * C),
      (t[7] = (n * h - p * e) * C),
      (t[8] = (l * e - n * r) * C),
      this
    );
  }
  transpose() {
    let t;
    const e = this.elements;
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    );
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    );
  }
  setUvTransform(t, e, n, a, r, l, u) {
    const h = Math.cos(r),
      p = Math.sin(r);
    return (
      this.set(
        n * h,
        n * p,
        -n * (h * l + p * u) + l + t,
        -a * p,
        a * h,
        -a * (-p * l + h * u) + u + e,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(t, e) {
    return this.premultiply(r_.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(r_.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(r_.makeTranslation(t, e)), this;
  }
  makeTranslation(t, e) {
    return (
      t.isVector2
        ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
        : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
      this
    );
  }
  makeRotation(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
  }
  equals(t) {
    const e = this.elements,
      n = t.elements;
    for (let a = 0; a < 9; a++) if (e[a] !== n[a]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      t
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const r_ = new yn();
function LC(i) {
  for (let t = i.length - 1; t >= 0; --t) if (i[t] >= 65535) return !0;
  return !1;
}
const KU = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Bd(i, t) {
  return new KU[i](t);
}
function d0(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function IC() {
  const i = d0("canvas");
  return (i.style.display = "block"), i;
}
const dE = {};
function zd(i) {
  i in dE || ((dE[i] = !0), console.warn(i));
}
function JU(i, t, e) {
  return new Promise(function (n, a) {
    function r() {
      switch (i.clientWaitSync(t, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case i.WAIT_FAILED:
          a();
          break;
        case i.TIMEOUT_EXPIRED:
          setTimeout(r, e);
          break;
        default:
          n();
      }
    }
    setTimeout(r, e);
  });
}
function ZU(i) {
  const t = i.elements;
  (t[2] = 0.5 * t[2] + 0.5 * t[3]),
    (t[6] = 0.5 * t[6] + 0.5 * t[7]),
    (t[10] = 0.5 * t[10] + 0.5 * t[11]),
    (t[14] = 0.5 * t[14] + 0.5 * t[15]);
}
function QU(i) {
  const t = i.elements;
  t[11] === -1
    ? ((t[10] = -t[10] - 1), (t[14] = -t[14]))
    : ((t[10] = -t[10]), (t[14] = -t[14] + 1));
}
const pE = new yn().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  mE = new yn().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
function $U() {
  const i = {
      enabled: !0,
      workingColorSpace: bo,
      spaces: {},
      convert: function (a, r, l) {
        return (
          this.enabled === !1 ||
            r === l ||
            !r ||
            !l ||
            (this.spaces[r].transfer === ai &&
              ((a.r = Ql(a.r)), (a.g = Ql(a.g)), (a.b = Ql(a.b))),
            this.spaces[r].primaries !== this.spaces[l].primaries &&
              (a.applyMatrix3(this.spaces[r].toXYZ),
              a.applyMatrix3(this.spaces[l].fromXYZ)),
            this.spaces[l].transfer === ai &&
              ((a.r = Fd(a.r)), (a.g = Fd(a.g)), (a.b = Fd(a.b)))),
          a
        );
      },
      workingToColorSpace: function (a, r) {
        return this.convert(a, this.workingColorSpace, r);
      },
      colorSpaceToWorking: function (a, r) {
        return this.convert(a, r, this.workingColorSpace);
      },
      getPrimaries: function (a) {
        return this.spaces[a].primaries;
      },
      getTransfer: function (a) {
        return a === ql ? u0 : this.spaces[a].transfer;
      },
      getLuminanceCoefficients: function (a, r = this.workingColorSpace) {
        return a.fromArray(this.spaces[r].luminanceCoefficients);
      },
      define: function (a) {
        Object.assign(this.spaces, a);
      },
      _getMatrix: function (a, r, l) {
        return a.copy(this.spaces[r].toXYZ).multiply(this.spaces[l].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (a) {
        return this.spaces[a].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (a = this.workingColorSpace) {
        return this.spaces[a].workingColorSpaceConfig.unpackColorSpace;
      },
      fromWorkingColorSpace: function (a, r) {
        return (
          zd(
            "THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."
          ),
          i.workingToColorSpace(a, r)
        );
      },
      toWorkingColorSpace: function (a, r) {
        return (
          zd(
            "THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."
          ),
          i.colorSpaceToWorking(a, r)
        );
      },
    },
    t = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    e = [0.2126, 0.7152, 0.0722],
    n = [0.3127, 0.329];
  return (
    i.define({
      [bo]: {
        primaries: t,
        whitePoint: n,
        transfer: u0,
        toXYZ: pE,
        fromXYZ: mE,
        luminanceCoefficients: e,
        workingColorSpaceConfig: { unpackColorSpace: Fa },
        outputColorSpaceConfig: { drawingBufferColorSpace: Fa },
      },
      [Fa]: {
        primaries: t,
        whitePoint: n,
        transfer: ai,
        toXYZ: pE,
        fromXYZ: mE,
        luminanceCoefficients: e,
        outputColorSpaceConfig: { drawingBufferColorSpace: Fa },
      },
    }),
    i
  );
}
const In = $U();
function Ql(i) {
  return i < 0.04045
    ? i * 0.0773993808
    : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function Fd(i) {
  return i < 0.0031308 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let ld;
class PC {
  static getDataURL(t, e = "image/png") {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
    let n;
    if (t instanceof HTMLCanvasElement) n = t;
    else {
      ld === void 0 && (ld = d0("canvas")),
        (ld.width = t.width),
        (ld.height = t.height);
      const a = ld.getContext("2d");
      t instanceof ImageData
        ? a.putImageData(t, 0, 0)
        : a.drawImage(t, 0, 0, t.width, t.height),
        (n = ld);
    }
    return n.toDataURL(e);
  }
  static sRGBToLinear(t) {
    if (
      (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ) {
      const e = d0("canvas");
      (e.width = t.width), (e.height = t.height);
      const n = e.getContext("2d");
      n.drawImage(t, 0, 0, t.width, t.height);
      const a = n.getImageData(0, 0, t.width, t.height),
        r = a.data;
      for (let l = 0; l < r.length; l++) r[l] = Ql(r[l] / 255) * 255;
      return n.putImageData(a, 0, 0), e;
    } else if (t.data) {
      const e = t.data.slice(0);
      for (let n = 0; n < e.length; n++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray
          ? (e[n] = Math.floor(Ql(e[n] / 255) * 255))
          : (e[n] = Ql(e[n]));
      return { data: e, width: t.width, height: t.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        t
      );
  }
}
let tO = 0;
class ru {
  constructor(t = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: tO++ }),
      (this.uuid = lr()),
      (this.data = t),
      (this.dataReady = !0),
      (this.version = 0);
  }
  getSize(t) {
    const e = this.data;
    return (
      e instanceof HTMLVideoElement
        ? t.set(e.videoWidth, e.videoHeight)
        : e !== null
        ? t.set(e.width, e.height, e.depth || 0)
        : t.set(0, 0, 0),
      t
    );
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      a = this.data;
    if (a !== null) {
      let r;
      if (Array.isArray(a)) {
        r = [];
        for (let l = 0, u = a.length; l < u; l++)
          a[l].isDataTexture ? r.push(o_(a[l].image)) : r.push(o_(a[l]));
      } else r = o_(a);
      n.url = r;
    }
    return e || (t.images[this.uuid] = n), n;
  }
}
function o_(i) {
  return (typeof HTMLImageElement < "u" && i instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && i instanceof ImageBitmap)
    ? PC.getDataURL(i)
    : i.data
    ? {
        data: Array.from(i.data),
        width: i.width,
        height: i.height,
        type: i.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let eO = 0;
const l_ = new Z();
class Zn extends ml {
  constructor(
    t = Zn.DEFAULT_IMAGE,
    e = Zn.DEFAULT_MAPPING,
    n = Ki,
    a = Ki,
    r = Kn,
    l = Nr,
    u = Ji,
    h = Es,
    p = Zn.DEFAULT_ANISOTROPY,
    m = ql
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: eO++ }),
      (this.uuid = lr()),
      (this.name = ""),
      (this.source = new ru(t)),
      (this.mipmaps = []),
      (this.mapping = e),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = a),
      (this.magFilter = r),
      (this.minFilter = l),
      (this.anisotropy = p),
      (this.format = u),
      (this.internalFormat = null),
      (this.type = h),
      (this.offset = new Yt(0, 0)),
      (this.repeat = new Yt(1, 1)),
      (this.center = new Yt(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new yn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = m),
      (this.userData = {}),
      (this.updateRanges = []),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.isArrayTexture = !!(t && t.depth && t.depth > 1)),
      (this.pmremVersion = 0);
  }
  get width() {
    return this.source.getSize(l_).x;
  }
  get height() {
    return this.source.getSize(l_).y;
  }
  get depth() {
    return this.source.getSize(l_).z;
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.source = t.source),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.channel = t.channel),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.colorSpace = t.colorSpace),
      (this.renderTarget = t.renderTarget),
      (this.isRenderTargetTexture = t.isRenderTargetTexture),
      (this.isArrayTexture = t.isArrayTexture),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  setValues(t) {
    for (const e in t) {
      const n = t[e];
      if (n === void 0) {
        console.warn(
          `THREE.Texture.setValues(): parameter '${e}' has value of undefined.`
        );
        continue;
      }
      const a = this[e];
      if (a === void 0) {
        console.warn(
          `THREE.Texture.setValues(): property '${e}' does not exist.`
        );
        continue;
      }
      (a && n && a.isVector2 && n.isVector2) ||
      (a && n && a.isVector3 && n.isVector3) ||
      (a && n && a.isMatrix3 && n.isMatrix3)
        ? a.copy(n)
        : (this[e] = n);
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
    const n = {
      metadata: { version: 4.7, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      e || (t.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== cu) return t;
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case fu:
          t.x = t.x - Math.floor(t.x);
          break;
        case Ki:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case kd:
          Math.abs(Math.floor(t.x) % 2) === 1
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x));
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case fu:
          t.y = t.y - Math.floor(t.y);
          break;
        case Ki:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case kd:
          Math.abs(Math.floor(t.y) % 2) === 1
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y));
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(t) {
    t === !0 && this.pmremVersion++;
  }
}
Zn.DEFAULT_IMAGE = null;
Zn.DEFAULT_MAPPING = cu;
Zn.DEFAULT_ANISOTROPY = 1;
class Hn {
  constructor(t = 0, e = 0, n = 0, a = 1) {
    (Hn.prototype.isVector4 = !0),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      (this.w = a);
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, n, a) {
    return (this.x = t), (this.y = e), (this.z = n), (this.w = a), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setW(t) {
    return (this.w = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return (
      (this.x = t.x),
      (this.y = t.y),
      (this.z = t.z),
      (this.w = t.w !== void 0 ? t.w : 1),
      this
    );
  }
  add(t) {
    return (
      (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
    );
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x),
      (this.y = t.y + e.y),
      (this.z = t.z + e.z),
      (this.w = t.w + e.w),
      this
    );
  }
  addScaledVector(t, e) {
    return (
      (this.x += t.x * e),
      (this.y += t.y * e),
      (this.z += t.z * e),
      (this.w += t.w * e),
      this
    );
  }
  sub(t) {
    return (
      (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
    );
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x),
      (this.y = t.y - e.y),
      (this.z = t.z - e.z),
      (this.w = t.w - e.w),
      this
    );
  }
  multiply(t) {
    return (
      (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
    );
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      a = this.z,
      r = this.w,
      l = t.elements;
    return (
      (this.x = l[0] * e + l[4] * n + l[8] * a + l[12] * r),
      (this.y = l[1] * e + l[5] * n + l[9] * a + l[13] * r),
      (this.z = l[2] * e + l[6] * n + l[10] * a + l[14] * r),
      (this.w = l[3] * e + l[7] * n + l[11] * a + l[15] * r),
      this
    );
  }
  divide(t) {
    return (
      (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), (this.w /= t.w), this
    );
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, a, r;
    const h = t.elements,
      p = h[0],
      m = h[4],
      v = h[8],
      x = h[1],
      _ = h[5],
      M = h[9],
      C = h[2],
      E = h[6],
      S = h[10];
    if (
      Math.abs(m - x) < 0.01 &&
      Math.abs(v - C) < 0.01 &&
      Math.abs(M - E) < 0.01
    ) {
      if (
        Math.abs(m + x) < 0.1 &&
        Math.abs(v + C) < 0.1 &&
        Math.abs(M + E) < 0.1 &&
        Math.abs(p + _ + S - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const B = (p + 1) / 2,
        D = (_ + 1) / 2,
        I = (S + 1) / 2,
        P = (m + x) / 4,
        V = (v + C) / 4,
        F = (M + E) / 4;
      return (
        B > D && B > I
          ? B < 0.01
            ? ((n = 0), (a = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(B)), (a = P / n), (r = V / n))
          : D > I
          ? D < 0.01
            ? ((n = 0.707106781), (a = 0), (r = 0.707106781))
            : ((a = Math.sqrt(D)), (n = P / a), (r = F / a))
          : I < 0.01
          ? ((n = 0.707106781), (a = 0.707106781), (r = 0))
          : ((r = Math.sqrt(I)), (n = V / r), (a = F / r)),
        this.set(n, a, r, e),
        this
      );
    }
    let R = Math.sqrt(
      (E - M) * (E - M) + (v - C) * (v - C) + (x - m) * (x - m)
    );
    return (
      Math.abs(R) < 0.001 && (R = 1),
      (this.x = (E - M) / R),
      (this.y = (v - C) / R),
      (this.z = (x - m) / R),
      (this.w = Math.acos((p + _ + S - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return (
      (this.x = e[12]),
      (this.y = e[13]),
      (this.z = e[14]),
      (this.w = e[15]),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = dn(this.x, t.x, e.x)),
      (this.y = dn(this.y, t.y, e.y)),
      (this.z = dn(this.z, t.z, e.z)),
      (this.w = dn(this.w, t.w, e.w)),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = dn(this.x, t, e)),
      (this.y = dn(this.y, t, e)),
      (this.z = dn(this.z, t, e)),
      (this.w = dn(this.w, t, e)),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, t, e));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    );
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      (this.w = t.w + (e.w - t.w) * n),
      this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return (
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      (this.w = t[e + 3]),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      (t[e + 3] = this.w),
      t
    );
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class GA extends ml {
  constructor(t = 1, e = 1, n = {}) {
    super(),
      (n = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: Kn,
          depthBuffer: !0,
          stencilBuffer: !1,
          resolveDepthBuffer: !0,
          resolveStencilBuffer: !0,
          depthTexture: null,
          samples: 0,
          count: 1,
          depth: 1,
          multiview: !1,
        },
        n
      )),
      (this.isRenderTarget = !0),
      (this.width = t),
      (this.height = e),
      (this.depth = n.depth),
      (this.scissor = new Hn(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new Hn(0, 0, t, e));
    const a = { width: t, height: e, depth: n.depth },
      r = new Zn(a);
    this.textures = [];
    const l = n.count;
    for (let u = 0; u < l; u++)
      (this.textures[u] = r.clone()),
        (this.textures[u].isRenderTargetTexture = !0),
        (this.textures[u].renderTarget = this);
    this._setTextureOptions(n),
      (this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples),
      (this.multiview = n.multiview);
  }
  _setTextureOptions(t = {}) {
    const e = {
      minFilter: Kn,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null,
    };
    t.mapping !== void 0 && (e.mapping = t.mapping),
      t.wrapS !== void 0 && (e.wrapS = t.wrapS),
      t.wrapT !== void 0 && (e.wrapT = t.wrapT),
      t.wrapR !== void 0 && (e.wrapR = t.wrapR),
      t.magFilter !== void 0 && (e.magFilter = t.magFilter),
      t.minFilter !== void 0 && (e.minFilter = t.minFilter),
      t.format !== void 0 && (e.format = t.format),
      t.type !== void 0 && (e.type = t.type),
      t.anisotropy !== void 0 && (e.anisotropy = t.anisotropy),
      t.colorSpace !== void 0 && (e.colorSpace = t.colorSpace),
      t.flipY !== void 0 && (e.flipY = t.flipY),
      t.generateMipmaps !== void 0 && (e.generateMipmaps = t.generateMipmaps),
      t.internalFormat !== void 0 && (e.internalFormat = t.internalFormat);
    for (let n = 0; n < this.textures.length; n++)
      this.textures[n].setValues(e);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(t) {
    this.textures[0] = t;
  }
  set depthTexture(t) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      t !== null && (t.renderTarget = this),
      (this._depthTexture = t);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(t, e, n = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n) {
      (this.width = t), (this.height = e), (this.depth = n);
      for (let a = 0, r = this.textures.length; a < r; a++)
        (this.textures[a].image.width = t),
          (this.textures[a].image.height = e),
          (this.textures[a].image.depth = n),
          (this.textures[a].isArrayTexture = this.textures[a].image.depth > 1);
      this.dispose();
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.scissor.copy(t.scissor),
      (this.scissorTest = t.scissorTest),
      this.viewport.copy(t.viewport),
      (this.textures.length = 0);
    for (let e = 0, n = t.textures.length; e < n; e++) {
      (this.textures[e] = t.textures[e].clone()),
        (this.textures[e].isRenderTargetTexture = !0),
        (this.textures[e].renderTarget = this);
      const a = Object.assign({}, t.textures[e].image);
      this.textures[e].source = new ru(a);
    }
    return (
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.resolveDepthBuffer = t.resolveDepthBuffer),
      (this.resolveStencilBuffer = t.resolveStencilBuffer),
      t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()),
      (this.samples = t.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class zr extends GA {
  constructor(t = 1, e = 1, n = {}) {
    super(t, e, n), (this.isWebGLRenderTarget = !0);
  }
}
class Gx extends Zn {
  constructor(t = null, e = 1, n = 1, a = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: t, width: e, height: n, depth: a }),
      (this.magFilter = Ta),
      (this.minFilter = Ta),
      (this.wrapR = Ki),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class nO extends zr {
  constructor(t = 1, e = 1, n = 1, a = {}) {
    super(t, e, a),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Gx(null, t, e, n)),
      this._setTextureOptions(a),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Vx extends Zn {
  constructor(t = null, e = 1, n = 1, a = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: t, width: e, height: n, depth: a }),
      (this.magFilter = Ta),
      (this.minFilter = Ta),
      (this.wrapR = Ki),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class iO extends zr {
  constructor(t = 1, e = 1, n = 1, a = {}) {
    super(t, e, a),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Vx(null, t, e, n)),
      this._setTextureOptions(a),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Ha {
  constructor(
    t = new Z(1 / 0, 1 / 0, 1 / 0),
    e = new Z(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = t), (this.max = e);
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e += 3)
      this.expandByPoint(fo.fromArray(t, e));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let e = 0, n = t.count; e < n; e++)
      this.expandByPoint(fo.fromBufferAttribute(t, e));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = fo.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(t) {
    return this.isEmpty()
      ? t.set(0, 0, 0)
      : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1);
    const n = t.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (e === !0 && r !== void 0 && t.isInstancedMesh !== !0)
        for (let l = 0, u = r.count; l < u; l++)
          t.isMesh === !0
            ? t.getVertexPosition(l, fo)
            : fo.fromBufferAttribute(r, l),
            fo.applyMatrix4(t.matrixWorld),
            this.expandByPoint(fo);
      else
        t.boundingBox !== void 0
          ? (t.boundingBox === null && t.computeBoundingBox(),
            Mv.copy(t.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(),
            Mv.copy(n.boundingBox)),
          Mv.applyMatrix4(t.matrixWorld),
          this.union(Mv);
    }
    const a = t.children;
    for (let r = 0, l = a.length; r < l; r++) this.expandByObject(a[r], e);
    return this;
  }
  containsPoint(t) {
    return (
      t.x >= this.min.x &&
      t.x <= this.max.x &&
      t.y >= this.min.y &&
      t.y <= this.max.y &&
      t.z >= this.min.z &&
      t.z <= this.max.z
    );
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    );
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return (
      t.max.x >= this.min.x &&
      t.min.x <= this.max.x &&
      t.max.y >= this.min.y &&
      t.min.y <= this.max.y &&
      t.max.z >= this.min.z &&
      t.min.z <= this.max.z
    );
  }
  intersectsSphere(t) {
    return (
      this.clampPoint(t.center, fo),
      fo.distanceToSquared(t.center) <= t.radius * t.radius
    );
  }
  intersectsPlane(t) {
    let e, n;
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
      e <= -t.constant && n >= -t.constant
    );
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1;
    this.getCenter(Tm),
      Ev.subVectors(this.max, Tm),
      cd.subVectors(t.a, Tm),
      ud.subVectors(t.b, Tm),
      fd.subVectors(t.c, Tm),
      Kc.subVectors(ud, cd),
      Jc.subVectors(fd, ud),
      pf.subVectors(cd, fd);
    let e = [
      0,
      -Kc.z,
      Kc.y,
      0,
      -Jc.z,
      Jc.y,
      0,
      -pf.z,
      pf.y,
      Kc.z,
      0,
      -Kc.x,
      Jc.z,
      0,
      -Jc.x,
      pf.z,
      0,
      -pf.x,
      -Kc.y,
      Kc.x,
      0,
      -Jc.y,
      Jc.x,
      0,
      -pf.y,
      pf.x,
      0,
    ];
    return !c_(e, cd, ud, fd, Ev) ||
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !c_(e, cd, ud, fd, Ev))
      ? !1
      : (Tv.crossVectors(Kc, Jc),
        (e = [Tv.x, Tv.y, Tv.z]),
        c_(e, cd, ud, fd, Ev));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, fo).distanceTo(t);
  }
  getBoundingSphere(t) {
    return (
      this.isEmpty()
        ? t.makeEmpty()
        : (this.getCenter(t.center),
          (t.radius = this.getSize(fo).length() * 0.5)),
      t
    );
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty()
      ? this
      : (Fl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        Fl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        Fl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        Fl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        Fl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        Fl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        Fl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        Fl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(Fl),
        this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
  toJSON() {
    return { min: this.min.toArray(), max: this.max.toArray() };
  }
  fromJSON(t) {
    return this.min.fromArray(t.min), this.max.fromArray(t.max), this;
  }
}
const Fl = [
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
    new Z(),
  ],
  fo = new Z(),
  Mv = new Ha(),
  cd = new Z(),
  ud = new Z(),
  fd = new Z(),
  Kc = new Z(),
  Jc = new Z(),
  pf = new Z(),
  Tm = new Z(),
  Ev = new Z(),
  Tv = new Z(),
  mf = new Z();
function c_(i, t, e, n, a) {
  for (let r = 0, l = i.length - 3; r <= l; r += 3) {
    mf.fromArray(i, r);
    const u =
        a.x * Math.abs(mf.x) + a.y * Math.abs(mf.y) + a.z * Math.abs(mf.z),
      h = t.dot(mf),
      p = e.dot(mf),
      m = n.dot(mf);
    if (Math.max(-Math.max(h, p, m), Math.min(h, p, m)) > u) return !1;
  }
  return !0;
}
const aO = new Ha(),
  wm = new Z(),
  u_ = new Z();
class wa {
  constructor(t = new Z(), e = -1) {
    (this.isSphere = !0), (this.center = t), (this.radius = e);
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this;
  }
  setFromPoints(t, e) {
    const n = this.center;
    e !== void 0 ? n.copy(e) : aO.setFromPoints(t).getCenter(n);
    let a = 0;
    for (let r = 0, l = t.length; r < l; r++)
      a = Math.max(a, n.distanceToSquared(t[r]));
    return (this.radius = Math.sqrt(a)), this;
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t);
    return (
      e.copy(t),
      n > this.radius * this.radius &&
        (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center)),
      e
    );
  }
  getBoundingBox(t) {
    return this.isEmpty()
      ? (t.makeEmpty(), t)
      : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return (
      this.center.applyMatrix4(t),
      (this.radius = this.radius * t.getMaxScaleOnAxis()),
      this
    );
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
    wm.subVectors(t, this.center);
    const e = wm.lengthSq();
    if (e > this.radius * this.radius) {
      const n = Math.sqrt(e),
        a = (n - this.radius) * 0.5;
      this.center.addScaledVector(wm, a / n), (this.radius += a);
    }
    return this;
  }
  union(t) {
    return t.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(t), this)
      : (this.center.equals(t.center) === !0
          ? (this.radius = Math.max(this.radius, t.radius))
          : (u_.subVectors(t.center, this.center).setLength(t.radius),
            this.expandByPoint(wm.copy(t.center).add(u_)),
            this.expandByPoint(wm.copy(t.center).sub(u_))),
        this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    return { radius: this.radius, center: this.center.toArray() };
  }
  fromJSON(t) {
    return (this.radius = t.radius), this.center.fromArray(t.center), this;
  }
}
const Hl = new Z(),
  f_ = new Z(),
  wv = new Z(),
  Zc = new Z(),
  h_ = new Z(),
  Cv = new Z(),
  d_ = new Z();
class ih {
  constructor(t = new Z(), e = new Z(0, 0, -1)) {
    (this.origin = t), (this.direction = e);
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, Hl)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0
      ? e.copy(this.origin)
      : e.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = Hl.subVectors(t, this.origin).dot(this.direction);
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (Hl.copy(this.origin).addScaledVector(this.direction, e),
        Hl.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, n, a) {
    f_.copy(t).add(e).multiplyScalar(0.5),
      wv.copy(e).sub(t).normalize(),
      Zc.copy(this.origin).sub(f_);
    const r = t.distanceTo(e) * 0.5,
      l = -this.direction.dot(wv),
      u = Zc.dot(this.direction),
      h = -Zc.dot(wv),
      p = Zc.lengthSq(),
      m = Math.abs(1 - l * l);
    let v, x, _, M;
    if (m > 0)
      if (((v = l * h - u), (x = l * u - h), (M = r * m), v >= 0))
        if (x >= -M)
          if (x <= M) {
            const C = 1 / m;
            (v *= C),
              (x *= C),
              (_ = v * (v + l * x + 2 * u) + x * (l * v + x + 2 * h) + p);
          } else
            (x = r),
              (v = Math.max(0, -(l * x + u))),
              (_ = -v * v + x * (x + 2 * h) + p);
        else
          (x = -r),
            (v = Math.max(0, -(l * x + u))),
            (_ = -v * v + x * (x + 2 * h) + p);
      else
        x <= -M
          ? ((v = Math.max(0, -(-l * r + u))),
            (x = v > 0 ? -r : Math.min(Math.max(-r, -h), r)),
            (_ = -v * v + x * (x + 2 * h) + p))
          : x <= M
          ? ((v = 0),
            (x = Math.min(Math.max(-r, -h), r)),
            (_ = x * (x + 2 * h) + p))
          : ((v = Math.max(0, -(l * r + u))),
            (x = v > 0 ? r : Math.min(Math.max(-r, -h), r)),
            (_ = -v * v + x * (x + 2 * h) + p));
    else
      (x = l > 0 ? -r : r),
        (v = Math.max(0, -(l * x + u))),
        (_ = -v * v + x * (x + 2 * h) + p);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, v),
      a && a.copy(f_).addScaledVector(wv, x),
      _
    );
  }
  intersectSphere(t, e) {
    Hl.subVectors(t.center, this.origin);
    const n = Hl.dot(this.direction),
      a = Hl.dot(Hl) - n * n,
      r = t.radius * t.radius;
    if (a > r) return null;
    const l = Math.sqrt(r - a),
      u = n - l,
      h = n + l;
    return h < 0 ? null : u < 0 ? this.at(h, e) : this.at(u, e);
  }
  intersectsSphere(t) {
    return t.radius < 0
      ? !1
      : this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t);
    return n === null ? null : this.at(n, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let n, a, r, l, u, h;
    const p = 1 / this.direction.x,
      m = 1 / this.direction.y,
      v = 1 / this.direction.z,
      x = this.origin;
    return (
      p >= 0
        ? ((n = (t.min.x - x.x) * p), (a = (t.max.x - x.x) * p))
        : ((n = (t.max.x - x.x) * p), (a = (t.min.x - x.x) * p)),
      m >= 0
        ? ((r = (t.min.y - x.y) * m), (l = (t.max.y - x.y) * m))
        : ((r = (t.max.y - x.y) * m), (l = (t.min.y - x.y) * m)),
      n > l ||
      r > a ||
      ((r > n || isNaN(n)) && (n = r),
      (l < a || isNaN(a)) && (a = l),
      v >= 0
        ? ((u = (t.min.z - x.z) * v), (h = (t.max.z - x.z) * v))
        : ((u = (t.max.z - x.z) * v), (h = (t.min.z - x.z) * v)),
      n > h || u > a) ||
      ((u > n || n !== n) && (n = u), (h < a || a !== a) && (a = h), a < 0)
        ? null
        : this.at(n >= 0 ? n : a, e)
    );
  }
  intersectsBox(t) {
    return this.intersectBox(t, Hl) !== null;
  }
  intersectTriangle(t, e, n, a, r) {
    h_.subVectors(e, t), Cv.subVectors(n, t), d_.crossVectors(h_, Cv);
    let l = this.direction.dot(d_),
      u;
    if (l > 0) {
      if (a) return null;
      u = 1;
    } else if (l < 0) (u = -1), (l = -l);
    else return null;
    Zc.subVectors(this.origin, t);
    const h = u * this.direction.dot(Cv.crossVectors(Zc, Cv));
    if (h < 0) return null;
    const p = u * this.direction.dot(h_.cross(Zc));
    if (p < 0 || h + p > l) return null;
    const m = -u * Zc.dot(d_);
    return m < 0 ? null : this.at(m / l, r);
  }
  applyMatrix4(t) {
    return (
      this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    );
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Xe {
  constructor(t, e, n, a, r, l, u, h, p, m, v, x, _, M, C, E) {
    (Xe.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      t !== void 0 && this.set(t, e, n, a, r, l, u, h, p, m, v, x, _, M, C, E);
  }
  set(t, e, n, a, r, l, u, h, p, m, v, x, _, M, C, E) {
    const S = this.elements;
    return (
      (S[0] = t),
      (S[4] = e),
      (S[8] = n),
      (S[12] = a),
      (S[1] = r),
      (S[5] = l),
      (S[9] = u),
      (S[13] = h),
      (S[2] = p),
      (S[6] = m),
      (S[10] = v),
      (S[14] = x),
      (S[3] = _),
      (S[7] = M),
      (S[11] = C),
      (S[15] = E),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Xe().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      (e[9] = n[9]),
      (e[10] = n[10]),
      (e[11] = n[11]),
      (e[12] = n[12]),
      (e[13] = n[13]),
      (e[14] = n[14]),
      (e[15] = n[15]),
      this
    );
  }
  copyPosition(t) {
    const e = this.elements,
      n = t.elements;
    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return (
      this.set(
        e[0],
        e[3],
        e[6],
        0,
        e[1],
        e[4],
        e[7],
        0,
        e[2],
        e[5],
        e[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(t, e, n) {
    return (
      this.set(
        t.x,
        e.x,
        n.x,
        0,
        t.y,
        e.y,
        n.y,
        0,
        t.z,
        e.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(t) {
    const e = this.elements,
      n = t.elements,
      a = 1 / hd.setFromMatrixColumn(t, 0).length(),
      r = 1 / hd.setFromMatrixColumn(t, 1).length(),
      l = 1 / hd.setFromMatrixColumn(t, 2).length();
    return (
      (e[0] = n[0] * a),
      (e[1] = n[1] * a),
      (e[2] = n[2] * a),
      (e[3] = 0),
      (e[4] = n[4] * r),
      (e[5] = n[5] * r),
      (e[6] = n[6] * r),
      (e[7] = 0),
      (e[8] = n[8] * l),
      (e[9] = n[9] * l),
      (e[10] = n[10] * l),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromEuler(t) {
    const e = this.elements,
      n = t.x,
      a = t.y,
      r = t.z,
      l = Math.cos(n),
      u = Math.sin(n),
      h = Math.cos(a),
      p = Math.sin(a),
      m = Math.cos(r),
      v = Math.sin(r);
    if (t.order === "XYZ") {
      const x = l * m,
        _ = l * v,
        M = u * m,
        C = u * v;
      (e[0] = h * m),
        (e[4] = -h * v),
        (e[8] = p),
        (e[1] = _ + M * p),
        (e[5] = x - C * p),
        (e[9] = -u * h),
        (e[2] = C - x * p),
        (e[6] = M + _ * p),
        (e[10] = l * h);
    } else if (t.order === "YXZ") {
      const x = h * m,
        _ = h * v,
        M = p * m,
        C = p * v;
      (e[0] = x + C * u),
        (e[4] = M * u - _),
        (e[8] = l * p),
        (e[1] = l * v),
        (e[5] = l * m),
        (e[9] = -u),
        (e[2] = _ * u - M),
        (e[6] = C + x * u),
        (e[10] = l * h);
    } else if (t.order === "ZXY") {
      const x = h * m,
        _ = h * v,
        M = p * m,
        C = p * v;
      (e[0] = x - C * u),
        (e[4] = -l * v),
        (e[8] = M + _ * u),
        (e[1] = _ + M * u),
        (e[5] = l * m),
        (e[9] = C - x * u),
        (e[2] = -l * p),
        (e[6] = u),
        (e[10] = l * h);
    } else if (t.order === "ZYX") {
      const x = l * m,
        _ = l * v,
        M = u * m,
        C = u * v;
      (e[0] = h * m),
        (e[4] = M * p - _),
        (e[8] = x * p + C),
        (e[1] = h * v),
        (e[5] = C * p + x),
        (e[9] = _ * p - M),
        (e[2] = -p),
        (e[6] = u * h),
        (e[10] = l * h);
    } else if (t.order === "YZX") {
      const x = l * h,
        _ = l * p,
        M = u * h,
        C = u * p;
      (e[0] = h * m),
        (e[4] = C - x * v),
        (e[8] = M * v + _),
        (e[1] = v),
        (e[5] = l * m),
        (e[9] = -u * m),
        (e[2] = -p * m),
        (e[6] = _ * v + M),
        (e[10] = x - C * v);
    } else if (t.order === "XZY") {
      const x = l * h,
        _ = l * p,
        M = u * h,
        C = u * p;
      (e[0] = h * m),
        (e[4] = -v),
        (e[8] = p * m),
        (e[1] = x * v + C),
        (e[5] = l * m),
        (e[9] = _ * v - M),
        (e[2] = M * v - _),
        (e[6] = u * m),
        (e[10] = C * v + x);
    }
    return (
      (e[3] = 0),
      (e[7] = 0),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(t) {
    return this.compose(sO, t, rO);
  }
  lookAt(t, e, n) {
    const a = this.elements;
    return (
      sr.subVectors(t, e),
      sr.lengthSq() === 0 && (sr.z = 1),
      sr.normalize(),
      Qc.crossVectors(n, sr),
      Qc.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (sr.x += 1e-4) : (sr.z += 1e-4),
        sr.normalize(),
        Qc.crossVectors(n, sr)),
      Qc.normalize(),
      Rv.crossVectors(sr, Qc),
      (a[0] = Qc.x),
      (a[4] = Rv.x),
      (a[8] = sr.x),
      (a[1] = Qc.y),
      (a[5] = Rv.y),
      (a[9] = sr.y),
      (a[2] = Qc.z),
      (a[6] = Rv.z),
      (a[10] = sr.z),
      this
    );
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      a = e.elements,
      r = this.elements,
      l = n[0],
      u = n[4],
      h = n[8],
      p = n[12],
      m = n[1],
      v = n[5],
      x = n[9],
      _ = n[13],
      M = n[2],
      C = n[6],
      E = n[10],
      S = n[14],
      R = n[3],
      B = n[7],
      D = n[11],
      I = n[15],
      P = a[0],
      V = a[4],
      F = a[8],
      N = a[12],
      L = a[1],
      Y = a[5],
      ct = a[9],
      nt = a[13],
      dt = a[2],
      pt = a[6],
      j = a[10],
      Q = a[14],
      et = a[3],
      xt = a[7],
      X = a[11],
      ft = a[15];
    return (
      (r[0] = l * P + u * L + h * dt + p * et),
      (r[4] = l * V + u * Y + h * pt + p * xt),
      (r[8] = l * F + u * ct + h * j + p * X),
      (r[12] = l * N + u * nt + h * Q + p * ft),
      (r[1] = m * P + v * L + x * dt + _ * et),
      (r[5] = m * V + v * Y + x * pt + _ * xt),
      (r[9] = m * F + v * ct + x * j + _ * X),
      (r[13] = m * N + v * nt + x * Q + _ * ft),
      (r[2] = M * P + C * L + E * dt + S * et),
      (r[6] = M * V + C * Y + E * pt + S * xt),
      (r[10] = M * F + C * ct + E * j + S * X),
      (r[14] = M * N + C * nt + E * Q + S * ft),
      (r[3] = R * P + B * L + D * dt + I * et),
      (r[7] = R * V + B * Y + D * pt + I * xt),
      (r[11] = R * F + B * ct + D * j + I * X),
      (r[15] = R * N + B * nt + D * Q + I * ft),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[4],
      a = t[8],
      r = t[12],
      l = t[1],
      u = t[5],
      h = t[9],
      p = t[13],
      m = t[2],
      v = t[6],
      x = t[10],
      _ = t[14],
      M = t[3],
      C = t[7],
      E = t[11],
      S = t[15];
    return (
      M *
        (+r * h * v -
          a * p * v -
          r * u * x +
          n * p * x +
          a * u * _ -
          n * h * _) +
      C *
        (+e * h * _ -
          e * p * x +
          r * l * x -
          a * l * _ +
          a * p * m -
          r * h * m) +
      E *
        (+e * p * v -
          e * u * _ -
          r * l * v +
          n * l * _ +
          r * u * m -
          n * p * m) +
      S *
        (-a * u * m - e * h * v + e * u * x + a * l * v - n * l * x + n * h * m)
    );
  }
  transpose() {
    const t = this.elements;
    let e;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  }
  setPosition(t, e, n) {
    const a = this.elements;
    return (
      t.isVector3
        ? ((a[12] = t.x), (a[13] = t.y), (a[14] = t.z))
        : ((a[12] = t), (a[13] = e), (a[14] = n)),
      this
    );
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      a = t[2],
      r = t[3],
      l = t[4],
      u = t[5],
      h = t[6],
      p = t[7],
      m = t[8],
      v = t[9],
      x = t[10],
      _ = t[11],
      M = t[12],
      C = t[13],
      E = t[14],
      S = t[15],
      R = v * E * p - C * x * p + C * h * _ - u * E * _ - v * h * S + u * x * S,
      B = M * x * p - m * E * p - M * h * _ + l * E * _ + m * h * S - l * x * S,
      D = m * C * p - M * v * p + M * u * _ - l * C * _ - m * u * S + l * v * S,
      I = M * v * h - m * C * h - M * u * x + l * C * x + m * u * E - l * v * E,
      P = e * R + n * B + a * D + r * I;
    if (P === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const V = 1 / P;
    return (
      (t[0] = R * V),
      (t[1] =
        (C * x * r -
          v * E * r -
          C * a * _ +
          n * E * _ +
          v * a * S -
          n * x * S) *
        V),
      (t[2] =
        (u * E * r -
          C * h * r +
          C * a * p -
          n * E * p -
          u * a * S +
          n * h * S) *
        V),
      (t[3] =
        (v * h * r -
          u * x * r -
          v * a * p +
          n * x * p +
          u * a * _ -
          n * h * _) *
        V),
      (t[4] = B * V),
      (t[5] =
        (m * E * r -
          M * x * r +
          M * a * _ -
          e * E * _ -
          m * a * S +
          e * x * S) *
        V),
      (t[6] =
        (M * h * r -
          l * E * r -
          M * a * p +
          e * E * p +
          l * a * S -
          e * h * S) *
        V),
      (t[7] =
        (l * x * r -
          m * h * r +
          m * a * p -
          e * x * p -
          l * a * _ +
          e * h * _) *
        V),
      (t[8] = D * V),
      (t[9] =
        (M * v * r -
          m * C * r -
          M * n * _ +
          e * C * _ +
          m * n * S -
          e * v * S) *
        V),
      (t[10] =
        (l * C * r -
          M * u * r +
          M * n * p -
          e * C * p -
          l * n * S +
          e * u * S) *
        V),
      (t[11] =
        (m * u * r -
          l * v * r -
          m * n * p +
          e * v * p +
          l * n * _ -
          e * u * _) *
        V),
      (t[12] = I * V),
      (t[13] =
        (m * C * a -
          M * v * a +
          M * n * x -
          e * C * x -
          m * n * E +
          e * v * E) *
        V),
      (t[14] =
        (M * u * a -
          l * C * a -
          M * n * h +
          e * C * h +
          l * n * E -
          e * u * E) *
        V),
      (t[15] =
        (l * v * a -
          m * u * a +
          m * n * h -
          e * v * h -
          l * n * x +
          e * u * x) *
        V),
      this
    );
  }
  scale(t) {
    const e = this.elements,
      n = t.x,
      a = t.y,
      r = t.z;
    return (
      (e[0] *= n),
      (e[4] *= a),
      (e[8] *= r),
      (e[1] *= n),
      (e[5] *= a),
      (e[9] *= r),
      (e[2] *= n),
      (e[6] *= a),
      (e[10] *= r),
      (e[3] *= n),
      (e[7] *= a),
      (e[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      a = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, a));
  }
  makeTranslation(t, e, n) {
    return (
      t.isVector3
        ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e),
      a = Math.sin(e),
      r = 1 - n,
      l = t.x,
      u = t.y,
      h = t.z,
      p = r * l,
      m = r * u;
    return (
      this.set(
        p * l + n,
        p * u - a * h,
        p * h + a * u,
        0,
        p * u + a * h,
        m * u + n,
        m * h - a * l,
        0,
        p * h - a * u,
        m * h + a * l,
        r * h * h + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, n, a, r, l) {
    return this.set(1, n, r, 0, t, 1, l, 0, e, a, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, n) {
    const a = this.elements,
      r = e._x,
      l = e._y,
      u = e._z,
      h = e._w,
      p = r + r,
      m = l + l,
      v = u + u,
      x = r * p,
      _ = r * m,
      M = r * v,
      C = l * m,
      E = l * v,
      S = u * v,
      R = h * p,
      B = h * m,
      D = h * v,
      I = n.x,
      P = n.y,
      V = n.z;
    return (
      (a[0] = (1 - (C + S)) * I),
      (a[1] = (_ + D) * I),
      (a[2] = (M - B) * I),
      (a[3] = 0),
      (a[4] = (_ - D) * P),
      (a[5] = (1 - (x + S)) * P),
      (a[6] = (E + R) * P),
      (a[7] = 0),
      (a[8] = (M + B) * V),
      (a[9] = (E - R) * V),
      (a[10] = (1 - (x + C)) * V),
      (a[11] = 0),
      (a[12] = t.x),
      (a[13] = t.y),
      (a[14] = t.z),
      (a[15] = 1),
      this
    );
  }
  decompose(t, e, n) {
    const a = this.elements;
    let r = hd.set(a[0], a[1], a[2]).length();
    const l = hd.set(a[4], a[5], a[6]).length(),
      u = hd.set(a[8], a[9], a[10]).length();
    this.determinant() < 0 && (r = -r),
      (t.x = a[12]),
      (t.y = a[13]),
      (t.z = a[14]),
      ho.copy(this);
    const p = 1 / r,
      m = 1 / l,
      v = 1 / u;
    return (
      (ho.elements[0] *= p),
      (ho.elements[1] *= p),
      (ho.elements[2] *= p),
      (ho.elements[4] *= m),
      (ho.elements[5] *= m),
      (ho.elements[6] *= m),
      (ho.elements[8] *= v),
      (ho.elements[9] *= v),
      (ho.elements[10] *= v),
      e.setFromRotationMatrix(ho),
      (n.x = r),
      (n.y = l),
      (n.z = u),
      this
    );
  }
  makePerspective(t, e, n, a, r, l, u = Lr) {
    const h = this.elements,
      p = (2 * r) / (e - t),
      m = (2 * r) / (n - a),
      v = (e + t) / (e - t),
      x = (n + a) / (n - a);
    let _, M;
    if (u === Lr) (_ = -(l + r) / (l - r)), (M = (-2 * l * r) / (l - r));
    else if (u === h0) (_ = -l / (l - r)), (M = (-l * r) / (l - r));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + u
      );
    return (
      (h[0] = p),
      (h[4] = 0),
      (h[8] = v),
      (h[12] = 0),
      (h[1] = 0),
      (h[5] = m),
      (h[9] = x),
      (h[13] = 0),
      (h[2] = 0),
      (h[6] = 0),
      (h[10] = _),
      (h[14] = M),
      (h[3] = 0),
      (h[7] = 0),
      (h[11] = -1),
      (h[15] = 0),
      this
    );
  }
  makeOrthographic(t, e, n, a, r, l, u = Lr) {
    const h = this.elements,
      p = 1 / (e - t),
      m = 1 / (n - a),
      v = 1 / (l - r),
      x = (e + t) * p,
      _ = (n + a) * m;
    let M, C;
    if (u === Lr) (M = (l + r) * v), (C = -2 * v);
    else if (u === h0) (M = r * v), (C = -1 * v);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + u
      );
    return (
      (h[0] = 2 * p),
      (h[4] = 0),
      (h[8] = 0),
      (h[12] = -x),
      (h[1] = 0),
      (h[5] = 2 * m),
      (h[9] = 0),
      (h[13] = -_),
      (h[2] = 0),
      (h[6] = 0),
      (h[10] = C),
      (h[14] = -M),
      (h[3] = 0),
      (h[7] = 0),
      (h[11] = 0),
      (h[15] = 1),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      n = t.elements;
    for (let a = 0; a < 16; a++) if (e[a] !== n[a]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      (t[e + 9] = n[9]),
      (t[e + 10] = n[10]),
      (t[e + 11] = n[11]),
      (t[e + 12] = n[12]),
      (t[e + 13] = n[13]),
      (t[e + 14] = n[14]),
      (t[e + 15] = n[15]),
      t
    );
  }
}
const hd = new Z(),
  ho = new Xe(),
  sO = new Z(0, 0, 0),
  rO = new Z(1, 1, 1),
  Qc = new Z(),
  Rv = new Z(),
  sr = new Z(),
  gE = new Xe(),
  vE = new pa();
class cr {
  constructor(t = 0, e = 0, n = 0, a = cr.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = a);
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    (this._order = t), this._onChangeCallback();
  }
  set(t, e, n, a = this._order) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = a),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const a = t.elements,
      r = a[0],
      l = a[4],
      u = a[8],
      h = a[1],
      p = a[5],
      m = a[9],
      v = a[2],
      x = a[6],
      _ = a[10];
    switch (e) {
      case "XYZ":
        (this._y = Math.asin(dn(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-m, _)), (this._z = Math.atan2(-l, r)))
            : ((this._x = Math.atan2(x, p)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-dn(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._y = Math.atan2(u, _)), (this._z = Math.atan2(h, p)))
            : ((this._y = Math.atan2(-v, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(dn(x, -1, 1))),
          Math.abs(x) < 0.9999999
            ? ((this._y = Math.atan2(-v, _)), (this._z = Math.atan2(-l, p)))
            : ((this._y = 0), (this._z = Math.atan2(h, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-dn(v, -1, 1))),
          Math.abs(v) < 0.9999999
            ? ((this._x = Math.atan2(x, _)), (this._z = Math.atan2(h, r)))
            : ((this._x = 0), (this._z = Math.atan2(-l, p)));
        break;
      case "YZX":
        (this._z = Math.asin(dn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(-m, p)), (this._y = Math.atan2(-v, r)))
            : ((this._x = 0), (this._y = Math.atan2(u, _)));
        break;
      case "XZY":
        (this._z = Math.asin(-dn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(x, p)), (this._y = Math.atan2(u, r)))
            : ((this._x = Math.atan2(-m, _)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            e
        );
    }
    return (this._order = e), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, n) {
    return (
      gE.makeRotationFromQuaternion(t), this.setFromRotationMatrix(gE, e, n)
    );
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return vE.setFromEuler(this), this.setFromQuaternion(vE, t);
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._order === this._order
    );
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      t[3] !== void 0 && (this._order = t[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._order),
      t
    );
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
cr.DEFAULT_ORDER = "XYZ";
class Zd {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = ((1 << t) | 0) >>> 0;
  }
  enable(t) {
    this.mask |= (1 << t) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= (1 << t) | 0;
  }
  disable(t) {
    this.mask &= ~((1 << t) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & ((1 << t) | 0)) !== 0;
  }
}
let oO = 0;
const yE = new Z(),
  dd = new pa(),
  Gl = new Xe(),
  Bv = new Z(),
  Cm = new Z(),
  lO = new Z(),
  cO = new pa(),
  xE = new Z(1, 0, 0),
  _E = new Z(0, 1, 0),
  bE = new Z(0, 0, 1),
  AE = { type: "added" },
  uO = { type: "removed" },
  pd = { type: "childadded", child: null },
  p_ = { type: "childremoved", child: null };
class Dn extends ml {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: oO++ }),
      (this.uuid = lr()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Dn.DEFAULT_UP.clone());
    const t = new Z(),
      e = new cr(),
      n = new pa(),
      a = new Z(1, 1, 1);
    function r() {
      n.setFromEuler(e, !1);
    }
    function l() {
      e.setFromQuaternion(n, void 0, !1);
    }
    e._onChange(r),
      n._onChange(l),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: t },
        rotation: { configurable: !0, enumerable: !0, value: e },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: a },
        modelViewMatrix: { value: new Xe() },
        normalMatrix: { value: new yn() },
      }),
      (this.matrix = new Xe()),
      (this.matrixWorld = new Xe()),
      (this.matrixAutoUpdate = Dn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Dn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Zd()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.customDepthMaterial = void 0),
      (this.customDistanceMaterial = void 0),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(t),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return dd.setFromAxisAngle(t, e), this.quaternion.multiply(dd), this;
  }
  rotateOnWorldAxis(t, e) {
    return dd.setFromAxisAngle(t, e), this.quaternion.premultiply(dd), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(xE, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(_E, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(bE, t);
  }
  translateOnAxis(t, e) {
    return (
      yE.copy(t).applyQuaternion(this.quaternion),
      this.position.add(yE.multiplyScalar(e)),
      this
    );
  }
  translateX(t) {
    return this.translateOnAxis(xE, t);
  }
  translateY(t) {
    return this.translateOnAxis(_E, t);
  }
  translateZ(t) {
    return this.translateOnAxis(bE, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      t.applyMatrix4(Gl.copy(this.matrixWorld).invert())
    );
  }
  lookAt(t, e, n) {
    t.isVector3 ? Bv.copy(t) : Bv.set(t, e, n);
    const a = this.parent;
    this.updateWorldMatrix(!0, !1),
      Cm.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Gl.lookAt(Cm, Bv, this.up)
        : Gl.lookAt(Bv, Cm, this.up),
      this.quaternion.setFromRotationMatrix(Gl),
      a &&
        (Gl.extractRotation(a.matrixWorld),
        dd.setFromRotationMatrix(Gl),
        this.quaternion.premultiply(dd.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return t === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          t
        ),
        this)
      : (t && t.isObject3D
          ? (t.removeFromParent(),
            (t.parent = this),
            this.children.push(t),
            t.dispatchEvent(AE),
            (pd.child = t),
            this.dispatchEvent(pd),
            (pd.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              t
            ),
        this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return (
      e !== -1 &&
        ((t.parent = null),
        this.children.splice(e, 1),
        t.dispatchEvent(uO),
        (p_.child = t),
        this.dispatchEvent(p_),
        (p_.child = null)),
      this
    );
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      Gl.copy(this.matrixWorld).invert(),
      t.parent !== null &&
        (t.parent.updateWorldMatrix(!0, !1), Gl.multiply(t.parent.matrixWorld)),
      t.applyMatrix4(Gl),
      t.removeFromParent(),
      (t.parent = this),
      this.children.push(t),
      t.updateWorldMatrix(!1, !0),
      t.dispatchEvent(AE),
      (pd.child = t),
      this.dispatchEvent(pd),
      (pd.child = null),
      this
    );
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this;
    for (let n = 0, a = this.children.length; n < a; n++) {
      const l = this.children[n].getObjectByProperty(t, e);
      if (l !== void 0) return l;
    }
  }
  getObjectsByProperty(t, e, n = []) {
    this[t] === e && n.push(this);
    const a = this.children;
    for (let r = 0, l = a.length; r < l; r++)
      a[r].getObjectsByProperty(t, e, n);
    return n;
  }
  getWorldPosition(t) {
    return (
      this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cm, t, lO), t
    );
  }
  getWorldScale(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cm, cO, t), t
    );
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {}
  traverse(t) {
    t(this);
    const e = this.children;
    for (let n = 0, a = e.length; n < a; n++) e[n].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1) return;
    t(this);
    const e = this.children;
    for (let n = 0, a = e.length; n < a; n++) e[n].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || t) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0));
    const e = this.children;
    for (let n = 0, a = e.length; n < a; n++) e[n].updateMatrixWorld(t);
  }
  updateWorldMatrix(t, e) {
    const n = this.parent;
    if (
      (t === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      e === !0)
    ) {
      const a = this.children;
      for (let r = 0, l = a.length; r < l; r++) a[r].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string",
      n = {};
    e &&
      ((t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.7,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const a = {};
    (a.uuid = this.uuid),
      (a.type = this.type),
      this.name !== "" && (a.name = this.name),
      this.castShadow === !0 && (a.castShadow = !0),
      this.receiveShadow === !0 && (a.receiveShadow = !0),
      this.visible === !1 && (a.visible = !1),
      this.frustumCulled === !1 && (a.frustumCulled = !1),
      this.renderOrder !== 0 && (a.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (a.userData = this.userData),
      (a.layers = this.layers.mask),
      (a.matrix = this.matrix.toArray()),
      (a.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((a.type = "InstancedMesh"),
        (a.count = this.count),
        (a.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (a.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((a.type = "BatchedMesh"),
        (a.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (a.sortObjects = this.sortObjects),
        (a.drawRanges = this._drawRanges),
        (a.reservedRanges = this._reservedRanges),
        (a.geometryInfo = this._geometryInfo.map((u) => ({
          ...u,
          boundingBox: u.boundingBox ? u.boundingBox.toJSON() : void 0,
          boundingSphere: u.boundingSphere ? u.boundingSphere.toJSON() : void 0,
        }))),
        (a.instanceInfo = this._instanceInfo.map((u) => ({ ...u }))),
        (a.availableInstanceIds = this._availableInstanceIds.slice()),
        (a.availableGeometryIds = this._availableGeometryIds.slice()),
        (a.nextIndexStart = this._nextIndexStart),
        (a.nextVertexStart = this._nextVertexStart),
        (a.geometryCount = this._geometryCount),
        (a.maxInstanceCount = this._maxInstanceCount),
        (a.maxVertexCount = this._maxVertexCount),
        (a.maxIndexCount = this._maxIndexCount),
        (a.geometryInitialized = this._geometryInitialized),
        (a.matricesTexture = this._matricesTexture.toJSON(t)),
        (a.indirectTexture = this._indirectTexture.toJSON(t)),
        this._colorsTexture !== null &&
          (a.colorsTexture = this._colorsTexture.toJSON(t)),
        this.boundingSphere !== null &&
          (a.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null &&
          (a.boundingBox = this.boundingBox.toJSON()));
    function r(u, h) {
      return u[h.uuid] === void 0 && (u[h.uuid] = h.toJSON(t)), h.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (a.background = this.background.toJSON())
          : this.background.isTexture &&
            (a.background = this.background.toJSON(t).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (a.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      a.geometry = r(t.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const h = u.shapes;
        if (Array.isArray(h))
          for (let p = 0, m = h.length; p < m; p++) {
            const v = h[p];
            r(t.shapes, v);
          }
        else r(t.shapes, h);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((a.bindMode = this.bindMode),
        (a.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (r(t.skeletons, this.skeleton), (a.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const u = [];
        for (let h = 0, p = this.material.length; h < p; h++)
          u.push(r(t.materials, this.material[h]));
        a.material = u;
      } else a.material = r(t.materials, this.material);
    if (this.children.length > 0) {
      a.children = [];
      for (let u = 0; u < this.children.length; u++)
        a.children.push(this.children[u].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      a.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const h = this.animations[u];
        a.animations.push(r(t.animations, h));
      }
    }
    if (e) {
      const u = l(t.geometries),
        h = l(t.materials),
        p = l(t.textures),
        m = l(t.images),
        v = l(t.shapes),
        x = l(t.skeletons),
        _ = l(t.animations),
        M = l(t.nodes);
      u.length > 0 && (n.geometries = u),
        h.length > 0 && (n.materials = h),
        p.length > 0 && (n.textures = p),
        m.length > 0 && (n.images = m),
        v.length > 0 && (n.shapes = v),
        x.length > 0 && (n.skeletons = x),
        _.length > 0 && (n.animations = _),
        M.length > 0 && (n.nodes = M);
    }
    return (n.object = a), n;
    function l(u) {
      const h = [];
      for (const p in u) {
        const m = u[p];
        delete m.metadata, h.push(m);
      }
      return h;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (
      ((this.name = t.name),
      this.up.copy(t.up),
      this.position.copy(t.position),
      (this.rotation.order = t.rotation.order),
      this.quaternion.copy(t.quaternion),
      this.scale.copy(t.scale),
      this.matrix.copy(t.matrix),
      this.matrixWorld.copy(t.matrixWorld),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
      (this.layers.mask = t.layers.mask),
      (this.visible = t.visible),
      (this.castShadow = t.castShadow),
      (this.receiveShadow = t.receiveShadow),
      (this.frustumCulled = t.frustumCulled),
      (this.renderOrder = t.renderOrder),
      (this.animations = t.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      e === !0)
    )
      for (let n = 0; n < t.children.length; n++) {
        const a = t.children[n];
        this.add(a.clone());
      }
    return this;
  }
}
Dn.DEFAULT_UP = new Z(0, 1, 0);
Dn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Dn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const po = new Z(),
  Vl = new Z(),
  m_ = new Z(),
  kl = new Z(),
  md = new Z(),
  gd = new Z(),
  SE = new Z(),
  g_ = new Z(),
  v_ = new Z(),
  y_ = new Z(),
  x_ = new Hn(),
  __ = new Hn(),
  b_ = new Hn();
class Vs {
  constructor(t = new Z(), e = new Z(), n = new Z()) {
    (this.a = t), (this.b = e), (this.c = n);
  }
  static getNormal(t, e, n, a) {
    a.subVectors(n, e), po.subVectors(t, e), a.cross(po);
    const r = a.lengthSq();
    return r > 0 ? a.multiplyScalar(1 / Math.sqrt(r)) : a.set(0, 0, 0);
  }
  static getBarycoord(t, e, n, a, r) {
    po.subVectors(a, e), Vl.subVectors(n, e), m_.subVectors(t, e);
    const l = po.dot(po),
      u = po.dot(Vl),
      h = po.dot(m_),
      p = Vl.dot(Vl),
      m = Vl.dot(m_),
      v = l * p - u * u;
    if (v === 0) return r.set(0, 0, 0), null;
    const x = 1 / v,
      _ = (p * h - u * m) * x,
      M = (l * m - u * h) * x;
    return r.set(1 - _ - M, M, _);
  }
  static containsPoint(t, e, n, a) {
    return this.getBarycoord(t, e, n, a, kl) === null
      ? !1
      : kl.x >= 0 && kl.y >= 0 && kl.x + kl.y <= 1;
  }
  static getInterpolation(t, e, n, a, r, l, u, h) {
    return this.getBarycoord(t, e, n, a, kl) === null
      ? ((h.x = 0),
        (h.y = 0),
        "z" in h && (h.z = 0),
        "w" in h && (h.w = 0),
        null)
      : (h.setScalar(0),
        h.addScaledVector(r, kl.x),
        h.addScaledVector(l, kl.y),
        h.addScaledVector(u, kl.z),
        h);
  }
  static getInterpolatedAttribute(t, e, n, a, r, l) {
    return (
      x_.setScalar(0),
      __.setScalar(0),
      b_.setScalar(0),
      x_.fromBufferAttribute(t, e),
      __.fromBufferAttribute(t, n),
      b_.fromBufferAttribute(t, a),
      l.setScalar(0),
      l.addScaledVector(x_, r.x),
      l.addScaledVector(__, r.y),
      l.addScaledVector(b_, r.z),
      l
    );
  }
  static isFrontFacing(t, e, n, a) {
    return po.subVectors(n, e), Vl.subVectors(t, e), po.cross(Vl).dot(a) < 0;
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  }
  setFromPointsAndIndices(t, e, n, a) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[a]), this;
  }
  setFromAttributeAndIndices(t, e, n, a) {
    return (
      this.a.fromBufferAttribute(t, e),
      this.b.fromBufferAttribute(t, n),
      this.c.fromBufferAttribute(t, a),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return (
      po.subVectors(this.c, this.b),
      Vl.subVectors(this.a, this.b),
      po.cross(Vl).length() * 0.5
    );
  }
  getMidpoint(t) {
    return t
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return Vs.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return Vs.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getInterpolation(t, e, n, a, r) {
    return Vs.getInterpolation(t, this.a, this.b, this.c, e, n, a, r);
  }
  containsPoint(t) {
    return Vs.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return Vs.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const n = this.a,
      a = this.b,
      r = this.c;
    let l, u;
    md.subVectors(a, n), gd.subVectors(r, n), g_.subVectors(t, n);
    const h = md.dot(g_),
      p = gd.dot(g_);
    if (h <= 0 && p <= 0) return e.copy(n);
    v_.subVectors(t, a);
    const m = md.dot(v_),
      v = gd.dot(v_);
    if (m >= 0 && v <= m) return e.copy(a);
    const x = h * v - m * p;
    if (x <= 0 && h >= 0 && m <= 0)
      return (l = h / (h - m)), e.copy(n).addScaledVector(md, l);
    y_.subVectors(t, r);
    const _ = md.dot(y_),
      M = gd.dot(y_);
    if (M >= 0 && _ <= M) return e.copy(r);
    const C = _ * p - h * M;
    if (C <= 0 && p >= 0 && M <= 0)
      return (u = p / (p - M)), e.copy(n).addScaledVector(gd, u);
    const E = m * M - _ * v;
    if (E <= 0 && v - m >= 0 && _ - M >= 0)
      return (
        SE.subVectors(r, a),
        (u = (v - m) / (v - m + (_ - M))),
        e.copy(a).addScaledVector(SE, u)
      );
    const S = 1 / (E + C + x);
    return (
      (l = C * S),
      (u = x * S),
      e.copy(n).addScaledVector(md, l).addScaledVector(gd, u)
    );
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
const zC = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  $c = { h: 0, s: 0, l: 0 },
  Dv = { h: 0, s: 0, l: 0 };
function A_(i, t, e) {
  return (
    e < 0 && (e += 1),
    e > 1 && (e -= 1),
    e < 1 / 6
      ? i + (t - i) * 6 * e
      : e < 1 / 2
      ? t
      : e < 2 / 3
      ? i + (t - i) * 6 * (2 / 3 - e)
      : i
  );
}
class Se {
  constructor(t, e, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(t, e, n)
    );
  }
  set(t, e, n) {
    if (e === void 0 && n === void 0) {
      const a = t;
      a && a.isColor
        ? this.copy(a)
        : typeof a == "number"
        ? this.setHex(a)
        : typeof a == "string" && this.setStyle(a);
    } else this.setRGB(t, e, n);
    return this;
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this;
  }
  setHex(t, e = Fa) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (t & 255) / 255),
      In.colorSpaceToWorking(this, e),
      this
    );
  }
  setRGB(t, e, n, a = In.workingColorSpace) {
    return (
      (this.r = t),
      (this.g = e),
      (this.b = n),
      In.colorSpaceToWorking(this, a),
      this
    );
  }
  setHSL(t, e, n, a = In.workingColorSpace) {
    if (((t = HA(t, 1)), (e = dn(e, 0, 1)), (n = dn(n, 0, 1)), e === 0))
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + e) : n + e - n * e,
        l = 2 * n - r;
      (this.r = A_(l, r, t + 1 / 3)),
        (this.g = A_(l, r, t)),
        (this.b = A_(l, r, t - 1 / 3));
    }
    return In.colorSpaceToWorking(this, a), this;
  }
  setStyle(t, e = Fa) {
    function n(r) {
      r !== void 0 &&
        parseFloat(r) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
    }
    let a;
    if ((a = /^(\w+)\(([^\)]*)\)/.exec(t))) {
      let r;
      const l = a[1],
        u = a[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (
            (r =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u
              ))
          )
            return (
              n(r[4]),
              this.setRGB(
                Math.min(255, parseInt(r[1], 10)) / 255,
                Math.min(255, parseInt(r[2], 10)) / 255,
                Math.min(255, parseInt(r[3], 10)) / 255,
                e
              )
            );
          if (
            (r =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u
              ))
          )
            return (
              n(r[4]),
              this.setRGB(
                Math.min(100, parseInt(r[1], 10)) / 100,
                Math.min(100, parseInt(r[2], 10)) / 100,
                Math.min(100, parseInt(r[3], 10)) / 100,
                e
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (r =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u
              ))
          )
            return (
              n(r[4]),
              this.setHSL(
                parseFloat(r[1]) / 360,
                parseFloat(r[2]) / 100,
                parseFloat(r[3]) / 100,
                e
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + t);
      }
    } else if ((a = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const r = a[1],
        l = r.length;
      if (l === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          e
        );
      if (l === 6) return this.setHex(parseInt(r, 16), e);
      console.warn("THREE.Color: Invalid hex color " + t);
    } else if (t && t.length > 0) return this.setColorName(t, e);
    return this;
  }
  setColorName(t, e = Fa) {
    const n = zC[t.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, e)
        : console.warn("THREE.Color: Unknown color " + t),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
  }
  copySRGBToLinear(t) {
    return (this.r = Ql(t.r)), (this.g = Ql(t.g)), (this.b = Ql(t.b)), this;
  }
  copyLinearToSRGB(t) {
    return (this.r = Fd(t.r)), (this.g = Fd(t.g)), (this.b = Fd(t.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = Fa) {
    return (
      In.workingToColorSpace(ts.copy(this), t),
      Math.round(dn(ts.r * 255, 0, 255)) * 65536 +
        Math.round(dn(ts.g * 255, 0, 255)) * 256 +
        Math.round(dn(ts.b * 255, 0, 255))
    );
  }
  getHexString(t = Fa) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = In.workingColorSpace) {
    In.workingToColorSpace(ts.copy(this), e);
    const n = ts.r,
      a = ts.g,
      r = ts.b,
      l = Math.max(n, a, r),
      u = Math.min(n, a, r);
    let h, p;
    const m = (u + l) / 2;
    if (u === l) (h = 0), (p = 0);
    else {
      const v = l - u;
      switch (((p = m <= 0.5 ? v / (l + u) : v / (2 - l - u)), l)) {
        case n:
          h = (a - r) / v + (a < r ? 6 : 0);
          break;
        case a:
          h = (r - n) / v + 2;
          break;
        case r:
          h = (n - a) / v + 4;
          break;
      }
      h /= 6;
    }
    return (t.h = h), (t.s = p), (t.l = m), t;
  }
  getRGB(t, e = In.workingColorSpace) {
    return (
      In.workingToColorSpace(ts.copy(this), e),
      (t.r = ts.r),
      (t.g = ts.g),
      (t.b = ts.b),
      t
    );
  }
  getStyle(t = Fa) {
    In.workingToColorSpace(ts.copy(this), t);
    const e = ts.r,
      n = ts.g,
      a = ts.b;
    return t !== Fa
      ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${a.toFixed(3)})`
      : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(
          a * 255
        )})`;
  }
  offsetHSL(t, e, n) {
    return this.getHSL($c), this.setHSL($c.h + t, $c.s + e, $c.l + n);
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
  }
  addColors(t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    );
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this;
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    );
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this;
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    );
  }
  lerpColors(t, e, n) {
    return (
      (this.r = t.r + (e.r - t.r) * n),
      (this.g = t.g + (e.g - t.g) * n),
      (this.b = t.b + (e.b - t.b) * n),
      this
    );
  }
  lerpHSL(t, e) {
    this.getHSL($c), t.getHSL(Dv);
    const n = Qm($c.h, Dv.h, e),
      a = Qm($c.s, Dv.s, e),
      r = Qm($c.l, Dv.l, e);
    return this.setHSL(n, a, r), this;
  }
  setFromVector3(t) {
    return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
  }
  applyMatrix3(t) {
    const e = this.r,
      n = this.g,
      a = this.b,
      r = t.elements;
    return (
      (this.r = r[0] * e + r[3] * n + r[6] * a),
      (this.g = r[1] * e + r[4] * n + r[7] * a),
      (this.b = r[2] * e + r[5] * n + r[8] * a),
      this
    );
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ts = new Se();
Se.NAMES = zC;
let fO = 0;
class ma extends ml {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: fO++ }),
      (this.uuid = lr()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Xf),
      (this.side = hl),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Ny),
      (this.blendDst = Ly),
      (this.blendEquation = su),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Se(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Jf),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Hb),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Uf),
      (this.stencilZFail = Uf),
      (this.stencilZPass = Uf),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.allowOverride = !0),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${e}' has value of undefined.`
          );
          continue;
        }
        const a = this[e];
        if (a === void 0) {
          console.warn(
            `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        a && a.isColor
          ? a.set(n)
          : a && a.isVector3 && n && n.isVector3
          ? a.copy(n)
          : (this[e] = n);
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(t).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(t).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(t).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(t).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(t).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(t).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(t).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Xf && (n.blending = this.blending),
      this.side !== hl && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== Ny && (n.blendSrc = this.blendSrc),
      this.blendDst !== Ly && (n.blendDst = this.blendDst),
      this.blendEquation !== su && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== Jf && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== Hb && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Uf && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== Uf && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Uf && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function a(r) {
      const l = [];
      for (const u in r) {
        const h = r[u];
        delete h.metadata, l.push(h);
      }
      return l;
    }
    if (e) {
      const r = a(t.textures),
        l = a(t.images);
      r.length > 0 && (n.textures = r), l.length > 0 && (n.images = l);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.name = t.name),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      this.blendColor.copy(t.blendColor),
      (this.blendAlpha = t.blendAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite);
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const a = e.length;
      n = new Array(a);
      for (let r = 0; r !== a; ++r) n[r] = e[r].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.alphaHash = t.alphaHash),
      (this.alphaToCoverage = t.alphaToCoverage),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.forceSinglePass = t.forceSinglePass),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
class ks extends ma {
  constructor(t) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Se(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new cr()),
      (this.combine = R0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.fog = t.fog),
      this
    );
  }
}
const Kl = hO();
function hO() {
  const i = new ArrayBuffer(4),
    t = new Float32Array(i),
    e = new Uint32Array(i),
    n = new Uint32Array(512),
    a = new Uint32Array(512);
  for (let h = 0; h < 256; ++h) {
    const p = h - 127;
    p < -27
      ? ((n[h] = 0), (n[h | 256] = 32768), (a[h] = 24), (a[h | 256] = 24))
      : p < -14
      ? ((n[h] = 1024 >> (-p - 14)),
        (n[h | 256] = (1024 >> (-p - 14)) | 32768),
        (a[h] = -p - 1),
        (a[h | 256] = -p - 1))
      : p <= 15
      ? ((n[h] = (p + 15) << 10),
        (n[h | 256] = ((p + 15) << 10) | 32768),
        (a[h] = 13),
        (a[h | 256] = 13))
      : p < 128
      ? ((n[h] = 31744), (n[h | 256] = 64512), (a[h] = 24), (a[h | 256] = 24))
      : ((n[h] = 31744), (n[h | 256] = 64512), (a[h] = 13), (a[h | 256] = 13));
  }
  const r = new Uint32Array(2048),
    l = new Uint32Array(64),
    u = new Uint32Array(64);
  for (let h = 1; h < 1024; ++h) {
    let p = h << 13,
      m = 0;
    for (; (p & 8388608) === 0; ) (p <<= 1), (m -= 8388608);
    (p &= -8388609), (m += 947912704), (r[h] = p | m);
  }
  for (let h = 1024; h < 2048; ++h) r[h] = 939524096 + ((h - 1024) << 13);
  for (let h = 1; h < 31; ++h) l[h] = h << 23;
  (l[31] = 1199570944), (l[32] = 2147483648);
  for (let h = 33; h < 63; ++h) l[h] = 2147483648 + ((h - 32) << 23);
  l[63] = 3347054592;
  for (let h = 1; h < 64; ++h) h !== 32 && (u[h] = 1024);
  return {
    floatView: t,
    uint32View: e,
    baseTable: n,
    shiftTable: a,
    mantissaTable: r,
    exponentTable: l,
    offsetTable: u,
  };
}
function Hs(i) {
  Math.abs(i) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (i = dn(i, -65504, 65504)),
    (Kl.floatView[0] = i);
  const t = Kl.uint32View[0],
    e = (t >> 23) & 511;
  return Kl.baseTable[e] + ((t & 8388607) >> Kl.shiftTable[e]);
}
function Vm(i) {
  const t = i >> 10;
  return (
    (Kl.uint32View[0] =
      Kl.mantissaTable[Kl.offsetTable[t] + (i & 1023)] + Kl.exponentTable[t]),
    Kl.floatView[0]
  );
}
class Ff {
  static toHalfFloat(t) {
    return Hs(t);
  }
  static fromHalfFloat(t) {
    return Vm(t);
  }
}
const ia = new Z(),
  Uv = new Yt();
let dO = 0;
class Gn {
  constructor(t, e, n = !1) {
    if (Array.isArray(t))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      Object.defineProperty(this, "id", { value: dO++ }),
      (this.name = ""),
      (this.array = t),
      (this.itemSize = e),
      (this.count = t !== void 0 ? t.length / e : 0),
      (this.normalized = n),
      (this.usage = f0),
      (this.updateRanges = []),
      (this.gpuType = Pi),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      (this.gpuType = t.gpuType),
      this
    );
  }
  copyAt(t, e, n) {
    (t *= this.itemSize), (n *= e.itemSize);
    for (let a = 0, r = this.itemSize; a < r; a++)
      this.array[t + a] = e.array[n + a];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        Uv.fromBufferAttribute(this, e),
          Uv.applyMatrix3(t),
          this.setXY(e, Uv.x, Uv.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        ia.fromBufferAttribute(this, e),
          ia.applyMatrix3(t),
          this.setXYZ(e, ia.x, ia.y, ia.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      ia.fromBufferAttribute(this, e),
        ia.applyMatrix4(t),
        this.setXYZ(e, ia.x, ia.y, ia.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      ia.fromBufferAttribute(this, e),
        ia.applyNormalMatrix(t),
        this.setXYZ(e, ia.x, ia.y, ia.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      ia.fromBufferAttribute(this, e),
        ia.transformDirection(t),
        this.setXYZ(e, ia.x, ia.y, ia.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getComponent(t, e) {
    let n = this.array[t * this.itemSize + e];
    return this.normalized && (n = As(n, this.array)), n;
  }
  setComponent(t, e, n) {
    return (
      this.normalized && (n = bn(n, this.array)),
      (this.array[t * this.itemSize + e] = n),
      this
    );
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = As(e, this.array)), e;
  }
  setX(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize] = e),
      this
    );
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = As(e, this.array)), e;
  }
  setY(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize + 1] = e),
      this
    );
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = As(e, this.array)), e;
  }
  setZ(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize + 2] = e),
      this
    );
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = As(e, this.array)), e;
  }
  setW(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize + 3] = e),
      this
    );
  }
  setXY(t, e, n) {
    return (
      (t *= this.itemSize),
      this.normalized && ((e = bn(e, this.array)), (n = bn(n, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      this
    );
  }
  setXYZ(t, e, n, a) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = bn(e, this.array)),
        (n = bn(n, this.array)),
        (a = bn(a, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = a),
      this
    );
  }
  setXYZW(t, e, n, a, r) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = bn(e, this.array)),
        (n = bn(n, this.array)),
        (a = bn(a, this.array)),
        (r = bn(r, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = a),
      (this.array[t + 3] = r),
      this
    );
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (t.name = this.name),
      this.usage !== f0 && (t.usage = this.usage),
      t
    );
  }
}
class pO extends Gn {
  constructor(t, e, n) {
    super(new Int8Array(t), e, n);
  }
}
class mO extends Gn {
  constructor(t, e, n) {
    super(new Uint8Array(t), e, n);
  }
}
class gO extends Gn {
  constructor(t, e, n) {
    super(new Uint8ClampedArray(t), e, n);
  }
}
class vO extends Gn {
  constructor(t, e, n) {
    super(new Int16Array(t), e, n);
  }
}
class VA extends Gn {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n);
  }
}
class yO extends Gn {
  constructor(t, e, n) {
    super(new Int32Array(t), e, n);
  }
}
class kA extends Gn {
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n);
  }
}
class xO extends Gn {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n), (this.isFloat16BufferAttribute = !0);
  }
  getX(t) {
    let e = Vm(this.array[t * this.itemSize]);
    return this.normalized && (e = As(e, this.array)), e;
  }
  setX(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize] = Hs(e)),
      this
    );
  }
  getY(t) {
    let e = Vm(this.array[t * this.itemSize + 1]);
    return this.normalized && (e = As(e, this.array)), e;
  }
  setY(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize + 1] = Hs(e)),
      this
    );
  }
  getZ(t) {
    let e = Vm(this.array[t * this.itemSize + 2]);
    return this.normalized && (e = As(e, this.array)), e;
  }
  setZ(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize + 2] = Hs(e)),
      this
    );
  }
  getW(t) {
    let e = Vm(this.array[t * this.itemSize + 3]);
    return this.normalized && (e = As(e, this.array)), e;
  }
  setW(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.array[t * this.itemSize + 3] = Hs(e)),
      this
    );
  }
  setXY(t, e, n) {
    return (
      (t *= this.itemSize),
      this.normalized && ((e = bn(e, this.array)), (n = bn(n, this.array))),
      (this.array[t + 0] = Hs(e)),
      (this.array[t + 1] = Hs(n)),
      this
    );
  }
  setXYZ(t, e, n, a) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = bn(e, this.array)),
        (n = bn(n, this.array)),
        (a = bn(a, this.array))),
      (this.array[t + 0] = Hs(e)),
      (this.array[t + 1] = Hs(n)),
      (this.array[t + 2] = Hs(a)),
      this
    );
  }
  setXYZW(t, e, n, a, r) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = bn(e, this.array)),
        (n = bn(n, this.array)),
        (a = bn(a, this.array)),
        (r = bn(r, this.array))),
      (this.array[t + 0] = Hs(e)),
      (this.array[t + 1] = Hs(n)),
      (this.array[t + 2] = Hs(a)),
      (this.array[t + 3] = Hs(r)),
      this
    );
  }
}
class Pe extends Gn {
  constructor(t, e, n) {
    super(new Float32Array(t), e, n);
  }
}
let _O = 0;
const Rr = new Xe(),
  S_ = new Dn(),
  vd = new Z(),
  rr = new Ha(),
  Rm = new Ha(),
  Ma = new Z();
class pn extends ml {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: _O++ }),
      (this.uuid = lr()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return (
      Array.isArray(t)
        ? (this.index = new (LC(t) ? kA : VA)(t, 1))
        : (this.index = t),
      this
    );
  }
  setIndirect(t) {
    return (this.indirect = t), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return (this.attributes[t] = e), this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, n = 0) {
    this.groups.push({ start: t, count: e, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    (this.drawRange.start = t), (this.drawRange.count = e);
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), (e.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new yn().getNormalMatrix(t);
      n.applyNormalMatrix(r), (n.needsUpdate = !0);
    }
    const a = this.attributes.tangent;
    return (
      a !== void 0 && (a.transformDirection(t), (a.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(t) {
    return Rr.makeRotationFromQuaternion(t), this.applyMatrix4(Rr), this;
  }
  rotateX(t) {
    return Rr.makeRotationX(t), this.applyMatrix4(Rr), this;
  }
  rotateY(t) {
    return Rr.makeRotationY(t), this.applyMatrix4(Rr), this;
  }
  rotateZ(t) {
    return Rr.makeRotationZ(t), this.applyMatrix4(Rr), this;
  }
  translate(t, e, n) {
    return Rr.makeTranslation(t, e, n), this.applyMatrix4(Rr), this;
  }
  scale(t, e, n) {
    return Rr.makeScale(t, e, n), this.applyMatrix4(Rr), this;
  }
  lookAt(t) {
    return S_.lookAt(t), S_.updateMatrix(), this.applyMatrix4(S_.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(vd).negate(),
      this.translate(vd.x, vd.y, vd.z),
      this
    );
  }
  setFromPoints(t) {
    const e = this.getAttribute("position");
    if (e === void 0) {
      const n = [];
      for (let a = 0, r = t.length; a < r; a++) {
        const l = t[a];
        n.push(l.x, l.y, l.z || 0);
      }
      this.setAttribute("position", new Pe(n, 3));
    } else {
      const n = Math.min(t.length, e.count);
      for (let a = 0; a < n; a++) {
        const r = t[a];
        e.setXYZ(a, r.x, r.y, r.z || 0);
      }
      t.length > e.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        ),
        (e.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ha());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new Z(-1 / 0, -1 / 0, -1 / 0),
          new Z(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (t !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let n = 0, a = e.length; n < a; n++) {
          const r = e[n];
          rr.setFromBufferAttribute(r),
            this.morphTargetsRelative
              ? (Ma.addVectors(this.boundingBox.min, rr.min),
                this.boundingBox.expandByPoint(Ma),
                Ma.addVectors(this.boundingBox.max, rr.max),
                this.boundingBox.expandByPoint(Ma))
              : (this.boundingBox.expandByPoint(rr.min),
                this.boundingBox.expandByPoint(rr.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new wa());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new Z(), 1 / 0);
      return;
    }
    if (t) {
      const n = this.boundingSphere.center;
      if ((rr.setFromBufferAttribute(t), e))
        for (let r = 0, l = e.length; r < l; r++) {
          const u = e[r];
          Rm.setFromBufferAttribute(u),
            this.morphTargetsRelative
              ? (Ma.addVectors(rr.min, Rm.min),
                rr.expandByPoint(Ma),
                Ma.addVectors(rr.max, Rm.max),
                rr.expandByPoint(Ma))
              : (rr.expandByPoint(Rm.min), rr.expandByPoint(Rm.max));
        }
      rr.getCenter(n);
      let a = 0;
      for (let r = 0, l = t.count; r < l; r++)
        Ma.fromBufferAttribute(t, r),
          (a = Math.max(a, n.distanceToSquared(Ma)));
      if (e)
        for (let r = 0, l = e.length; r < l; r++) {
          const u = e[r],
            h = this.morphTargetsRelative;
          for (let p = 0, m = u.count; p < m; p++)
            Ma.fromBufferAttribute(u, p),
              h && (vd.fromBufferAttribute(t, p), Ma.add(vd)),
              (a = Math.max(a, n.distanceToSquared(Ma)));
        }
      (this.boundingSphere.radius = Math.sqrt(a)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const t = this.index,
      e = this.attributes;
    if (
      t === null ||
      e.position === void 0 ||
      e.normal === void 0 ||
      e.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = e.position,
      a = e.normal,
      r = e.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Gn(new Float32Array(4 * n.count), 4));
    const l = this.getAttribute("tangent"),
      u = [],
      h = [];
    for (let F = 0; F < n.count; F++) (u[F] = new Z()), (h[F] = new Z());
    const p = new Z(),
      m = new Z(),
      v = new Z(),
      x = new Yt(),
      _ = new Yt(),
      M = new Yt(),
      C = new Z(),
      E = new Z();
    function S(F, N, L) {
      p.fromBufferAttribute(n, F),
        m.fromBufferAttribute(n, N),
        v.fromBufferAttribute(n, L),
        x.fromBufferAttribute(r, F),
        _.fromBufferAttribute(r, N),
        M.fromBufferAttribute(r, L),
        m.sub(p),
        v.sub(p),
        _.sub(x),
        M.sub(x);
      const Y = 1 / (_.x * M.y - M.x * _.y);
      isFinite(Y) &&
        (C.copy(m)
          .multiplyScalar(M.y)
          .addScaledVector(v, -_.y)
          .multiplyScalar(Y),
        E.copy(v)
          .multiplyScalar(_.x)
          .addScaledVector(m, -M.x)
          .multiplyScalar(Y),
        u[F].add(C),
        u[N].add(C),
        u[L].add(C),
        h[F].add(E),
        h[N].add(E),
        h[L].add(E));
    }
    let R = this.groups;
    R.length === 0 && (R = [{ start: 0, count: t.count }]);
    for (let F = 0, N = R.length; F < N; ++F) {
      const L = R[F],
        Y = L.start,
        ct = L.count;
      for (let nt = Y, dt = Y + ct; nt < dt; nt += 3)
        S(t.getX(nt + 0), t.getX(nt + 1), t.getX(nt + 2));
    }
    const B = new Z(),
      D = new Z(),
      I = new Z(),
      P = new Z();
    function V(F) {
      I.fromBufferAttribute(a, F), P.copy(I);
      const N = u[F];
      B.copy(N),
        B.sub(I.multiplyScalar(I.dot(N))).normalize(),
        D.crossVectors(P, N);
      const Y = D.dot(h[F]) < 0 ? -1 : 1;
      l.setXYZW(F, B.x, B.y, B.z, Y);
    }
    for (let F = 0, N = R.length; F < N; ++F) {
      const L = R[F],
        Y = L.start,
        ct = L.count;
      for (let nt = Y, dt = Y + ct; nt < dt; nt += 3)
        V(t.getX(nt + 0)), V(t.getX(nt + 1)), V(t.getX(nt + 2));
    }
  }
  computeVertexNormals() {
    const t = this.index,
      e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new Gn(new Float32Array(e.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let x = 0, _ = n.count; x < _; x++) n.setXYZ(x, 0, 0, 0);
      const a = new Z(),
        r = new Z(),
        l = new Z(),
        u = new Z(),
        h = new Z(),
        p = new Z(),
        m = new Z(),
        v = new Z();
      if (t)
        for (let x = 0, _ = t.count; x < _; x += 3) {
          const M = t.getX(x + 0),
            C = t.getX(x + 1),
            E = t.getX(x + 2);
          a.fromBufferAttribute(e, M),
            r.fromBufferAttribute(e, C),
            l.fromBufferAttribute(e, E),
            m.subVectors(l, r),
            v.subVectors(a, r),
            m.cross(v),
            u.fromBufferAttribute(n, M),
            h.fromBufferAttribute(n, C),
            p.fromBufferAttribute(n, E),
            u.add(m),
            h.add(m),
            p.add(m),
            n.setXYZ(M, u.x, u.y, u.z),
            n.setXYZ(C, h.x, h.y, h.z),
            n.setXYZ(E, p.x, p.y, p.z);
        }
      else
        for (let x = 0, _ = e.count; x < _; x += 3)
          a.fromBufferAttribute(e, x + 0),
            r.fromBufferAttribute(e, x + 1),
            l.fromBufferAttribute(e, x + 2),
            m.subVectors(l, r),
            v.subVectors(a, r),
            m.cross(v),
            n.setXYZ(x + 0, m.x, m.y, m.z),
            n.setXYZ(x + 1, m.x, m.y, m.z),
            n.setXYZ(x + 2, m.x, m.y, m.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      Ma.fromBufferAttribute(t, e),
        Ma.normalize(),
        t.setXYZ(e, Ma.x, Ma.y, Ma.z);
  }
  toNonIndexed() {
    function t(u, h) {
      const p = u.array,
        m = u.itemSize,
        v = u.normalized,
        x = new p.constructor(h.length * m);
      let _ = 0,
        M = 0;
      for (let C = 0, E = h.length; C < E; C++) {
        u.isInterleavedBufferAttribute
          ? (_ = h[C] * u.data.stride + u.offset)
          : (_ = h[C] * m);
        for (let S = 0; S < m; S++) x[M++] = p[_++];
      }
      return new Gn(x, m, v);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const e = new pn(),
      n = this.index.array,
      a = this.attributes;
    for (const u in a) {
      const h = a[u],
        p = t(h, n);
      e.setAttribute(u, p);
    }
    const r = this.morphAttributes;
    for (const u in r) {
      const h = [],
        p = r[u];
      for (let m = 0, v = p.length; m < v; m++) {
        const x = p[m],
          _ = t(x, n);
        h.push(_);
      }
      e.morphAttributes[u] = h;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let u = 0, h = l.length; u < h; u++) {
      const p = l[u];
      e.addGroup(p.start, p.count, p.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      this.name !== "" && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const h = this.parameters;
      for (const p in h) h[p] !== void 0 && (t[p] = h[p]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array),
      });
    const n = this.attributes;
    for (const h in n) {
      const p = n[h];
      t.data.attributes[h] = p.toJSON(t.data);
    }
    const a = {};
    let r = !1;
    for (const h in this.morphAttributes) {
      const p = this.morphAttributes[h],
        m = [];
      for (let v = 0, x = p.length; v < x; v++) {
        const _ = p[v];
        m.push(_.toJSON(t.data));
      }
      m.length > 0 && ((a[h] = m), (r = !0));
    }
    r &&
      ((t.data.morphAttributes = a),
      (t.data.morphTargetsRelative = this.morphTargetsRelative));
    const l = this.groups;
    l.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(l)));
    const u = this.boundingSphere;
    return u !== null && (t.data.boundingSphere = u.toJSON()), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone());
    const a = t.attributes;
    for (const p in a) {
      const m = a[p];
      this.setAttribute(p, m.clone(e));
    }
    const r = t.morphAttributes;
    for (const p in r) {
      const m = [],
        v = r[p];
      for (let x = 0, _ = v.length; x < _; x++) m.push(v[x].clone(e));
      this.morphAttributes[p] = m;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const l = t.groups;
    for (let p = 0, m = l.length; p < m; p++) {
      const v = l[p];
      this.addGroup(v.start, v.count, v.materialIndex);
    }
    const u = t.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const h = t.boundingSphere;
    return (
      h !== null && (this.boundingSphere = h.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const ME = new Xe(),
  gf = new ih(),
  Ov = new wa(),
  EE = new Z(),
  Nv = new Z(),
  Lv = new Z(),
  Iv = new Z(),
  M_ = new Z(),
  Pv = new Z(),
  TE = new Z(),
  zv = new Z();
class Ti extends Dn {
  constructor(t = new pn(), e = new ks()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = t),
      (this.material = e),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      (this.count = 1),
      this.updateMorphTargets();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      t.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          t.morphTargetDictionary
        )),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      n = Object.keys(e);
    if (n.length > 0) {
      const a = e[n[0]];
      if (a !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, l = a.length; r < l; r++) {
          const u = a[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = r);
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const n = this.geometry,
      a = n.attributes.position,
      r = n.morphAttributes.position,
      l = n.morphTargetsRelative;
    e.fromBufferAttribute(a, t);
    const u = this.morphTargetInfluences;
    if (r && u) {
      Pv.set(0, 0, 0);
      for (let h = 0, p = r.length; h < p; h++) {
        const m = u[h],
          v = r[h];
        m !== 0 &&
          (M_.fromBufferAttribute(v, t),
          l ? Pv.addScaledVector(M_, m) : Pv.addScaledVector(M_.sub(e), m));
      }
      e.add(Pv);
    }
    return e;
  }
  raycast(t, e) {
    const n = this.geometry,
      a = this.material,
      r = this.matrixWorld;
    a !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Ov.copy(n.boundingSphere),
      Ov.applyMatrix4(r),
      gf.copy(t.ray).recast(t.near),
      !(
        Ov.containsPoint(gf.origin) === !1 &&
        (gf.intersectSphere(Ov, EE) === null ||
          gf.origin.distanceToSquared(EE) > (t.far - t.near) ** 2)
      ) &&
        (ME.copy(r).invert(),
        gf.copy(t.ray).applyMatrix4(ME),
        !(n.boundingBox !== null && gf.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(t, e, gf)));
  }
  _computeIntersections(t, e, n) {
    let a;
    const r = this.geometry,
      l = this.material,
      u = r.index,
      h = r.attributes.position,
      p = r.attributes.uv,
      m = r.attributes.uv1,
      v = r.attributes.normal,
      x = r.groups,
      _ = r.drawRange;
    if (u !== null)
      if (Array.isArray(l))
        for (let M = 0, C = x.length; M < C; M++) {
          const E = x[M],
            S = l[E.materialIndex],
            R = Math.max(E.start, _.start),
            B = Math.min(
              u.count,
              Math.min(E.start + E.count, _.start + _.count)
            );
          for (let D = R, I = B; D < I; D += 3) {
            const P = u.getX(D),
              V = u.getX(D + 1),
              F = u.getX(D + 2);
            (a = Fv(this, S, t, n, p, m, v, P, V, F)),
              a &&
                ((a.faceIndex = Math.floor(D / 3)),
                (a.face.materialIndex = E.materialIndex),
                e.push(a));
          }
        }
      else {
        const M = Math.max(0, _.start),
          C = Math.min(u.count, _.start + _.count);
        for (let E = M, S = C; E < S; E += 3) {
          const R = u.getX(E),
            B = u.getX(E + 1),
            D = u.getX(E + 2);
          (a = Fv(this, l, t, n, p, m, v, R, B, D)),
            a && ((a.faceIndex = Math.floor(E / 3)), e.push(a));
        }
      }
    else if (h !== void 0)
      if (Array.isArray(l))
        for (let M = 0, C = x.length; M < C; M++) {
          const E = x[M],
            S = l[E.materialIndex],
            R = Math.max(E.start, _.start),
            B = Math.min(
              h.count,
              Math.min(E.start + E.count, _.start + _.count)
            );
          for (let D = R, I = B; D < I; D += 3) {
            const P = D,
              V = D + 1,
              F = D + 2;
            (a = Fv(this, S, t, n, p, m, v, P, V, F)),
              a &&
                ((a.faceIndex = Math.floor(D / 3)),
                (a.face.materialIndex = E.materialIndex),
                e.push(a));
          }
        }
      else {
        const M = Math.max(0, _.start),
          C = Math.min(h.count, _.start + _.count);
        for (let E = M, S = C; E < S; E += 3) {
          const R = E,
            B = E + 1,
            D = E + 2;
          (a = Fv(this, l, t, n, p, m, v, R, B, D)),
            a && ((a.faceIndex = Math.floor(E / 3)), e.push(a));
        }
      }
  }
}
function bO(i, t, e, n, a, r, l, u) {
  let h;
  if (
    (t.side === Ms
      ? (h = n.intersectTriangle(l, r, a, !0, u))
      : (h = n.intersectTriangle(a, r, l, t.side === hl, u)),
    h === null)
  )
    return null;
  zv.copy(u), zv.applyMatrix4(i.matrixWorld);
  const p = e.ray.origin.distanceTo(zv);
  return p < e.near || p > e.far
    ? null
    : { distance: p, point: zv.clone(), object: i };
}
function Fv(i, t, e, n, a, r, l, u, h, p) {
  i.getVertexPosition(u, Nv),
    i.getVertexPosition(h, Lv),
    i.getVertexPosition(p, Iv);
  const m = bO(i, t, e, n, Nv, Lv, Iv, TE);
  if (m) {
    const v = new Z();
    Vs.getBarycoord(TE, Nv, Lv, Iv, v),
      a && (m.uv = Vs.getInterpolatedAttribute(a, u, h, p, v, new Yt())),
      r && (m.uv1 = Vs.getInterpolatedAttribute(r, u, h, p, v, new Yt())),
      l &&
        ((m.normal = Vs.getInterpolatedAttribute(l, u, h, p, v, new Z())),
        m.normal.dot(n.direction) > 0 && m.normal.multiplyScalar(-1));
    const x = { a: u, b: h, c: p, normal: new Z(), materialIndex: 0 };
    Vs.getNormal(Nv, Lv, Iv, x.normal), (m.face = x), (m.barycoord = v);
  }
  return m;
}
class ah extends pn {
  constructor(t = 1, e = 1, n = 1, a = 1, r = 1, l = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: a,
        heightSegments: r,
        depthSegments: l,
      });
    const u = this;
    (a = Math.floor(a)), (r = Math.floor(r)), (l = Math.floor(l));
    const h = [],
      p = [],
      m = [],
      v = [];
    let x = 0,
      _ = 0;
    M("z", "y", "x", -1, -1, n, e, t, l, r, 0),
      M("z", "y", "x", 1, -1, n, e, -t, l, r, 1),
      M("x", "z", "y", 1, 1, t, n, e, a, l, 2),
      M("x", "z", "y", 1, -1, t, n, -e, a, l, 3),
      M("x", "y", "z", 1, -1, t, e, n, a, r, 4),
      M("x", "y", "z", -1, -1, t, e, -n, a, r, 5),
      this.setIndex(h),
      this.setAttribute("position", new Pe(p, 3)),
      this.setAttribute("normal", new Pe(m, 3)),
      this.setAttribute("uv", new Pe(v, 2));
    function M(C, E, S, R, B, D, I, P, V, F, N) {
      const L = D / V,
        Y = I / F,
        ct = D / 2,
        nt = I / 2,
        dt = P / 2,
        pt = V + 1,
        j = F + 1;
      let Q = 0,
        et = 0;
      const xt = new Z();
      for (let X = 0; X < j; X++) {
        const ft = X * Y - nt;
        for (let At = 0; At < pt; At++) {
          const Rt = At * L - ct;
          (xt[C] = Rt * R),
            (xt[E] = ft * B),
            (xt[S] = dt),
            p.push(xt.x, xt.y, xt.z),
            (xt[C] = 0),
            (xt[E] = 0),
            (xt[S] = P > 0 ? 1 : -1),
            m.push(xt.x, xt.y, xt.z),
            v.push(At / V),
            v.push(1 - X / F),
            (Q += 1);
        }
      }
      for (let X = 0; X < F; X++)
        for (let ft = 0; ft < V; ft++) {
          const At = x + ft + pt * X,
            Rt = x + ft + pt * (X + 1),
            ht = x + (ft + 1) + pt * (X + 1),
            It = x + (ft + 1) + pt * X;
          h.push(At, Rt, It), h.push(Rt, ht, It), (et += 6);
        }
      u.addGroup(_, et, N), (_ += et), (x += Q);
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new ah(
      t.width,
      t.height,
      t.depth,
      t.widthSegments,
      t.heightSegments,
      t.depthSegments
    );
  }
}
function Qd(i) {
  const t = {};
  for (const e in i) {
    t[e] = {};
    for (const n in i[e]) {
      const a = i[e][n];
      a &&
      (a.isColor ||
        a.isMatrix3 ||
        a.isMatrix4 ||
        a.isVector2 ||
        a.isVector3 ||
        a.isVector4 ||
        a.isTexture ||
        a.isQuaternion)
        ? a.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (t[e][n] = null))
          : (t[e][n] = a.clone())
        : Array.isArray(a)
        ? (t[e][n] = a.slice())
        : (t[e][n] = a);
    }
  }
  return t;
}
function _s(i) {
  const t = {};
  for (let e = 0; e < i.length; e++) {
    const n = Qd(i[e]);
    for (const a in n) t[a] = n[a];
  }
  return t;
}
function AO(i) {
  const t = [];
  for (let e = 0; e < i.length; e++) t.push(i[e].clone());
  return t;
}
function FC(i) {
  const t = i.getRenderTarget();
  return t === null
    ? i.outputColorSpace
    : t.isXRRenderTarget === !0
    ? t.texture.colorSpace
    : In.workingColorSpace;
}
const HC = { clone: Qd, merge: _s };
var SO = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  MO = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Xs extends ma {
  constructor(t) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = SO),
      (this.fragmentShader = MO),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = Qd(t.uniforms)),
      (this.uniformsGroups = AO(t.uniformsGroups)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.fog = t.fog),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    (e.glslVersion = this.glslVersion), (e.uniforms = {});
    for (const a in this.uniforms) {
      const l = this.uniforms[a].value;
      l && l.isTexture
        ? (e.uniforms[a] = { type: "t", value: l.toJSON(t).uuid })
        : l && l.isColor
        ? (e.uniforms[a] = { type: "c", value: l.getHex() })
        : l && l.isVector2
        ? (e.uniforms[a] = { type: "v2", value: l.toArray() })
        : l && l.isVector3
        ? (e.uniforms[a] = { type: "v3", value: l.toArray() })
        : l && l.isVector4
        ? (e.uniforms[a] = { type: "v4", value: l.toArray() })
        : l && l.isMatrix3
        ? (e.uniforms[a] = { type: "m3", value: l.toArray() })
        : l && l.isMatrix4
        ? (e.uniforms[a] = { type: "m4", value: l.toArray() })
        : (e.uniforms[a] = { value: l });
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader),
      (e.lights = this.lights),
      (e.clipping = this.clipping);
    const n = {};
    for (const a in this.extensions) this.extensions[a] === !0 && (n[a] = !0);
    return Object.keys(n).length > 0 && (e.extensions = n), e;
  }
}
class kx extends Dn {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Xe()),
      (this.projectionMatrix = new Xe()),
      (this.projectionMatrixInverse = new Xe()),
      (this.coordinateSystem = Lr);
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      (this.coordinateSystem = t.coordinateSystem),
      this
    );
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const tu = new Z(),
  wE = new Yt(),
  CE = new Yt();
class Ei extends kx {
  constructor(t = 50, e = 1, n = 0.1, a = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = t),
      (this.zoom = 1),
      (this.near = n),
      (this.far = a),
      (this.focus = 10),
      (this.aspect = e),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    );
  }
  setFocalLength(t) {
    const e = (0.5 * this.getFilmHeight()) / t;
    (this.fov = Jd * 2 * Math.atan(e)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t = Math.tan(Wf * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / t;
  }
  getEffectiveFOV() {
    return Jd * 2 * Math.atan(Math.tan(Wf * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(t, e, n) {
    tu.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      e.set(tu.x, tu.y).multiplyScalar(-t / tu.z),
      tu.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(tu.x, tu.y).multiplyScalar(-t / tu.z);
  }
  getViewSize(t, e) {
    return this.getViewBounds(t, wE, CE), e.subVectors(CE, wE);
  }
  setViewOffset(t, e, n, a, r, l) {
    (this.aspect = t / e),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = a),
      (this.view.width = r),
      (this.view.height = l),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = (t * Math.tan(Wf * 0.5 * this.fov)) / this.zoom,
      n = 2 * e,
      a = this.aspect * n,
      r = -0.5 * a;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const h = l.fullWidth,
        p = l.fullHeight;
      (r += (l.offsetX * a) / h),
        (e -= (l.offsetY * n) / p),
        (a *= l.width / h),
        (n *= l.height / p);
    }
    const u = this.filmOffset;
    u !== 0 && (r += (t * u) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        r,
        r + a,
        e,
        e - n,
        t,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    );
  }
}
const yd = -90,
  xd = 1;
class GC extends Dn {
  constructor(t, e, n) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const a = new Ei(yd, xd, t, e);
    (a.layers = this.layers), this.add(a);
    const r = new Ei(yd, xd, t, e);
    (r.layers = this.layers), this.add(r);
    const l = new Ei(yd, xd, t, e);
    (l.layers = this.layers), this.add(l);
    const u = new Ei(yd, xd, t, e);
    (u.layers = this.layers), this.add(u);
    const h = new Ei(yd, xd, t, e);
    (h.layers = this.layers), this.add(h);
    const p = new Ei(yd, xd, t, e);
    (p.layers = this.layers), this.add(p);
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem,
      e = this.children.concat(),
      [n, a, r, l, u, h] = e;
    for (const p of e) this.remove(p);
    if (t === Lr)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        a.up.set(0, 1, 0),
        a.lookAt(-1, 0, 0),
        r.up.set(0, 0, -1),
        r.lookAt(0, 1, 0),
        l.up.set(0, 0, 1),
        l.lookAt(0, -1, 0),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, 1),
        h.up.set(0, 1, 0),
        h.lookAt(0, 0, -1);
    else if (t === h0)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        a.up.set(0, -1, 0),
        a.lookAt(1, 0, 0),
        r.up.set(0, 0, 1),
        r.lookAt(0, 1, 0),
        l.up.set(0, 0, -1),
        l.lookAt(0, -1, 0),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, 1),
        h.up.set(0, -1, 0),
        h.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          t
      );
    for (const p of e) this.add(p), p.updateMatrixWorld();
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: a } = this;
    this.coordinateSystem !== t.coordinateSystem &&
      ((this.coordinateSystem = t.coordinateSystem),
      this.updateCoordinateSystem());
    const [r, l, u, h, p, m] = this.children,
      v = t.getRenderTarget(),
      x = t.getActiveCubeFace(),
      _ = t.getActiveMipmapLevel(),
      M = t.xr.enabled;
    t.xr.enabled = !1;
    const C = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      t.setRenderTarget(n, 0, a),
      t.render(e, r),
      t.setRenderTarget(n, 1, a),
      t.render(e, l),
      t.setRenderTarget(n, 2, a),
      t.render(e, u),
      t.setRenderTarget(n, 3, a),
      t.render(e, h),
      t.setRenderTarget(n, 4, a),
      t.render(e, p),
      (n.texture.generateMipmaps = C),
      t.setRenderTarget(n, 5, a),
      t.render(e, m),
      t.setRenderTarget(v, x, _),
      (t.xr.enabled = M),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class O0 extends Zn {
  constructor(t = [], e = dl, n, a, r, l, u, h, p, m) {
    super(t, e, n, a, r, l, u, h, p, m),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
class jA extends zr {
  constructor(t = 1, e = {}) {
    super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: t, height: t, depth: 1 },
      a = [n, n, n, n, n, n];
    (this.texture = new O0(a)),
      this._setTextureOptions(e),
      (this.texture.isRenderTargetTexture = !0);
  }
  fromEquirectangularTexture(t, e) {
    (this.texture.type = e.type),
      (this.texture.colorSpace = e.colorSpace),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      a = new ah(5, 5, 5),
      r = new Xs({
        name: "CubemapFromEquirect",
        uniforms: Qd(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Ms,
        blending: ol,
      });
    r.uniforms.tEquirect.value = e;
    const l = new Ti(a, r),
      u = e.minFilter;
    return (
      e.minFilter === Nr && (e.minFilter = Kn),
      new GC(1, 10, this).update(t, l),
      (e.minFilter = u),
      l.geometry.dispose(),
      l.material.dispose(),
      this
    );
  }
  clear(t, e = !0, n = !0, a = !0) {
    const r = t.getRenderTarget();
    for (let l = 0; l < 6; l++) t.setRenderTarget(this, l), t.clear(e, n, a);
    t.setRenderTarget(r);
  }
}
class Jl extends Dn {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const EO = { type: "move" };
class Ty {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Jl()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Jl()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Z()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Z())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Jl()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Z()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Z())),
      this._grip
    );
  }
  dispatchEvent(t) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(t),
      this._grip !== null && this._grip.dispatchEvent(t),
      this._hand !== null && this._hand.dispatchEvent(t),
      this
    );
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand;
      if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
    }
    return this.dispatchEvent({ type: "connected", data: t }), this;
  }
  disconnect(t) {
    return (
      this.dispatchEvent({ type: "disconnected", data: t }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(t, e, n) {
    let a = null,
      r = null,
      l = null;
    const u = this._targetRay,
      h = this._grip,
      p = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred") {
      if (p && t.hand) {
        l = !0;
        for (const C of t.hand.values()) {
          const E = e.getJointPose(C, n),
            S = this._getHandJoint(p, C);
          E !== null &&
            (S.matrix.fromArray(E.transform.matrix),
            S.matrix.decompose(S.position, S.rotation, S.scale),
            (S.matrixWorldNeedsUpdate = !0),
            (S.jointRadius = E.radius)),
            (S.visible = E !== null);
        }
        const m = p.joints["index-finger-tip"],
          v = p.joints["thumb-tip"],
          x = m.position.distanceTo(v.position),
          _ = 0.02,
          M = 0.005;
        p.inputState.pinching && x > _ + M
          ? ((p.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: t.handedness,
              target: this,
            }))
          : !p.inputState.pinching &&
            x <= _ - M &&
            ((p.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: t.handedness,
              target: this,
            }));
      } else
        h !== null &&
          t.gripSpace &&
          ((r = e.getPose(t.gripSpace, n)),
          r !== null &&
            (h.matrix.fromArray(r.transform.matrix),
            h.matrix.decompose(h.position, h.rotation, h.scale),
            (h.matrixWorldNeedsUpdate = !0),
            r.linearVelocity
              ? ((h.hasLinearVelocity = !0),
                h.linearVelocity.copy(r.linearVelocity))
              : (h.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((h.hasAngularVelocity = !0),
                h.angularVelocity.copy(r.angularVelocity))
              : (h.hasAngularVelocity = !1)));
      u !== null &&
        ((a = e.getPose(t.targetRaySpace, n)),
        a === null && r !== null && (a = r),
        a !== null &&
          (u.matrix.fromArray(a.transform.matrix),
          u.matrix.decompose(u.position, u.rotation, u.scale),
          (u.matrixWorldNeedsUpdate = !0),
          a.linearVelocity
            ? ((u.hasLinearVelocity = !0),
              u.linearVelocity.copy(a.linearVelocity))
            : (u.hasLinearVelocity = !1),
          a.angularVelocity
            ? ((u.hasAngularVelocity = !0),
              u.angularVelocity.copy(a.angularVelocity))
            : (u.hasAngularVelocity = !1),
          this.dispatchEvent(EO)));
    }
    return (
      u !== null && (u.visible = a !== null),
      h !== null && (h.visible = r !== null),
      p !== null && (p.visible = l !== null),
      this
    );
  }
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const n = new Jl();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (t.joints[e.jointName] = n),
        t.add(n);
    }
    return t.joints[e.jointName];
  }
}
class jx {
  constructor(t, e = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Se(t)),
      (this.density = e);
  }
  clone() {
    return new jx(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Xx {
  constructor(t, e = 1, n = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Se(t)),
      (this.near = e),
      (this.far = n);
  }
  clone() {
    return new Xx(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class N0 extends Dn {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new cr()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new cr()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.background !== null && (this.background = t.background.clone()),
      t.environment !== null && (this.environment = t.environment.clone()),
      t.fog !== null && (this.fog = t.fog.clone()),
      (this.backgroundBlurriness = t.backgroundBlurriness),
      (this.backgroundIntensity = t.backgroundIntensity),
      this.backgroundRotation.copy(t.backgroundRotation),
      (this.environmentIntensity = t.environmentIntensity),
      this.environmentRotation.copy(t.environmentRotation),
      t.overrideMaterial !== null &&
        (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      this.fog !== null && (e.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (e.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (e.object.backgroundIntensity = this.backgroundIntensity),
      (e.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (e.object.environmentIntensity = this.environmentIntensity),
      (e.object.environmentRotation = this.environmentRotation.toArray()),
      e
    );
  }
}
class L0 {
  constructor(t, e) {
    (this.isInterleavedBuffer = !0),
      (this.array = t),
      (this.stride = e),
      (this.count = t !== void 0 ? t.length / e : 0),
      (this.usage = f0),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = lr());
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return (
      (this.array = new t.array.constructor(t.array)),
      (this.count = t.count),
      (this.stride = t.stride),
      (this.usage = t.usage),
      this
    );
  }
  copyAt(t, e, n) {
    (t *= this.stride), (n *= e.stride);
    for (let a = 0, r = this.stride; a < r; a++)
      this.array[t + a] = e.array[n + a];
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  clone(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = lr()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(
        t.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(e, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this;
  }
  toJSON(t) {
    return (
      t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = lr()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const xs = new Z();
class hu {
  constructor(t, e, n, a = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = t),
      (this.itemSize = e),
      (this.offset = n),
      (this.normalized = a);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      xs.fromBufferAttribute(this, e),
        xs.applyMatrix4(t),
        this.setXYZ(e, xs.x, xs.y, xs.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      xs.fromBufferAttribute(this, e),
        xs.applyNormalMatrix(t),
        this.setXYZ(e, xs.x, xs.y, xs.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      xs.fromBufferAttribute(this, e),
        xs.transformDirection(t),
        this.setXYZ(e, xs.x, xs.y, xs.z);
    return this;
  }
  getComponent(t, e) {
    let n = this.array[t * this.data.stride + this.offset + e];
    return this.normalized && (n = As(n, this.array)), n;
  }
  setComponent(t, e, n) {
    return (
      this.normalized && (n = bn(n, this.array)),
      (this.data.array[t * this.data.stride + this.offset + e] = n),
      this
    );
  }
  setX(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset] = e),
      this
    );
  }
  setY(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 1] = e),
      this
    );
  }
  setZ(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 2] = e),
      this
    );
  }
  setW(t, e) {
    return (
      this.normalized && (e = bn(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 3] = e),
      this
    );
  }
  getX(t) {
    let e = this.data.array[t * this.data.stride + this.offset];
    return this.normalized && (e = As(e, this.array)), e;
  }
  getY(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 1];
    return this.normalized && (e = As(e, this.array)), e;
  }
  getZ(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 2];
    return this.normalized && (e = As(e, this.array)), e;
  }
  getW(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 3];
    return this.normalized && (e = As(e, this.array)), e;
  }
  setXY(t, e, n) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized && ((e = bn(e, this.array)), (n = bn(n, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      this
    );
  }
  setXYZ(t, e, n, a) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized &&
        ((e = bn(e, this.array)),
        (n = bn(n, this.array)),
        (a = bn(a, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = a),
      this
    );
  }
  setXYZW(t, e, n, a, r) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized &&
        ((e = bn(e, this.array)),
        (n = bn(n, this.array)),
        (a = bn(a, this.array)),
        (r = bn(r, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = a),
      (this.data.array[t + 3] = r),
      this
    );
  }
  clone(t) {
    if (t === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const a = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[a + r]);
      }
      return new Gn(
        new this.array.constructor(e),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new hu(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(t) {
    if (t === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const a = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[a + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized,
      };
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class XA extends ma {
  constructor(t) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Se(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.rotation = t.rotation),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.fog = t.fog),
      this
    );
  }
}
let _d;
const Bm = new Z(),
  bd = new Z(),
  Ad = new Z(),
  Sd = new Yt(),
  Dm = new Yt(),
  VC = new Xe(),
  Hv = new Z(),
  Um = new Z(),
  Gv = new Z(),
  RE = new Yt(),
  E_ = new Yt(),
  BE = new Yt();
class kC extends Dn {
  constructor(t = new XA()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), _d === void 0)
    ) {
      _d = new pn();
      const e = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new L0(e, 5);
      _d.setIndex([0, 1, 2, 0, 2, 3]),
        _d.setAttribute("position", new hu(n, 3, 0, !1)),
        _d.setAttribute("uv", new hu(n, 2, 3, !1));
    }
    (this.geometry = _d),
      (this.material = t),
      (this.center = new Yt(0.5, 0.5)),
      (this.count = 1);
  }
  raycast(t, e) {
    t.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      bd.setFromMatrixScale(this.matrixWorld),
      VC.copy(t.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        t.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Ad.setFromMatrixPosition(this.modelViewMatrix),
      t.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        bd.multiplyScalar(-Ad.z);
    const n = this.material.rotation;
    let a, r;
    n !== 0 && ((r = Math.cos(n)), (a = Math.sin(n)));
    const l = this.center;
    Vv(Hv.set(-0.5, -0.5, 0), Ad, l, bd, a, r),
      Vv(Um.set(0.5, -0.5, 0), Ad, l, bd, a, r),
      Vv(Gv.set(0.5, 0.5, 0), Ad, l, bd, a, r),
      RE.set(0, 0),
      E_.set(1, 0),
      BE.set(1, 1);
    let u = t.ray.intersectTriangle(Hv, Um, Gv, !1, Bm);
    if (
      u === null &&
      (Vv(Um.set(-0.5, 0.5, 0), Ad, l, bd, a, r),
      E_.set(0, 1),
      (u = t.ray.intersectTriangle(Hv, Gv, Um, !1, Bm)),
      u === null)
    )
      return;
    const h = t.ray.origin.distanceTo(Bm);
    h < t.near ||
      h > t.far ||
      e.push({
        distance: h,
        point: Bm.clone(),
        uv: Vs.getInterpolation(Bm, Hv, Um, Gv, RE, E_, BE, new Yt()),
        face: null,
        object: this,
      });
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.center !== void 0 && this.center.copy(t.center),
      (this.material = t.material),
      this
    );
  }
}
function Vv(i, t, e, n, a, r) {
  Sd.subVectors(i, e).addScalar(0.5).multiply(n),
    a !== void 0
      ? ((Dm.x = r * Sd.x - a * Sd.y), (Dm.y = a * Sd.x + r * Sd.y))
      : Dm.copy(Sd),
    i.copy(t),
    (i.x += Dm.x),
    (i.y += Dm.y),
    i.applyMatrix4(VC);
}
const kv = new Z(),
  DE = new Z();
class jC extends Dn {
  constructor() {
    super(),
      (this.isLOD = !0),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
      (this.autoUpdate = !0);
  }
  copy(t) {
    super.copy(t, !1);
    const e = t.levels;
    for (let n = 0, a = e.length; n < a; n++) {
      const r = e[n];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return (this.autoUpdate = t.autoUpdate), this;
  }
  addLevel(t, e = 0, n = 0) {
    e = Math.abs(e);
    const a = this.levels;
    let r;
    for (r = 0; r < a.length && !(e < a[r].distance); r++);
    return (
      a.splice(r, 0, { distance: e, hysteresis: n, object: t }),
      this.add(t),
      this
    );
  }
  removeLevel(t) {
    const e = this.levels;
    for (let n = 0; n < e.length; n++)
      if (e[n].distance === t) {
        const a = e.splice(n, 1);
        return this.remove(a[0].object), !0;
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(t) {
    const e = this.levels;
    if (e.length > 0) {
      let n, a;
      for (n = 1, a = e.length; n < a; n++) {
        let r = e[n].distance;
        if ((e[n].object.visible && (r -= r * e[n].hysteresis), t < r)) break;
      }
      return e[n - 1].object;
    }
    return null;
  }
  raycast(t, e) {
    if (this.levels.length > 0) {
      kv.setFromMatrixPosition(this.matrixWorld);
      const a = t.ray.origin.distanceTo(kv);
      this.getObjectForDistance(a).raycast(t, e);
    }
  }
  update(t) {
    const e = this.levels;
    if (e.length > 1) {
      kv.setFromMatrixPosition(t.matrixWorld),
        DE.setFromMatrixPosition(this.matrixWorld);
      const n = kv.distanceTo(DE) / t.zoom;
      e[0].object.visible = !0;
      let a, r;
      for (a = 1, r = e.length; a < r; a++) {
        let l = e[a].distance;
        if ((e[a].object.visible && (l -= l * e[a].hysteresis), n >= l))
          (e[a - 1].object.visible = !1), (e[a].object.visible = !0);
        else break;
      }
      for (this._currentLevel = a - 1; a < r; a++) e[a].object.visible = !1;
    }
  }
  toJSON(t) {
    const e = super.toJSON(t);
    this.autoUpdate === !1 && (e.object.autoUpdate = !1),
      (e.object.levels = []);
    const n = this.levels;
    for (let a = 0, r = n.length; a < r; a++) {
      const l = n[a];
      e.object.levels.push({
        object: l.object.uuid,
        distance: l.distance,
        hysteresis: l.hysteresis,
      });
    }
    return e;
  }
}
const UE = new Z(),
  OE = new Hn(),
  NE = new Hn(),
  TO = new Z(),
  LE = new Xe(),
  jv = new Z(),
  T_ = new wa(),
  IE = new Xe(),
  w_ = new ih();
class WA extends Ti {
  constructor(t, e) {
    super(t, e),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = zb),
      (this.bindMatrix = new Xe()),
      (this.bindMatrixInverse = new Xe()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const t = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Ha()),
      this.boundingBox.makeEmpty();
    const e = t.getAttribute("position");
    for (let n = 0; n < e.count; n++)
      this.getVertexPosition(n, jv), this.boundingBox.expandByPoint(jv);
  }
  computeBoundingSphere() {
    const t = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new wa()),
      this.boundingSphere.makeEmpty();
    const e = t.getAttribute("position");
    for (let n = 0; n < e.count; n++)
      this.getVertexPosition(n, jv), this.boundingSphere.expandByPoint(jv);
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.bindMode = t.bindMode),
      this.bindMatrix.copy(t.bindMatrix),
      this.bindMatrixInverse.copy(t.bindMatrixInverse),
      (this.skeleton = t.skeleton),
      t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
      t.boundingSphere !== null &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    );
  }
  raycast(t, e) {
    const n = this.material,
      a = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      T_.copy(this.boundingSphere),
      T_.applyMatrix4(a),
      t.ray.intersectsSphere(T_) !== !1 &&
        (IE.copy(a).invert(),
        w_.copy(t.ray).applyMatrix4(IE),
        !(
          this.boundingBox !== null && w_.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(t, e, w_)));
  }
  getVertexPosition(t, e) {
    return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
  }
  bind(t, e) {
    (this.skeleton = t),
      e === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (e = this.matrixWorld)),
      this.bindMatrix.copy(e),
      this.bindMatrixInverse.copy(e).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const t = new Hn(),
      e = this.geometry.attributes.skinWeight;
    for (let n = 0, a = e.count; n < a; n++) {
      t.fromBufferAttribute(e, n);
      const r = 1 / t.manhattanLength();
      r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
        e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.bindMode === zb
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === _C
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(t, e) {
    const n = this.skeleton,
      a = this.geometry;
    OE.fromBufferAttribute(a.attributes.skinIndex, t),
      NE.fromBufferAttribute(a.attributes.skinWeight, t),
      UE.copy(e).applyMatrix4(this.bindMatrix),
      e.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const l = NE.getComponent(r);
      if (l !== 0) {
        const u = OE.getComponent(r);
        LE.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]),
          e.addScaledVector(TO.copy(UE).applyMatrix4(LE), l);
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse);
  }
}
class Wx extends Dn {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class _o extends Zn {
  constructor(t = null, e = 1, n = 1, a, r, l, u, h, p = Ta, m = Ta, v, x) {
    super(null, l, u, h, p, m, a, r, v, x),
      (this.isDataTexture = !0),
      (this.image = { data: t, width: e, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const PE = new Xe(),
  wO = new Xe();
class I0 {
  constructor(t = [], e = []) {
    (this.uuid = lr()),
      (this.bones = t.slice(0)),
      (this.boneInverses = e),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const t = this.bones,
      e = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(t.length * 16)), e.length === 0))
      this.calculateInverses();
    else if (t.length !== e.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, a = this.bones.length; n < a; n++)
        this.boneInverses.push(new Xe());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = new Xe();
      this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n && n.matrixWorld.copy(this.boneInverses[t]).invert();
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const t = this.bones,
      e = this.boneInverses,
      n = this.boneMatrices,
      a = this.boneTexture;
    for (let r = 0, l = t.length; r < l; r++) {
      const u = t[r] ? t[r].matrixWorld : wO;
      PE.multiplyMatrices(u, e[r]), PE.toArray(n, r * 16);
    }
    a !== null && (a.needsUpdate = !0);
  }
  clone() {
    return new I0(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let t = Math.sqrt(this.bones.length * 4);
    (t = Math.ceil(t / 4) * 4), (t = Math.max(t, 4));
    const e = new Float32Array(t * t * 4);
    e.set(this.boneMatrices);
    const n = new _o(e, t, t, Ji, Pi);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = e),
      (this.boneTexture = n),
      this
    );
  }
  getBoneByName(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const a = this.bones[e];
      if (a.name === t) return a;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(t, e) {
    this.uuid = t.uuid;
    for (let n = 0, a = t.bones.length; n < a; n++) {
      const r = t.bones[n];
      let l = e[r];
      l === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", r),
        (l = new Wx())),
        this.bones.push(l),
        this.boneInverses.push(new Xe().fromArray(t.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.7,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    t.uuid = this.uuid;
    const e = this.bones,
      n = this.boneInverses;
    for (let a = 0, r = e.length; a < r; a++) {
      const l = e[a];
      t.bones.push(l.uuid);
      const u = n[a];
      t.boneInverses.push(u.toArray());
    }
    return t;
  }
}
class Zf extends Gn {
  constructor(t, e, n, a = 1) {
    super(t, e, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = a);
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.meshPerAttribute = this.meshPerAttribute),
      (t.isInstancedBufferAttribute = !0),
      t
    );
  }
}
const Md = new Xe(),
  zE = new Xe(),
  Xv = [],
  FE = new Ha(),
  CO = new Xe(),
  Om = new Ti(),
  Nm = new wa();
class YA extends Ti {
  constructor(t, e, n) {
    super(t, e),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Zf(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let a = 0; a < n; a++) this.setMatrixAt(a, CO);
  }
  computeBoundingBox() {
    const t = this.geometry,
      e = this.count;
    this.boundingBox === null && (this.boundingBox = new Ha()),
      t.boundingBox === null && t.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Md),
        FE.copy(t.boundingBox).applyMatrix4(Md),
        this.boundingBox.union(FE);
  }
  computeBoundingSphere() {
    const t = this.geometry,
      e = this.count;
    this.boundingSphere === null && (this.boundingSphere = new wa()),
      t.boundingSphere === null && t.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Md),
        Nm.copy(t.boundingSphere).applyMatrix4(Md),
        this.boundingSphere.union(Nm);
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.instanceMatrix.copy(t.instanceMatrix),
      t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()),
      t.instanceColor !== null &&
        (this.instanceColor = t.instanceColor.clone()),
      (this.count = t.count),
      t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
      t.boundingSphere !== null &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    );
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, t * 3);
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  }
  getMorphAt(t, e) {
    const n = e.morphTargetInfluences,
      a = this.morphTexture.source.data.data,
      r = n.length + 1,
      l = t * r + 1;
    for (let u = 0; u < n.length; u++) n[u] = a[l + u];
  }
  raycast(t, e) {
    const n = this.matrixWorld,
      a = this.count;
    if (
      ((Om.geometry = this.geometry),
      (Om.material = this.material),
      Om.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Nm.copy(this.boundingSphere),
        Nm.applyMatrix4(n),
        t.ray.intersectsSphere(Nm) !== !1))
    )
      for (let r = 0; r < a; r++) {
        this.getMatrixAt(r, Md),
          zE.multiplyMatrices(n, Md),
          (Om.matrixWorld = zE),
          Om.raycast(t, Xv);
        for (let l = 0, u = Xv.length; l < u; l++) {
          const h = Xv[l];
          (h.instanceId = r), (h.object = this), e.push(h);
        }
        Xv.length = 0;
      }
  }
  setColorAt(t, e) {
    this.instanceColor === null &&
      (this.instanceColor = new Zf(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      e.toArray(this.instanceColor.array, t * 3);
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  }
  setMorphAt(t, e) {
    const n = e.morphTargetInfluences,
      a = n.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new _o(
        new Float32Array(a * this.count),
        a,
        this.count,
        D0,
        Pi
      ));
    const r = this.morphTexture.source.data.data;
    let l = 0;
    for (let p = 0; p < n.length; p++) l += n[p];
    const u = this.geometry.morphTargetsRelative ? 1 : 1 - l,
      h = a * t;
    (r[h] = u), r.set(n, h + 1);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null));
  }
}
const C_ = new Z(),
  RO = new Z(),
  BO = new yn();
class Yl {
  constructor(t = new Z(1, 0, 0), e = 0) {
    (this.isPlane = !0), (this.normal = t), (this.constant = e);
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this;
  }
  setComponents(t, e, n, a) {
    return this.normal.set(t, e, n), (this.constant = a), this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
  }
  setFromCoplanarPoints(t, e, n) {
    const a = C_.subVectors(n, e).cross(RO.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(a, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), (this.constant *= t), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
  }
  intersectLine(t, e) {
    const n = t.delta(C_),
      a = this.normal.dot(n);
    if (a === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const r = -(t.start.dot(this.normal) + this.constant) / a;
    return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      n = this.distanceToPoint(t.end);
    return (e < 0 && n > 0) || (n < 0 && e > 0);
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const n = e || BO.getNormalMatrix(t),
      a = this.coplanarPoint(C_).applyMatrix4(t),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -a.dot(r)), this;
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const vf = new wa(),
  Wv = new Z();
class ap {
  constructor(
    t = new Yl(),
    e = new Yl(),
    n = new Yl(),
    a = new Yl(),
    r = new Yl(),
    l = new Yl()
  ) {
    this.planes = [t, e, n, a, r, l];
  }
  set(t, e, n, a, r, l) {
    const u = this.planes;
    return (
      u[0].copy(t),
      u[1].copy(e),
      u[2].copy(n),
      u[3].copy(a),
      u[4].copy(r),
      u[5].copy(l),
      this
    );
  }
  copy(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
    return this;
  }
  setFromProjectionMatrix(t, e = Lr) {
    const n = this.planes,
      a = t.elements,
      r = a[0],
      l = a[1],
      u = a[2],
      h = a[3],
      p = a[4],
      m = a[5],
      v = a[6],
      x = a[7],
      _ = a[8],
      M = a[9],
      C = a[10],
      E = a[11],
      S = a[12],
      R = a[13],
      B = a[14],
      D = a[15];
    if (
      (n[0].setComponents(h - r, x - p, E - _, D - S).normalize(),
      n[1].setComponents(h + r, x + p, E + _, D + S).normalize(),
      n[2].setComponents(h + l, x + m, E + M, D + R).normalize(),
      n[3].setComponents(h - l, x - m, E - M, D - R).normalize(),
      n[4].setComponents(h - u, x - v, E - C, D - B).normalize(),
      e === Lr)
    )
      n[5].setComponents(h + u, x + v, E + C, D + B).normalize();
    else if (e === h0) n[5].setComponents(u, v, C, B).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          e
      );
    return this;
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0)
      t.boundingSphere === null && t.computeBoundingSphere(),
        vf.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
    else {
      const e = t.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(),
        vf.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
    }
    return this.intersectsSphere(vf);
  }
  intersectsSprite(t) {
    return (
      vf.center.set(0, 0, 0),
      (vf.radius = 0.7071067811865476),
      vf.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(vf)
    );
  }
  intersectsSphere(t) {
    const e = this.planes,
      n = t.center,
      a = -t.radius;
    for (let r = 0; r < 6; r++) if (e[r].distanceToPoint(n) < a) return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const a = e[n];
      if (
        ((Wv.x = a.normal.x > 0 ? t.max.x : t.min.x),
        (Wv.y = a.normal.y > 0 ? t.max.y : t.min.y),
        (Wv.z = a.normal.z > 0 ? t.max.z : t.min.z),
        a.distanceToPoint(Wv) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const al = new Xe(),
  sl = new ap();
class Yx {
  constructor() {
    this.coordinateSystem = Lr;
  }
  intersectsObject(t, e) {
    if (!e.isArrayCamera || e.cameras.length === 0) return !1;
    for (let n = 0; n < e.cameras.length; n++) {
      const a = e.cameras[n];
      if (
        (al.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
        sl.setFromProjectionMatrix(al, this.coordinateSystem),
        sl.intersectsObject(t))
      )
        return !0;
    }
    return !1;
  }
  intersectsSprite(t, e) {
    if (!e || !e.cameras || e.cameras.length === 0) return !1;
    for (let n = 0; n < e.cameras.length; n++) {
      const a = e.cameras[n];
      if (
        (al.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
        sl.setFromProjectionMatrix(al, this.coordinateSystem),
        sl.intersectsSprite(t))
      )
        return !0;
    }
    return !1;
  }
  intersectsSphere(t, e) {
    if (!e || !e.cameras || e.cameras.length === 0) return !1;
    for (let n = 0; n < e.cameras.length; n++) {
      const a = e.cameras[n];
      if (
        (al.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
        sl.setFromProjectionMatrix(al, this.coordinateSystem),
        sl.intersectsSphere(t))
      )
        return !0;
    }
    return !1;
  }
  intersectsBox(t, e) {
    if (!e || !e.cameras || e.cameras.length === 0) return !1;
    for (let n = 0; n < e.cameras.length; n++) {
      const a = e.cameras[n];
      if (
        (al.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
        sl.setFromProjectionMatrix(al, this.coordinateSystem),
        sl.intersectsBox(t))
      )
        return !0;
    }
    return !1;
  }
  containsPoint(t, e) {
    if (!e || !e.cameras || e.cameras.length === 0) return !1;
    for (let n = 0; n < e.cameras.length; n++) {
      const a = e.cameras[n];
      if (
        (al.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
        sl.setFromProjectionMatrix(al, this.coordinateSystem),
        sl.containsPoint(t))
      )
        return !0;
    }
    return !1;
  }
  clone() {
    return new Yx();
  }
}
function R_(i, t) {
  return i - t;
}
function DO(i, t) {
  return i.z - t.z;
}
function UO(i, t) {
  return t.z - i.z;
}
class OO {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(t, e, n, a) {
    const r = this.pool,
      l = this.list;
    this.index >= r.length &&
      r.push({ start: -1, count: -1, z: -1, index: -1 });
    const u = r[this.index];
    l.push(u),
      this.index++,
      (u.start = t),
      (u.count = e),
      (u.z = n),
      (u.index = a);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Fs = new Xe(),
  NO = new Se(1, 1, 1),
  HE = new ap(),
  LO = new Yx(),
  Yv = new Ha(),
  yf = new wa(),
  Lm = new Z(),
  GE = new Z(),
  IO = new Z(),
  B_ = new OO(),
  es = new Ti(),
  qv = [];
function PO(i, t, e = 0) {
  const n = t.itemSize;
  if (
    i.isInterleavedBufferAttribute ||
    i.array.constructor !== t.array.constructor
  ) {
    const a = i.count;
    for (let r = 0; r < a; r++)
      for (let l = 0; l < n; l++)
        t.setComponent(r + e, l, i.getComponent(r, l));
  } else t.array.set(i.array, e * n);
  t.needsUpdate = !0;
}
function xf(i, t) {
  if (i.constructor !== t.constructor) {
    const e = Math.min(i.length, t.length);
    for (let n = 0; n < e; n++) t[n] = i[n];
  } else {
    const e = Math.min(i.length, t.length);
    t.set(new i.constructor(i.buffer, 0, e));
  }
}
class XC extends Ti {
  constructor(t, e, n = e * 2, a) {
    super(new pn(), a),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = t),
      (this._maxVertexCount = e),
      (this._maxIndexCount = n),
      (this._multiDrawCounts = new Int32Array(t)),
      (this._multiDrawStarts = new Int32Array(t)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let t = Math.sqrt(this._maxInstanceCount * 4);
    (t = Math.ceil(t / 4) * 4), (t = Math.max(t, 4));
    const e = new Float32Array(t * t * 4),
      n = new _o(e, t, t, Ji, Pi);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let t = Math.sqrt(this._maxInstanceCount);
    t = Math.ceil(t);
    const e = new Uint32Array(t * t),
      n = new _o(e, t, t, U0, pl);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let t = Math.sqrt(this._maxInstanceCount);
    t = Math.ceil(t);
    const e = new Float32Array(t * t * 4).fill(1),
      n = new _o(e, t, t, Ji, Pi);
    (n.colorSpace = In.workingColorSpace), (this._colorsTexture = n);
  }
  _initializeGeometry(t) {
    const e = this.geometry,
      n = this._maxVertexCount,
      a = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const r in t.attributes) {
        const l = t.getAttribute(r),
          { array: u, itemSize: h, normalized: p } = l,
          m = new u.constructor(n * h),
          v = new Gn(m, h, p);
        e.setAttribute(r, v);
      }
      if (t.getIndex() !== null) {
        const r = n > 65535 ? new Uint32Array(a) : new Uint16Array(a);
        e.setIndex(new Gn(r, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(t) {
    const e = this.geometry;
    if (!!t.getIndex() != !!e.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".'
      );
    for (const n in e.attributes) {
      if (!t.hasAttribute(n))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`
        );
      const a = t.getAttribute(n),
        r = e.getAttribute(n);
      if (a.itemSize !== r.itemSize || a.normalized !== r.normalized)
        throw new Error(
          "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  validateInstanceId(t) {
    const e = this._instanceInfo;
    if (t < 0 || t >= e.length || e[t].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`
      );
  }
  validateGeometryId(t) {
    const e = this._geometryInfo;
    if (t < 0 || t >= e.length || e[t].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`
      );
  }
  setCustomSort(t) {
    return (this.customSort = t), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ha());
    const t = this.boundingBox,
      e = this._instanceInfo;
    t.makeEmpty();
    for (let n = 0, a = e.length; n < a; n++) {
      if (e[n].active === !1) continue;
      const r = e[n].geometryIndex;
      this.getMatrixAt(n, Fs),
        this.getBoundingBoxAt(r, Yv).applyMatrix4(Fs),
        t.union(Yv);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new wa());
    const t = this.boundingSphere,
      e = this._instanceInfo;
    t.makeEmpty();
    for (let n = 0, a = e.length; n < a; n++) {
      if (e[n].active === !1) continue;
      const r = e[n].geometryIndex;
      this.getMatrixAt(n, Fs),
        this.getBoundingSphereAt(r, yf).applyMatrix4(Fs),
        t.union(yf);
    }
  }
  addInstance(t) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const n = { visible: !0, active: !0, geometryIndex: t };
    let a = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(R_),
        (a = this._availableInstanceIds.shift()),
        (this._instanceInfo[a] = n))
      : ((a = this._instanceInfo.length), this._instanceInfo.push(n));
    const r = this._matricesTexture;
    Fs.identity().toArray(r.image.data, a * 16), (r.needsUpdate = !0);
    const l = this._colorsTexture;
    return (
      l && (NO.toArray(l.image.data, a * 4), (l.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      a
    );
  }
  addGeometry(t, e = -1, n = -1) {
    this._initializeGeometry(t), this._validateGeometry(t);
    const a = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      r = this._geometryInfo;
    (a.vertexStart = this._nextVertexStart),
      (a.reservedVertexCount = e === -1 ? t.getAttribute("position").count : e);
    const l = t.getIndex();
    if (
      (l !== null &&
        ((a.indexStart = this._nextIndexStart),
        (a.reservedIndexCount = n === -1 ? l.count : n)),
      (a.indexStart !== -1 &&
        a.indexStart + a.reservedIndexCount > this._maxIndexCount) ||
        a.vertexStart + a.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    let h;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(R_),
          (h = this._availableGeometryIds.shift()),
          (r[h] = a))
        : ((h = this._geometryCount), this._geometryCount++, r.push(a)),
      this.setGeometryAt(h, t),
      (this._nextIndexStart = a.indexStart + a.reservedIndexCount),
      (this._nextVertexStart = a.vertexStart + a.reservedVertexCount),
      h
    );
  }
  setGeometryAt(t, e) {
    if (t >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(e);
    const n = this.geometry,
      a = n.getIndex() !== null,
      r = n.getIndex(),
      l = e.getIndex(),
      u = this._geometryInfo[t];
    if (
      (a && l.count > u.reservedIndexCount) ||
      e.attributes.position.count > u.reservedVertexCount
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const h = u.vertexStart,
      p = u.reservedVertexCount;
    u.vertexCount = e.getAttribute("position").count;
    for (const m in n.attributes) {
      const v = e.getAttribute(m),
        x = n.getAttribute(m);
      PO(v, x, h);
      const _ = v.itemSize;
      for (let M = v.count, C = p; M < C; M++) {
        const E = h + M;
        for (let S = 0; S < _; S++) x.setComponent(E, S, 0);
      }
      (x.needsUpdate = !0), x.addUpdateRange(h * _, p * _);
    }
    if (a) {
      const m = u.indexStart,
        v = u.reservedIndexCount;
      u.indexCount = e.getIndex().count;
      for (let x = 0; x < l.count; x++) r.setX(m + x, h + l.getX(x));
      for (let x = l.count, _ = v; x < _; x++) r.setX(m + x, h);
      (r.needsUpdate = !0), r.addUpdateRange(m, u.reservedIndexCount);
    }
    return (
      (u.start = a ? u.indexStart : u.vertexStart),
      (u.count = a ? u.indexCount : u.vertexCount),
      (u.boundingBox = null),
      e.boundingBox !== null && (u.boundingBox = e.boundingBox.clone()),
      (u.boundingSphere = null),
      e.boundingSphere !== null &&
        (u.boundingSphere = e.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      t
    );
  }
  deleteGeometry(t) {
    const e = this._geometryInfo;
    if (t >= e.length || e[t].active === !1) return this;
    const n = this._instanceInfo;
    for (let a = 0, r = n.length; a < r; a++)
      n[a].active && n[a].geometryIndex === t && this.deleteInstance(a);
    return (
      (e[t].active = !1),
      this._availableGeometryIds.push(t),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(t) {
    return (
      this.validateInstanceId(t),
      (this._instanceInfo[t].active = !1),
      this._availableInstanceIds.push(t),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let t = 0,
      e = 0;
    const n = this._geometryInfo,
      a = n
        .map((l, u) => u)
        .sort((l, u) => n[l].vertexStart - n[u].vertexStart),
      r = this.geometry;
    for (let l = 0, u = n.length; l < u; l++) {
      const h = a[l],
        p = n[h];
      if (p.active !== !1) {
        if (r.index !== null) {
          if (p.indexStart !== e) {
            const { indexStart: m, vertexStart: v, reservedIndexCount: x } = p,
              _ = r.index,
              M = _.array,
              C = t - v;
            for (let E = m; E < m + x; E++) M[E] = M[E] + C;
            _.array.copyWithin(e, m, m + x),
              _.addUpdateRange(e, x),
              (p.indexStart = e);
          }
          e += p.reservedIndexCount;
        }
        if (p.vertexStart !== t) {
          const { vertexStart: m, reservedVertexCount: v } = p,
            x = r.attributes;
          for (const _ in x) {
            const M = x[_],
              { array: C, itemSize: E } = M;
            C.copyWithin(t * E, m * E, (m + v) * E),
              M.addUpdateRange(t * E, v * E);
          }
          p.vertexStart = t;
        }
        (t += p.reservedVertexCount),
          (p.start = r.index ? p.indexStart : p.vertexStart),
          (this._nextIndexStart = r.index
            ? p.indexStart + p.reservedIndexCount
            : 0),
          (this._nextVertexStart = p.vertexStart + p.reservedVertexCount);
      }
    }
    return this;
  }
  getBoundingBoxAt(t, e) {
    if (t >= this._geometryCount) return null;
    const n = this.geometry,
      a = this._geometryInfo[t];
    if (a.boundingBox === null) {
      const r = new Ha(),
        l = n.index,
        u = n.attributes.position;
      for (let h = a.start, p = a.start + a.count; h < p; h++) {
        let m = h;
        l && (m = l.getX(m)), r.expandByPoint(Lm.fromBufferAttribute(u, m));
      }
      a.boundingBox = r;
    }
    return e.copy(a.boundingBox), e;
  }
  getBoundingSphereAt(t, e) {
    if (t >= this._geometryCount) return null;
    const n = this.geometry,
      a = this._geometryInfo[t];
    if (a.boundingSphere === null) {
      const r = new wa();
      this.getBoundingBoxAt(t, Yv), Yv.getCenter(r.center);
      const l = n.index,
        u = n.attributes.position;
      let h = 0;
      for (let p = a.start, m = a.start + a.count; p < m; p++) {
        let v = p;
        l && (v = l.getX(v)),
          Lm.fromBufferAttribute(u, v),
          (h = Math.max(h, r.center.distanceToSquared(Lm)));
      }
      (r.radius = Math.sqrt(h)), (a.boundingSphere = r);
    }
    return e.copy(a.boundingSphere), e;
  }
  setMatrixAt(t, e) {
    this.validateInstanceId(t);
    const n = this._matricesTexture,
      a = this._matricesTexture.image.data;
    return e.toArray(a, t * 16), (n.needsUpdate = !0), this;
  }
  getMatrixAt(t, e) {
    return (
      this.validateInstanceId(t),
      e.fromArray(this._matricesTexture.image.data, t * 16)
    );
  }
  setColorAt(t, e) {
    return (
      this.validateInstanceId(t),
      this._colorsTexture === null && this._initColorsTexture(),
      e.toArray(this._colorsTexture.image.data, t * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(t, e) {
    return (
      this.validateInstanceId(t),
      e.fromArray(this._colorsTexture.image.data, t * 4)
    );
  }
  setVisibleAt(t, e) {
    return (
      this.validateInstanceId(t),
      this._instanceInfo[t].visible === e
        ? this
        : ((this._instanceInfo[t].visible = e),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(t) {
    return this.validateInstanceId(t), this._instanceInfo[t].visible;
  }
  setGeometryIdAt(t, e) {
    return (
      this.validateInstanceId(t),
      this.validateGeometryId(e),
      (this._instanceInfo[t].geometryIndex = e),
      this
    );
  }
  getGeometryIdAt(t) {
    return this.validateInstanceId(t), this._instanceInfo[t].geometryIndex;
  }
  getGeometryRangeAt(t, e = {}) {
    this.validateGeometryId(t);
    const n = this._geometryInfo[t];
    return (
      (e.vertexStart = n.vertexStart),
      (e.vertexCount = n.vertexCount),
      (e.reservedVertexCount = n.reservedVertexCount),
      (e.indexStart = n.indexStart),
      (e.indexCount = n.indexCount),
      (e.reservedIndexCount = n.reservedIndexCount),
      (e.start = n.start),
      (e.count = n.count),
      e
    );
  }
  setInstanceCount(t) {
    const e = this._availableInstanceIds,
      n = this._instanceInfo;
    for (e.sort(R_); e[e.length - 1] === n.length; ) n.pop(), e.pop();
    if (t < n.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`
      );
    const a = new Int32Array(t),
      r = new Int32Array(t);
    xf(this._multiDrawCounts, a),
      xf(this._multiDrawStarts, r),
      (this._multiDrawCounts = a),
      (this._multiDrawStarts = r),
      (this._maxInstanceCount = t);
    const l = this._indirectTexture,
      u = this._matricesTexture,
      h = this._colorsTexture;
    l.dispose(),
      this._initIndirectTexture(),
      xf(l.image.data, this._indirectTexture.image.data),
      u.dispose(),
      this._initMatricesTexture(),
      xf(u.image.data, this._matricesTexture.image.data),
      h &&
        (h.dispose(),
        this._initColorsTexture(),
        xf(h.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(t, e) {
    const n = [...this._geometryInfo].filter((u) => u.active);
    if (Math.max(...n.map((u) => u.vertexStart + u.reservedVertexCount)) > t)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`
      );
    if (
      this.geometry.index &&
      Math.max(...n.map((h) => h.indexStart + h.reservedIndexCount)) > e
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`
      );
    const r = this.geometry;
    r.dispose(),
      (this._maxVertexCount = t),
      (this._maxIndexCount = e),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new pn()),
        this._initializeGeometry(r));
    const l = this.geometry;
    r.index && xf(r.index.array, l.index.array);
    for (const u in r.attributes)
      xf(r.attributes[u].array, l.attributes[u].array);
  }
  raycast(t, e) {
    const n = this._instanceInfo,
      a = this._geometryInfo,
      r = this.matrixWorld,
      l = this.geometry;
    (es.material = this.material),
      (es.geometry.index = l.index),
      (es.geometry.attributes = l.attributes),
      es.geometry.boundingBox === null && (es.geometry.boundingBox = new Ha()),
      es.geometry.boundingSphere === null &&
        (es.geometry.boundingSphere = new wa());
    for (let u = 0, h = n.length; u < h; u++) {
      if (!n[u].visible || !n[u].active) continue;
      const p = n[u].geometryIndex,
        m = a[p];
      es.geometry.setDrawRange(m.start, m.count),
        this.getMatrixAt(u, es.matrixWorld).premultiply(r),
        this.getBoundingBoxAt(p, es.geometry.boundingBox),
        this.getBoundingSphereAt(p, es.geometry.boundingSphere),
        es.raycast(t, qv);
      for (let v = 0, x = qv.length; v < x; v++) {
        const _ = qv[v];
        (_.object = this), (_.batchId = u), e.push(_);
      }
      qv.length = 0;
    }
    (es.material = null),
      (es.geometry.index = null),
      (es.geometry.attributes = {}),
      es.geometry.setDrawRange(0, 1 / 0);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.geometry = t.geometry.clone()),
      (this.perObjectFrustumCulled = t.perObjectFrustumCulled),
      (this.sortObjects = t.sortObjects),
      (this.boundingBox =
        t.boundingBox !== null ? t.boundingBox.clone() : null),
      (this.boundingSphere =
        t.boundingSphere !== null ? t.boundingSphere.clone() : null),
      (this._geometryInfo = t._geometryInfo.map((e) => ({
        ...e,
        boundingBox: e.boundingBox !== null ? e.boundingBox.clone() : null,
        boundingSphere:
          e.boundingSphere !== null ? e.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = t._instanceInfo.map((e) => ({ ...e }))),
      (this._availableInstanceIds = t._availableInstanceIds.slice()),
      (this._availableGeometryIds = t._availableGeometryIds.slice()),
      (this._nextIndexStart = t._nextIndexStart),
      (this._nextVertexStart = t._nextVertexStart),
      (this._geometryCount = t._geometryCount),
      (this._maxInstanceCount = t._maxInstanceCount),
      (this._maxVertexCount = t._maxVertexCount),
      (this._maxIndexCount = t._maxIndexCount),
      (this._geometryInitialized = t._geometryInitialized),
      (this._multiDrawCounts = t._multiDrawCounts.slice()),
      (this._multiDrawStarts = t._multiDrawStarts.slice()),
      (this._indirectTexture = t._indirectTexture.clone()),
      (this._indirectTexture.image.data =
        this._indirectTexture.image.data.slice()),
      (this._matricesTexture = t._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = t._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null));
  }
  onBeforeRender(t, e, n, a, r) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const l = a.getIndex(),
      u = l === null ? 1 : l.array.BYTES_PER_ELEMENT,
      h = this._instanceInfo,
      p = this._multiDrawStarts,
      m = this._multiDrawCounts,
      v = this._geometryInfo,
      x = this.perObjectFrustumCulled,
      _ = this._indirectTexture,
      M = _.image.data,
      C = n.isArrayCamera ? LO : HE;
    x &&
      !n.isArrayCamera &&
      (Fs.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(
        this.matrixWorld
      ),
      HE.setFromProjectionMatrix(Fs, t.coordinateSystem));
    let E = 0;
    if (this.sortObjects) {
      Fs.copy(this.matrixWorld).invert(),
        Lm.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Fs),
        GE.set(0, 0, -1)
          .transformDirection(n.matrixWorld)
          .transformDirection(Fs);
      for (let B = 0, D = h.length; B < D; B++)
        if (h[B].visible && h[B].active) {
          const I = h[B].geometryIndex;
          this.getMatrixAt(B, Fs),
            this.getBoundingSphereAt(I, yf).applyMatrix4(Fs);
          let P = !1;
          if ((x && (P = !C.intersectsSphere(yf, n)), !P)) {
            const V = v[I],
              F = IO.subVectors(yf.center, Lm).dot(GE);
            B_.push(V.start, V.count, F, B);
          }
        }
      const S = B_.list,
        R = this.customSort;
      R === null ? S.sort(r.transparent ? UO : DO) : R.call(this, S, n);
      for (let B = 0, D = S.length; B < D; B++) {
        const I = S[B];
        (p[E] = I.start * u), (m[E] = I.count), (M[E] = I.index), E++;
      }
      B_.reset();
    } else
      for (let S = 0, R = h.length; S < R; S++)
        if (h[S].visible && h[S].active) {
          const B = h[S].geometryIndex;
          let D = !1;
          if (
            (x &&
              (this.getMatrixAt(S, Fs),
              this.getBoundingSphereAt(B, yf).applyMatrix4(Fs),
              (D = !C.intersectsSphere(yf, n))),
            !D)
          ) {
            const I = v[B];
            (p[E] = I.start * u), (m[E] = I.count), (M[E] = S), E++;
          }
        }
    (_.needsUpdate = !0),
      (this._multiDrawCount = E),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(t, e, n, a, r, l) {
    this.onBeforeRender(t, null, a, r, l);
  }
}
class is extends ma {
  constructor(t) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Se(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.linewidth = t.linewidth),
      (this.linecap = t.linecap),
      (this.linejoin = t.linejoin),
      (this.fog = t.fog),
      this
    );
  }
}
const gx = new Z(),
  vx = new Z(),
  VE = new Xe(),
  Im = new ih(),
  Kv = new wa(),
  D_ = new Z(),
  kE = new Z();
class tc extends Dn {
  constructor(t = new pn(), e = new is()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = t),
      (this.material = e),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position,
        n = [0];
      for (let a = 1, r = e.count; a < r; a++)
        gx.fromBufferAttribute(e, a - 1),
          vx.fromBufferAttribute(e, a),
          (n[a] = n[a - 1]),
          (n[a] += gx.distanceTo(vx));
      t.setAttribute("lineDistance", new Pe(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(t, e) {
    const n = this.geometry,
      a = this.matrixWorld,
      r = t.params.Line.threshold,
      l = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Kv.copy(n.boundingSphere),
      Kv.applyMatrix4(a),
      (Kv.radius += r),
      t.ray.intersectsSphere(Kv) === !1)
    )
      return;
    VE.copy(a).invert(), Im.copy(t.ray).applyMatrix4(VE);
    const u = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      h = u * u,
      p = this.isLineSegments ? 2 : 1,
      m = n.index,
      x = n.attributes.position;
    if (m !== null) {
      const _ = Math.max(0, l.start),
        M = Math.min(m.count, l.start + l.count);
      for (let C = _, E = M - 1; C < E; C += p) {
        const S = m.getX(C),
          R = m.getX(C + 1),
          B = Jv(this, t, Im, h, S, R, C);
        B && e.push(B);
      }
      if (this.isLineLoop) {
        const C = m.getX(M - 1),
          E = m.getX(_),
          S = Jv(this, t, Im, h, C, E, M - 1);
        S && e.push(S);
      }
    } else {
      const _ = Math.max(0, l.start),
        M = Math.min(x.count, l.start + l.count);
      for (let C = _, E = M - 1; C < E; C += p) {
        const S = Jv(this, t, Im, h, C, C + 1, C);
        S && e.push(S);
      }
      if (this.isLineLoop) {
        const C = Jv(this, t, Im, h, M - 1, _, M - 1);
        C && e.push(C);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      n = Object.keys(e);
    if (n.length > 0) {
      const a = e[n[0]];
      if (a !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, l = a.length; r < l; r++) {
          const u = a[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = r);
        }
      }
    }
  }
}
function Jv(i, t, e, n, a, r, l) {
  const u = i.geometry.attributes.position;
  if (
    (gx.fromBufferAttribute(u, a),
    vx.fromBufferAttribute(u, r),
    e.distanceSqToSegment(gx, vx, D_, kE) > n)
  )
    return;
  D_.applyMatrix4(i.matrixWorld);
  const p = t.ray.origin.distanceTo(D_);
  if (!(p < t.near || p > t.far))
    return {
      distance: p,
      point: kE.clone().applyMatrix4(i.matrixWorld),
      index: l,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: i,
    };
}
const jE = new Z(),
  XE = new Z();
class Ao extends tc {
  constructor(t, e) {
    super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position,
        n = [];
      for (let a = 0, r = e.count; a < r; a += 2)
        jE.fromBufferAttribute(e, a),
          XE.fromBufferAttribute(e, a + 1),
          (n[a] = a === 0 ? 0 : n[a - 1]),
          (n[a + 1] = n[a] + jE.distanceTo(XE));
      t.setAttribute("lineDistance", new Pe(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class qA extends tc {
  constructor(t, e) {
    super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class qx extends ma {
  constructor(t) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Se(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.fog = t.fog),
      this
    );
  }
}
const WE = new Xe(),
  Vb = new ih(),
  Zv = new wa(),
  Qv = new Z();
class KA extends Dn {
  constructor(t = new pn(), e = new qx()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = t),
      (this.material = e),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  raycast(t, e) {
    const n = this.geometry,
      a = this.matrixWorld,
      r = t.params.Points.threshold,
      l = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Zv.copy(n.boundingSphere),
      Zv.applyMatrix4(a),
      (Zv.radius += r),
      t.ray.intersectsSphere(Zv) === !1)
    )
      return;
    WE.copy(a).invert(), Vb.copy(t.ray).applyMatrix4(WE);
    const u = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      h = u * u,
      p = n.index,
      v = n.attributes.position;
    if (p !== null) {
      const x = Math.max(0, l.start),
        _ = Math.min(p.count, l.start + l.count);
      for (let M = x, C = _; M < C; M++) {
        const E = p.getX(M);
        Qv.fromBufferAttribute(v, E), YE(Qv, E, h, a, t, e, this);
      }
    } else {
      const x = Math.max(0, l.start),
        _ = Math.min(v.count, l.start + l.count);
      for (let M = x, C = _; M < C; M++)
        Qv.fromBufferAttribute(v, M), YE(Qv, M, h, a, t, e, this);
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      n = Object.keys(e);
    if (n.length > 0) {
      const a = e[n[0]];
      if (a !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, l = a.length; r < l; r++) {
          const u = a[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[u] = r);
        }
      }
    }
  }
}
function YE(i, t, e, n, a, r, l) {
  const u = Vb.distanceSqToPoint(i);
  if (u < e) {
    const h = new Z();
    Vb.closestPointToPoint(i, h), h.applyMatrix4(n);
    const p = a.ray.origin.distanceTo(h);
    if (p < a.near || p > a.far) return;
    r.push({
      distance: p,
      distanceToRay: Math.sqrt(u),
      point: h,
      index: t,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: l,
    });
  }
}
class WC extends Zn {
  constructor(t, e, n, a, r = Kn, l = Kn, u, h, p) {
    super(t, e, n, a, r, l, u, h, p),
      (this.isVideoTexture = !0),
      (this.generateMipmaps = !1);
    const m = this;
    function v() {
      (m.needsUpdate = !0), t.requestVideoFrameCallback(v);
    }
    "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(v);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const t = this.image;
    "requestVideoFrameCallback" in t === !1 &&
      t.readyState >= t.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class zO extends WC {
  constructor(t, e, n, a, r, l, u, h) {
    super({}, t, e, n, a, r, l, u, h), (this.isVideoFrameTexture = !0);
  }
  update() {}
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(t) {
    (this.image = t), (this.needsUpdate = !0);
  }
}
class FO extends Zn {
  constructor(t, e) {
    super({ width: t, height: e }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = Ta),
      (this.minFilter = Ta),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class Kx extends Zn {
  constructor(t, e, n, a, r, l, u, h, p, m, v, x) {
    super(null, l, u, h, p, m, a, r, v, x),
      (this.isCompressedTexture = !0),
      (this.image = { width: e, height: n }),
      (this.mipmaps = t),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class HO extends Kx {
  constructor(t, e, n, a, r, l) {
    super(t, e, n, r, l),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = a),
      (this.wrapR = Ki),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class GO extends Kx {
  constructor(t, e, n) {
    super(void 0, t[0].width, t[0].height, e, n, dl),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = t);
  }
}
class VO extends Zn {
  constructor(t, e, n, a, r, l, u, h, p) {
    super(t, e, n, a, r, l, u, h, p),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class JA extends Zn {
  constructor(t, e, n = pl, a, r, l, u = Ta, h = Ta, p, m = Wd, v = 1) {
    if (m !== Wd && m !== Yd)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    const x = { width: t, height: e, depth: v };
    super(x, a, r, l, u, h, m, n, p),
      (this.isDepthTexture = !0),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.source = new ru(Object.assign({}, t.image))),
      (this.compareFunction = t.compareFunction),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      this.compareFunction !== null &&
        (e.compareFunction = this.compareFunction),
      e
    );
  }
}
class Jx extends pn {
  constructor(t = 1, e = 1, n = 4, a = 8, r = 1) {
    super(),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: t,
        height: e,
        capSegments: n,
        radialSegments: a,
        heightSegments: r,
      }),
      (e = Math.max(0, e)),
      (n = Math.max(1, Math.floor(n))),
      (a = Math.max(3, Math.floor(a))),
      (r = Math.max(1, Math.floor(r)));
    const l = [],
      u = [],
      h = [],
      p = [],
      m = e / 2,
      v = (Math.PI / 2) * t,
      x = e,
      _ = 2 * v + x,
      M = n * 2 + r,
      C = a + 1,
      E = new Z(),
      S = new Z();
    for (let R = 0; R <= M; R++) {
      let B = 0,
        D = 0,
        I = 0,
        P = 0;
      if (R <= n) {
        const N = R / n,
          L = (N * Math.PI) / 2;
        (D = -m - t * Math.cos(L)),
          (I = t * Math.sin(L)),
          (P = -t * Math.cos(L)),
          (B = N * v);
      } else if (R <= n + r) {
        const N = (R - n) / r;
        (D = -m + N * e), (I = t), (P = 0), (B = v + N * x);
      } else {
        const N = (R - n - r) / n,
          L = (N * Math.PI) / 2;
        (D = m + t * Math.sin(L)),
          (I = t * Math.cos(L)),
          (P = t * Math.sin(L)),
          (B = v + x + N * v);
      }
      const V = Math.max(0, Math.min(1, B / _));
      let F = 0;
      R === 0 ? (F = 0.5 / a) : R === M && (F = -0.5 / a);
      for (let N = 0; N <= a; N++) {
        const L = N / a,
          Y = L * Math.PI * 2,
          ct = Math.sin(Y),
          nt = Math.cos(Y);
        (S.x = -I * nt),
          (S.y = D),
          (S.z = I * ct),
          u.push(S.x, S.y, S.z),
          E.set(-I * nt, P, I * ct),
          E.normalize(),
          h.push(E.x, E.y, E.z),
          p.push(L + F, V);
      }
      if (R > 0) {
        const N = (R - 1) * C;
        for (let L = 0; L < a; L++) {
          const Y = N + L,
            ct = N + L + 1,
            nt = R * C + L,
            dt = R * C + L + 1;
          l.push(Y, ct, nt), l.push(ct, dt, nt);
        }
      }
    }
    this.setIndex(l),
      this.setAttribute("position", new Pe(u, 3)),
      this.setAttribute("normal", new Pe(h, 3)),
      this.setAttribute("uv", new Pe(p, 2));
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new Jx(
      t.radius,
      t.height,
      t.capSegments,
      t.radialSegments,
      t.heightSegments
    );
  }
}
class Zx extends pn {
  constructor(t = 1, e = 32, n = 0, a = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: t,
        segments: e,
        thetaStart: n,
        thetaLength: a,
      }),
      (e = Math.max(3, e));
    const r = [],
      l = [],
      u = [],
      h = [],
      p = new Z(),
      m = new Yt();
    l.push(0, 0, 0), u.push(0, 0, 1), h.push(0.5, 0.5);
    for (let v = 0, x = 3; v <= e; v++, x += 3) {
      const _ = n + (v / e) * a;
      (p.x = t * Math.cos(_)),
        (p.y = t * Math.sin(_)),
        l.push(p.x, p.y, p.z),
        u.push(0, 0, 1),
        (m.x = (l[x] / t + 1) / 2),
        (m.y = (l[x + 1] / t + 1) / 2),
        h.push(m.x, m.y);
    }
    for (let v = 1; v <= e; v++) r.push(v, v + 1, 0);
    this.setIndex(r),
      this.setAttribute("position", new Pe(l, 3)),
      this.setAttribute("normal", new Pe(u, 3)),
      this.setAttribute("uv", new Pe(h, 2));
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new Zx(t.radius, t.segments, t.thetaStart, t.thetaLength);
  }
}
class P0 extends pn {
  constructor(
    t = 1,
    e = 1,
    n = 1,
    a = 32,
    r = 1,
    l = !1,
    u = 0,
    h = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: a,
        heightSegments: r,
        openEnded: l,
        thetaStart: u,
        thetaLength: h,
      });
    const p = this;
    (a = Math.floor(a)), (r = Math.floor(r));
    const m = [],
      v = [],
      x = [],
      _ = [];
    let M = 0;
    const C = [],
      E = n / 2;
    let S = 0;
    R(),
      l === !1 && (t > 0 && B(!0), e > 0 && B(!1)),
      this.setIndex(m),
      this.setAttribute("position", new Pe(v, 3)),
      this.setAttribute("normal", new Pe(x, 3)),
      this.setAttribute("uv", new Pe(_, 2));
    function R() {
      const D = new Z(),
        I = new Z();
      let P = 0;
      const V = (e - t) / n;
      for (let F = 0; F <= r; F++) {
        const N = [],
          L = F / r,
          Y = L * (e - t) + t;
        for (let ct = 0; ct <= a; ct++) {
          const nt = ct / a,
            dt = nt * h + u,
            pt = Math.sin(dt),
            j = Math.cos(dt);
          (I.x = Y * pt),
            (I.y = -L * n + E),
            (I.z = Y * j),
            v.push(I.x, I.y, I.z),
            D.set(pt, V, j).normalize(),
            x.push(D.x, D.y, D.z),
            _.push(nt, 1 - L),
            N.push(M++);
        }
        C.push(N);
      }
      for (let F = 0; F < a; F++)
        for (let N = 0; N < r; N++) {
          const L = C[N][F],
            Y = C[N + 1][F],
            ct = C[N + 1][F + 1],
            nt = C[N][F + 1];
          (t > 0 || N !== 0) && (m.push(L, Y, nt), (P += 3)),
            (e > 0 || N !== r - 1) && (m.push(Y, ct, nt), (P += 3));
        }
      p.addGroup(S, P, 0), (S += P);
    }
    function B(D) {
      const I = M,
        P = new Yt(),
        V = new Z();
      let F = 0;
      const N = D === !0 ? t : e,
        L = D === !0 ? 1 : -1;
      for (let ct = 1; ct <= a; ct++)
        v.push(0, E * L, 0), x.push(0, L, 0), _.push(0.5, 0.5), M++;
      const Y = M;
      for (let ct = 0; ct <= a; ct++) {
        const dt = (ct / a) * h + u,
          pt = Math.cos(dt),
          j = Math.sin(dt);
        (V.x = N * j),
          (V.y = E * L),
          (V.z = N * pt),
          v.push(V.x, V.y, V.z),
          x.push(0, L, 0),
          (P.x = pt * 0.5 + 0.5),
          (P.y = j * 0.5 * L + 0.5),
          _.push(P.x, P.y),
          M++;
      }
      for (let ct = 0; ct < a; ct++) {
        const nt = I + ct,
          dt = Y + ct;
        D === !0 ? m.push(dt, dt + 1, nt) : m.push(dt + 1, dt, nt), (F += 3);
      }
      p.addGroup(S, F, D === !0 ? 1 : 2), (S += F);
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new P0(
      t.radiusTop,
      t.radiusBottom,
      t.height,
      t.radialSegments,
      t.heightSegments,
      t.openEnded,
      t.thetaStart,
      t.thetaLength
    );
  }
}
class z0 extends P0 {
  constructor(t = 1, e = 1, n = 32, a = 1, r = !1, l = 0, u = Math.PI * 2) {
    super(0, t, e, n, a, r, l, u),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: n,
        heightSegments: a,
        openEnded: r,
        thetaStart: l,
        thetaLength: u,
      });
  }
  static fromJSON(t) {
    return new z0(
      t.radius,
      t.height,
      t.radialSegments,
      t.heightSegments,
      t.openEnded,
      t.thetaStart,
      t.thetaLength
    );
  }
}
class yu extends pn {
  constructor(t = [], e = [], n = 1, a = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: t, indices: e, radius: n, detail: a });
    const r = [],
      l = [];
    u(a),
      p(n),
      m(),
      this.setAttribute("position", new Pe(r, 3)),
      this.setAttribute("normal", new Pe(r.slice(), 3)),
      this.setAttribute("uv", new Pe(l, 2)),
      a === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function u(R) {
      const B = new Z(),
        D = new Z(),
        I = new Z();
      for (let P = 0; P < e.length; P += 3)
        _(e[P + 0], B), _(e[P + 1], D), _(e[P + 2], I), h(B, D, I, R);
    }
    function h(R, B, D, I) {
      const P = I + 1,
        V = [];
      for (let F = 0; F <= P; F++) {
        V[F] = [];
        const N = R.clone().lerp(D, F / P),
          L = B.clone().lerp(D, F / P),
          Y = P - F;
        for (let ct = 0; ct <= Y; ct++)
          ct === 0 && F === P
            ? (V[F][ct] = N)
            : (V[F][ct] = N.clone().lerp(L, ct / Y));
      }
      for (let F = 0; F < P; F++)
        for (let N = 0; N < 2 * (P - F) - 1; N++) {
          const L = Math.floor(N / 2);
          N % 2 === 0
            ? (x(V[F][L + 1]), x(V[F + 1][L]), x(V[F][L]))
            : (x(V[F][L + 1]), x(V[F + 1][L + 1]), x(V[F + 1][L]));
        }
    }
    function p(R) {
      const B = new Z();
      for (let D = 0; D < r.length; D += 3)
        (B.x = r[D + 0]),
          (B.y = r[D + 1]),
          (B.z = r[D + 2]),
          B.normalize().multiplyScalar(R),
          (r[D + 0] = B.x),
          (r[D + 1] = B.y),
          (r[D + 2] = B.z);
    }
    function m() {
      const R = new Z();
      for (let B = 0; B < r.length; B += 3) {
        (R.x = r[B + 0]), (R.y = r[B + 1]), (R.z = r[B + 2]);
        const D = E(R) / 2 / Math.PI + 0.5,
          I = S(R) / Math.PI + 0.5;
        l.push(D, 1 - I);
      }
      M(), v();
    }
    function v() {
      for (let R = 0; R < l.length; R += 6) {
        const B = l[R + 0],
          D = l[R + 2],
          I = l[R + 4],
          P = Math.max(B, D, I),
          V = Math.min(B, D, I);
        P > 0.9 &&
          V < 0.1 &&
          (B < 0.2 && (l[R + 0] += 1),
          D < 0.2 && (l[R + 2] += 1),
          I < 0.2 && (l[R + 4] += 1));
      }
    }
    function x(R) {
      r.push(R.x, R.y, R.z);
    }
    function _(R, B) {
      const D = R * 3;
      (B.x = t[D + 0]), (B.y = t[D + 1]), (B.z = t[D + 2]);
    }
    function M() {
      const R = new Z(),
        B = new Z(),
        D = new Z(),
        I = new Z(),
        P = new Yt(),
        V = new Yt(),
        F = new Yt();
      for (let N = 0, L = 0; N < r.length; N += 9, L += 6) {
        R.set(r[N + 0], r[N + 1], r[N + 2]),
          B.set(r[N + 3], r[N + 4], r[N + 5]),
          D.set(r[N + 6], r[N + 7], r[N + 8]),
          P.set(l[L + 0], l[L + 1]),
          V.set(l[L + 2], l[L + 3]),
          F.set(l[L + 4], l[L + 5]),
          I.copy(R).add(B).add(D).divideScalar(3);
        const Y = E(I);
        C(P, L + 0, R, Y), C(V, L + 2, B, Y), C(F, L + 4, D, Y);
      }
    }
    function C(R, B, D, I) {
      I < 0 && R.x === 1 && (l[B] = R.x - 1),
        D.x === 0 && D.z === 0 && (l[B] = I / 2 / Math.PI + 0.5);
    }
    function E(R) {
      return Math.atan2(R.z, -R.x);
    }
    function S(R) {
      return Math.atan2(-R.y, Math.sqrt(R.x * R.x + R.z * R.z));
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new yu(t.vertices, t.indices, t.radius, t.details);
  }
}
class Qx extends yu {
  constructor(t = 1, e = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      a = 1 / n,
      r = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -a,
        -n,
        0,
        -a,
        n,
        0,
        a,
        -n,
        0,
        a,
        n,
        -a,
        -n,
        0,
        -a,
        n,
        0,
        a,
        -n,
        0,
        a,
        n,
        0,
        -n,
        0,
        -a,
        n,
        0,
        -a,
        -n,
        0,
        a,
        n,
        0,
        a,
      ],
      l = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(r, l, t, e),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
  static fromJSON(t) {
    return new Qx(t.radius, t.detail);
  }
}
const $v = new Z(),
  ty = new Z(),
  U_ = new Z(),
  ey = new Vs();
class YC extends pn {
  constructor(t = null, e = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: t, thresholdAngle: e }),
      t !== null)
    ) {
      const a = Math.pow(10, 4),
        r = Math.cos(Wf * e),
        l = t.getIndex(),
        u = t.getAttribute("position"),
        h = l ? l.count : u.count,
        p = [0, 0, 0],
        m = ["a", "b", "c"],
        v = new Array(3),
        x = {},
        _ = [];
      for (let M = 0; M < h; M += 3) {
        l
          ? ((p[0] = l.getX(M)), (p[1] = l.getX(M + 1)), (p[2] = l.getX(M + 2)))
          : ((p[0] = M), (p[1] = M + 1), (p[2] = M + 2));
        const { a: C, b: E, c: S } = ey;
        if (
          (C.fromBufferAttribute(u, p[0]),
          E.fromBufferAttribute(u, p[1]),
          S.fromBufferAttribute(u, p[2]),
          ey.getNormal(U_),
          (v[0] = `${Math.round(C.x * a)},${Math.round(C.y * a)},${Math.round(
            C.z * a
          )}`),
          (v[1] = `${Math.round(E.x * a)},${Math.round(E.y * a)},${Math.round(
            E.z * a
          )}`),
          (v[2] = `${Math.round(S.x * a)},${Math.round(S.y * a)},${Math.round(
            S.z * a
          )}`),
          !(v[0] === v[1] || v[1] === v[2] || v[2] === v[0]))
        )
          for (let R = 0; R < 3; R++) {
            const B = (R + 1) % 3,
              D = v[R],
              I = v[B],
              P = ey[m[R]],
              V = ey[m[B]],
              F = `${D}_${I}`,
              N = `${I}_${D}`;
            N in x && x[N]
              ? (U_.dot(x[N].normal) <= r &&
                  (_.push(P.x, P.y, P.z), _.push(V.x, V.y, V.z)),
                (x[N] = null))
              : F in x ||
                (x[F] = { index0: p[R], index1: p[B], normal: U_.clone() });
          }
      }
      for (const M in x)
        if (x[M]) {
          const { index0: C, index1: E } = x[M];
          $v.fromBufferAttribute(u, C),
            ty.fromBufferAttribute(u, E),
            _.push($v.x, $v.y, $v.z),
            _.push(ty.x, ty.y, ty.z);
        }
      this.setAttribute("position", new Pe(_, 3));
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
}
class So {
  constructor() {
    (this.type = "Curve"),
      (this.arcLengthDivisions = 200),
      (this.needsUpdate = !1),
      (this.cacheArcLengths = null);
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
  }
  getPointAt(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  }
  getPoints(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
    return e;
  }
  getSpacedPoints(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
    return e;
  }
  getLength() {
    const t = this.getLengths();
    return t[t.length - 1];
  }
  getLengths(t = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === t + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n,
      a = this.getPoint(0),
      r = 0;
    e.push(0);
    for (let l = 1; l <= t; l++)
      (n = this.getPoint(l / t)), (r += n.distanceTo(a)), e.push(r), (a = n);
    return (this.cacheArcLengths = e), e;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(t, e = null) {
    const n = this.getLengths();
    let a = 0;
    const r = n.length;
    let l;
    e ? (l = e) : (l = t * n[r - 1]);
    let u = 0,
      h = r - 1,
      p;
    for (; u <= h; )
      if (((a = Math.floor(u + (h - u) / 2)), (p = n[a] - l), p < 0)) u = a + 1;
      else if (p > 0) h = a - 1;
      else {
        h = a;
        break;
      }
    if (((a = h), n[a] === l)) return a / (r - 1);
    const m = n[a],
      x = n[a + 1] - m,
      _ = (l - m) / x;
    return (a + _) / (r - 1);
  }
  getTangent(t, e) {
    let a = t - 1e-4,
      r = t + 1e-4;
    a < 0 && (a = 0), r > 1 && (r = 1);
    const l = this.getPoint(a),
      u = this.getPoint(r),
      h = e || (l.isVector2 ? new Yt() : new Z());
    return h.copy(u).sub(l).normalize(), h;
  }
  getTangentAt(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  }
  computeFrenetFrames(t, e = !1) {
    const n = new Z(),
      a = [],
      r = [],
      l = [],
      u = new Z(),
      h = new Xe();
    for (let _ = 0; _ <= t; _++) {
      const M = _ / t;
      a[_] = this.getTangentAt(M, new Z());
    }
    (r[0] = new Z()), (l[0] = new Z());
    let p = Number.MAX_VALUE;
    const m = Math.abs(a[0].x),
      v = Math.abs(a[0].y),
      x = Math.abs(a[0].z);
    m <= p && ((p = m), n.set(1, 0, 0)),
      v <= p && ((p = v), n.set(0, 1, 0)),
      x <= p && n.set(0, 0, 1),
      u.crossVectors(a[0], n).normalize(),
      r[0].crossVectors(a[0], u),
      l[0].crossVectors(a[0], r[0]);
    for (let _ = 1; _ <= t; _++) {
      if (
        ((r[_] = r[_ - 1].clone()),
        (l[_] = l[_ - 1].clone()),
        u.crossVectors(a[_ - 1], a[_]),
        u.length() > Number.EPSILON)
      ) {
        u.normalize();
        const M = Math.acos(dn(a[_ - 1].dot(a[_]), -1, 1));
        r[_].applyMatrix4(h.makeRotationAxis(u, M));
      }
      l[_].crossVectors(a[_], r[_]);
    }
    if (e === !0) {
      let _ = Math.acos(dn(r[0].dot(r[t]), -1, 1));
      (_ /= t), a[0].dot(u.crossVectors(r[0], r[t])) > 0 && (_ = -_);
      for (let M = 1; M <= t; M++)
        r[M].applyMatrix4(h.makeRotationAxis(a[M], _ * M)),
          l[M].crossVectors(a[M], r[M]);
    }
    return { tangents: a, normals: r, binormals: l };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
  toJSON() {
    const t = {
      metadata: { version: 4.7, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
    );
  }
  fromJSON(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
}
class $x extends So {
  constructor(
    t = 0,
    e = 0,
    n = 1,
    a = 1,
    r = 0,
    l = Math.PI * 2,
    u = !1,
    h = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = t),
      (this.aY = e),
      (this.xRadius = n),
      (this.yRadius = a),
      (this.aStartAngle = r),
      (this.aEndAngle = l),
      (this.aClockwise = u),
      (this.aRotation = h);
  }
  getPoint(t, e = new Yt()) {
    const n = e,
      a = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += a;
    for (; r > a; ) r -= a;
    r < Number.EPSILON && (l ? (r = 0) : (r = a)),
      this.aClockwise === !0 && !l && (r === a ? (r = -a) : (r = r - a));
    const u = this.aStartAngle + t * r;
    let h = this.aX + this.xRadius * Math.cos(u),
      p = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const m = Math.cos(this.aRotation),
        v = Math.sin(this.aRotation),
        x = h - this.aX,
        _ = p - this.aY;
      (h = x * m - _ * v + this.aX), (p = x * v + _ * m + this.aY);
    }
    return n.set(h, p);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
}
class qC extends $x {
  constructor(t, e, n, a, r, l) {
    super(t, e, n, n, a, r, l),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function ZA() {
  let i = 0,
    t = 0,
    e = 0,
    n = 0;
  function a(r, l, u, h) {
    (i = r),
      (t = u),
      (e = -3 * r + 3 * l - 2 * u - h),
      (n = 2 * r - 2 * l + u + h);
  }
  return {
    initCatmullRom: function (r, l, u, h, p) {
      a(l, u, p * (u - r), p * (h - l));
    },
    initNonuniformCatmullRom: function (r, l, u, h, p, m, v) {
      let x = (l - r) / p - (u - r) / (p + m) + (u - l) / m,
        _ = (u - l) / m - (h - l) / (m + v) + (h - u) / v;
      (x *= m), (_ *= m), a(l, u, x, _);
    },
    calc: function (r) {
      const l = r * r,
        u = l * r;
      return i + t * r + e * l + n * u;
    },
  };
}
const ny = new Z(),
  O_ = new ZA(),
  N_ = new ZA(),
  L_ = new ZA();
class KC extends So {
  constructor(t = [], e = !1, n = "centripetal", a = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = t),
      (this.closed = e),
      (this.curveType = n),
      (this.tension = a);
  }
  getPoint(t, e = new Z()) {
    const n = e,
      a = this.points,
      r = a.length,
      l = (r - (this.closed ? 0 : 1)) * t;
    let u = Math.floor(l),
      h = l - u;
    this.closed
      ? (u += u > 0 ? 0 : (Math.floor(Math.abs(u) / r) + 1) * r)
      : h === 0 && u === r - 1 && ((u = r - 2), (h = 1));
    let p, m;
    this.closed || u > 0
      ? (p = a[(u - 1) % r])
      : (ny.subVectors(a[0], a[1]).add(a[0]), (p = ny));
    const v = a[u % r],
      x = a[(u + 1) % r];
    if (
      (this.closed || u + 2 < r
        ? (m = a[(u + 2) % r])
        : (ny.subVectors(a[r - 1], a[r - 2]).add(a[r - 1]), (m = ny)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const _ = this.curveType === "chordal" ? 0.5 : 0.25;
      let M = Math.pow(p.distanceToSquared(v), _),
        C = Math.pow(v.distanceToSquared(x), _),
        E = Math.pow(x.distanceToSquared(m), _);
      C < 1e-4 && (C = 1),
        M < 1e-4 && (M = C),
        E < 1e-4 && (E = C),
        O_.initNonuniformCatmullRom(p.x, v.x, x.x, m.x, M, C, E),
        N_.initNonuniformCatmullRom(p.y, v.y, x.y, m.y, M, C, E),
        L_.initNonuniformCatmullRom(p.z, v.z, x.z, m.z, M, C, E);
    } else
      this.curveType === "catmullrom" &&
        (O_.initCatmullRom(p.x, v.x, x.x, m.x, this.tension),
        N_.initCatmullRom(p.y, v.y, x.y, m.y, this.tension),
        L_.initCatmullRom(p.z, v.z, x.z, m.z, this.tension));
    return n.set(O_.calc(h), N_.calc(h), L_.calc(h)), n;
  }
  copy(t) {
    super.copy(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const a = t.points[e];
      this.points.push(a.clone());
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const a = this.points[e];
      t.points.push(a.toArray());
    }
    return (
      (t.closed = this.closed),
      (t.curveType = this.curveType),
      (t.tension = this.tension),
      t
    );
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const a = t.points[e];
      this.points.push(new Z().fromArray(a));
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    );
  }
}
function qE(i, t, e, n, a) {
  const r = (n - t) * 0.5,
    l = (a - e) * 0.5,
    u = i * i,
    h = i * u;
  return (
    (2 * e - 2 * n + r + l) * h + (-3 * e + 3 * n - 2 * r - l) * u + r * i + e
  );
}
function kO(i, t) {
  const e = 1 - i;
  return e * e * t;
}
function jO(i, t) {
  return 2 * (1 - i) * i * t;
}
function XO(i, t) {
  return i * i * t;
}
function $m(i, t, e, n) {
  return kO(i, t) + jO(i, e) + XO(i, n);
}
function WO(i, t) {
  const e = 1 - i;
  return e * e * e * t;
}
function YO(i, t) {
  const e = 1 - i;
  return 3 * e * e * i * t;
}
function qO(i, t) {
  return 3 * (1 - i) * i * i * t;
}
function KO(i, t) {
  return i * i * i * t;
}
function t0(i, t, e, n, a) {
  return WO(i, t) + YO(i, e) + qO(i, n) + KO(i, a);
}
class QA extends So {
  constructor(t = new Yt(), e = new Yt(), n = new Yt(), a = new Yt()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = a);
  }
  getPoint(t, e = new Yt()) {
    const n = e,
      a = this.v0,
      r = this.v1,
      l = this.v2,
      u = this.v3;
    return n.set(t0(t, a.x, r.x, l.x, u.x), t0(t, a.y, r.y, l.y, u.y)), n;
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
class JC extends So {
  constructor(t = new Z(), e = new Z(), n = new Z(), a = new Z()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = a);
  }
  getPoint(t, e = new Z()) {
    const n = e,
      a = this.v0,
      r = this.v1,
      l = this.v2,
      u = this.v3;
    return (
      n.set(
        t0(t, a.x, r.x, l.x, u.x),
        t0(t, a.y, r.y, l.y, u.y),
        t0(t, a.z, r.z, l.z, u.z)
      ),
      n
    );
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
class $A extends So {
  constructor(t = new Yt(), e = new Yt()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = t),
      (this.v2 = e);
  }
  getPoint(t, e = new Yt()) {
    const n = e;
    return (
      t === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    );
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new Yt()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    );
  }
}
class ZC extends So {
  constructor(t = new Z(), e = new Z()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = t),
      (this.v2 = e);
  }
  getPoint(t, e = new Z()) {
    const n = e;
    return (
      t === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    );
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new Z()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    );
  }
}
class tS extends So {
  constructor(t = new Yt(), e = new Yt(), n = new Yt()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(t, e = new Yt()) {
    const n = e,
      a = this.v0,
      r = this.v1,
      l = this.v2;
    return n.set($m(t, a.x, r.x, l.x), $m(t, a.y, r.y, l.y)), n;
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }
}
class eS extends So {
  constructor(t = new Z(), e = new Z(), n = new Z()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(t, e = new Z()) {
    const n = e,
      a = this.v0,
      r = this.v1,
      l = this.v2;
    return (
      n.set($m(t, a.x, r.x, l.x), $m(t, a.y, r.y, l.y), $m(t, a.z, r.z, l.z)), n
    );
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }
}
class nS extends So {
  constructor(t = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = t);
  }
  getPoint(t, e = new Yt()) {
    const n = e,
      a = this.points,
      r = (a.length - 1) * t,
      l = Math.floor(r),
      u = r - l,
      h = a[l === 0 ? l : l - 1],
      p = a[l],
      m = a[l > a.length - 2 ? a.length - 1 : l + 1],
      v = a[l > a.length - 3 ? a.length - 1 : l + 2];
    return n.set(qE(u, h.x, p.x, m.x, v.x), qE(u, h.y, p.y, m.y, v.y)), n;
  }
  copy(t) {
    super.copy(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const a = t.points[e];
      this.points.push(a.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const a = this.points[e];
      t.points.push(a.toArray());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const a = t.points[e];
      this.points.push(new Yt().fromArray(a));
    }
    return this;
  }
}
var yx = Object.freeze({
  __proto__: null,
  ArcCurve: qC,
  CatmullRomCurve3: KC,
  CubicBezierCurve: QA,
  CubicBezierCurve3: JC,
  EllipseCurve: $x,
  LineCurve: $A,
  LineCurve3: ZC,
  QuadraticBezierCurve: tS,
  QuadraticBezierCurve3: eS,
  SplineCurve: nS,
});
class QC extends So {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(t) {
    this.curves.push(t);
  }
  closePath() {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1);
    if (!t.equals(e)) {
      const n = t.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new yx[n](e, t));
    }
    return this;
  }
  getPoint(t, e) {
    const n = t * this.getLength(),
      a = this.getCurveLengths();
    let r = 0;
    for (; r < a.length; ) {
      if (a[r] >= n) {
        const l = a[r] - n,
          u = this.curves[r],
          h = u.getLength(),
          p = h === 0 ? 0 : 1 - l / h;
        return u.getPointAt(p, e);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, a = this.curves.length; n < a; n++)
      (e += this.curves[n].getLength()), t.push(e);
    return (this.cacheLengths = t), t;
  }
  getSpacedPoints(t = 40) {
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(t = 12) {
    const e = [];
    let n;
    for (let a = 0, r = this.curves; a < r.length; a++) {
      const l = r[a],
        u = l.isEllipseCurve
          ? t * 2
          : l.isLineCurve || l.isLineCurve3
          ? 1
          : l.isSplineCurve
          ? t * l.points.length
          : t,
        h = l.getPoints(u);
      for (let p = 0; p < h.length; p++) {
        const m = h[p];
        (n && n.equals(m)) || (e.push(m), (n = m));
      }
    }
    return (
      this.autoClose &&
        e.length > 1 &&
        !e[e.length - 1].equals(e[0]) &&
        e.push(e[0]),
      e
    );
  }
  copy(t) {
    super.copy(t), (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const a = t.curves[e];
      this.curves.push(a.clone());
    }
    return (this.autoClose = t.autoClose), this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.autoClose = this.autoClose), (t.curves = []);
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const a = this.curves[e];
      t.curves.push(a.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const a = t.curves[e];
      this.curves.push(new yx[a.type]().fromJSON(a));
    }
    return this;
  }
}
class xx extends QC {
  constructor(t) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Yt()),
      t && this.setFromPoints(t);
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
    return this;
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this;
  }
  lineTo(t, e) {
    const n = new $A(this.currentPoint.clone(), new Yt(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  }
  quadraticCurveTo(t, e, n, a) {
    const r = new tS(this.currentPoint.clone(), new Yt(t, e), new Yt(n, a));
    return this.curves.push(r), this.currentPoint.set(n, a), this;
  }
  bezierCurveTo(t, e, n, a, r, l) {
    const u = new QA(
      this.currentPoint.clone(),
      new Yt(t, e),
      new Yt(n, a),
      new Yt(r, l)
    );
    return this.curves.push(u), this.currentPoint.set(r, l), this;
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t),
      n = new nS(e);
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
  }
  arc(t, e, n, a, r, l) {
    const u = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absarc(t + u, e + h, n, a, r, l), this;
  }
  absarc(t, e, n, a, r, l) {
    return this.absellipse(t, e, n, n, a, r, l), this;
  }
  ellipse(t, e, n, a, r, l, u, h) {
    const p = this.currentPoint.x,
      m = this.currentPoint.y;
    return this.absellipse(t + p, e + m, n, a, r, l, u, h), this;
  }
  absellipse(t, e, n, a, r, l, u, h) {
    const p = new $x(t, e, n, a, r, l, u, h);
    if (this.curves.length > 0) {
      const v = p.getPoint(0);
      v.equals(this.currentPoint) || this.lineTo(v.x, v.y);
    }
    this.curves.push(p);
    const m = p.getPoint(1);
    return this.currentPoint.copy(m), this;
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.currentPoint = this.currentPoint.toArray()), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
  }
}
class Yf extends xx {
  constructor(t) {
    super(t), (this.uuid = lr()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(t) {
    const e = [];
    for (let n = 0, a = this.holes.length; n < a; n++)
      e[n] = this.holes[n].getPoints(t);
    return e;
  }
  extractPoints(t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
  }
  copy(t) {
    super.copy(t), (this.holes = []);
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const a = t.holes[e];
      this.holes.push(a.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.uuid = this.uuid), (t.holes = []);
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const a = this.holes[e];
      t.holes.push(a.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const a = t.holes[e];
      this.holes.push(new xx().fromJSON(a));
    }
    return this;
  }
}
function JO(i, t, e = 2) {
  const n = t && t.length,
    a = n ? t[0] * e : i.length;
  let r = $C(i, 0, a, e, !0);
  const l = [];
  if (!r || r.next === r.prev) return l;
  let u, h, p;
  if ((n && (r = eN(i, t, r, e)), i.length > 80 * e)) {
    (u = 1 / 0), (h = 1 / 0);
    let m = -1 / 0,
      v = -1 / 0;
    for (let x = e; x < a; x += e) {
      const _ = i[x],
        M = i[x + 1];
      _ < u && (u = _), M < h && (h = M), _ > m && (m = _), M > v && (v = M);
    }
    (p = Math.max(m - u, v - h)), (p = p !== 0 ? 32767 / p : 0);
  }
  return p0(r, l, e, u, h, p, 0), l;
}
function $C(i, t, e, n, a) {
  let r;
  if (a === hN(i, t, e, n) > 0)
    for (let l = t; l < e; l += n) r = KE((l / n) | 0, i[l], i[l + 1], r);
  else
    for (let l = e - n; l >= t; l -= n) r = KE((l / n) | 0, i[l], i[l + 1], r);
  return r && $d(r, r.next) && (g0(r), (r = r.next)), r;
}
function Qf(i, t) {
  if (!i) return i;
  t || (t = i);
  let e = i,
    n;
  do
    if (
      ((n = !1), !e.steiner && ($d(e, e.next) || Li(e.prev, e, e.next) === 0))
    ) {
      if ((g0(e), (e = t = e.prev), e === e.next)) break;
      n = !0;
    } else e = e.next;
  while (n || e !== t);
  return t;
}
function p0(i, t, e, n, a, r, l) {
  if (!i) return;
  !l && r && rN(i, n, a, r);
  let u = i;
  for (; i.prev !== i.next; ) {
    const h = i.prev,
      p = i.next;
    if (r ? QO(i, n, a, r) : ZO(i)) {
      t.push(h.i, i.i, p.i), g0(i), (i = p.next), (u = p.next);
      continue;
    }
    if (((i = p), i === u)) {
      l
        ? l === 1
          ? ((i = $O(Qf(i), t)), p0(i, t, e, n, a, r, 2))
          : l === 2 && tN(i, t, e, n, a, r)
        : p0(Qf(i), t, e, n, a, r, 1);
      break;
    }
  }
}
function ZO(i) {
  const t = i.prev,
    e = i,
    n = i.next;
  if (Li(t, e, n) >= 0) return !1;
  const a = t.x,
    r = e.x,
    l = n.x,
    u = t.y,
    h = e.y,
    p = n.y,
    m = Math.min(a, r, l),
    v = Math.min(u, h, p),
    x = Math.max(a, r, l),
    _ = Math.max(u, h, p);
  let M = n.next;
  for (; M !== t; ) {
    if (
      M.x >= m &&
      M.x <= x &&
      M.y >= v &&
      M.y <= _ &&
      km(a, u, r, h, l, p, M.x, M.y) &&
      Li(M.prev, M, M.next) >= 0
    )
      return !1;
    M = M.next;
  }
  return !0;
}
function QO(i, t, e, n) {
  const a = i.prev,
    r = i,
    l = i.next;
  if (Li(a, r, l) >= 0) return !1;
  const u = a.x,
    h = r.x,
    p = l.x,
    m = a.y,
    v = r.y,
    x = l.y,
    _ = Math.min(u, h, p),
    M = Math.min(m, v, x),
    C = Math.max(u, h, p),
    E = Math.max(m, v, x),
    S = kb(_, M, t, e, n),
    R = kb(C, E, t, e, n);
  let B = i.prevZ,
    D = i.nextZ;
  for (; B && B.z >= S && D && D.z <= R; ) {
    if (
      (B.x >= _ &&
        B.x <= C &&
        B.y >= M &&
        B.y <= E &&
        B !== a &&
        B !== l &&
        km(u, m, h, v, p, x, B.x, B.y) &&
        Li(B.prev, B, B.next) >= 0) ||
      ((B = B.prevZ),
      D.x >= _ &&
        D.x <= C &&
        D.y >= M &&
        D.y <= E &&
        D !== a &&
        D !== l &&
        km(u, m, h, v, p, x, D.x, D.y) &&
        Li(D.prev, D, D.next) >= 0)
    )
      return !1;
    D = D.nextZ;
  }
  for (; B && B.z >= S; ) {
    if (
      B.x >= _ &&
      B.x <= C &&
      B.y >= M &&
      B.y <= E &&
      B !== a &&
      B !== l &&
      km(u, m, h, v, p, x, B.x, B.y) &&
      Li(B.prev, B, B.next) >= 0
    )
      return !1;
    B = B.prevZ;
  }
  for (; D && D.z <= R; ) {
    if (
      D.x >= _ &&
      D.x <= C &&
      D.y >= M &&
      D.y <= E &&
      D !== a &&
      D !== l &&
      km(u, m, h, v, p, x, D.x, D.y) &&
      Li(D.prev, D, D.next) >= 0
    )
      return !1;
    D = D.nextZ;
  }
  return !0;
}
function $O(i, t) {
  let e = i;
  do {
    const n = e.prev,
      a = e.next.next;
    !$d(n, a) &&
      eR(n, e, e.next, a) &&
      m0(n, a) &&
      m0(a, n) &&
      (t.push(n.i, e.i, a.i), g0(e), g0(e.next), (e = i = a)),
      (e = e.next);
  } while (e !== i);
  return Qf(e);
}
function tN(i, t, e, n, a, r) {
  let l = i;
  do {
    let u = l.next.next;
    for (; u !== l.prev; ) {
      if (l.i !== u.i && cN(l, u)) {
        let h = nR(l, u);
        (l = Qf(l, l.next)),
          (h = Qf(h, h.next)),
          p0(l, t, e, n, a, r, 0),
          p0(h, t, e, n, a, r, 0);
        return;
      }
      u = u.next;
    }
    l = l.next;
  } while (l !== i);
}
function eN(i, t, e, n) {
  const a = [];
  for (let r = 0, l = t.length; r < l; r++) {
    const u = t[r] * n,
      h = r < l - 1 ? t[r + 1] * n : i.length,
      p = $C(i, u, h, n, !1);
    p === p.next && (p.steiner = !0), a.push(lN(p));
  }
  a.sort(nN);
  for (let r = 0; r < a.length; r++) e = iN(a[r], e);
  return e;
}
function nN(i, t) {
  let e = i.x - t.x;
  if (e === 0 && ((e = i.y - t.y), e === 0)) {
    const n = (i.next.y - i.y) / (i.next.x - i.x),
      a = (t.next.y - t.y) / (t.next.x - t.x);
    e = n - a;
  }
  return e;
}
function iN(i, t) {
  const e = aN(i, t);
  if (!e) return t;
  const n = nR(e, i);
  return Qf(n, n.next), Qf(e, e.next);
}
function aN(i, t) {
  let e = t;
  const n = i.x,
    a = i.y;
  let r = -1 / 0,
    l;
  if ($d(i, e)) return e;
  do {
    if ($d(i, e.next)) return e.next;
    if (a <= e.y && a >= e.next.y && e.next.y !== e.y) {
      const v = e.x + ((a - e.y) * (e.next.x - e.x)) / (e.next.y - e.y);
      if (
        v <= n &&
        v > r &&
        ((r = v), (l = e.x < e.next.x ? e : e.next), v === n)
      )
        return l;
    }
    e = e.next;
  } while (e !== t);
  if (!l) return null;
  const u = l,
    h = l.x,
    p = l.y;
  let m = 1 / 0;
  e = l;
  do {
    if (
      n >= e.x &&
      e.x >= h &&
      n !== e.x &&
      tR(a < p ? n : r, a, h, p, a < p ? r : n, a, e.x, e.y)
    ) {
      const v = Math.abs(a - e.y) / (n - e.x);
      m0(e, i) &&
        (v < m || (v === m && (e.x > l.x || (e.x === l.x && sN(l, e))))) &&
        ((l = e), (m = v));
    }
    e = e.next;
  } while (e !== u);
  return l;
}
function sN(i, t) {
  return Li(i.prev, i, t.prev) < 0 && Li(t.next, i, i.next) < 0;
}
function rN(i, t, e, n) {
  let a = i;
  do
    a.z === 0 && (a.z = kb(a.x, a.y, t, e, n)),
      (a.prevZ = a.prev),
      (a.nextZ = a.next),
      (a = a.next);
  while (a !== i);
  (a.prevZ.nextZ = null), (a.prevZ = null), oN(a);
}
function oN(i) {
  let t,
    e = 1;
  do {
    let n = i,
      a;
    i = null;
    let r = null;
    for (t = 0; n; ) {
      t++;
      let l = n,
        u = 0;
      for (let p = 0; p < e && (u++, (l = l.nextZ), !!l); p++);
      let h = e;
      for (; u > 0 || (h > 0 && l); )
        u !== 0 && (h === 0 || !l || n.z <= l.z)
          ? ((a = n), (n = n.nextZ), u--)
          : ((a = l), (l = l.nextZ), h--),
          r ? (r.nextZ = a) : (i = a),
          (a.prevZ = r),
          (r = a);
      n = l;
    }
    (r.nextZ = null), (e *= 2);
  } while (t > 1);
  return i;
}
function kb(i, t, e, n, a) {
  return (
    (i = ((i - e) * a) | 0),
    (t = ((t - n) * a) | 0),
    (i = (i | (i << 8)) & 16711935),
    (i = (i | (i << 4)) & 252645135),
    (i = (i | (i << 2)) & 858993459),
    (i = (i | (i << 1)) & 1431655765),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    i | (t << 1)
  );
}
function lN(i) {
  let t = i,
    e = i;
  do (t.x < e.x || (t.x === e.x && t.y < e.y)) && (e = t), (t = t.next);
  while (t !== i);
  return e;
}
function tR(i, t, e, n, a, r, l, u) {
  return (
    (a - l) * (t - u) >= (i - l) * (r - u) &&
    (i - l) * (n - u) >= (e - l) * (t - u) &&
    (e - l) * (r - u) >= (a - l) * (n - u)
  );
}
function km(i, t, e, n, a, r, l, u) {
  return !(i === l && t === u) && tR(i, t, e, n, a, r, l, u);
}
function cN(i, t) {
  return (
    i.next.i !== t.i &&
    i.prev.i !== t.i &&
    !uN(i, t) &&
    ((m0(i, t) &&
      m0(t, i) &&
      fN(i, t) &&
      (Li(i.prev, i, t.prev) || Li(i, t.prev, t))) ||
      ($d(i, t) && Li(i.prev, i, i.next) > 0 && Li(t.prev, t, t.next) > 0))
  );
}
function Li(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function $d(i, t) {
  return i.x === t.x && i.y === t.y;
}
function eR(i, t, e, n) {
  const a = ay(Li(i, t, e)),
    r = ay(Li(i, t, n)),
    l = ay(Li(e, n, i)),
    u = ay(Li(e, n, t));
  return !!(
    (a !== r && l !== u) ||
    (a === 0 && iy(i, e, t)) ||
    (r === 0 && iy(i, n, t)) ||
    (l === 0 && iy(e, i, n)) ||
    (u === 0 && iy(e, t, n))
  );
}
function iy(i, t, e) {
  return (
    t.x <= Math.max(i.x, e.x) &&
    t.x >= Math.min(i.x, e.x) &&
    t.y <= Math.max(i.y, e.y) &&
    t.y >= Math.min(i.y, e.y)
  );
}
function ay(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function uN(i, t) {
  let e = i;
  do {
    if (
      e.i !== i.i &&
      e.next.i !== i.i &&
      e.i !== t.i &&
      e.next.i !== t.i &&
      eR(e, e.next, i, t)
    )
      return !0;
    e = e.next;
  } while (e !== i);
  return !1;
}
function m0(i, t) {
  return Li(i.prev, i, i.next) < 0
    ? Li(i, t, i.next) >= 0 && Li(i, i.prev, t) >= 0
    : Li(i, t, i.prev) < 0 || Li(i, i.next, t) < 0;
}
function fN(i, t) {
  let e = i,
    n = !1;
  const a = (i.x + t.x) / 2,
    r = (i.y + t.y) / 2;
  do
    e.y > r != e.next.y > r &&
      e.next.y !== e.y &&
      a < ((e.next.x - e.x) * (r - e.y)) / (e.next.y - e.y) + e.x &&
      (n = !n),
      (e = e.next);
  while (e !== i);
  return n;
}
function nR(i, t) {
  const e = jb(i.i, i.x, i.y),
    n = jb(t.i, t.x, t.y),
    a = i.next,
    r = t.prev;
  return (
    (i.next = t),
    (t.prev = i),
    (e.next = a),
    (a.prev = e),
    (n.next = e),
    (e.prev = n),
    (r.next = n),
    (n.prev = r),
    n
  );
}
function KE(i, t, e, n) {
  const a = jb(i, t, e);
  return (
    n
      ? ((a.next = n.next), (a.prev = n), (n.next.prev = a), (n.next = a))
      : ((a.prev = a), (a.next = a)),
    a
  );
}
function g0(i) {
  (i.next.prev = i.prev),
    (i.prev.next = i.next),
    i.prevZ && (i.prevZ.nextZ = i.nextZ),
    i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function jb(i, t, e) {
  return {
    i,
    x: t,
    y: e,
    prev: null,
    next: null,
    z: 0,
    prevZ: null,
    nextZ: null,
    steiner: !1,
  };
}
function hN(i, t, e, n) {
  let a = 0;
  for (let r = t, l = e - n; r < e; r += n)
    (a += (i[l] - i[r]) * (i[r + 1] + i[l + 1])), (l = r);
  return a;
}
class dN {
  static triangulate(t, e, n = 2) {
    return JO(t, e, n);
  }
}
class xo {
  static area(t) {
    const e = t.length;
    let n = 0;
    for (let a = e - 1, r = 0; r < e; a = r++)
      n += t[a].x * t[r].y - t[r].x * t[a].y;
    return n * 0.5;
  }
  static isClockWise(t) {
    return xo.area(t) < 0;
  }
  static triangulateShape(t, e) {
    const n = [],
      a = [],
      r = [];
    JE(t), ZE(n, t);
    let l = t.length;
    e.forEach(JE);
    for (let h = 0; h < e.length; h++)
      a.push(l), (l += e[h].length), ZE(n, e[h]);
    const u = dN.triangulate(n, a);
    for (let h = 0; h < u.length; h += 3) r.push(u.slice(h, h + 3));
    return r;
  }
}
function JE(i) {
  const t = i.length;
  t > 2 && i[t - 1].equals(i[0]) && i.pop();
}
function ZE(i, t) {
  for (let e = 0; e < t.length; e++) i.push(t[e].x), i.push(t[e].y);
}
class t1 extends pn {
  constructor(
    t = new Yf([
      new Yt(0.5, 0.5),
      new Yt(-0.5, 0.5),
      new Yt(-0.5, -0.5),
      new Yt(0.5, -0.5),
    ]),
    e = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: t, options: e }),
      (t = Array.isArray(t) ? t : [t]);
    const n = this,
      a = [],
      r = [];
    for (let u = 0, h = t.length; u < h; u++) {
      const p = t[u];
      l(p);
    }
    this.setAttribute("position", new Pe(a, 3)),
      this.setAttribute("uv", new Pe(r, 2)),
      this.computeVertexNormals();
    function l(u) {
      const h = [],
        p = e.curveSegments !== void 0 ? e.curveSegments : 12,
        m = e.steps !== void 0 ? e.steps : 1,
        v = e.depth !== void 0 ? e.depth : 1;
      let x = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0,
        _ = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2,
        M = e.bevelSize !== void 0 ? e.bevelSize : _ - 0.1,
        C = e.bevelOffset !== void 0 ? e.bevelOffset : 0,
        E = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
      const S = e.extrudePath,
        R = e.UVGenerator !== void 0 ? e.UVGenerator : pN;
      let B,
        D = !1,
        I,
        P,
        V,
        F;
      S &&
        ((B = S.getSpacedPoints(m)),
        (D = !0),
        (x = !1),
        (I = S.computeFrenetFrames(m, !1)),
        (P = new Z()),
        (V = new Z()),
        (F = new Z())),
        x || ((E = 0), (_ = 0), (M = 0), (C = 0));
      const N = u.extractPoints(p);
      let L = N.shape;
      const Y = N.holes;
      if (!xo.isClockWise(L)) {
        L = L.reverse();
        for (let J = 0, le = Y.length; J < le; J++) {
          const se = Y[J];
          xo.isClockWise(se) && (Y[J] = se.reverse());
        }
      }
      function nt(J) {
        const se = 10000000000000001e-36;
        let $t = J[0];
        for (let kt = 1; kt <= J.length; kt++) {
          const ye = kt % J.length,
            te = J[ye],
            pe = te.x - $t.x,
            Ye = te.y - $t.y,
            $ = pe * pe + Ye * Ye,
            k = Math.max(
              Math.abs(te.x),
              Math.abs(te.y),
              Math.abs($t.x),
              Math.abs($t.y)
            ),
            Mt = se * k * k;
          if ($ <= Mt) {
            J.splice(ye, 1), kt--;
            continue;
          }
          $t = te;
        }
      }
      nt(L), Y.forEach(nt);
      const dt = Y.length,
        pt = L;
      for (let J = 0; J < dt; J++) {
        const le = Y[J];
        L = L.concat(le);
      }
      function j(J, le, se) {
        return (
          le || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          J.clone().addScaledVector(le, se)
        );
      }
      const Q = L.length;
      function et(J, le, se) {
        let $t, kt, ye;
        const te = J.x - le.x,
          pe = J.y - le.y,
          Ye = se.x - J.x,
          $ = se.y - J.y,
          k = te * te + pe * pe,
          Mt = te * $ - pe * Ye;
        if (Math.abs(Mt) > Number.EPSILON) {
          const Ft = Math.sqrt(k),
            Gt = Math.sqrt(Ye * Ye + $ * $),
            zt = le.x - pe / Ft,
            me = le.y + te / Ft,
            de = se.x - $ / Gt,
            we = se.y + Ye / Gt,
            Ce = ((de - zt) * $ - (we - me) * Ye) / (te * $ - pe * Ye);
          ($t = zt + te * Ce - J.x), (kt = me + pe * Ce - J.y);
          const jt = $t * $t + kt * kt;
          if (jt <= 2) return new Yt($t, kt);
          ye = Math.sqrt(jt / 2);
        } else {
          let Ft = !1;
          te > Number.EPSILON
            ? Ye > Number.EPSILON && (Ft = !0)
            : te < -Number.EPSILON
            ? Ye < -Number.EPSILON && (Ft = !0)
            : Math.sign(pe) === Math.sign($) && (Ft = !0),
            Ft
              ? (($t = -pe), (kt = te), (ye = Math.sqrt(k)))
              : (($t = te), (kt = pe), (ye = Math.sqrt(k / 2)));
        }
        return new Yt($t / ye, kt / ye);
      }
      const xt = [];
      for (
        let J = 0, le = pt.length, se = le - 1, $t = J + 1;
        J < le;
        J++, se++, $t++
      )
        se === le && (se = 0),
          $t === le && ($t = 0),
          (xt[J] = et(pt[J], pt[se], pt[$t]));
      const X = [];
      let ft,
        At = xt.concat();
      for (let J = 0, le = dt; J < le; J++) {
        const se = Y[J];
        ft = [];
        for (
          let $t = 0, kt = se.length, ye = kt - 1, te = $t + 1;
          $t < kt;
          $t++, ye++, te++
        )
          ye === kt && (ye = 0),
            te === kt && (te = 0),
            (ft[$t] = et(se[$t], se[ye], se[te]));
        X.push(ft), (At = At.concat(ft));
      }
      let Rt;
      if (E === 0) Rt = xo.triangulateShape(pt, Y);
      else {
        const J = [],
          le = [];
        for (let se = 0; se < E; se++) {
          const $t = se / E,
            kt = _ * Math.cos(($t * Math.PI) / 2),
            ye = M * Math.sin(($t * Math.PI) / 2) + C;
          for (let te = 0, pe = pt.length; te < pe; te++) {
            const Ye = j(pt[te], xt[te], ye);
            Fe(Ye.x, Ye.y, -kt), $t === 0 && J.push(Ye);
          }
          for (let te = 0, pe = dt; te < pe; te++) {
            const Ye = Y[te];
            ft = X[te];
            const $ = [];
            for (let k = 0, Mt = Ye.length; k < Mt; k++) {
              const Ft = j(Ye[k], ft[k], ye);
              Fe(Ft.x, Ft.y, -kt), $t === 0 && $.push(Ft);
            }
            $t === 0 && le.push($);
          }
        }
        Rt = xo.triangulateShape(J, le);
      }
      const ht = Rt.length,
        It = M + C;
      for (let J = 0; J < Q; J++) {
        const le = x ? j(L[J], At[J], It) : L[J];
        D
          ? (V.copy(I.normals[0]).multiplyScalar(le.x),
            P.copy(I.binormals[0]).multiplyScalar(le.y),
            F.copy(B[0]).add(V).add(P),
            Fe(F.x, F.y, F.z))
          : Fe(le.x, le.y, 0);
      }
      for (let J = 1; J <= m; J++)
        for (let le = 0; le < Q; le++) {
          const se = x ? j(L[le], At[le], It) : L[le];
          D
            ? (V.copy(I.normals[J]).multiplyScalar(se.x),
              P.copy(I.binormals[J]).multiplyScalar(se.y),
              F.copy(B[J]).add(V).add(P),
              Fe(F.x, F.y, F.z))
            : Fe(se.x, se.y, (v / m) * J);
        }
      for (let J = E - 1; J >= 0; J--) {
        const le = J / E,
          se = _ * Math.cos((le * Math.PI) / 2),
          $t = M * Math.sin((le * Math.PI) / 2) + C;
        for (let kt = 0, ye = pt.length; kt < ye; kt++) {
          const te = j(pt[kt], xt[kt], $t);
          Fe(te.x, te.y, v + se);
        }
        for (let kt = 0, ye = Y.length; kt < ye; kt++) {
          const te = Y[kt];
          ft = X[kt];
          for (let pe = 0, Ye = te.length; pe < Ye; pe++) {
            const $ = j(te[pe], ft[pe], $t);
            D
              ? Fe($.x, $.y + B[m - 1].y, B[m - 1].x + se)
              : Fe($.x, $.y, v + se);
          }
        }
      }
      Pt(), re();
      function Pt() {
        const J = a.length / 3;
        if (x) {
          let le = 0,
            se = Q * le;
          for (let $t = 0; $t < ht; $t++) {
            const kt = Rt[$t];
            Ae(kt[2] + se, kt[1] + se, kt[0] + se);
          }
          (le = m + E * 2), (se = Q * le);
          for (let $t = 0; $t < ht; $t++) {
            const kt = Rt[$t];
            Ae(kt[0] + se, kt[1] + se, kt[2] + se);
          }
        } else {
          for (let le = 0; le < ht; le++) {
            const se = Rt[le];
            Ae(se[2], se[1], se[0]);
          }
          for (let le = 0; le < ht; le++) {
            const se = Rt[le];
            Ae(se[0] + Q * m, se[1] + Q * m, se[2] + Q * m);
          }
        }
        n.addGroup(J, a.length / 3 - J, 0);
      }
      function re() {
        const J = a.length / 3;
        let le = 0;
        ie(pt, le), (le += pt.length);
        for (let se = 0, $t = Y.length; se < $t; se++) {
          const kt = Y[se];
          ie(kt, le), (le += kt.length);
        }
        n.addGroup(J, a.length / 3 - J, 1);
      }
      function ie(J, le) {
        let se = J.length;
        for (; --se >= 0; ) {
          const $t = se;
          let kt = se - 1;
          kt < 0 && (kt = J.length - 1);
          for (let ye = 0, te = m + E * 2; ye < te; ye++) {
            const pe = Q * ye,
              Ye = Q * (ye + 1),
              $ = le + $t + pe,
              k = le + kt + pe,
              Mt = le + kt + Ye,
              Ft = le + $t + Ye;
            De($, k, Mt, Ft);
          }
        }
      }
      function Fe(J, le, se) {
        h.push(J), h.push(le), h.push(se);
      }
      function Ae(J, le, se) {
        je(J), je(le), je(se);
        const $t = a.length / 3,
          kt = R.generateTopUV(n, a, $t - 3, $t - 2, $t - 1);
        Ue(kt[0]), Ue(kt[1]), Ue(kt[2]);
      }
      function De(J, le, se, $t) {
        je(J), je(le), je($t), je(le), je(se), je($t);
        const kt = a.length / 3,
          ye = R.generateSideWallUV(n, a, kt - 6, kt - 3, kt - 2, kt - 1);
        Ue(ye[0]), Ue(ye[1]), Ue(ye[3]), Ue(ye[1]), Ue(ye[2]), Ue(ye[3]);
      }
      function je(J) {
        a.push(h[J * 3 + 0]), a.push(h[J * 3 + 1]), a.push(h[J * 3 + 2]);
      }
      function Ue(J) {
        r.push(J.x), r.push(J.y);
      }
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  toJSON() {
    const t = super.toJSON(),
      e = this.parameters.shapes,
      n = this.parameters.options;
    return mN(e, n, t);
  }
  static fromJSON(t, e) {
    const n = [];
    for (let r = 0, l = t.shapes.length; r < l; r++) {
      const u = e[t.shapes[r]];
      n.push(u);
    }
    const a = t.options.extrudePath;
    return (
      a !== void 0 && (t.options.extrudePath = new yx[a.type]().fromJSON(a)),
      new t1(n, t.options)
    );
  }
}
const pN = {
  generateTopUV: function (i, t, e, n, a) {
    const r = t[e * 3],
      l = t[e * 3 + 1],
      u = t[n * 3],
      h = t[n * 3 + 1],
      p = t[a * 3],
      m = t[a * 3 + 1];
    return [new Yt(r, l), new Yt(u, h), new Yt(p, m)];
  },
  generateSideWallUV: function (i, t, e, n, a, r) {
    const l = t[e * 3],
      u = t[e * 3 + 1],
      h = t[e * 3 + 2],
      p = t[n * 3],
      m = t[n * 3 + 1],
      v = t[n * 3 + 2],
      x = t[a * 3],
      _ = t[a * 3 + 1],
      M = t[a * 3 + 2],
      C = t[r * 3],
      E = t[r * 3 + 1],
      S = t[r * 3 + 2];
    return Math.abs(u - m) < Math.abs(l - p)
      ? [new Yt(l, 1 - h), new Yt(p, 1 - v), new Yt(x, 1 - M), new Yt(C, 1 - S)]
      : [
          new Yt(u, 1 - h),
          new Yt(m, 1 - v),
          new Yt(_, 1 - M),
          new Yt(E, 1 - S),
        ];
  },
};
function mN(i, t, e) {
  if (((e.shapes = []), Array.isArray(i)))
    for (let n = 0, a = i.length; n < a; n++) {
      const r = i[n];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(i.uuid);
  return (
    (e.options = Object.assign({}, t)),
    t.extrudePath !== void 0 &&
      (e.options.extrudePath = t.extrudePath.toJSON()),
    e
  );
}
class F0 extends yu {
  constructor(t = 1, e = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      a = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      r = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(a, r, t, e),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
  static fromJSON(t) {
    return new F0(t.radius, t.detail);
  }
}
class e1 extends pn {
  constructor(
    t = [new Yt(0, -0.5), new Yt(0.5, 0), new Yt(0, 0.5)],
    e = 12,
    n = 0,
    a = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: t, segments: e, phiStart: n, phiLength: a }),
      (e = Math.floor(e)),
      (a = dn(a, 0, Math.PI * 2));
    const r = [],
      l = [],
      u = [],
      h = [],
      p = [],
      m = 1 / e,
      v = new Z(),
      x = new Yt(),
      _ = new Z(),
      M = new Z(),
      C = new Z();
    let E = 0,
      S = 0;
    for (let R = 0; R <= t.length - 1; R++)
      switch (R) {
        case 0:
          (E = t[R + 1].x - t[R].x),
            (S = t[R + 1].y - t[R].y),
            (_.x = S * 1),
            (_.y = -E),
            (_.z = S * 0),
            C.copy(_),
            _.normalize(),
            h.push(_.x, _.y, _.z);
          break;
        case t.length - 1:
          h.push(C.x, C.y, C.z);
          break;
        default:
          (E = t[R + 1].x - t[R].x),
            (S = t[R + 1].y - t[R].y),
            (_.x = S * 1),
            (_.y = -E),
            (_.z = S * 0),
            M.copy(_),
            (_.x += C.x),
            (_.y += C.y),
            (_.z += C.z),
            _.normalize(),
            h.push(_.x, _.y, _.z),
            C.copy(M);
      }
    for (let R = 0; R <= e; R++) {
      const B = n + R * m * a,
        D = Math.sin(B),
        I = Math.cos(B);
      for (let P = 0; P <= t.length - 1; P++) {
        (v.x = t[P].x * D),
          (v.y = t[P].y),
          (v.z = t[P].x * I),
          l.push(v.x, v.y, v.z),
          (x.x = R / e),
          (x.y = P / (t.length - 1)),
          u.push(x.x, x.y);
        const V = h[3 * P + 0] * D,
          F = h[3 * P + 1],
          N = h[3 * P + 0] * I;
        p.push(V, F, N);
      }
    }
    for (let R = 0; R < e; R++)
      for (let B = 0; B < t.length - 1; B++) {
        const D = B + R * t.length,
          I = D,
          P = D + t.length,
          V = D + t.length + 1,
          F = D + 1;
        r.push(I, P, F), r.push(V, F, P);
      }
    this.setIndex(r),
      this.setAttribute("position", new Pe(l, 3)),
      this.setAttribute("uv", new Pe(u, 2)),
      this.setAttribute("normal", new Pe(p, 3));
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new e1(t.points, t.segments, t.phiStart, t.phiLength);
  }
}
class H0 extends yu {
  constructor(t = 1, e = 0) {
    const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      a = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(n, a, t, e),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
  static fromJSON(t) {
    return new H0(t.radius, t.detail);
  }
}
class xu extends pn {
  constructor(t = 1, e = 1, n = 1, a = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: a,
      });
    const r = t / 2,
      l = e / 2,
      u = Math.floor(n),
      h = Math.floor(a),
      p = u + 1,
      m = h + 1,
      v = t / u,
      x = e / h,
      _ = [],
      M = [],
      C = [],
      E = [];
    for (let S = 0; S < m; S++) {
      const R = S * x - l;
      for (let B = 0; B < p; B++) {
        const D = B * v - r;
        M.push(D, -R, 0), C.push(0, 0, 1), E.push(B / u), E.push(1 - S / h);
      }
    }
    for (let S = 0; S < h; S++)
      for (let R = 0; R < u; R++) {
        const B = R + p * S,
          D = R + p * (S + 1),
          I = R + 1 + p * (S + 1),
          P = R + 1 + p * S;
        _.push(B, D, P), _.push(D, I, P);
      }
    this.setIndex(_),
      this.setAttribute("position", new Pe(M, 3)),
      this.setAttribute("normal", new Pe(C, 3)),
      this.setAttribute("uv", new Pe(E, 2));
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new xu(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
class n1 extends pn {
  constructor(t = 0.5, e = 1, n = 32, a = 1, r = 0, l = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: n,
        phiSegments: a,
        thetaStart: r,
        thetaLength: l,
      }),
      (n = Math.max(3, n)),
      (a = Math.max(1, a));
    const u = [],
      h = [],
      p = [],
      m = [];
    let v = t;
    const x = (e - t) / a,
      _ = new Z(),
      M = new Yt();
    for (let C = 0; C <= a; C++) {
      for (let E = 0; E <= n; E++) {
        const S = r + (E / n) * l;
        (_.x = v * Math.cos(S)),
          (_.y = v * Math.sin(S)),
          h.push(_.x, _.y, _.z),
          p.push(0, 0, 1),
          (M.x = (_.x / e + 1) / 2),
          (M.y = (_.y / e + 1) / 2),
          m.push(M.x, M.y);
      }
      v += x;
    }
    for (let C = 0; C < a; C++) {
      const E = C * (n + 1);
      for (let S = 0; S < n; S++) {
        const R = S + E,
          B = R,
          D = R + n + 1,
          I = R + n + 2,
          P = R + 1;
        u.push(B, D, P), u.push(D, I, P);
      }
    }
    this.setIndex(u),
      this.setAttribute("position", new Pe(h, 3)),
      this.setAttribute("normal", new Pe(p, 3)),
      this.setAttribute("uv", new Pe(m, 2));
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new n1(
      t.innerRadius,
      t.outerRadius,
      t.thetaSegments,
      t.phiSegments,
      t.thetaStart,
      t.thetaLength
    );
  }
}
class i1 extends pn {
  constructor(
    t = new Yf([new Yt(0, 0.5), new Yt(-0.5, -0.5), new Yt(0.5, -0.5)]),
    e = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: t, curveSegments: e });
    const n = [],
      a = [],
      r = [],
      l = [];
    let u = 0,
      h = 0;
    if (Array.isArray(t) === !1) p(t);
    else
      for (let m = 0; m < t.length; m++)
        p(t[m]), this.addGroup(u, h, m), (u += h), (h = 0);
    this.setIndex(n),
      this.setAttribute("position", new Pe(a, 3)),
      this.setAttribute("normal", new Pe(r, 3)),
      this.setAttribute("uv", new Pe(l, 2));
    function p(m) {
      const v = a.length / 3,
        x = m.extractPoints(e);
      let _ = x.shape;
      const M = x.holes;
      xo.isClockWise(_) === !1 && (_ = _.reverse());
      for (let E = 0, S = M.length; E < S; E++) {
        const R = M[E];
        xo.isClockWise(R) === !0 && (M[E] = R.reverse());
      }
      const C = xo.triangulateShape(_, M);
      for (let E = 0, S = M.length; E < S; E++) {
        const R = M[E];
        _ = _.concat(R);
      }
      for (let E = 0, S = _.length; E < S; E++) {
        const R = _[E];
        a.push(R.x, R.y, 0), r.push(0, 0, 1), l.push(R.x, R.y);
      }
      for (let E = 0, S = C.length; E < S; E++) {
        const R = C[E],
          B = R[0] + v,
          D = R[1] + v,
          I = R[2] + v;
        n.push(B, D, I), (h += 3);
      }
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  toJSON() {
    const t = super.toJSON(),
      e = this.parameters.shapes;
    return gN(e, t);
  }
  static fromJSON(t, e) {
    const n = [];
    for (let a = 0, r = t.shapes.length; a < r; a++) {
      const l = e[t.shapes[a]];
      n.push(l);
    }
    return new i1(n, t.curveSegments);
  }
}
function gN(i, t) {
  if (((t.shapes = []), Array.isArray(i)))
    for (let e = 0, n = i.length; e < n; e++) {
      const a = i[e];
      t.shapes.push(a.uuid);
    }
  else t.shapes.push(i.uuid);
  return t;
}
class G0 extends pn {
  constructor(
    t = 1,
    e = 32,
    n = 16,
    a = 0,
    r = Math.PI * 2,
    l = 0,
    u = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: a,
        phiLength: r,
        thetaStart: l,
        thetaLength: u,
      }),
      (e = Math.max(3, Math.floor(e))),
      (n = Math.max(2, Math.floor(n)));
    const h = Math.min(l + u, Math.PI);
    let p = 0;
    const m = [],
      v = new Z(),
      x = new Z(),
      _ = [],
      M = [],
      C = [],
      E = [];
    for (let S = 0; S <= n; S++) {
      const R = [],
        B = S / n;
      let D = 0;
      S === 0 && l === 0
        ? (D = 0.5 / e)
        : S === n && h === Math.PI && (D = -0.5 / e);
      for (let I = 0; I <= e; I++) {
        const P = I / e;
        (v.x = -t * Math.cos(a + P * r) * Math.sin(l + B * u)),
          (v.y = t * Math.cos(l + B * u)),
          (v.z = t * Math.sin(a + P * r) * Math.sin(l + B * u)),
          M.push(v.x, v.y, v.z),
          x.copy(v).normalize(),
          C.push(x.x, x.y, x.z),
          E.push(P + D, 1 - B),
          R.push(p++);
      }
      m.push(R);
    }
    for (let S = 0; S < n; S++)
      for (let R = 0; R < e; R++) {
        const B = m[S][R + 1],
          D = m[S][R],
          I = m[S + 1][R],
          P = m[S + 1][R + 1];
        (S !== 0 || l > 0) && _.push(B, D, P),
          (S !== n - 1 || h < Math.PI) && _.push(D, I, P);
      }
    this.setIndex(_),
      this.setAttribute("position", new Pe(M, 3)),
      this.setAttribute("normal", new Pe(C, 3)),
      this.setAttribute("uv", new Pe(E, 2));
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new G0(
      t.radius,
      t.widthSegments,
      t.heightSegments,
      t.phiStart,
      t.phiLength,
      t.thetaStart,
      t.thetaLength
    );
  }
}
class a1 extends yu {
  constructor(t = 1, e = 0) {
    const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      a = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(n, a, t, e),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
  static fromJSON(t) {
    return new a1(t.radius, t.detail);
  }
}
class s1 extends pn {
  constructor(t = 1, e = 0.4, n = 12, a = 48, r = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: n,
        tubularSegments: a,
        arc: r,
      }),
      (n = Math.floor(n)),
      (a = Math.floor(a));
    const l = [],
      u = [],
      h = [],
      p = [],
      m = new Z(),
      v = new Z(),
      x = new Z();
    for (let _ = 0; _ <= n; _++)
      for (let M = 0; M <= a; M++) {
        const C = (M / a) * r,
          E = (_ / n) * Math.PI * 2;
        (v.x = (t + e * Math.cos(E)) * Math.cos(C)),
          (v.y = (t + e * Math.cos(E)) * Math.sin(C)),
          (v.z = e * Math.sin(E)),
          u.push(v.x, v.y, v.z),
          (m.x = t * Math.cos(C)),
          (m.y = t * Math.sin(C)),
          x.subVectors(v, m).normalize(),
          h.push(x.x, x.y, x.z),
          p.push(M / a),
          p.push(_ / n);
      }
    for (let _ = 1; _ <= n; _++)
      for (let M = 1; M <= a; M++) {
        const C = (a + 1) * _ + M - 1,
          E = (a + 1) * (_ - 1) + M - 1,
          S = (a + 1) * (_ - 1) + M,
          R = (a + 1) * _ + M;
        l.push(C, E, R), l.push(E, S, R);
      }
    this.setIndex(l),
      this.setAttribute("position", new Pe(u, 3)),
      this.setAttribute("normal", new Pe(h, 3)),
      this.setAttribute("uv", new Pe(p, 2));
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new s1(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc);
  }
}
class r1 extends pn {
  constructor(t = 1, e = 0.4, n = 64, a = 8, r = 2, l = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: t,
        tube: e,
        tubularSegments: n,
        radialSegments: a,
        p: r,
        q: l,
      }),
      (n = Math.floor(n)),
      (a = Math.floor(a));
    const u = [],
      h = [],
      p = [],
      m = [],
      v = new Z(),
      x = new Z(),
      _ = new Z(),
      M = new Z(),
      C = new Z(),
      E = new Z(),
      S = new Z();
    for (let B = 0; B <= n; ++B) {
      const D = (B / n) * r * Math.PI * 2;
      R(D, r, l, t, _),
        R(D + 0.01, r, l, t, M),
        E.subVectors(M, _),
        S.addVectors(M, _),
        C.crossVectors(E, S),
        S.crossVectors(C, E),
        C.normalize(),
        S.normalize();
      for (let I = 0; I <= a; ++I) {
        const P = (I / a) * Math.PI * 2,
          V = -e * Math.cos(P),
          F = e * Math.sin(P);
        (v.x = _.x + (V * S.x + F * C.x)),
          (v.y = _.y + (V * S.y + F * C.y)),
          (v.z = _.z + (V * S.z + F * C.z)),
          h.push(v.x, v.y, v.z),
          x.subVectors(v, _).normalize(),
          p.push(x.x, x.y, x.z),
          m.push(B / n),
          m.push(I / a);
      }
    }
    for (let B = 1; B <= n; B++)
      for (let D = 1; D <= a; D++) {
        const I = (a + 1) * (B - 1) + (D - 1),
          P = (a + 1) * B + (D - 1),
          V = (a + 1) * B + D,
          F = (a + 1) * (B - 1) + D;
        u.push(I, P, F), u.push(P, V, F);
      }
    this.setIndex(u),
      this.setAttribute("position", new Pe(h, 3)),
      this.setAttribute("normal", new Pe(p, 3)),
      this.setAttribute("uv", new Pe(m, 2));
    function R(B, D, I, P, V) {
      const F = Math.cos(B),
        N = Math.sin(B),
        L = (I / D) * B,
        Y = Math.cos(L);
      (V.x = P * (2 + Y) * 0.5 * F),
        (V.y = P * (2 + Y) * N * 0.5),
        (V.z = P * Math.sin(L) * 0.5);
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  static fromJSON(t) {
    return new r1(
      t.radius,
      t.tube,
      t.tubularSegments,
      t.radialSegments,
      t.p,
      t.q
    );
  }
}
class o1 extends pn {
  constructor(
    t = new eS(new Z(-1, -1, 0), new Z(-1, 1, 0), new Z(1, 1, 0)),
    e = 64,
    n = 1,
    a = 8,
    r = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: t,
        tubularSegments: e,
        radius: n,
        radialSegments: a,
        closed: r,
      });
    const l = t.computeFrenetFrames(e, r);
    (this.tangents = l.tangents),
      (this.normals = l.normals),
      (this.binormals = l.binormals);
    const u = new Z(),
      h = new Z(),
      p = new Yt();
    let m = new Z();
    const v = [],
      x = [],
      _ = [],
      M = [];
    C(),
      this.setIndex(M),
      this.setAttribute("position", new Pe(v, 3)),
      this.setAttribute("normal", new Pe(x, 3)),
      this.setAttribute("uv", new Pe(_, 2));
    function C() {
      for (let B = 0; B < e; B++) E(B);
      E(r === !1 ? e : 0), R(), S();
    }
    function E(B) {
      m = t.getPointAt(B / e, m);
      const D = l.normals[B],
        I = l.binormals[B];
      for (let P = 0; P <= a; P++) {
        const V = (P / a) * Math.PI * 2,
          F = Math.sin(V),
          N = -Math.cos(V);
        (h.x = N * D.x + F * I.x),
          (h.y = N * D.y + F * I.y),
          (h.z = N * D.z + F * I.z),
          h.normalize(),
          x.push(h.x, h.y, h.z),
          (u.x = m.x + n * h.x),
          (u.y = m.y + n * h.y),
          (u.z = m.z + n * h.z),
          v.push(u.x, u.y, u.z);
      }
    }
    function S() {
      for (let B = 1; B <= e; B++)
        for (let D = 1; D <= a; D++) {
          const I = (a + 1) * (B - 1) + (D - 1),
            P = (a + 1) * B + (D - 1),
            V = (a + 1) * B + D,
            F = (a + 1) * (B - 1) + D;
          M.push(I, P, F), M.push(P, V, F);
        }
    }
    function R() {
      for (let B = 0; B <= e; B++)
        for (let D = 0; D <= a; D++)
          (p.x = B / e), (p.y = D / a), _.push(p.x, p.y);
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (t.path = this.parameters.path.toJSON()), t;
  }
  static fromJSON(t) {
    return new o1(
      new yx[t.path.type]().fromJSON(t.path),
      t.tubularSegments,
      t.radius,
      t.radialSegments,
      t.closed
    );
  }
}
class iR extends pn {
  constructor(t = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: t }),
      t !== null)
    ) {
      const e = [],
        n = new Set(),
        a = new Z(),
        r = new Z();
      if (t.index !== null) {
        const l = t.attributes.position,
          u = t.index;
        let h = t.groups;
        h.length === 0 &&
          (h = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let p = 0, m = h.length; p < m; ++p) {
          const v = h[p],
            x = v.start,
            _ = v.count;
          for (let M = x, C = x + _; M < C; M += 3)
            for (let E = 0; E < 3; E++) {
              const S = u.getX(M + E),
                R = u.getX(M + ((E + 1) % 3));
              a.fromBufferAttribute(l, S),
                r.fromBufferAttribute(l, R),
                QE(a, r, n) === !0 &&
                  (e.push(a.x, a.y, a.z), e.push(r.x, r.y, r.z));
            }
        }
      } else {
        const l = t.attributes.position;
        for (let u = 0, h = l.count / 3; u < h; u++)
          for (let p = 0; p < 3; p++) {
            const m = 3 * u + p,
              v = 3 * u + ((p + 1) % 3);
            a.fromBufferAttribute(l, m),
              r.fromBufferAttribute(l, v),
              QE(a, r, n) === !0 &&
                (e.push(a.x, a.y, a.z), e.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new Pe(e, 3));
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    );
  }
}
function QE(i, t, e) {
  const n = `${i.x},${i.y},${i.z}-${t.x},${t.y},${t.z}`,
    a = `${t.x},${t.y},${t.z}-${i.x},${i.y},${i.z}`;
  return e.has(n) === !0 || e.has(a) === !0 ? !1 : (e.add(n), e.add(a), !0);
}
var $E = Object.freeze({
  __proto__: null,
  BoxGeometry: ah,
  CapsuleGeometry: Jx,
  CircleGeometry: Zx,
  ConeGeometry: z0,
  CylinderGeometry: P0,
  DodecahedronGeometry: Qx,
  EdgesGeometry: YC,
  ExtrudeGeometry: t1,
  IcosahedronGeometry: F0,
  LatheGeometry: e1,
  OctahedronGeometry: H0,
  PlaneGeometry: xu,
  PolyhedronGeometry: yu,
  RingGeometry: n1,
  ShapeGeometry: i1,
  SphereGeometry: G0,
  TetrahedronGeometry: a1,
  TorusGeometry: s1,
  TorusKnotGeometry: r1,
  TubeGeometry: o1,
  WireframeGeometry: iR,
});
class aR extends ma {
  constructor(t) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Se(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), (this.fog = t.fog), this;
  }
}
class sR extends Xs {
  constructor(t) {
    super(t),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class V0 extends ma {
  constructor(t) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new Se(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Se(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = vu),
      (this.normalScale = new Yt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new cr()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: "" }),
      this.color.copy(t.color),
      (this.roughness = t.roughness),
      (this.metalness = t.metalness),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.roughnessMap = t.roughnessMap),
      (this.metalnessMap = t.metalnessMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.envMapIntensity = t.envMapIntensity),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    );
  }
}
class Fr extends V0 {
  constructor(t) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Yt(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return dn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (e) {
          this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Se(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Se(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Se(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(t);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(t) {
    this._anisotropy > 0 != t > 0 && this.version++, (this._anisotropy = t);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(t) {
    this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(t) {
    this._dispersion > 0 != t > 0 && this.version++, (this._dispersion = t);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, (this._transmission = t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = t.anisotropy),
      (this.anisotropyRotation = t.anisotropyRotation),
      (this.anisotropyMap = t.anisotropyMap),
      (this.clearcoat = t.clearcoat),
      (this.clearcoatMap = t.clearcoatMap),
      (this.clearcoatRoughness = t.clearcoatRoughness),
      (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = t.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
      (this.dispersion = t.dispersion),
      (this.ior = t.ior),
      (this.iridescence = t.iridescence),
      (this.iridescenceMap = t.iridescenceMap),
      (this.iridescenceIOR = t.iridescenceIOR),
      (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
      (this.sheen = t.sheen),
      this.sheenColor.copy(t.sheenColor),
      (this.sheenColorMap = t.sheenColorMap),
      (this.sheenRoughness = t.sheenRoughness),
      (this.sheenRoughnessMap = t.sheenRoughnessMap),
      (this.transmission = t.transmission),
      (this.transmissionMap = t.transmissionMap),
      (this.thickness = t.thickness),
      (this.thicknessMap = t.thicknessMap),
      (this.attenuationDistance = t.attenuationDistance),
      this.attenuationColor.copy(t.attenuationColor),
      (this.specularIntensity = t.specularIntensity),
      (this.specularIntensityMap = t.specularIntensityMap),
      this.specularColor.copy(t.specularColor),
      (this.specularColorMap = t.specularColorMap),
      this
    );
  }
}
class rR extends ma {
  constructor(t) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Se(16777215)),
      (this.specular = new Se(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Se(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = vu),
      (this.normalScale = new Yt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new cr()),
      (this.combine = R0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      this.specular.copy(t.specular),
      (this.shininess = t.shininess),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    );
  }
}
class oR extends ma {
  constructor(t) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Se(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Se(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = vu),
      (this.normalScale = new Yt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.gradientMap = t.gradientMap),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.fog = t.fog),
      this
    );
  }
}
class lR extends ma {
  constructor(t) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = vu),
      (this.normalScale = new Yt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.flatShading = t.flatShading),
      this
    );
  }
}
class cR extends ma {
  constructor(t) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Se(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Se(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = vu),
      (this.normalScale = new Yt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new cr()),
      (this.combine = R0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    );
  }
}
class iS extends ma {
  constructor(t) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = MC),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.depthPacking = t.depthPacking),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    );
  }
}
class aS extends ma {
  constructor(t) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    );
  }
}
class uR extends ma {
  constructor(t) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Se(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = vu),
      (this.normalScale = new Yt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { MATCAP: "" }),
      this.color.copy(t.color),
      (this.matcap = t.matcap),
      (this.map = t.map),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    );
  }
}
class fR extends is {
  constructor(t) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.scale = t.scale),
      (this.dashSize = t.dashSize),
      (this.gapSize = t.gapSize),
      this
    );
  }
}
function Hf(i, t) {
  return !i || i.constructor === t
    ? i
    : typeof t.BYTES_PER_ELEMENT == "number"
    ? new t(i)
    : Array.prototype.slice.call(i);
}
function hR(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function dR(i) {
  function t(a, r) {
    return i[a] - i[r];
  }
  const e = i.length,
    n = new Array(e);
  for (let a = 0; a !== e; ++a) n[a] = a;
  return n.sort(t), n;
}
function Xb(i, t, e) {
  const n = i.length,
    a = new i.constructor(n);
  for (let r = 0, l = 0; l !== n; ++r) {
    const u = e[r] * t;
    for (let h = 0; h !== t; ++h) a[l++] = i[u + h];
  }
  return a;
}
function sS(i, t, e, n) {
  let a = 1,
    r = i[0];
  for (; r !== void 0 && r[n] === void 0; ) r = i[a++];
  if (r === void 0) return;
  let l = r[n];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        (l = r[n]),
          l !== void 0 && (t.push(r.time), e.push(...l)),
          (r = i[a++]);
      while (r !== void 0);
    else if (l.toArray !== void 0)
      do
        (l = r[n]),
          l !== void 0 && (t.push(r.time), l.toArray(e, e.length)),
          (r = i[a++]);
      while (r !== void 0);
    else
      do (l = r[n]), l !== void 0 && (t.push(r.time), e.push(l)), (r = i[a++]);
      while (r !== void 0);
}
function vN(i, t, e, n, a = 30) {
  const r = i.clone();
  r.name = t;
  const l = [];
  for (let h = 0; h < r.tracks.length; ++h) {
    const p = r.tracks[h],
      m = p.getValueSize(),
      v = [],
      x = [];
    for (let _ = 0; _ < p.times.length; ++_) {
      const M = p.times[_] * a;
      if (!(M < e || M >= n)) {
        v.push(p.times[_]);
        for (let C = 0; C < m; ++C) x.push(p.values[_ * m + C]);
      }
    }
    v.length !== 0 &&
      ((p.times = Hf(v, p.times.constructor)),
      (p.values = Hf(x, p.values.constructor)),
      l.push(p));
  }
  r.tracks = l;
  let u = 1 / 0;
  for (let h = 0; h < r.tracks.length; ++h)
    u > r.tracks[h].times[0] && (u = r.tracks[h].times[0]);
  for (let h = 0; h < r.tracks.length; ++h) r.tracks[h].shift(-1 * u);
  return r.resetDuration(), r;
}
function yN(i, t = 0, e = i, n = 30) {
  n <= 0 && (n = 30);
  const a = e.tracks.length,
    r = t / n;
  for (let l = 0; l < a; ++l) {
    const u = e.tracks[l],
      h = u.ValueTypeName;
    if (h === "bool" || h === "string") continue;
    const p = i.tracks.find(function (S) {
      return S.name === u.name && S.ValueTypeName === h;
    });
    if (p === void 0) continue;
    let m = 0;
    const v = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (m = v / 3);
    let x = 0;
    const _ = p.getValueSize();
    p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (x = _ / 3);
    const M = u.times.length - 1;
    let C;
    if (r <= u.times[0]) {
      const S = m,
        R = v - m;
      C = u.values.slice(S, R);
    } else if (r >= u.times[M]) {
      const S = M * v + m,
        R = S + v - m;
      C = u.values.slice(S, R);
    } else {
      const S = u.createInterpolant(),
        R = m,
        B = v - m;
      S.evaluate(r), (C = S.resultBuffer.slice(R, B));
    }
    h === "quaternion" &&
      new pa().fromArray(C).normalize().conjugate().toArray(C);
    const E = p.times.length;
    for (let S = 0; S < E; ++S) {
      const R = S * _ + x;
      if (h === "quaternion")
        pa.multiplyQuaternionsFlat(p.values, R, C, 0, p.values, R);
      else {
        const B = _ - x * 2;
        for (let D = 0; D < B; ++D) p.values[R + D] -= C[D];
      }
    }
  }
  return (i.blendMode = PA), i;
}
class xN {
  static convertArray(t, e) {
    return Hf(t, e);
  }
  static isTypedArray(t) {
    return hR(t);
  }
  static getKeyframeOrder(t) {
    return dR(t);
  }
  static sortedArray(t, e, n) {
    return Xb(t, e, n);
  }
  static flattenJSON(t, e, n, a) {
    sS(t, e, n, a);
  }
  static subclip(t, e, n, a, r = 30) {
    return vN(t, e, n, a, r);
  }
  static makeClipAdditive(t, e = 0, n = t, a = 30) {
    return yN(t, e, n, a);
  }
}
class sp {
  constructor(t, e, n, a) {
    (this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = a !== void 0 ? a : new e.constructor(n)),
      (this.sampleValues = e),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(t) {
    const e = this.parameterPositions;
    let n = this._cachedIndex,
      a = e[n],
      r = e[n - 1];
    t: {
      e: {
        let l;
        n: {
          i: if (!(t < a)) {
            for (let u = n + 2; ; ) {
              if (a === void 0) {
                if (t < r) break i;
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === u) break;
              if (((r = a), (a = e[++n]), t < a)) break e;
            }
            l = e.length;
            break n;
          }
          if (!(t >= r)) {
            const u = e[1];
            t < u && ((n = 2), (r = u));
            for (let h = n - 2; ; ) {
              if (r === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === h) break;
              if (((a = r), (r = e[--n - 1]), t >= r)) break e;
            }
            (l = n), (n = 0);
            break n;
          }
          break t;
        }
        for (; n < l; ) {
          const u = (n + l) >>> 1;
          t < e[u] ? (l = u) : (n = u + 1);
        }
        if (((a = e[n]), (r = e[n - 1]), r === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (a === void 0)
          return (
            (n = e.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, a);
    }
    return this.interpolate_(n, r, t, a);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      a = this.valueSize,
      r = t * a;
    for (let l = 0; l !== a; ++l) e[l] = n[r + l];
    return e;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class pR extends sp {
  constructor(t, e, n, a) {
    super(t, e, n, a),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Pf, endingEnd: Pf });
  }
  intervalChanged_(t, e, n) {
    const a = this.parameterPositions;
    let r = t - 2,
      l = t + 1,
      u = a[r],
      h = a[l];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case zf:
          (r = t), (u = 2 * e - n);
          break;
        case c0:
          (r = a.length - 2), (u = e + a[r] - a[r + 1]);
          break;
        default:
          (r = t), (u = n);
      }
    if (h === void 0)
      switch (this.getSettings_().endingEnd) {
        case zf:
          (l = t), (h = 2 * n - e);
          break;
        case c0:
          (l = 1), (h = n + a[1] - a[0]);
          break;
        default:
          (l = t - 1), (h = e);
      }
    const p = (n - e) * 0.5,
      m = this.valueSize;
    (this._weightPrev = p / (e - u)),
      (this._weightNext = p / (h - n)),
      (this._offsetPrev = r * m),
      (this._offsetNext = l * m);
  }
  interpolate_(t, e, n, a) {
    const r = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      h = t * u,
      p = h - u,
      m = this._offsetPrev,
      v = this._offsetNext,
      x = this._weightPrev,
      _ = this._weightNext,
      M = (n - e) / (a - e),
      C = M * M,
      E = C * M,
      S = -x * E + 2 * x * C - x * M,
      R = (1 + x) * E + (-1.5 - 2 * x) * C + (-0.5 + x) * M + 1,
      B = (-1 - _) * E + (1.5 + _) * C + 0.5 * M,
      D = _ * E - _ * C;
    for (let I = 0; I !== u; ++I)
      r[I] = S * l[m + I] + R * l[p + I] + B * l[h + I] + D * l[v + I];
    return r;
  }
}
class rS extends sp {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
  interpolate_(t, e, n, a) {
    const r = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      h = t * u,
      p = h - u,
      m = (n - e) / (a - e),
      v = 1 - m;
    for (let x = 0; x !== u; ++x) r[x] = l[p + x] * v + l[h + x] * m;
    return r;
  }
}
class mR extends sp {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1);
  }
}
class Hr {
  constructor(t, e, n, a) {
    if (t === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    (this.name = t),
      (this.times = Hf(e, this.TimeBufferType)),
      (this.values = Hf(n, this.ValueBufferType)),
      this.setInterpolation(a || this.DefaultInterpolation);
  }
  static toJSON(t) {
    const e = t.constructor;
    let n;
    if (e.toJSON !== this.toJSON) n = e.toJSON(t);
    else {
      n = {
        name: t.name,
        times: Hf(t.times, Array),
        values: Hf(t.values, Array),
      };
      const a = t.getInterpolation();
      a !== t.DefaultInterpolation && (n.interpolation = a);
    }
    return (n.type = t.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new mR(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodLinear(t) {
    return new rS(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodSmooth(t) {
    return new pR(this.times, this.values, this.getValueSize(), t);
  }
  setInterpolation(t) {
    let e;
    switch (t) {
      case qd:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case Kd:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case Ey:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (t !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = e), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return qd;
      case this.InterpolantFactoryMethodLinear:
        return Kd;
      case this.InterpolantFactoryMethodSmooth:
        return Ey;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(t) {
    if (t !== 0) {
      const e = this.times;
      for (let n = 0, a = e.length; n !== a; ++n) e[n] += t;
    }
    return this;
  }
  scale(t) {
    if (t !== 1) {
      const e = this.times;
      for (let n = 0, a = e.length; n !== a; ++n) e[n] *= t;
    }
    return this;
  }
  trim(t, e) {
    const n = this.times,
      a = n.length;
    let r = 0,
      l = a - 1;
    for (; r !== a && n[r] < t; ) ++r;
    for (; l !== -1 && n[l] > e; ) --l;
    if ((++l, r !== 0 || l !== a)) {
      r >= l && ((l = Math.max(l, 1)), (r = l - 1));
      const u = this.getValueSize();
      (this.times = n.slice(r, l)),
        (this.values = this.values.slice(r * u, l * u));
    }
    return this;
  }
  validate() {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (t = !1));
    const n = this.times,
      a = this.values,
      r = n.length;
    r === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
    let l = null;
    for (let u = 0; u !== r; u++) {
      const h = n[u];
      if (typeof h == "number" && isNaN(h)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          u,
          h
        ),
          (t = !1);
        break;
      }
      if (l !== null && l > h) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, u, h, l),
          (t = !1);
        break;
      }
      l = h;
    }
    if (a !== void 0 && hR(a))
      for (let u = 0, h = a.length; u !== h; ++u) {
        const p = a[u];
        if (isNaN(p)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            u,
            p
          ),
            (t = !1);
          break;
        }
      }
    return t;
  }
  optimize() {
    const t = this.times.slice(),
      e = this.values.slice(),
      n = this.getValueSize(),
      a = this.getInterpolation() === Ey,
      r = t.length - 1;
    let l = 1;
    for (let u = 1; u < r; ++u) {
      let h = !1;
      const p = t[u],
        m = t[u + 1];
      if (p !== m && (u !== 1 || p !== t[0]))
        if (a) h = !0;
        else {
          const v = u * n,
            x = v - n,
            _ = v + n;
          for (let M = 0; M !== n; ++M) {
            const C = e[v + M];
            if (C !== e[x + M] || C !== e[_ + M]) {
              h = !0;
              break;
            }
          }
        }
      if (h) {
        if (u !== l) {
          t[l] = t[u];
          const v = u * n,
            x = l * n;
          for (let _ = 0; _ !== n; ++_) e[x + _] = e[v + _];
        }
        ++l;
      }
    }
    if (r > 0) {
      t[l] = t[r];
      for (let u = r * n, h = l * n, p = 0; p !== n; ++p) e[h + p] = e[u + p];
      ++l;
    }
    return (
      l !== t.length
        ? ((this.times = t.slice(0, l)), (this.values = e.slice(0, l * n)))
        : ((this.times = t), (this.values = e)),
      this
    );
  }
  clone() {
    const t = this.times.slice(),
      e = this.values.slice(),
      n = this.constructor,
      a = new n(this.name, t, e);
    return (a.createInterpolant = this.createInterpolant), a;
  }
}
Hr.prototype.ValueTypeName = "";
Hr.prototype.TimeBufferType = Float32Array;
Hr.prototype.ValueBufferType = Float32Array;
Hr.prototype.DefaultInterpolation = Kd;
class sh extends Hr {
  constructor(t, e, n) {
    super(t, e, n);
  }
}
sh.prototype.ValueTypeName = "bool";
sh.prototype.ValueBufferType = Array;
sh.prototype.DefaultInterpolation = qd;
sh.prototype.InterpolantFactoryMethodLinear = void 0;
sh.prototype.InterpolantFactoryMethodSmooth = void 0;
class oS extends Hr {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
}
oS.prototype.ValueTypeName = "color";
class $f extends Hr {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
}
$f.prototype.ValueTypeName = "number";
class gR extends sp {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
  interpolate_(t, e, n, a) {
    const r = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      h = (n - e) / (a - e);
    let p = t * u;
    for (let m = p + u; p !== m; p += 4) pa.slerpFlat(r, 0, l, p - u, l, p, h);
    return r;
  }
}
class du extends Hr {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
  InterpolantFactoryMethodLinear(t) {
    return new gR(this.times, this.values, this.getValueSize(), t);
  }
}
du.prototype.ValueTypeName = "quaternion";
du.prototype.InterpolantFactoryMethodSmooth = void 0;
class rh extends Hr {
  constructor(t, e, n) {
    super(t, e, n);
  }
}
rh.prototype.ValueTypeName = "string";
rh.prototype.ValueBufferType = Array;
rh.prototype.DefaultInterpolation = qd;
rh.prototype.InterpolantFactoryMethodLinear = void 0;
rh.prototype.InterpolantFactoryMethodSmooth = void 0;
class pu extends Hr {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
}
pu.prototype.ValueTypeName = "vector";
class th {
  constructor(t = "", e = -1, n = [], a = Hx) {
    (this.name = t),
      (this.tracks = n),
      (this.duration = e),
      (this.blendMode = a),
      (this.uuid = lr()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(t) {
    const e = [],
      n = t.tracks,
      a = 1 / (t.fps || 1);
    for (let l = 0, u = n.length; l !== u; ++l) e.push(bN(n[l]).scale(a));
    const r = new this(t.name, t.duration, e, t.blendMode);
    return (r.uuid = t.uuid), r;
  }
  static toJSON(t) {
    const e = [],
      n = t.tracks,
      a = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode,
      };
    for (let r = 0, l = n.length; r !== l; ++r) e.push(Hr.toJSON(n[r]));
    return a;
  }
  static CreateFromMorphTargetSequence(t, e, n, a) {
    const r = e.length,
      l = [];
    for (let u = 0; u < r; u++) {
      let h = [],
        p = [];
      h.push((u + r - 1) % r, u, (u + 1) % r), p.push(0, 1, 0);
      const m = dR(h);
      (h = Xb(h, 1, m)),
        (p = Xb(p, 1, m)),
        !a && h[0] === 0 && (h.push(r), p.push(p[0])),
        l.push(
          new $f(".morphTargetInfluences[" + e[u].name + "]", h, p).scale(1 / n)
        );
    }
    return new this(t, -1, l);
  }
  static findByName(t, e) {
    let n = t;
    if (!Array.isArray(t)) {
      const a = t;
      n = (a.geometry && a.geometry.animations) || a.animations;
    }
    for (let a = 0; a < n.length; a++) if (n[a].name === e) return n[a];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(t, e, n) {
    const a = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, h = t.length; u < h; u++) {
      const p = t[u],
        m = p.name.match(r);
      if (m && m.length > 1) {
        const v = m[1];
        let x = a[v];
        x || (a[v] = x = []), x.push(p);
      }
    }
    const l = [];
    for (const u in a)
      l.push(this.CreateFromMorphTargetSequence(u, a[u], e, n));
    return l;
  }
  static parseAnimation(t, e) {
    if (
      (console.warn(
        "THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"
      ),
      !t)
    )
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (v, x, _, M, C) {
        if (_.length !== 0) {
          const E = [],
            S = [];
          sS(_, E, S, M), E.length !== 0 && C.push(new v(x, E, S));
        }
      },
      a = [],
      r = t.name || "default",
      l = t.fps || 30,
      u = t.blendMode;
    let h = t.length || -1;
    const p = t.hierarchy || [];
    for (let v = 0; v < p.length; v++) {
      const x = p[v].keys;
      if (!(!x || x.length === 0))
        if (x[0].morphTargets) {
          const _ = {};
          let M;
          for (M = 0; M < x.length; M++)
            if (x[M].morphTargets)
              for (let C = 0; C < x[M].morphTargets.length; C++)
                _[x[M].morphTargets[C]] = -1;
          for (const C in _) {
            const E = [],
              S = [];
            for (let R = 0; R !== x[M].morphTargets.length; ++R) {
              const B = x[M];
              E.push(B.time), S.push(B.morphTarget === C ? 1 : 0);
            }
            a.push(new $f(".morphTargetInfluence[" + C + "]", E, S));
          }
          h = _.length * l;
        } else {
          const _ = ".bones[" + e[v].name + "]";
          n(pu, _ + ".position", x, "pos", a),
            n(du, _ + ".quaternion", x, "rot", a),
            n(pu, _ + ".scale", x, "scl", a);
        }
    }
    return a.length === 0 ? null : new this(r, h, a, u);
  }
  resetDuration() {
    const t = this.tracks;
    let e = 0;
    for (let n = 0, a = t.length; n !== a; ++n) {
      const r = this.tracks[n];
      e = Math.max(e, r.times[r.times.length - 1]);
    }
    return (this.duration = e), this;
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  }
  validate() {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
    return this;
  }
  clone() {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
    return new this.constructor(this.name, this.duration, t, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function _N(i) {
  switch (i.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return $f;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return pu;
    case "color":
      return oS;
    case "quaternion":
      return du;
    case "bool":
    case "boolean":
      return sh;
    case "string":
      return rh;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function bN(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const t = _N(i.type);
  if (i.times === void 0) {
    const e = [],
      n = [];
    sS(i.keys, e, n, "value"), (i.times = e), (i.values = n);
  }
  return t.parse !== void 0
    ? t.parse(i)
    : new t(i.name, i.times, i.values, i.interpolation);
}
const Zl = {
  enabled: !1,
  files: {},
  add: function (i, t) {
    this.enabled !== !1 && (this.files[i] = t);
  },
  get: function (i) {
    if (this.enabled !== !1) return this.files[i];
  },
  remove: function (i) {
    delete this.files[i];
  },
  clear: function () {
    this.files = {};
  },
};
class l1 {
  constructor(t, e, n) {
    const a = this;
    let r = !1,
      l = 0,
      u = 0,
      h;
    const p = [];
    (this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = n),
      (this.itemStart = function (m) {
        u++, r === !1 && a.onStart !== void 0 && a.onStart(m, l, u), (r = !0);
      }),
      (this.itemEnd = function (m) {
        l++,
          a.onProgress !== void 0 && a.onProgress(m, l, u),
          l === u && ((r = !1), a.onLoad !== void 0 && a.onLoad());
      }),
      (this.itemError = function (m) {
        a.onError !== void 0 && a.onError(m);
      }),
      (this.resolveURL = function (m) {
        return h ? h(m) : m;
      }),
      (this.setURLModifier = function (m) {
        return (h = m), this;
      }),
      (this.addHandler = function (m, v) {
        return p.push(m, v), this;
      }),
      (this.removeHandler = function (m) {
        const v = p.indexOf(m);
        return v !== -1 && p.splice(v, 2), this;
      }),
      (this.getHandler = function (m) {
        for (let v = 0, x = p.length; v < x; v += 2) {
          const _ = p[v],
            M = p[v + 1];
          if ((_.global && (_.lastIndex = 0), _.test(m))) return M;
        }
        return null;
      });
  }
}
const vR = new l1();
let Va = class {
  constructor(t) {
    (this.manager = t !== void 0 ? t : vR),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(t, e) {
    const n = this;
    return new Promise(function (a, r) {
      n.load(t, a, e, r);
    });
  }
  parse() {}
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this;
  }
  setWithCredentials(t) {
    return (this.withCredentials = t), this;
  }
  setPath(t) {
    return (this.path = t), this;
  }
  setResourcePath(t) {
    return (this.resourcePath = t), this;
  }
  setRequestHeader(t) {
    return (this.requestHeader = t), this;
  }
};
Va.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const jl = {};
class AN extends Error {
  constructor(t, e) {
    super(t), (this.response = e);
  }
}
class Ga extends Va {
  constructor(t) {
    super(t), (this.mimeType = ""), (this.responseType = "");
  }
  load(t, e, n, a) {
    t === void 0 && (t = ""),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = Zl.get(t);
    if (r !== void 0)
      return (
        this.manager.itemStart(t),
        setTimeout(() => {
          e && e(r), this.manager.itemEnd(t);
        }, 0),
        r
      );
    if (jl[t] !== void 0) {
      jl[t].push({ onLoad: e, onProgress: n, onError: a });
      return;
    }
    (jl[t] = []), jl[t].push({ onLoad: e, onProgress: n, onError: a });
    const l = new Request(t, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      u = this.mimeType,
      h = this.responseType;
    fetch(l)
      .then((p) => {
        if (p.status === 200 || p.status === 0) {
          if (
            (p.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              p.body === void 0 ||
              p.body.getReader === void 0)
          )
            return p;
          const m = jl[t],
            v = p.body.getReader(),
            x = p.headers.get("X-File-Size") || p.headers.get("Content-Length"),
            _ = x ? parseInt(x) : 0,
            M = _ !== 0;
          let C = 0;
          const E = new ReadableStream({
            start(S) {
              R();
              function R() {
                v.read().then(
                  ({ done: B, value: D }) => {
                    if (B) S.close();
                    else {
                      C += D.byteLength;
                      const I = new ProgressEvent("progress", {
                        lengthComputable: M,
                        loaded: C,
                        total: _,
                      });
                      for (let P = 0, V = m.length; P < V; P++) {
                        const F = m[P];
                        F.onProgress && F.onProgress(I);
                      }
                      S.enqueue(D), R();
                    }
                  },
                  (B) => {
                    S.error(B);
                  }
                );
              }
            },
          });
          return new Response(E);
        } else
          throw new AN(
            `fetch for "${p.url}" responded with ${p.status}: ${p.statusText}`,
            p
          );
      })
      .then((p) => {
        switch (h) {
          case "arraybuffer":
            return p.arrayBuffer();
          case "blob":
            return p.blob();
          case "document":
            return p.text().then((m) => new DOMParser().parseFromString(m, u));
          case "json":
            return p.json();
          default:
            if (u === "") return p.text();
            {
              const v = /charset="?([^;"\s]*)"?/i.exec(u),
                x = v && v[1] ? v[1].toLowerCase() : void 0,
                _ = new TextDecoder(x);
              return p.arrayBuffer().then((M) => _.decode(M));
            }
        }
      })
      .then((p) => {
        Zl.add(t, p);
        const m = jl[t];
        delete jl[t];
        for (let v = 0, x = m.length; v < x; v++) {
          const _ = m[v];
          _.onLoad && _.onLoad(p);
        }
      })
      .catch((p) => {
        const m = jl[t];
        if (m === void 0) throw (this.manager.itemError(t), p);
        delete jl[t];
        for (let v = 0, x = m.length; v < x; v++) {
          const _ = m[v];
          _.onError && _.onError(p);
        }
        this.manager.itemError(t);
      })
      .finally(() => {
        this.manager.itemEnd(t);
      }),
      this.manager.itemStart(t);
  }
  setResponseType(t) {
    return (this.responseType = t), this;
  }
  setMimeType(t) {
    return (this.mimeType = t), this;
  }
}
class SN extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = this,
      l = new Ga(this.manager);
    l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        t,
        function (u) {
          try {
            e(r.parse(JSON.parse(u)));
          } catch (h) {
            a ? a(h) : console.error(h), r.manager.itemError(t);
          }
        },
        n,
        a
      );
  }
  parse(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const a = th.parse(t[n]);
      e.push(a);
    }
    return e;
  }
}
class MN extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = this,
      l = [],
      u = new Kx(),
      h = new Ga(this.manager);
    h.setPath(this.path),
      h.setResponseType("arraybuffer"),
      h.setRequestHeader(this.requestHeader),
      h.setWithCredentials(r.withCredentials);
    let p = 0;
    function m(v) {
      h.load(
        t[v],
        function (x) {
          const _ = r.parse(x, !0);
          (l[v] = {
            width: _.width,
            height: _.height,
            format: _.format,
            mipmaps: _.mipmaps,
          }),
            (p += 1),
            p === 6 &&
              (_.mipmapCount === 1 && (u.minFilter = Kn),
              (u.image = l),
              (u.format = _.format),
              (u.needsUpdate = !0),
              e && e(u));
        },
        n,
        a
      );
    }
    if (Array.isArray(t)) for (let v = 0, x = t.length; v < x; ++v) m(v);
    else
      h.load(
        t,
        function (v) {
          const x = r.parse(v, !0);
          if (x.isCubemap) {
            const _ = x.mipmaps.length / x.mipmapCount;
            for (let M = 0; M < _; M++) {
              l[M] = { mipmaps: [] };
              for (let C = 0; C < x.mipmapCount; C++)
                l[M].mipmaps.push(x.mipmaps[M * x.mipmapCount + C]),
                  (l[M].format = x.format),
                  (l[M].width = x.width),
                  (l[M].height = x.height);
            }
            u.image = l;
          } else
            (u.image.width = x.width),
              (u.image.height = x.height),
              (u.mipmaps = x.mipmaps);
          x.mipmapCount === 1 && (u.minFilter = Kn),
            (u.format = x.format),
            (u.needsUpdate = !0),
            e && e(u);
        },
        n,
        a
      );
    return u;
  }
}
class v0 extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      l = Zl.get(t);
    if (l !== void 0)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(l), r.manager.itemEnd(t);
        }, 0),
        l
      );
    const u = d0("img");
    function h() {
      m(), Zl.add(t, this), e && e(this), r.manager.itemEnd(t);
    }
    function p(v) {
      m(), a && a(v), r.manager.itemError(t), r.manager.itemEnd(t);
    }
    function m() {
      u.removeEventListener("load", h, !1),
        u.removeEventListener("error", p, !1);
    }
    return (
      u.addEventListener("load", h, !1),
      u.addEventListener("error", p, !1),
      t.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (u.crossOrigin = this.crossOrigin),
      r.manager.itemStart(t),
      (u.src = t),
      u
    );
  }
}
class yR extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = new O0();
    r.colorSpace = Fa;
    const l = new v0(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let u = 0;
    function h(p) {
      l.load(
        t[p],
        function (m) {
          (r.images[p] = m), u++, u === 6 && ((r.needsUpdate = !0), e && e(r));
        },
        void 0,
        a
      );
    }
    for (let p = 0; p < t.length; ++p) h(p);
    return r;
  }
}
class lS extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = this,
      l = new _o(),
      u = new Ga(this.manager);
    return (
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setPath(this.path),
      u.setWithCredentials(r.withCredentials),
      u.load(
        t,
        function (h) {
          let p;
          try {
            p = r.parse(h);
          } catch (m) {
            if (a !== void 0) a(m);
            else {
              console.error(m);
              return;
            }
          }
          p.image !== void 0
            ? (l.image = p.image)
            : p.data !== void 0 &&
              ((l.image.width = p.width),
              (l.image.height = p.height),
              (l.image.data = p.data)),
            (l.wrapS = p.wrapS !== void 0 ? p.wrapS : Ki),
            (l.wrapT = p.wrapT !== void 0 ? p.wrapT : Ki),
            (l.magFilter = p.magFilter !== void 0 ? p.magFilter : Kn),
            (l.minFilter = p.minFilter !== void 0 ? p.minFilter : Kn),
            (l.anisotropy = p.anisotropy !== void 0 ? p.anisotropy : 1),
            p.colorSpace !== void 0 && (l.colorSpace = p.colorSpace),
            p.flipY !== void 0 && (l.flipY = p.flipY),
            p.format !== void 0 && (l.format = p.format),
            p.type !== void 0 && (l.type = p.type),
            p.mipmaps !== void 0 &&
              ((l.mipmaps = p.mipmaps), (l.minFilter = Nr)),
            p.mipmapCount === 1 && (l.minFilter = Kn),
            p.generateMipmaps !== void 0 &&
              (l.generateMipmaps = p.generateMipmaps),
            (l.needsUpdate = !0),
            e && e(l, p);
        },
        n,
        a
      ),
      l
    );
  }
}
class xR extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = new Zn(),
      l = new v0(this.manager);
    return (
      l.setCrossOrigin(this.crossOrigin),
      l.setPath(this.path),
      l.load(
        t,
        function (u) {
          (r.image = u), (r.needsUpdate = !0), e !== void 0 && e(r);
        },
        n,
        a
      ),
      r
    );
  }
}
class _u extends Dn {
  constructor(t, e = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Se(t)),
      (this.intensity = e);
  }
  dispose() {}
  copy(t, e) {
    return (
      super.copy(t, e),
      this.color.copy(t.color),
      (this.intensity = t.intensity),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (e.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (e.object.distance = this.distance),
      this.angle !== void 0 && (e.object.angle = this.angle),
      this.decay !== void 0 && (e.object.decay = this.decay),
      this.penumbra !== void 0 && (e.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (e.object.target = this.target.uuid),
      e
    );
  }
}
class _R extends _u {
  constructor(t, e, n) {
    super(t, n),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Dn.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Se(e));
  }
  copy(t, e) {
    return super.copy(t, e), this.groundColor.copy(t.groundColor), this;
  }
}
const I_ = new Xe(),
  tT = new Z(),
  eT = new Z();
class cS {
  constructor(t) {
    (this.camera = t),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Yt(512, 512)),
      (this.mapType = Es),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Xe()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new ap()),
      (this._frameExtents = new Yt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Hn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera,
      n = this.matrix;
    tT.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(tT),
      eT.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(eT),
      e.updateMatrixWorld(),
      I_.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(I_),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(I_);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return (
      (this.camera = t.camera.clone()),
      (this.intensity = t.intensity),
      (this.bias = t.bias),
      (this.radius = t.radius),
      (this.autoUpdate = t.autoUpdate),
      (this.needsUpdate = t.needsUpdate),
      (this.normalBias = t.normalBias),
      (this.blurSamples = t.blurSamples),
      this.mapSize.copy(t.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return (
      this.intensity !== 1 && (t.intensity = this.intensity),
      this.bias !== 0 && (t.bias = this.bias),
      this.normalBias !== 0 && (t.normalBias = this.normalBias),
      this.radius !== 1 && (t.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    );
  }
}
class EN extends cS {
  constructor() {
    super(new Ei(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1),
      (this.aspect = 1);
  }
  updateMatrices(t) {
    const e = this.camera,
      n = Jd * 2 * t.angle * this.focus,
      a = (this.mapSize.width / this.mapSize.height) * this.aspect,
      r = t.distance || e.far;
    (n !== e.fov || a !== e.aspect || r !== e.far) &&
      ((e.fov = n), (e.aspect = a), (e.far = r), e.updateProjectionMatrix()),
      super.updateMatrices(t);
  }
  copy(t) {
    return super.copy(t), (this.focus = t.focus), this;
  }
}
class uS extends _u {
  constructor(t, e, n = 0, a = Math.PI / 3, r = 0, l = 2) {
    super(t, e),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Dn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Dn()),
      (this.distance = n),
      (this.angle = a),
      (this.penumbra = r),
      (this.decay = l),
      (this.map = null),
      (this.shadow = new EN());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(t) {
    this.intensity = t / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.distance = t.distance),
      (this.angle = t.angle),
      (this.penumbra = t.penumbra),
      (this.decay = t.decay),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    );
  }
}
const nT = new Xe(),
  Pm = new Z(),
  P_ = new Z();
class TN extends cS {
  constructor() {
    super(new Ei(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Yt(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Hn(2, 1, 1, 1),
        new Hn(0, 1, 1, 1),
        new Hn(3, 1, 1, 1),
        new Hn(1, 1, 1, 1),
        new Hn(3, 0, 1, 1),
        new Hn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Z(1, 0, 0),
        new Z(-1, 0, 0),
        new Z(0, 0, 1),
        new Z(0, 0, -1),
        new Z(0, 1, 0),
        new Z(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Z(0, 1, 0),
        new Z(0, 1, 0),
        new Z(0, 1, 0),
        new Z(0, 1, 0),
        new Z(0, 0, 1),
        new Z(0, 0, -1),
      ]);
  }
  updateMatrices(t, e = 0) {
    const n = this.camera,
      a = this.matrix,
      r = t.distance || n.far;
    r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
      Pm.setFromMatrixPosition(t.matrixWorld),
      n.position.copy(Pm),
      P_.copy(n.position),
      P_.add(this._cubeDirections[e]),
      n.up.copy(this._cubeUps[e]),
      n.lookAt(P_),
      n.updateMatrixWorld(),
      a.makeTranslation(-Pm.x, -Pm.y, -Pm.z),
      nT.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(nT);
  }
}
class fS extends _u {
  constructor(t, e, n = 0, a = 2) {
    super(t, e),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = a),
      (this.shadow = new TN());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.distance = t.distance),
      (this.decay = t.decay),
      (this.shadow = t.shadow.clone()),
      this
    );
  }
}
class Ir extends kx {
  constructor(t = -1, e = 1, n = 1, a = -1, r = 0.1, l = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = n),
      (this.bottom = a),
      (this.near = r),
      (this.far = l),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      this
    );
  }
  setViewOffset(t, e, n, a, r, l) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = a),
      (this.view.width = r),
      (this.view.height = l),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      a = (this.top + this.bottom) / 2;
    let r = n - t,
      l = n + t,
      u = a + e,
      h = a - e;
    if (this.view !== null && this.view.enabled) {
      const p = (this.right - this.left) / this.view.fullWidth / this.zoom,
        m = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += p * this.view.offsetX),
        (l = r + p * this.view.width),
        (u -= m * this.view.offsetY),
        (h = u - m * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      r,
      l,
      u,
      h,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      e
    );
  }
}
class wN extends cS {
  constructor() {
    super(new Ir(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class hS extends _u {
  constructor(t, e) {
    super(t, e),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Dn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Dn()),
      (this.shadow = new wN());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    );
  }
}
class bR extends _u {
  constructor(t, e) {
    super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class AR extends _u {
  constructor(t, e, n = 10, a = 10) {
    super(t, e),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = n),
      (this.height = a);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(t) {
    this.intensity = t / (this.width * this.height * Math.PI);
  }
  copy(t) {
    return (
      super.copy(t), (this.width = t.width), (this.height = t.height), this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (e.object.width = this.width), (e.object.height = this.height), e;
  }
}
class SR {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let t = 0; t < 9; t++) this.coefficients.push(new Z());
  }
  set(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
    return this;
  }
  zero() {
    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
    return this;
  }
  getAt(t, e) {
    const n = t.x,
      a = t.y,
      r = t.z,
      l = this.coefficients;
    return (
      e.copy(l[0]).multiplyScalar(0.282095),
      e.addScaledVector(l[1], 0.488603 * a),
      e.addScaledVector(l[2], 0.488603 * r),
      e.addScaledVector(l[3], 0.488603 * n),
      e.addScaledVector(l[4], 1.092548 * (n * a)),
      e.addScaledVector(l[5], 1.092548 * (a * r)),
      e.addScaledVector(l[6], 0.315392 * (3 * r * r - 1)),
      e.addScaledVector(l[7], 1.092548 * (n * r)),
      e.addScaledVector(l[8], 0.546274 * (n * n - a * a)),
      e
    );
  }
  getIrradianceAt(t, e) {
    const n = t.x,
      a = t.y,
      r = t.z,
      l = this.coefficients;
    return (
      e.copy(l[0]).multiplyScalar(0.886227),
      e.addScaledVector(l[1], 2 * 0.511664 * a),
      e.addScaledVector(l[2], 2 * 0.511664 * r),
      e.addScaledVector(l[3], 2 * 0.511664 * n),
      e.addScaledVector(l[4], 2 * 0.429043 * n * a),
      e.addScaledVector(l[5], 2 * 0.429043 * a * r),
      e.addScaledVector(l[6], 0.743125 * r * r - 0.247708),
      e.addScaledVector(l[7], 2 * 0.429043 * n * r),
      e.addScaledVector(l[8], 0.429043 * (n * n - a * a)),
      e
    );
  }
  add(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
    return this;
  }
  addScaledSH(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(t.coefficients[n], e);
    return this;
  }
  scale(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
    return this;
  }
  lerp(t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
    return this;
  }
  equals(t) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
    return !0;
  }
  copy(t) {
    return this.set(t.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(t, e = 0) {
    const n = this.coefficients;
    for (let a = 0; a < 9; a++) n[a].fromArray(t, e + a * 3);
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.coefficients;
    for (let a = 0; a < 9; a++) n[a].toArray(t, e + a * 3);
    return t;
  }
  static getBasisAt(t, e) {
    const n = t.x,
      a = t.y,
      r = t.z;
    (e[0] = 0.282095),
      (e[1] = 0.488603 * a),
      (e[2] = 0.488603 * r),
      (e[3] = 0.488603 * n),
      (e[4] = 1.092548 * n * a),
      (e[5] = 1.092548 * a * r),
      (e[6] = 0.315392 * (3 * r * r - 1)),
      (e[7] = 1.092548 * n * r),
      (e[8] = 0.546274 * (n * n - a * a));
  }
}
class MR extends _u {
  constructor(t = new SR(), e = 1) {
    super(void 0, e), (this.isLightProbe = !0), (this.sh = t);
  }
  copy(t) {
    return super.copy(t), this.sh.copy(t.sh), this;
  }
  fromJSON(t) {
    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (e.object.sh = this.sh.toArray()), e;
  }
}
class c1 extends Va {
  constructor(t) {
    super(t), (this.textures = {});
  }
  load(t, e, n, a) {
    const r = this,
      l = new Ga(r.manager);
    l.setPath(r.path),
      l.setRequestHeader(r.requestHeader),
      l.setWithCredentials(r.withCredentials),
      l.load(
        t,
        function (u) {
          try {
            e(r.parse(JSON.parse(u)));
          } catch (h) {
            a ? a(h) : console.error(h), r.manager.itemError(t);
          }
        },
        n,
        a
      );
  }
  parse(t) {
    const e = this.textures;
    function n(r) {
      return (
        e[r] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", r),
        e[r]
      );
    }
    const a = this.createMaterialFromType(t.type);
    if (
      (t.uuid !== void 0 && (a.uuid = t.uuid),
      t.name !== void 0 && (a.name = t.name),
      t.color !== void 0 && a.color !== void 0 && a.color.setHex(t.color),
      t.roughness !== void 0 && (a.roughness = t.roughness),
      t.metalness !== void 0 && (a.metalness = t.metalness),
      t.sheen !== void 0 && (a.sheen = t.sheen),
      t.sheenColor !== void 0 && (a.sheenColor = new Se().setHex(t.sheenColor)),
      t.sheenRoughness !== void 0 && (a.sheenRoughness = t.sheenRoughness),
      t.emissive !== void 0 &&
        a.emissive !== void 0 &&
        a.emissive.setHex(t.emissive),
      t.specular !== void 0 &&
        a.specular !== void 0 &&
        a.specular.setHex(t.specular),
      t.specularIntensity !== void 0 &&
        (a.specularIntensity = t.specularIntensity),
      t.specularColor !== void 0 &&
        a.specularColor !== void 0 &&
        a.specularColor.setHex(t.specularColor),
      t.shininess !== void 0 && (a.shininess = t.shininess),
      t.clearcoat !== void 0 && (a.clearcoat = t.clearcoat),
      t.clearcoatRoughness !== void 0 &&
        (a.clearcoatRoughness = t.clearcoatRoughness),
      t.dispersion !== void 0 && (a.dispersion = t.dispersion),
      t.iridescence !== void 0 && (a.iridescence = t.iridescence),
      t.iridescenceIOR !== void 0 && (a.iridescenceIOR = t.iridescenceIOR),
      t.iridescenceThicknessRange !== void 0 &&
        (a.iridescenceThicknessRange = t.iridescenceThicknessRange),
      t.transmission !== void 0 && (a.transmission = t.transmission),
      t.thickness !== void 0 && (a.thickness = t.thickness),
      t.attenuationDistance !== void 0 &&
        (a.attenuationDistance = t.attenuationDistance),
      t.attenuationColor !== void 0 &&
        a.attenuationColor !== void 0 &&
        a.attenuationColor.setHex(t.attenuationColor),
      t.anisotropy !== void 0 && (a.anisotropy = t.anisotropy),
      t.anisotropyRotation !== void 0 &&
        (a.anisotropyRotation = t.anisotropyRotation),
      t.fog !== void 0 && (a.fog = t.fog),
      t.flatShading !== void 0 && (a.flatShading = t.flatShading),
      t.blending !== void 0 && (a.blending = t.blending),
      t.combine !== void 0 && (a.combine = t.combine),
      t.side !== void 0 && (a.side = t.side),
      t.shadowSide !== void 0 && (a.shadowSide = t.shadowSide),
      t.opacity !== void 0 && (a.opacity = t.opacity),
      t.transparent !== void 0 && (a.transparent = t.transparent),
      t.alphaTest !== void 0 && (a.alphaTest = t.alphaTest),
      t.alphaHash !== void 0 && (a.alphaHash = t.alphaHash),
      t.depthFunc !== void 0 && (a.depthFunc = t.depthFunc),
      t.depthTest !== void 0 && (a.depthTest = t.depthTest),
      t.depthWrite !== void 0 && (a.depthWrite = t.depthWrite),
      t.colorWrite !== void 0 && (a.colorWrite = t.colorWrite),
      t.blendSrc !== void 0 && (a.blendSrc = t.blendSrc),
      t.blendDst !== void 0 && (a.blendDst = t.blendDst),
      t.blendEquation !== void 0 && (a.blendEquation = t.blendEquation),
      t.blendSrcAlpha !== void 0 && (a.blendSrcAlpha = t.blendSrcAlpha),
      t.blendDstAlpha !== void 0 && (a.blendDstAlpha = t.blendDstAlpha),
      t.blendEquationAlpha !== void 0 &&
        (a.blendEquationAlpha = t.blendEquationAlpha),
      t.blendColor !== void 0 &&
        a.blendColor !== void 0 &&
        a.blendColor.setHex(t.blendColor),
      t.blendAlpha !== void 0 && (a.blendAlpha = t.blendAlpha),
      t.stencilWriteMask !== void 0 &&
        (a.stencilWriteMask = t.stencilWriteMask),
      t.stencilFunc !== void 0 && (a.stencilFunc = t.stencilFunc),
      t.stencilRef !== void 0 && (a.stencilRef = t.stencilRef),
      t.stencilFuncMask !== void 0 && (a.stencilFuncMask = t.stencilFuncMask),
      t.stencilFail !== void 0 && (a.stencilFail = t.stencilFail),
      t.stencilZFail !== void 0 && (a.stencilZFail = t.stencilZFail),
      t.stencilZPass !== void 0 && (a.stencilZPass = t.stencilZPass),
      t.stencilWrite !== void 0 && (a.stencilWrite = t.stencilWrite),
      t.wireframe !== void 0 && (a.wireframe = t.wireframe),
      t.wireframeLinewidth !== void 0 &&
        (a.wireframeLinewidth = t.wireframeLinewidth),
      t.wireframeLinecap !== void 0 &&
        (a.wireframeLinecap = t.wireframeLinecap),
      t.wireframeLinejoin !== void 0 &&
        (a.wireframeLinejoin = t.wireframeLinejoin),
      t.rotation !== void 0 && (a.rotation = t.rotation),
      t.linewidth !== void 0 && (a.linewidth = t.linewidth),
      t.dashSize !== void 0 && (a.dashSize = t.dashSize),
      t.gapSize !== void 0 && (a.gapSize = t.gapSize),
      t.scale !== void 0 && (a.scale = t.scale),
      t.polygonOffset !== void 0 && (a.polygonOffset = t.polygonOffset),
      t.polygonOffsetFactor !== void 0 &&
        (a.polygonOffsetFactor = t.polygonOffsetFactor),
      t.polygonOffsetUnits !== void 0 &&
        (a.polygonOffsetUnits = t.polygonOffsetUnits),
      t.dithering !== void 0 && (a.dithering = t.dithering),
      t.alphaToCoverage !== void 0 && (a.alphaToCoverage = t.alphaToCoverage),
      t.premultipliedAlpha !== void 0 &&
        (a.premultipliedAlpha = t.premultipliedAlpha),
      t.forceSinglePass !== void 0 && (a.forceSinglePass = t.forceSinglePass),
      t.visible !== void 0 && (a.visible = t.visible),
      t.toneMapped !== void 0 && (a.toneMapped = t.toneMapped),
      t.userData !== void 0 && (a.userData = t.userData),
      t.vertexColors !== void 0 &&
        (typeof t.vertexColors == "number"
          ? (a.vertexColors = t.vertexColors > 0)
          : (a.vertexColors = t.vertexColors)),
      t.uniforms !== void 0)
    )
      for (const r in t.uniforms) {
        const l = t.uniforms[r];
        switch (((a.uniforms[r] = {}), l.type)) {
          case "t":
            a.uniforms[r].value = n(l.value);
            break;
          case "c":
            a.uniforms[r].value = new Se().setHex(l.value);
            break;
          case "v2":
            a.uniforms[r].value = new Yt().fromArray(l.value);
            break;
          case "v3":
            a.uniforms[r].value = new Z().fromArray(l.value);
            break;
          case "v4":
            a.uniforms[r].value = new Hn().fromArray(l.value);
            break;
          case "m3":
            a.uniforms[r].value = new yn().fromArray(l.value);
            break;
          case "m4":
            a.uniforms[r].value = new Xe().fromArray(l.value);
            break;
          default:
            a.uniforms[r].value = l.value;
        }
      }
    if (
      (t.defines !== void 0 && (a.defines = t.defines),
      t.vertexShader !== void 0 && (a.vertexShader = t.vertexShader),
      t.fragmentShader !== void 0 && (a.fragmentShader = t.fragmentShader),
      t.glslVersion !== void 0 && (a.glslVersion = t.glslVersion),
      t.extensions !== void 0)
    )
      for (const r in t.extensions) a.extensions[r] = t.extensions[r];
    if (
      (t.lights !== void 0 && (a.lights = t.lights),
      t.clipping !== void 0 && (a.clipping = t.clipping),
      t.size !== void 0 && (a.size = t.size),
      t.sizeAttenuation !== void 0 && (a.sizeAttenuation = t.sizeAttenuation),
      t.map !== void 0 && (a.map = n(t.map)),
      t.matcap !== void 0 && (a.matcap = n(t.matcap)),
      t.alphaMap !== void 0 && (a.alphaMap = n(t.alphaMap)),
      t.bumpMap !== void 0 && (a.bumpMap = n(t.bumpMap)),
      t.bumpScale !== void 0 && (a.bumpScale = t.bumpScale),
      t.normalMap !== void 0 && (a.normalMap = n(t.normalMap)),
      t.normalMapType !== void 0 && (a.normalMapType = t.normalMapType),
      t.normalScale !== void 0)
    ) {
      let r = t.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]),
        (a.normalScale = new Yt().fromArray(r));
    }
    return (
      t.displacementMap !== void 0 &&
        (a.displacementMap = n(t.displacementMap)),
      t.displacementScale !== void 0 &&
        (a.displacementScale = t.displacementScale),
      t.displacementBias !== void 0 &&
        (a.displacementBias = t.displacementBias),
      t.roughnessMap !== void 0 && (a.roughnessMap = n(t.roughnessMap)),
      t.metalnessMap !== void 0 && (a.metalnessMap = n(t.metalnessMap)),
      t.emissiveMap !== void 0 && (a.emissiveMap = n(t.emissiveMap)),
      t.emissiveIntensity !== void 0 &&
        (a.emissiveIntensity = t.emissiveIntensity),
      t.specularMap !== void 0 && (a.specularMap = n(t.specularMap)),
      t.specularIntensityMap !== void 0 &&
        (a.specularIntensityMap = n(t.specularIntensityMap)),
      t.specularColorMap !== void 0 &&
        (a.specularColorMap = n(t.specularColorMap)),
      t.envMap !== void 0 && (a.envMap = n(t.envMap)),
      t.envMapRotation !== void 0 &&
        a.envMapRotation.fromArray(t.envMapRotation),
      t.envMapIntensity !== void 0 && (a.envMapIntensity = t.envMapIntensity),
      t.reflectivity !== void 0 && (a.reflectivity = t.reflectivity),
      t.refractionRatio !== void 0 && (a.refractionRatio = t.refractionRatio),
      t.lightMap !== void 0 && (a.lightMap = n(t.lightMap)),
      t.lightMapIntensity !== void 0 &&
        (a.lightMapIntensity = t.lightMapIntensity),
      t.aoMap !== void 0 && (a.aoMap = n(t.aoMap)),
      t.aoMapIntensity !== void 0 && (a.aoMapIntensity = t.aoMapIntensity),
      t.gradientMap !== void 0 && (a.gradientMap = n(t.gradientMap)),
      t.clearcoatMap !== void 0 && (a.clearcoatMap = n(t.clearcoatMap)),
      t.clearcoatRoughnessMap !== void 0 &&
        (a.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
      t.clearcoatNormalMap !== void 0 &&
        (a.clearcoatNormalMap = n(t.clearcoatNormalMap)),
      t.clearcoatNormalScale !== void 0 &&
        (a.clearcoatNormalScale = new Yt().fromArray(t.clearcoatNormalScale)),
      t.iridescenceMap !== void 0 && (a.iridescenceMap = n(t.iridescenceMap)),
      t.iridescenceThicknessMap !== void 0 &&
        (a.iridescenceThicknessMap = n(t.iridescenceThicknessMap)),
      t.transmissionMap !== void 0 &&
        (a.transmissionMap = n(t.transmissionMap)),
      t.thicknessMap !== void 0 && (a.thicknessMap = n(t.thicknessMap)),
      t.anisotropyMap !== void 0 && (a.anisotropyMap = n(t.anisotropyMap)),
      t.sheenColorMap !== void 0 && (a.sheenColorMap = n(t.sheenColorMap)),
      t.sheenRoughnessMap !== void 0 &&
        (a.sheenRoughnessMap = n(t.sheenRoughnessMap)),
      a
    );
  }
  setTextures(t) {
    return (this.textures = t), this;
  }
  createMaterialFromType(t) {
    return c1.createMaterialFromType(t);
  }
  static createMaterialFromType(t) {
    const e = {
      ShadowMaterial: aR,
      SpriteMaterial: XA,
      RawShaderMaterial: sR,
      ShaderMaterial: Xs,
      PointsMaterial: qx,
      MeshPhysicalMaterial: Fr,
      MeshStandardMaterial: V0,
      MeshPhongMaterial: rR,
      MeshToonMaterial: oR,
      MeshNormalMaterial: lR,
      MeshLambertMaterial: cR,
      MeshDepthMaterial: iS,
      MeshDistanceMaterial: aS,
      MeshBasicMaterial: ks,
      MeshMatcapMaterial: uR,
      LineDashedMaterial: fR,
      LineBasicMaterial: is,
      Material: ma,
    };
    return new e[t]();
  }
}
class lu {
  static extractUrlBase(t) {
    const e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.slice(0, e + 1);
  }
  static resolveURL(t, e) {
    return typeof t != "string" || t === ""
      ? ""
      : (/^https?:\/\//i.test(e) &&
          /^\//.test(t) &&
          (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(t) ||
        /^data:.*,.*$/i.test(t) ||
        /^blob:.*$/i.test(t)
          ? t
          : e + t);
  }
}
class ER extends pn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(t) {
    return super.copy(t), (this.instanceCount = t.instanceCount), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.instanceCount = this.instanceCount),
      (t.isInstancedBufferGeometry = !0),
      t
    );
  }
}
class TR extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = this,
      l = new Ga(r.manager);
    l.setPath(r.path),
      l.setRequestHeader(r.requestHeader),
      l.setWithCredentials(r.withCredentials),
      l.load(
        t,
        function (u) {
          try {
            e(r.parse(JSON.parse(u)));
          } catch (h) {
            a ? a(h) : console.error(h), r.manager.itemError(t);
          }
        },
        n,
        a
      );
  }
  parse(t) {
    const e = {},
      n = {};
    function a(_, M) {
      if (e[M] !== void 0) return e[M];
      const E = _.interleavedBuffers[M],
        S = r(_, E.buffer),
        R = Bd(E.type, S),
        B = new L0(R, E.stride);
      return (B.uuid = E.uuid), (e[M] = B), B;
    }
    function r(_, M) {
      if (n[M] !== void 0) return n[M];
      const E = _.arrayBuffers[M],
        S = new Uint32Array(E).buffer;
      return (n[M] = S), S;
    }
    const l = t.isInstancedBufferGeometry ? new ER() : new pn(),
      u = t.data.index;
    if (u !== void 0) {
      const _ = Bd(u.type, u.array);
      l.setIndex(new Gn(_, 1));
    }
    const h = t.data.attributes;
    for (const _ in h) {
      const M = h[_];
      let C;
      if (M.isInterleavedBufferAttribute) {
        const E = a(t.data, M.data);
        C = new hu(E, M.itemSize, M.offset, M.normalized);
      } else {
        const E = Bd(M.type, M.array),
          S = M.isInstancedBufferAttribute ? Zf : Gn;
        C = new S(E, M.itemSize, M.normalized);
      }
      M.name !== void 0 && (C.name = M.name),
        M.usage !== void 0 && C.setUsage(M.usage),
        l.setAttribute(_, C);
    }
    const p = t.data.morphAttributes;
    if (p)
      for (const _ in p) {
        const M = p[_],
          C = [];
        for (let E = 0, S = M.length; E < S; E++) {
          const R = M[E];
          let B;
          if (R.isInterleavedBufferAttribute) {
            const D = a(t.data, R.data);
            B = new hu(D, R.itemSize, R.offset, R.normalized);
          } else {
            const D = Bd(R.type, R.array);
            B = new Gn(D, R.itemSize, R.normalized);
          }
          R.name !== void 0 && (B.name = R.name), C.push(B);
        }
        l.morphAttributes[_] = C;
      }
    t.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const v = t.data.groups || t.data.drawcalls || t.data.offsets;
    if (v !== void 0)
      for (let _ = 0, M = v.length; _ !== M; ++_) {
        const C = v[_];
        l.addGroup(C.start, C.count, C.materialIndex);
      }
    const x = t.data.boundingSphere;
    return (
      x !== void 0 && (l.boundingSphere = new wa().fromJSON(x)),
      t.name && (l.name = t.name),
      t.userData && (l.userData = t.userData),
      l
    );
  }
}
class CN extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = this,
      l = this.path === "" ? lu.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || l;
    const u = new Ga(this.manager);
    u.setPath(this.path),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(this.withCredentials),
      u.load(
        t,
        function (h) {
          let p = null;
          try {
            p = JSON.parse(h);
          } catch (v) {
            a !== void 0 && a(v),
              console.error(
                "THREE:ObjectLoader: Can't parse " + t + ".",
                v.message
              );
            return;
          }
          const m = p.metadata;
          if (
            m === void 0 ||
            m.type === void 0 ||
            m.type.toLowerCase() === "geometry"
          ) {
            a !== void 0 && a(new Error("THREE.ObjectLoader: Can't load " + t)),
              console.error("THREE.ObjectLoader: Can't load " + t);
            return;
          }
          r.parse(p, e);
        },
        n,
        a
      );
  }
  async loadAsync(t, e) {
    const n = this,
      a = this.path === "" ? lu.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || a;
    const r = new Ga(this.manager);
    r.setPath(this.path),
      r.setRequestHeader(this.requestHeader),
      r.setWithCredentials(this.withCredentials);
    const l = await r.loadAsync(t, e),
      u = JSON.parse(l),
      h = u.metadata;
    if (
      h === void 0 ||
      h.type === void 0 ||
      h.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + t);
    return await n.parseAsync(u);
  }
  parse(t, e) {
    const n = this.parseAnimations(t.animations),
      a = this.parseShapes(t.shapes),
      r = this.parseGeometries(t.geometries, a),
      l = this.parseImages(t.images, function () {
        e !== void 0 && e(p);
      }),
      u = this.parseTextures(t.textures, l),
      h = this.parseMaterials(t.materials, u),
      p = this.parseObject(t.object, r, h, u, n),
      m = this.parseSkeletons(t.skeletons, p);
    if ((this.bindSkeletons(p, m), this.bindLightTargets(p), e !== void 0)) {
      let v = !1;
      for (const x in l)
        if (l[x].data instanceof HTMLImageElement) {
          v = !0;
          break;
        }
      v === !1 && e(p);
    }
    return p;
  }
  async parseAsync(t) {
    const e = this.parseAnimations(t.animations),
      n = this.parseShapes(t.shapes),
      a = this.parseGeometries(t.geometries, n),
      r = await this.parseImagesAsync(t.images),
      l = this.parseTextures(t.textures, r),
      u = this.parseMaterials(t.materials, l),
      h = this.parseObject(t.object, a, u, l, e),
      p = this.parseSkeletons(t.skeletons, h);
    return this.bindSkeletons(h, p), this.bindLightTargets(h), h;
  }
  parseShapes(t) {
    const e = {};
    if (t !== void 0)
      for (let n = 0, a = t.length; n < a; n++) {
        const r = new Yf().fromJSON(t[n]);
        e[r.uuid] = r;
      }
    return e;
  }
  parseSkeletons(t, e) {
    const n = {},
      a = {};
    if (
      (e.traverse(function (r) {
        r.isBone && (a[r.uuid] = r);
      }),
      t !== void 0)
    )
      for (let r = 0, l = t.length; r < l; r++) {
        const u = new I0().fromJSON(t[r], a);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(t, e) {
    const n = {};
    if (t !== void 0) {
      const a = new TR();
      for (let r = 0, l = t.length; r < l; r++) {
        let u;
        const h = t[r];
        switch (h.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            u = a.parse(h);
            break;
          default:
            h.type in $E
              ? (u = $E[h.type].fromJSON(h, e))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${h.type}"`
                );
        }
        (u.uuid = h.uuid),
          h.name !== void 0 && (u.name = h.name),
          h.userData !== void 0 && (u.userData = h.userData),
          (n[h.uuid] = u);
      }
    }
    return n;
  }
  parseMaterials(t, e) {
    const n = {},
      a = {};
    if (t !== void 0) {
      const r = new c1();
      r.setTextures(e);
      for (let l = 0, u = t.length; l < u; l++) {
        const h = t[l];
        n[h.uuid] === void 0 && (n[h.uuid] = r.parse(h)),
          (a[h.uuid] = n[h.uuid]);
      }
    }
    return a;
  }
  parseAnimations(t) {
    const e = {};
    if (t !== void 0)
      for (let n = 0; n < t.length; n++) {
        const a = t[n],
          r = th.parse(a);
        e[r.uuid] = r;
      }
    return e;
  }
  parseImages(t, e) {
    const n = this,
      a = {};
    let r;
    function l(h) {
      return (
        n.manager.itemStart(h),
        r.load(
          h,
          function () {
            n.manager.itemEnd(h);
          },
          void 0,
          function () {
            n.manager.itemError(h), n.manager.itemEnd(h);
          }
        )
      );
    }
    function u(h) {
      if (typeof h == "string") {
        const p = h,
          m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.resourcePath + p;
        return l(m);
      } else
        return h.data
          ? { data: Bd(h.type, h.data), width: h.width, height: h.height }
          : null;
    }
    if (t !== void 0 && t.length > 0) {
      const h = new l1(e);
      (r = new v0(h)), r.setCrossOrigin(this.crossOrigin);
      for (let p = 0, m = t.length; p < m; p++) {
        const v = t[p],
          x = v.url;
        if (Array.isArray(x)) {
          const _ = [];
          for (let M = 0, C = x.length; M < C; M++) {
            const E = x[M],
              S = u(E);
            S !== null &&
              (S instanceof HTMLImageElement
                ? _.push(S)
                : _.push(new _o(S.data, S.width, S.height)));
          }
          a[v.uuid] = new ru(_);
        } else {
          const _ = u(v.url);
          a[v.uuid] = new ru(_);
        }
      }
    }
    return a;
  }
  async parseImagesAsync(t) {
    const e = this,
      n = {};
    let a;
    async function r(l) {
      if (typeof l == "string") {
        const u = l,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : e.resourcePath + u;
        return await a.loadAsync(h);
      } else
        return l.data
          ? { data: Bd(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (t !== void 0 && t.length > 0) {
      (a = new v0(this.manager)), a.setCrossOrigin(this.crossOrigin);
      for (let l = 0, u = t.length; l < u; l++) {
        const h = t[l],
          p = h.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, x = p.length; v < x; v++) {
            const _ = p[v],
              M = await r(_);
            M !== null &&
              (M instanceof HTMLImageElement
                ? m.push(M)
                : m.push(new _o(M.data, M.width, M.height)));
          }
          n[h.uuid] = new ru(m);
        } else {
          const m = await r(h.url);
          n[h.uuid] = new ru(m);
        }
      }
    }
    return n;
  }
  parseTextures(t, e) {
    function n(r, l) {
      return typeof r == "number"
        ? r
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            r
          ),
          l[r]);
    }
    const a = {};
    if (t !== void 0)
      for (let r = 0, l = t.length; r < l; r++) {
        const u = t[r];
        u.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', u.uuid),
          e[u.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", u.image);
        const h = e[u.image],
          p = h.data;
        let m;
        Array.isArray(p)
          ? ((m = new O0()), p.length === 6 && (m.needsUpdate = !0))
          : (p && p.data ? (m = new _o()) : (m = new Zn()),
            p && (m.needsUpdate = !0)),
          (m.source = h),
          (m.uuid = u.uuid),
          u.name !== void 0 && (m.name = u.name),
          u.mapping !== void 0 && (m.mapping = n(u.mapping, RN)),
          u.channel !== void 0 && (m.channel = u.channel),
          u.offset !== void 0 && m.offset.fromArray(u.offset),
          u.repeat !== void 0 && m.repeat.fromArray(u.repeat),
          u.center !== void 0 && m.center.fromArray(u.center),
          u.rotation !== void 0 && (m.rotation = u.rotation),
          u.wrap !== void 0 &&
            ((m.wrapS = n(u.wrap[0], iT)), (m.wrapT = n(u.wrap[1], iT))),
          u.format !== void 0 && (m.format = u.format),
          u.internalFormat !== void 0 && (m.internalFormat = u.internalFormat),
          u.type !== void 0 && (m.type = u.type),
          u.colorSpace !== void 0 && (m.colorSpace = u.colorSpace),
          u.minFilter !== void 0 && (m.minFilter = n(u.minFilter, aT)),
          u.magFilter !== void 0 && (m.magFilter = n(u.magFilter, aT)),
          u.anisotropy !== void 0 && (m.anisotropy = u.anisotropy),
          u.flipY !== void 0 && (m.flipY = u.flipY),
          u.generateMipmaps !== void 0 &&
            (m.generateMipmaps = u.generateMipmaps),
          u.premultiplyAlpha !== void 0 &&
            (m.premultiplyAlpha = u.premultiplyAlpha),
          u.unpackAlignment !== void 0 &&
            (m.unpackAlignment = u.unpackAlignment),
          u.compareFunction !== void 0 &&
            (m.compareFunction = u.compareFunction),
          u.userData !== void 0 && (m.userData = u.userData),
          (a[u.uuid] = m);
      }
    return a;
  }
  parseObject(t, e, n, a, r) {
    let l;
    function u(x) {
      return (
        e[x] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", x),
        e[x]
      );
    }
    function h(x) {
      if (x !== void 0) {
        if (Array.isArray(x)) {
          const _ = [];
          for (let M = 0, C = x.length; M < C; M++) {
            const E = x[M];
            n[E] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", E),
              _.push(n[E]);
          }
          return _;
        }
        return (
          n[x] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", x),
          n[x]
        );
      }
    }
    function p(x) {
      return (
        a[x] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", x),
        a[x]
      );
    }
    let m, v;
    switch (t.type) {
      case "Scene":
        (l = new N0()),
          t.background !== void 0 &&
            (Number.isInteger(t.background)
              ? (l.background = new Se(t.background))
              : (l.background = p(t.background))),
          t.environment !== void 0 && (l.environment = p(t.environment)),
          t.fog !== void 0 &&
            (t.fog.type === "Fog"
              ? (l.fog = new Xx(t.fog.color, t.fog.near, t.fog.far))
              : t.fog.type === "FogExp2" &&
                (l.fog = new jx(t.fog.color, t.fog.density)),
            t.fog.name !== "" && (l.fog.name = t.fog.name)),
          t.backgroundBlurriness !== void 0 &&
            (l.backgroundBlurriness = t.backgroundBlurriness),
          t.backgroundIntensity !== void 0 &&
            (l.backgroundIntensity = t.backgroundIntensity),
          t.backgroundRotation !== void 0 &&
            l.backgroundRotation.fromArray(t.backgroundRotation),
          t.environmentIntensity !== void 0 &&
            (l.environmentIntensity = t.environmentIntensity),
          t.environmentRotation !== void 0 &&
            l.environmentRotation.fromArray(t.environmentRotation);
        break;
      case "PerspectiveCamera":
        (l = new Ei(t.fov, t.aspect, t.near, t.far)),
          t.focus !== void 0 && (l.focus = t.focus),
          t.zoom !== void 0 && (l.zoom = t.zoom),
          t.filmGauge !== void 0 && (l.filmGauge = t.filmGauge),
          t.filmOffset !== void 0 && (l.filmOffset = t.filmOffset),
          t.view !== void 0 && (l.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        (l = new Ir(t.left, t.right, t.top, t.bottom, t.near, t.far)),
          t.zoom !== void 0 && (l.zoom = t.zoom),
          t.view !== void 0 && (l.view = Object.assign({}, t.view));
        break;
      case "AmbientLight":
        l = new bR(t.color, t.intensity);
        break;
      case "DirectionalLight":
        (l = new hS(t.color, t.intensity)), (l.target = t.target || "");
        break;
      case "PointLight":
        l = new fS(t.color, t.intensity, t.distance, t.decay);
        break;
      case "RectAreaLight":
        l = new AR(t.color, t.intensity, t.width, t.height);
        break;
      case "SpotLight":
        (l = new uS(
          t.color,
          t.intensity,
          t.distance,
          t.angle,
          t.penumbra,
          t.decay
        )),
          (l.target = t.target || "");
        break;
      case "HemisphereLight":
        l = new _R(t.color, t.groundColor, t.intensity);
        break;
      case "LightProbe":
        l = new MR().fromJSON(t);
        break;
      case "SkinnedMesh":
        (m = u(t.geometry)),
          (v = h(t.material)),
          (l = new WA(m, v)),
          t.bindMode !== void 0 && (l.bindMode = t.bindMode),
          t.bindMatrix !== void 0 && l.bindMatrix.fromArray(t.bindMatrix),
          t.skeleton !== void 0 && (l.skeleton = t.skeleton);
        break;
      case "Mesh":
        (m = u(t.geometry)), (v = h(t.material)), (l = new Ti(m, v));
        break;
      case "InstancedMesh":
        (m = u(t.geometry)), (v = h(t.material));
        const x = t.count,
          _ = t.instanceMatrix,
          M = t.instanceColor;
        (l = new YA(m, v, x)),
          (l.instanceMatrix = new Zf(new Float32Array(_.array), 16)),
          M !== void 0 &&
            (l.instanceColor = new Zf(new Float32Array(M.array), M.itemSize));
        break;
      case "BatchedMesh":
        (m = u(t.geometry)),
          (v = h(t.material)),
          (l = new XC(
            t.maxInstanceCount,
            t.maxVertexCount,
            t.maxIndexCount,
            v
          )),
          (l.geometry = m),
          (l.perObjectFrustumCulled = t.perObjectFrustumCulled),
          (l.sortObjects = t.sortObjects),
          (l._drawRanges = t.drawRanges),
          (l._reservedRanges = t.reservedRanges),
          (l._geometryInfo = t.geometryInfo.map((C) => {
            let E = null,
              S = null;
            return (
              C.boundingBox !== void 0 &&
                (E = new Ha().fromJSON(C.boundingBox)),
              C.boundingSphere !== void 0 &&
                (S = new wa().fromJSON(C.boundingSphere)),
              { ...C, boundingBox: E, boundingSphere: S }
            );
          })),
          (l._instanceInfo = t.instanceInfo),
          (l._availableInstanceIds = t._availableInstanceIds),
          (l._availableGeometryIds = t._availableGeometryIds),
          (l._nextIndexStart = t.nextIndexStart),
          (l._nextVertexStart = t.nextVertexStart),
          (l._geometryCount = t.geometryCount),
          (l._maxInstanceCount = t.maxInstanceCount),
          (l._maxVertexCount = t.maxVertexCount),
          (l._maxIndexCount = t.maxIndexCount),
          (l._geometryInitialized = t.geometryInitialized),
          (l._matricesTexture = p(t.matricesTexture.uuid)),
          (l._indirectTexture = p(t.indirectTexture.uuid)),
          t.colorsTexture !== void 0 &&
            (l._colorsTexture = p(t.colorsTexture.uuid)),
          t.boundingSphere !== void 0 &&
            (l.boundingSphere = new wa().fromJSON(t.boundingSphere)),
          t.boundingBox !== void 0 &&
            (l.boundingBox = new Ha().fromJSON(t.boundingBox));
        break;
      case "LOD":
        l = new jC();
        break;
      case "Line":
        l = new tc(u(t.geometry), h(t.material));
        break;
      case "LineLoop":
        l = new qA(u(t.geometry), h(t.material));
        break;
      case "LineSegments":
        l = new Ao(u(t.geometry), h(t.material));
        break;
      case "PointCloud":
      case "Points":
        l = new KA(u(t.geometry), h(t.material));
        break;
      case "Sprite":
        l = new kC(h(t.material));
        break;
      case "Group":
        l = new Jl();
        break;
      case "Bone":
        l = new Wx();
        break;
      default:
        l = new Dn();
    }
    if (
      ((l.uuid = t.uuid),
      t.name !== void 0 && (l.name = t.name),
      t.matrix !== void 0
        ? (l.matrix.fromArray(t.matrix),
          t.matrixAutoUpdate !== void 0 &&
            (l.matrixAutoUpdate = t.matrixAutoUpdate),
          l.matrixAutoUpdate &&
            l.matrix.decompose(l.position, l.quaternion, l.scale))
        : (t.position !== void 0 && l.position.fromArray(t.position),
          t.rotation !== void 0 && l.rotation.fromArray(t.rotation),
          t.quaternion !== void 0 && l.quaternion.fromArray(t.quaternion),
          t.scale !== void 0 && l.scale.fromArray(t.scale)),
      t.up !== void 0 && l.up.fromArray(t.up),
      t.castShadow !== void 0 && (l.castShadow = t.castShadow),
      t.receiveShadow !== void 0 && (l.receiveShadow = t.receiveShadow),
      t.shadow &&
        (t.shadow.intensity !== void 0 &&
          (l.shadow.intensity = t.shadow.intensity),
        t.shadow.bias !== void 0 && (l.shadow.bias = t.shadow.bias),
        t.shadow.normalBias !== void 0 &&
          (l.shadow.normalBias = t.shadow.normalBias),
        t.shadow.radius !== void 0 && (l.shadow.radius = t.shadow.radius),
        t.shadow.mapSize !== void 0 &&
          l.shadow.mapSize.fromArray(t.shadow.mapSize),
        t.shadow.camera !== void 0 &&
          (l.shadow.camera = this.parseObject(t.shadow.camera))),
      t.visible !== void 0 && (l.visible = t.visible),
      t.frustumCulled !== void 0 && (l.frustumCulled = t.frustumCulled),
      t.renderOrder !== void 0 && (l.renderOrder = t.renderOrder),
      t.userData !== void 0 && (l.userData = t.userData),
      t.layers !== void 0 && (l.layers.mask = t.layers),
      t.children !== void 0)
    ) {
      const x = t.children;
      for (let _ = 0; _ < x.length; _++)
        l.add(this.parseObject(x[_], e, n, a, r));
    }
    if (t.animations !== void 0) {
      const x = t.animations;
      for (let _ = 0; _ < x.length; _++) {
        const M = x[_];
        l.animations.push(r[M]);
      }
    }
    if (t.type === "LOD") {
      t.autoUpdate !== void 0 && (l.autoUpdate = t.autoUpdate);
      const x = t.levels;
      for (let _ = 0; _ < x.length; _++) {
        const M = x[_],
          C = l.getObjectByProperty("uuid", M.object);
        C !== void 0 && l.addLevel(C, M.distance, M.hysteresis);
      }
    }
    return l;
  }
  bindSkeletons(t, e) {
    Object.keys(e).length !== 0 &&
      t.traverse(function (n) {
        if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
          const a = e[n.skeleton];
          a === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                n.skeleton
              )
            : n.bind(a, n.bindMatrix);
        }
      });
  }
  bindLightTargets(t) {
    t.traverse(function (e) {
      if (e.isDirectionalLight || e.isSpotLight) {
        const n = e.target,
          a = t.getObjectByProperty("uuid", n);
        a !== void 0 ? (e.target = a) : (e.target = new Dn());
      }
    });
  }
}
const RN = {
    UVMapping: cu,
    CubeReflectionMapping: dl,
    CubeRefractionMapping: uu,
    EquirectangularReflectionMapping: Vd,
    EquirectangularRefractionMapping: l0,
    CubeUVReflectionMapping: ip,
  },
  iT = {
    RepeatWrapping: fu,
    ClampToEdgeWrapping: Ki,
    MirroredRepeatWrapping: kd,
  },
  aT = {
    NearestFilter: Ta,
    NearestMipmapNearestFilter: Ox,
    NearestMipmapLinearFilter: If,
    LinearFilter: Kn,
    LinearMipmapNearestFilter: Pd,
    LinearMipmapLinearFilter: Nr,
  },
  z_ = new WeakMap();
class wR extends Va {
  constructor(t) {
    super(t),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(t) {
    return (this.options = t), this;
  }
  load(t, e, n, a) {
    t === void 0 && (t = ""),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      l = Zl.get(t);
    if (l !== void 0) {
      if ((r.manager.itemStart(t), l.then)) {
        l.then((p) => {
          if (z_.has(l) === !0)
            a && a(z_.get(l)), r.manager.itemError(t), r.manager.itemEnd(t);
          else return e && e(p), r.manager.itemEnd(t), p;
        });
        return;
      }
      return (
        setTimeout(function () {
          e && e(l), r.manager.itemEnd(t);
        }, 0),
        l
      );
    }
    const u = {};
    (u.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (u.headers = this.requestHeader);
    const h = fetch(t, u)
      .then(function (p) {
        return p.blob();
      })
      .then(function (p) {
        return createImageBitmap(
          p,
          Object.assign(r.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (p) {
        return Zl.add(t, p), e && e(p), r.manager.itemEnd(t), p;
      })
      .catch(function (p) {
        a && a(p),
          z_.set(h, p),
          Zl.remove(t),
          r.manager.itemError(t),
          r.manager.itemEnd(t);
      });
    Zl.add(t, h), r.manager.itemStart(t);
  }
}
let sy;
class dS {
  static getContext() {
    return (
      sy === void 0 &&
        (sy = new (window.AudioContext || window.webkitAudioContext)()),
      sy
    );
  }
  static setContext(t) {
    sy = t;
  }
}
class BN extends Va {
  constructor(t) {
    super(t);
  }
  load(t, e, n, a) {
    const r = this,
      l = new Ga(this.manager);
    l.setResponseType("arraybuffer"),
      l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        t,
        function (h) {
          try {
            const p = h.slice(0);
            dS.getContext()
              .decodeAudioData(p, function (v) {
                e(v);
              })
              .catch(u);
          } catch (p) {
            u(p);
          }
        },
        n,
        a
      );
    function u(h) {
      a ? a(h) : console.error(h), r.manager.itemError(t);
    }
  }
}
const sT = new Xe(),
  rT = new Xe(),
  _f = new Xe();
class DN {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Ei()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Ei()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(t) {
    const e = this._cache;
    if (
      e.focus !== t.focus ||
      e.fov !== t.fov ||
      e.aspect !== t.aspect * this.aspect ||
      e.near !== t.near ||
      e.far !== t.far ||
      e.zoom !== t.zoom ||
      e.eyeSep !== this.eyeSep
    ) {
      (e.focus = t.focus),
        (e.fov = t.fov),
        (e.aspect = t.aspect * this.aspect),
        (e.near = t.near),
        (e.far = t.far),
        (e.zoom = t.zoom),
        (e.eyeSep = this.eyeSep),
        _f.copy(t.projectionMatrix);
      const a = e.eyeSep / 2,
        r = (a * e.near) / e.focus,
        l = (e.near * Math.tan(Wf * e.fov * 0.5)) / e.zoom;
      let u, h;
      (rT.elements[12] = -a),
        (sT.elements[12] = a),
        (u = -l * e.aspect + r),
        (h = l * e.aspect + r),
        (_f.elements[0] = (2 * e.near) / (h - u)),
        (_f.elements[8] = (h + u) / (h - u)),
        this.cameraL.projectionMatrix.copy(_f),
        (u = -l * e.aspect - r),
        (h = l * e.aspect - r),
        (_f.elements[0] = (2 * e.near) / (h - u)),
        (_f.elements[8] = (h + u) / (h - u)),
        this.cameraR.projectionMatrix.copy(_f);
    }
    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(rT),
      this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(sT);
  }
}
class CR extends Ei {
  constructor(t = []) {
    super(),
      (this.isArrayCamera = !0),
      (this.isMultiViewCamera = !1),
      (this.cameras = t);
  }
}
class pS {
  constructor(t = !0) {
    (this.autoStart = t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = oT()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const e = oT();
      (t = (e - this.oldTime) / 1e3),
        (this.oldTime = e),
        (this.elapsedTime += t);
    }
    return t;
  }
}
function oT() {
  return performance.now();
}
const bf = new Z(),
  F_ = new pa(),
  UN = new Z(),
  Af = new Z(),
  Sf = new Z();
class ON extends Dn {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = dS.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new pS());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(t) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = t),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t);
    const e = this.context.listener;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(bf, F_, UN),
      Af.set(0, 0, -1).applyQuaternion(F_),
      Sf.set(0, 1, 0).applyQuaternion(F_),
      e.positionX)
    ) {
      const n = this.context.currentTime + this.timeDelta;
      e.positionX.linearRampToValueAtTime(bf.x, n),
        e.positionY.linearRampToValueAtTime(bf.y, n),
        e.positionZ.linearRampToValueAtTime(bf.z, n),
        e.forwardX.linearRampToValueAtTime(Af.x, n),
        e.forwardY.linearRampToValueAtTime(Af.y, n),
        e.forwardZ.linearRampToValueAtTime(Af.z, n),
        e.upX.linearRampToValueAtTime(Sf.x, n),
        e.upY.linearRampToValueAtTime(Sf.y, n),
        e.upZ.linearRampToValueAtTime(Sf.z, n);
    } else
      e.setPosition(bf.x, bf.y, bf.z),
        e.setOrientation(Af.x, Af.y, Af.z, Sf.x, Sf.y, Sf.z);
  }
}
class RR extends Dn {
  constructor(t) {
    super(),
      (this.type = "Audio"),
      (this.listener = t),
      (this.context = t.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(t.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = t),
      this.connect(),
      this
    );
  }
  setMediaElementSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(t)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(t)),
      this.connect(),
      this
    );
  }
  setBuffer(t) {
    return (
      (this.buffer = t),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(t = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + t;
    const e = this.context.createBufferSource();
    return (
      (e.buffer = this.buffer),
      (e.loop = this.loop),
      (e.loopStart = this.loopStart),
      (e.loopEnd = this.loopEnd),
      (e.onended = this.onEnded.bind(this)),
      e.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = e),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(t = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + t),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].connect(this.filters[t]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(t) {
    return (
      t || (t = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = t.slice()), this.connect())
        : (this.filters = t.slice()),
      this
    );
  }
  setDetune(t) {
    return (
      (this.detune = t),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(t) {
    return this.setFilters(t ? [t] : []);
  }
  setPlaybackRate(t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = t),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    (this.isPlaying = !1), (this._progress = 0);
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = t),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(t) {
    return (this.loopStart = t), this;
  }
  setLoopEnd(t) {
    return (this.loopEnd = t), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    );
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.sourceType !== "buffer"
        ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
          this)
        : ((this.autoplay = t.autoplay),
          (this.buffer = t.buffer),
          (this.detune = t.detune),
          (this.loop = t.loop),
          (this.loopStart = t.loopStart),
          (this.loopEnd = t.loopEnd),
          (this.offset = t.offset),
          (this.duration = t.duration),
          (this.playbackRate = t.playbackRate),
          (this.hasPlaybackControl = t.hasPlaybackControl),
          (this.sourceType = t.sourceType),
          (this.filters = t.filters.slice()),
          this)
    );
  }
  clone(t) {
    return new this.constructor(this.listener).copy(this, t);
  }
}
const Mf = new Z(),
  lT = new pa(),
  NN = new Z(),
  Ef = new Z();
class LN extends RR {
  constructor(t) {
    super(t),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(t) {
    return (this.panner.refDistance = t), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(t) {
    return (this.panner.rolloffFactor = t), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(t) {
    return (this.panner.distanceModel = t), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(t) {
    return (this.panner.maxDistance = t), this;
  }
  setDirectionalCone(t, e, n) {
    return (
      (this.panner.coneInnerAngle = t),
      (this.panner.coneOuterAngle = e),
      (this.panner.coneOuterGain = n),
      this
    );
  }
  updateMatrixWorld(t) {
    if (
      (super.updateMatrixWorld(t),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Mf, lT, NN), Ef.set(0, 0, 1).applyQuaternion(lT);
    const e = this.panner;
    if (e.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      e.positionX.linearRampToValueAtTime(Mf.x, n),
        e.positionY.linearRampToValueAtTime(Mf.y, n),
        e.positionZ.linearRampToValueAtTime(Mf.z, n),
        e.orientationX.linearRampToValueAtTime(Ef.x, n),
        e.orientationY.linearRampToValueAtTime(Ef.y, n),
        e.orientationZ.linearRampToValueAtTime(Ef.z, n);
    } else e.setPosition(Mf.x, Mf.y, Mf.z), e.setOrientation(Ef.x, Ef.y, Ef.z);
  }
}
class IN {
  constructor(t, e = 2048) {
    (this.analyser = t.context.createAnalyser()),
      (this.analyser.fftSize = e),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      t.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let t = 0;
    const e = this.getFrequencyData();
    for (let n = 0; n < e.length; n++) t += e[n];
    return t / e.length;
  }
}
class BR {
  constructor(t, e, n) {
    (this.binding = t), (this.valueSize = n);
    let a, r, l;
    switch (e) {
      case "quaternion":
        (a = this._slerp),
          (r = this._slerpAdditive),
          (l = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (a = this._select),
          (r = this._select),
          (l = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5));
        break;
      default:
        (a = this._lerp),
          (r = this._lerpAdditive),
          (l = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5));
    }
    (this._mixBufferRegion = a),
      (this._mixBufferRegionAdditive = r),
      (this._setIdentity = l),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(t, e) {
    const n = this.buffer,
      a = this.valueSize,
      r = t * a + a;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let u = 0; u !== a; ++u) n[r + u] = n[u];
      l = e;
    } else {
      l += e;
      const u = e / l;
      this._mixBufferRegion(n, r, 0, u, a);
    }
    this.cumulativeWeight = l;
  }
  accumulateAdditive(t) {
    const e = this.buffer,
      n = this.valueSize,
      a = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(e, a, 0, t, n),
      (this.cumulativeWeightAdditive += t);
  }
  apply(t) {
    const e = this.valueSize,
      n = this.buffer,
      a = t * e + e,
      r = this.cumulativeWeight,
      l = this.cumulativeWeightAdditive,
      u = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)
    ) {
      const h = e * this._origIndex;
      this._mixBufferRegion(n, a, h, 1 - r, e);
    }
    l > 0 && this._mixBufferRegionAdditive(n, a, this._addIndex * e, 1, e);
    for (let h = e, p = e + e; h !== p; ++h)
      if (n[h] !== n[h + e]) {
        u.setValue(n, a);
        break;
      }
  }
  saveOriginalState() {
    const t = this.binding,
      e = this.buffer,
      n = this.valueSize,
      a = n * this._origIndex;
    t.getValue(e, a);
    for (let r = n, l = a; r !== l; ++r) e[r] = e[a + (r % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const t = this.valueSize * 3;
    this.binding.setValue(this.buffer, t);
  }
  _setAdditiveIdentityNumeric() {
    const t = this._addIndex * this.valueSize,
      e = t + this.valueSize;
    for (let n = t; n < e; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const t = this._origIndex * this.valueSize,
      e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  }
  _select(t, e, n, a, r) {
    if (a >= 0.5) for (let l = 0; l !== r; ++l) t[e + l] = t[n + l];
  }
  _slerp(t, e, n, a) {
    pa.slerpFlat(t, e, t, e, t, n, a);
  }
  _slerpAdditive(t, e, n, a, r) {
    const l = this._workIndex * r;
    pa.multiplyQuaternionsFlat(t, l, t, e, t, n),
      pa.slerpFlat(t, e, t, e, t, l, a);
  }
  _lerp(t, e, n, a, r) {
    const l = 1 - a;
    for (let u = 0; u !== r; ++u) {
      const h = e + u;
      t[h] = t[h] * l + t[n + u] * a;
    }
  }
  _lerpAdditive(t, e, n, a, r) {
    for (let l = 0; l !== r; ++l) {
      const u = e + l;
      t[u] = t[u] + t[n + l] * a;
    }
  }
}
const mS = "\\[\\]\\.:\\/",
  PN = new RegExp("[" + mS + "]", "g"),
  gS = "[^" + mS + "]",
  zN = "[^" + mS.replace("\\.", "") + "]",
  FN = /((?:WC+[\/:])*)/.source.replace("WC", gS),
  HN = /(WCOD+)?/.source.replace("WCOD", zN),
  GN = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", gS),
  VN = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", gS),
  kN = new RegExp("^" + FN + HN + GN + VN + "$"),
  jN = ["material", "materials", "bones", "map"];
class XN {
  constructor(t, e, n) {
    const a = n || Fn.parseTrackName(e);
    (this._targetGroup = t), (this._bindings = t.subscribe_(e, a));
  }
  getValue(t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      a = this._bindings[n];
    a !== void 0 && a.getValue(t, e);
  }
  setValue(t, e) {
    const n = this._bindings;
    for (let a = this._targetGroup.nCachedObjects_, r = n.length; a !== r; ++a)
      n[a].setValue(t, e);
  }
  bind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind();
  }
  unbind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind();
  }
}
class Fn {
  constructor(t, e, n) {
    (this.path = e),
      (this.parsedPath = n || Fn.parseTrackName(e)),
      (this.node = Fn.findNode(t, this.parsedPath.nodeName)),
      (this.rootNode = t),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(t, e, n) {
    return t && t.isAnimationObjectGroup
      ? new Fn.Composite(t, e, n)
      : new Fn(t, e, n);
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, "_").replace(PN, "");
  }
  static parseTrackName(t) {
    const e = kN.exec(t);
    if (e === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6],
      },
      a = n.nodeName && n.nodeName.lastIndexOf(".");
    if (a !== void 0 && a !== -1) {
      const r = n.nodeName.substring(a + 1);
      jN.indexOf(r) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, a)), (n.objectName = r));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + t
      );
    return n;
  }
  static findNode(t, e) {
    if (
      e === void 0 ||
      e === "" ||
      e === "." ||
      e === -1 ||
      e === t.name ||
      e === t.uuid
    )
      return t;
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (n !== void 0) return n;
    }
    if (t.children) {
      const n = function (r) {
          for (let l = 0; l < r.length; l++) {
            const u = r[l];
            if (u.name === e || u.uuid === e) return u;
            const h = n(u.children);
            if (h) return h;
          }
          return null;
        },
        a = n(t.children);
      if (a) return a;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName];
  }
  _getValue_array(t, e) {
    const n = this.resolvedProperty;
    for (let a = 0, r = n.length; a !== r; ++a) t[e++] = n[a];
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e);
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e];
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    (this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    (this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(t, e) {
    const n = this.resolvedProperty;
    for (let a = 0, r = n.length; a !== r; ++a) n[a] = t[e++];
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const n = this.resolvedProperty;
    for (let a = 0, r = n.length; a !== r; ++a) n[a] = t[e++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const n = this.resolvedProperty;
    for (let a = 0, r = n.length; a !== r; ++a) n[a] = t[e++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e];
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    (this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    (this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e);
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e);
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e);
  }
  bind() {
    let t = this.node;
    const e = this.parsedPath,
      n = e.objectName,
      a = e.propertyName;
    let r = e.propertyIndex;
    if (
      (t || ((t = Fn.findNode(this.rootNode, e.nodeName)), (this.node = t)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !t)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (n) {
      let p = e.objectIndex;
      switch (n) {
        case "materials":
          if (!t.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!t.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          t = t.skeleton.bones;
          for (let m = 0; m < t.length; m++)
            if (t[m].name === p) {
              p = m;
              break;
            }
          break;
        case "map":
          if ("map" in t) {
            t = t.map;
            break;
          }
          if (!t.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!t.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          t = t.material.map;
          break;
        default:
          if (t[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          t = t[n];
      }
      if (p !== void 0) {
        if (t[p] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            t
          );
          return;
        }
        t = t[p];
      }
    }
    const l = t[a];
    if (l === void 0) {
      const p = e.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          p +
          "." +
          a +
          " but it wasn't found.",
        t
      );
      return;
    }
    let u = this.Versioning.None;
    (this.targetObject = t),
      t.isMaterial === !0
        ? (u = this.Versioning.NeedsUpdate)
        : t.isObject3D === !0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    let h = this.BindingType.Direct;
    if (r !== void 0) {
      if (a === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!t.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        t.morphTargetDictionary[r] !== void 0 &&
          (r = t.morphTargetDictionary[r]);
      }
      (h = this.BindingType.ArrayElement),
        (this.resolvedProperty = l),
        (this.propertyIndex = r);
    } else
      l.fromArray !== void 0 && l.toArray !== void 0
        ? ((h = this.BindingType.HasFromToArray), (this.resolvedProperty = l))
        : Array.isArray(l)
        ? ((h = this.BindingType.EntireArray), (this.resolvedProperty = l))
        : (this.propertyName = a);
    (this.getValue = this.GetterByBindingType[h]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[h][u]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Fn.Composite = XN;
Fn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Fn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Fn.prototype.GetterByBindingType = [
  Fn.prototype._getValue_direct,
  Fn.prototype._getValue_array,
  Fn.prototype._getValue_arrayElement,
  Fn.prototype._getValue_toArray,
];
Fn.prototype.SetterByBindingTypeAndVersioning = [
  [
    Fn.prototype._setValue_direct,
    Fn.prototype._setValue_direct_setNeedsUpdate,
    Fn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Fn.prototype._setValue_array,
    Fn.prototype._setValue_array_setNeedsUpdate,
    Fn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Fn.prototype._setValue_arrayElement,
    Fn.prototype._setValue_arrayElement_setNeedsUpdate,
    Fn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Fn.prototype._setValue_fromArray,
    Fn.prototype._setValue_fromArray_setNeedsUpdate,
    Fn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class WN {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = lr()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const t = {};
    this._indicesByUUID = t;
    for (let n = 0, a = arguments.length; n !== a; ++n)
      t[arguments[n].uuid] = n;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const e = this;
    this.stats = {
      objects: {
        get total() {
          return e._objects.length;
        },
        get inUse() {
          return this.total - e.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return e._bindings.length;
      },
    };
  }
  add() {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._paths,
      a = this._parsedPaths,
      r = this._bindings,
      l = r.length;
    let u,
      h = t.length,
      p = this.nCachedObjects_;
    for (let m = 0, v = arguments.length; m !== v; ++m) {
      const x = arguments[m],
        _ = x.uuid;
      let M = e[_];
      if (M === void 0) {
        (M = h++), (e[_] = M), t.push(x);
        for (let C = 0, E = l; C !== E; ++C) r[C].push(new Fn(x, n[C], a[C]));
      } else if (M < p) {
        u = t[M];
        const C = --p,
          E = t[C];
        (e[E.uuid] = M), (t[M] = E), (e[_] = C), (t[C] = x);
        for (let S = 0, R = l; S !== R; ++S) {
          const B = r[S],
            D = B[C];
          let I = B[M];
          (B[M] = D), I === void 0 && (I = new Fn(x, n[S], a[S])), (B[C] = I);
        }
      } else
        t[M] !== u &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = p;
  }
  remove() {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._bindings,
      a = n.length;
    let r = this.nCachedObjects_;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const h = arguments[l],
        p = h.uuid,
        m = e[p];
      if (m !== void 0 && m >= r) {
        const v = r++,
          x = t[v];
        (e[x.uuid] = m), (t[m] = x), (e[p] = v), (t[v] = h);
        for (let _ = 0, M = a; _ !== M; ++_) {
          const C = n[_],
            E = C[v],
            S = C[m];
          (C[m] = E), (C[v] = S);
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  uncache() {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._bindings,
      a = n.length;
    let r = this.nCachedObjects_,
      l = t.length;
    for (let u = 0, h = arguments.length; u !== h; ++u) {
      const p = arguments[u],
        m = p.uuid,
        v = e[m];
      if (v !== void 0)
        if ((delete e[m], v < r)) {
          const x = --r,
            _ = t[x],
            M = --l,
            C = t[M];
          (e[_.uuid] = v), (t[v] = _), (e[C.uuid] = x), (t[x] = C), t.pop();
          for (let E = 0, S = a; E !== S; ++E) {
            const R = n[E],
              B = R[x],
              D = R[M];
            (R[v] = B), (R[x] = D), R.pop();
          }
        } else {
          const x = --l,
            _ = t[x];
          x > 0 && (e[_.uuid] = v), (t[v] = _), t.pop();
          for (let M = 0, C = a; M !== C; ++M) {
            const E = n[M];
            (E[v] = E[x]), E.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  subscribe_(t, e) {
    const n = this._bindingsIndicesByPath;
    let a = n[t];
    const r = this._bindings;
    if (a !== void 0) return r[a];
    const l = this._paths,
      u = this._parsedPaths,
      h = this._objects,
      p = h.length,
      m = this.nCachedObjects_,
      v = new Array(p);
    (a = r.length), (n[t] = a), l.push(t), u.push(e), r.push(v);
    for (let x = m, _ = h.length; x !== _; ++x) {
      const M = h[x];
      v[x] = new Fn(M, t, e);
    }
    return v;
  }
  unsubscribe_(t) {
    const e = this._bindingsIndicesByPath,
      n = e[t];
    if (n !== void 0) {
      const a = this._paths,
        r = this._parsedPaths,
        l = this._bindings,
        u = l.length - 1,
        h = l[u],
        p = t[u];
      (e[p] = n),
        (l[n] = h),
        l.pop(),
        (r[n] = r[u]),
        r.pop(),
        (a[n] = a[u]),
        a.pop();
    }
  }
}
class DR {
  constructor(t, e, n = null, a = e.blendMode) {
    (this._mixer = t),
      (this._clip = e),
      (this._localRoot = n),
      (this.blendMode = a);
    const r = e.tracks,
      l = r.length,
      u = new Array(l),
      h = { endingStart: Pf, endingEnd: Pf };
    for (let p = 0; p !== l; ++p) {
      const m = r[p].createInterpolant(null);
      (u[p] = m), (m.settings = h);
    }
    (this._interpolantSettings = h),
      (this._interpolants = u),
      (this._propertyBindings = new Array(l)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = IA),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(t) {
    return (this._startTime = t), this;
  }
  setLoop(t, e) {
    return (this.loop = t), (this.repetitions = e), this;
  }
  setEffectiveWeight(t) {
    return (
      (this.weight = t),
      (this._effectiveWeight = this.enabled ? t : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(t) {
    return this._scheduleFading(t, 0, 1);
  }
  fadeOut(t) {
    return this._scheduleFading(t, 1, 0);
  }
  crossFadeFrom(t, e, n = !1) {
    if ((t.fadeOut(e), this.fadeIn(e), n === !0)) {
      const a = this._clip.duration,
        r = t._clip.duration,
        l = r / a,
        u = a / r;
      t.warp(1, l, e), this.warp(u, 1, e);
    }
    return this;
  }
  crossFadeTo(t, e, n = !1) {
    return t.crossFadeFrom(this, e, n);
  }
  stopFading() {
    const t = this._weightInterpolant;
    return (
      t !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  setEffectiveTimeScale(t) {
    return (
      (this.timeScale = t),
      (this._effectiveTimeScale = this.paused ? 0 : t),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(t) {
    return (this.timeScale = this._clip.duration / t), this.stopWarping();
  }
  syncWith(t) {
    return (
      (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
    );
  }
  halt(t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  }
  warp(t, e, n) {
    const a = this._mixer,
      r = a.time,
      l = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null &&
      ((u = a._lendControlInterpolant()), (this._timeScaleInterpolant = u));
    const h = u.parameterPositions,
      p = u.sampleValues;
    return (h[0] = r), (h[1] = r + n), (p[0] = t / l), (p[1] = e / l), this;
  }
  stopWarping() {
    const t = this._timeScaleInterpolant;
    return (
      t !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(t, e, n, a) {
    if (!this.enabled) {
      this._updateWeight(t);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const h = (t - r) * n;
      h < 0 || n === 0 ? (e = 0) : ((this._startTime = null), (e = n * h));
    }
    e *= this._updateTimeScale(t);
    const l = this._updateTime(e),
      u = this._updateWeight(t);
    if (u > 0) {
      const h = this._interpolants,
        p = this._propertyBindings;
      switch (this.blendMode) {
        case PA:
          for (let m = 0, v = h.length; m !== v; ++m)
            h[m].evaluate(l), p[m].accumulateAdditive(u);
          break;
        case Hx:
        default:
          for (let m = 0, v = h.length; m !== v; ++m)
            h[m].evaluate(l), p[m].accumulate(a, u);
      }
    }
  }
  _updateWeight(t) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const a = n.evaluate(t)[0];
        (e *= a),
          t > n.parameterPositions[1] &&
            (this.stopFading(), a === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = e), e;
  }
  _updateTimeScale(t) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const a = n.evaluate(t)[0];
        (e *= a),
          t > n.parameterPositions[1] &&
            (this.stopWarping(),
            e === 0 ? (this.paused = !0) : (this.timeScale = e));
      }
    }
    return (this._effectiveTimeScale = e), e;
  }
  _updateTime(t) {
    const e = this._clip.duration,
      n = this.loop;
    let a = this.time + t,
      r = this._loopCount;
    const l = n === AC;
    if (t === 0) return r === -1 ? a : l && (r & 1) === 1 ? e - a : a;
    if (n === bC) {
      r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      t: {
        if (a >= e) a = e;
        else if (a < 0) a = 0;
        else {
          this.time = a;
          break t;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = a),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (r === -1 &&
          (t >= 0
            ? ((r = 0), this._setEndings(!0, this.repetitions === 0, l))
            : this._setEndings(this.repetitions === 0, !0, l)),
        a >= e || a < 0)
      ) {
        const u = Math.floor(a / e);
        (a -= e * u), (r += Math.abs(u));
        const h = this.repetitions - r;
        if (h <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (a = t > 0 ? e : 0),
            (this.time = a),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t > 0 ? 1 : -1,
            });
        else {
          if (h === 1) {
            const p = t < 0;
            this._setEndings(p, !p, l);
          } else this._setEndings(!1, !1, l);
          (this._loopCount = r),
            (this.time = a),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: u,
            });
        }
      } else this.time = a;
      if (l && (r & 1) === 1) return e - a;
    }
    return a;
  }
  _setEndings(t, e, n) {
    const a = this._interpolantSettings;
    n
      ? ((a.endingStart = zf), (a.endingEnd = zf))
      : (t
          ? (a.endingStart = this.zeroSlopeAtStart ? zf : Pf)
          : (a.endingStart = c0),
        e ? (a.endingEnd = this.zeroSlopeAtEnd ? zf : Pf) : (a.endingEnd = c0));
  }
  _scheduleFading(t, e, n) {
    const a = this._mixer,
      r = a.time;
    let l = this._weightInterpolant;
    l === null &&
      ((l = a._lendControlInterpolant()), (this._weightInterpolant = l));
    const u = l.parameterPositions,
      h = l.sampleValues;
    return (u[0] = r), (h[0] = e), (u[1] = r + t), (h[1] = n), this;
  }
}
const YN = new Float32Array(1);
class vS extends ml {
  constructor(t) {
    super(),
      (this._root = t),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(t, e) {
    const n = t._localRoot || this._root,
      a = t._clip.tracks,
      r = a.length,
      l = t._propertyBindings,
      u = t._interpolants,
      h = n.uuid,
      p = this._bindingsByRootAndName;
    let m = p[h];
    m === void 0 && ((m = {}), (p[h] = m));
    for (let v = 0; v !== r; ++v) {
      const x = a[v],
        _ = x.name;
      let M = m[_];
      if (M !== void 0) ++M.referenceCount, (l[v] = M);
      else {
        if (((M = l[v]), M !== void 0)) {
          M._cacheIndex === null &&
            (++M.referenceCount, this._addInactiveBinding(M, h, _));
          continue;
        }
        const C = e && e._propertyBindings[v].binding.parsedPath;
        (M = new BR(Fn.create(n, _, C), x.ValueTypeName, x.getValueSize())),
          ++M.referenceCount,
          this._addInactiveBinding(M, h, _),
          (l[v] = M);
      }
      u[v].resultBuffer = M.buffer;
    }
  }
  _activateAction(t) {
    if (!this._isActiveAction(t)) {
      if (t._cacheIndex === null) {
        const n = (t._localRoot || this._root).uuid,
          a = t._clip.uuid,
          r = this._actionsByClip[a];
        this._bindAction(t, r && r.knownActions[0]),
          this._addInactiveAction(t, a, n);
      }
      const e = t._propertyBindings;
      for (let n = 0, a = e.length; n !== a; ++n) {
        const r = e[n];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(t);
    }
  }
  _deactivateAction(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let n = 0, a = e.length; n !== a; ++n) {
        const r = e[n];
        --r.useCount === 0 &&
          (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(t);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(t) {
    const e = t._cacheIndex;
    return e !== null && e < this._nActiveActions;
  }
  _addInactiveAction(t, e, n) {
    const a = this._actions,
      r = this._actionsByClip;
    let l = r[e];
    if (l === void 0)
      (l = { knownActions: [t], actionByRoot: {} }),
        (t._byClipCacheIndex = 0),
        (r[e] = l);
    else {
      const u = l.knownActions;
      (t._byClipCacheIndex = u.length), u.push(t);
    }
    (t._cacheIndex = a.length), a.push(t), (l.actionByRoot[n] = t);
  }
  _removeInactiveAction(t) {
    const e = this._actions,
      n = e[e.length - 1],
      a = t._cacheIndex;
    (n._cacheIndex = a), (e[a] = n), e.pop(), (t._cacheIndex = null);
    const r = t._clip.uuid,
      l = this._actionsByClip,
      u = l[r],
      h = u.knownActions,
      p = h[h.length - 1],
      m = t._byClipCacheIndex;
    (p._byClipCacheIndex = m),
      (h[m] = p),
      h.pop(),
      (t._byClipCacheIndex = null);
    const v = u.actionByRoot,
      x = (t._localRoot || this._root).uuid;
    delete v[x],
      h.length === 0 && delete l[r],
      this._removeInactiveBindingsForAction(t);
  }
  _removeInactiveBindingsForAction(t) {
    const e = t._propertyBindings;
    for (let n = 0, a = e.length; n !== a; ++n) {
      const r = e[n];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      a = this._nActiveActions++,
      r = e[a];
    (t._cacheIndex = a), (e[a] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _takeBackAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      a = --this._nActiveActions,
      r = e[a];
    (t._cacheIndex = a), (e[a] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _addInactiveBinding(t, e, n) {
    const a = this._bindingsByRootAndName,
      r = this._bindings;
    let l = a[e];
    l === void 0 && ((l = {}), (a[e] = l)),
      (l[n] = t),
      (t._cacheIndex = r.length),
      r.push(t);
  }
  _removeInactiveBinding(t) {
    const e = this._bindings,
      n = t.binding,
      a = n.rootNode.uuid,
      r = n.path,
      l = this._bindingsByRootAndName,
      u = l[a],
      h = e[e.length - 1],
      p = t._cacheIndex;
    (h._cacheIndex = p),
      (e[p] = h),
      e.pop(),
      delete u[r],
      Object.keys(u).length === 0 && delete l[a];
  }
  _lendBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      a = this._nActiveBindings++,
      r = e[a];
    (t._cacheIndex = a), (e[a] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _takeBackBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      a = --this._nActiveBindings,
      r = e[a];
    (t._cacheIndex = a), (e[a] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _lendControlInterpolant() {
    const t = this._controlInterpolants,
      e = this._nActiveControlInterpolants++;
    let n = t[e];
    return (
      n === void 0 &&
        ((n = new rS(new Float32Array(2), new Float32Array(2), 1, YN)),
        (n.__cacheIndex = e),
        (t[e] = n)),
      n
    );
  }
  _takeBackControlInterpolant(t) {
    const e = this._controlInterpolants,
      n = t.__cacheIndex,
      a = --this._nActiveControlInterpolants,
      r = e[a];
    (t.__cacheIndex = a), (e[a] = t), (r.__cacheIndex = n), (e[n] = r);
  }
  clipAction(t, e, n) {
    const a = e || this._root,
      r = a.uuid;
    let l = typeof t == "string" ? th.findByName(a, t) : t;
    const u = l !== null ? l.uuid : t,
      h = this._actionsByClip[u];
    let p = null;
    if (
      (n === void 0 && (l !== null ? (n = l.blendMode) : (n = Hx)),
      h !== void 0)
    ) {
      const v = h.actionByRoot[r];
      if (v !== void 0 && v.blendMode === n) return v;
      (p = h.knownActions[0]), l === null && (l = p._clip);
    }
    if (l === null) return null;
    const m = new DR(this, l, e, n);
    return this._bindAction(m, p), this._addInactiveAction(m, u, r), m;
  }
  existingAction(t, e) {
    const n = e || this._root,
      a = n.uuid,
      r = typeof t == "string" ? th.findByName(n, t) : t,
      l = r ? r.uuid : t,
      u = this._actionsByClip[l];
    return (u !== void 0 && u.actionByRoot[a]) || null;
  }
  stopAllAction() {
    const t = this._actions,
      e = this._nActiveActions;
    for (let n = e - 1; n >= 0; --n) t[n].stop();
    return this;
  }
  update(t) {
    t *= this.timeScale;
    const e = this._actions,
      n = this._nActiveActions,
      a = (this.time += t),
      r = Math.sign(t),
      l = (this._accuIndex ^= 1);
    for (let p = 0; p !== n; ++p) e[p]._update(a, t, r, l);
    const u = this._bindings,
      h = this._nActiveBindings;
    for (let p = 0; p !== h; ++p) u[p].apply(l);
    return this;
  }
  setTime(t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
    return this.update(t);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(t) {
    const e = this._actions,
      n = t.uuid,
      a = this._actionsByClip,
      r = a[n];
    if (r !== void 0) {
      const l = r.knownActions;
      for (let u = 0, h = l.length; u !== h; ++u) {
        const p = l[u];
        this._deactivateAction(p);
        const m = p._cacheIndex,
          v = e[e.length - 1];
        (p._cacheIndex = null),
          (p._byClipCacheIndex = null),
          (v._cacheIndex = m),
          (e[m] = v),
          e.pop(),
          this._removeInactiveBindingsForAction(p);
      }
      delete a[n];
    }
  }
  uncacheRoot(t) {
    const e = t.uuid,
      n = this._actionsByClip;
    for (const l in n) {
      const u = n[l].actionByRoot,
        h = u[e];
      h !== void 0 &&
        (this._deactivateAction(h), this._removeInactiveAction(h));
    }
    const a = this._bindingsByRootAndName,
      r = a[e];
    if (r !== void 0)
      for (const l in r) {
        const u = r[l];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  }
  uncacheAction(t, e) {
    const n = this.existingAction(t, e);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class qN extends GA {
  constructor(t = 1, e = 1, n = 1, a = {}) {
    super(t, e, a),
      (this.isRenderTarget3D = !0),
      (this.depth = n),
      (this.texture = new Vx(null, t, e, n)),
      this._setTextureOptions(a),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class yS {
  constructor(t) {
    this.value = t;
  }
  clone() {
    return new yS(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let KN = 0;
class JN extends ml {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: KN++ }),
      (this.name = ""),
      (this.usage = f0),
      (this.uniforms = []);
  }
  add(t) {
    return this.uniforms.push(t), this;
  }
  remove(t) {
    const e = this.uniforms.indexOf(t);
    return e !== -1 && this.uniforms.splice(e, 1), this;
  }
  setName(t) {
    return (this.name = t), this;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy(t) {
    (this.name = t.name), (this.usage = t.usage);
    const e = t.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, a = e.length; n < a; n++) {
      const r = Array.isArray(e[n]) ? e[n] : [e[n]];
      for (let l = 0; l < r.length; l++) this.uniforms.push(r[l].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ZN extends L0 {
  constructor(t, e, n = 1) {
    super(t, e),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = n);
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
  }
  clone(t) {
    const e = super.clone(t);
    return (e.meshPerAttribute = this.meshPerAttribute), e;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.isInstancedInterleavedBuffer = !0),
      (e.meshPerAttribute = this.meshPerAttribute),
      e
    );
  }
}
class QN {
  constructor(t, e, n, a, r) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = t),
      (this.type = e),
      (this.itemSize = n),
      (this.elementSize = a),
      (this.count = r),
      (this.version = 0);
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setBuffer(t) {
    return (this.buffer = t), this;
  }
  setType(t, e) {
    return (this.type = t), (this.elementSize = e), this;
  }
  setItemSize(t) {
    return (this.itemSize = t), this;
  }
  setCount(t) {
    return (this.count = t), this;
  }
}
const cT = new Xe();
class xS {
  constructor(t, e, n = 0, a = 1 / 0) {
    (this.ray = new ih(t, e)),
      (this.near = n),
      (this.far = a),
      (this.camera = null),
      (this.layers = new Zd()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(t, e) {
    this.ray.set(t, e);
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction
          .set(t.x, t.y, 0.5)
          .unproject(e)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = e))
      : e.isOrthographicCamera
      ? (this.ray.origin
          .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
          .unproject(e),
        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
        (this.camera = e))
      : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  }
  setFromXRController(t) {
    return (
      cT.identity().extractRotation(t.matrixWorld),
      this.ray.origin.setFromMatrixPosition(t.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(cT),
      this
    );
  }
  intersectObject(t, e = !0, n = []) {
    return Wb(t, this, n, e), n.sort(uT), n;
  }
  intersectObjects(t, e = !0, n = []) {
    for (let a = 0, r = t.length; a < r; a++) Wb(t[a], this, n, e);
    return n.sort(uT), n;
  }
}
function uT(i, t) {
  return i.distance - t.distance;
}
function Wb(i, t, e, n) {
  let a = !0;
  if (
    (i.layers.test(t.layers) && i.raycast(t, e) === !1 && (a = !1),
    a === !0 && n === !0)
  ) {
    const r = i.children;
    for (let l = 0, u = r.length; l < u; l++) Wb(r[l], t, e, !0);
  }
}
class Yb {
  constructor(t = 1, e = 0, n = 0) {
    (this.radius = t), (this.phi = e), (this.theta = n);
  }
  set(t, e, n) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this;
  }
  copy(t) {
    return (
      (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
    );
  }
  makeSafe() {
    return (this.phi = dn(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, n)),
          (this.phi = Math.acos(dn(e / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class $N {
  constructor(t = 1, e = 0, n = 0) {
    (this.radius = t), (this.theta = e), (this.y = n);
  }
  set(t, e, n) {
    return (this.radius = t), (this.theta = e), (this.y = n), this;
  }
  copy(t) {
    return (
      (this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this
    );
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + n * n)),
      (this.theta = Math.atan2(t, n)),
      (this.y = e),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _S {
  constructor(t, e, n, a) {
    (_S.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      t !== void 0 && this.set(t, e, n, a);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 4; n++) this.elements[n] = t[n + e];
    return this;
  }
  set(t, e, n, a) {
    const r = this.elements;
    return (r[0] = t), (r[2] = e), (r[1] = n), (r[3] = a), this;
  }
}
const fT = new Yt();
class tL {
  constructor(t = new Yt(1 / 0, 1 / 0), e = new Yt(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = t), (this.max = e);
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = fT.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(t) {
    return this.isEmpty()
      ? t.set(0, 0)
      : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  containsPoint(t) {
    return (
      t.x >= this.min.x &&
      t.x <= this.max.x &&
      t.y >= this.min.y &&
      t.y <= this.max.y
    );
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y
    );
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(t) {
    return (
      t.max.x >= this.min.x &&
      t.min.x <= this.max.x &&
      t.max.y >= this.min.y &&
      t.min.y <= this.max.y
    );
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, fT).distanceTo(t);
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const hT = new Z(),
  ry = new Z();
class eL {
  constructor(t = new Z(), e = new Z()) {
    (this.start = t), (this.end = e);
  }
  set(t, e) {
    return this.start.copy(t), this.end.copy(e), this;
  }
  copy(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this;
  }
  getCenter(t) {
    return t.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(t) {
    return t.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, e) {
    return this.delta(e).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(t, e) {
    hT.subVectors(t, this.start), ry.subVectors(this.end, this.start);
    const n = ry.dot(ry);
    let r = ry.dot(hT) / n;
    return e && (r = dn(r, 0, 1)), r;
  }
  closestPointToPoint(t, e, n) {
    const a = this.closestPointToPointParameter(t, e);
    return this.delta(n).multiplyScalar(a).add(this.start);
  }
  applyMatrix4(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
  }
  equals(t) {
    return t.start.equals(this.start) && t.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const dT = new Z();
class nL extends Dn {
  constructor(t, e) {
    super(),
      (this.light = t),
      (this.matrixAutoUpdate = !1),
      (this.color = e),
      (this.type = "SpotLightHelper");
    const n = new pn(),
      a = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let l = 0, u = 1, h = 32; l < h; l++, u++) {
      const p = (l / h) * Math.PI * 2,
        m = (u / h) * Math.PI * 2;
      a.push(Math.cos(p), Math.sin(p), 1, Math.cos(m), Math.sin(m), 1);
    }
    n.setAttribute("position", new Pe(a, 3));
    const r = new is({ fog: !1, toneMapped: !1 });
    (this.cone = new Ao(n, r)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const t = this.light.distance ? this.light.distance : 1e3,
      e = t * Math.tan(this.light.angle);
    this.cone.scale.set(e, e, t),
      dT.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(dT),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const eu = new Z(),
  oy = new Xe(),
  H_ = new Xe();
class UR extends Ao {
  constructor(t) {
    const e = OR(t),
      n = new pn(),
      a = [],
      r = [],
      l = new Se(0, 0, 1),
      u = new Se(0, 1, 0);
    for (let p = 0; p < e.length; p++) {
      const m = e[p];
      m.parent &&
        m.parent.isBone &&
        (a.push(0, 0, 0),
        a.push(0, 0, 0),
        r.push(l.r, l.g, l.b),
        r.push(u.r, u.g, u.b));
    }
    n.setAttribute("position", new Pe(a, 3)),
      n.setAttribute("color", new Pe(r, 3));
    const h = new is({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(n, h),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = t),
      (this.bones = e),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(t) {
    const e = this.bones,
      n = this.geometry,
      a = n.getAttribute("position");
    H_.copy(this.root.matrixWorld).invert();
    for (let r = 0, l = 0; r < e.length; r++) {
      const u = e[r];
      u.parent &&
        u.parent.isBone &&
        (oy.multiplyMatrices(H_, u.matrixWorld),
        eu.setFromMatrixPosition(oy),
        a.setXYZ(l, eu.x, eu.y, eu.z),
        oy.multiplyMatrices(H_, u.parent.matrixWorld),
        eu.setFromMatrixPosition(oy),
        a.setXYZ(l + 1, eu.x, eu.y, eu.z),
        (l += 2));
    }
    (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(t);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function OR(i) {
  const t = [];
  i.isBone === !0 && t.push(i);
  for (let e = 0; e < i.children.length; e++) t.push(...OR(i.children[e]));
  return t;
}
class iL extends Ti {
  constructor(t, e, n) {
    const a = new G0(e, 4, 2),
      r = new ks({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(a, r),
      (this.light = t),
      (this.color = n),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const aL = new Z(),
  pT = new Se(),
  mT = new Se();
class sL extends Dn {
  constructor(t, e, n) {
    super(),
      (this.light = t),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "HemisphereLightHelper");
    const a = new H0(e);
    a.rotateY(Math.PI * 0.5),
      (this.material = new ks({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const r = a.getAttribute("position"),
      l = new Float32Array(r.count * 3);
    a.setAttribute("color", new Gn(l, 3)),
      this.add(new Ti(a, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const t = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const e = t.geometry.getAttribute("color");
      pT.copy(this.light.color), mT.copy(this.light.groundColor);
      for (let n = 0, a = e.count; n < a; n++) {
        const r = n < a / 2 ? pT : mT;
        e.setXYZ(n, r.r, r.g, r.b);
      }
      e.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      t.lookAt(aL.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class rL extends Ao {
  constructor(t = 10, e = 10, n = 4473924, a = 8947848) {
    (n = new Se(n)), (a = new Se(a));
    const r = e / 2,
      l = t / e,
      u = t / 2,
      h = [],
      p = [];
    for (let x = 0, _ = 0, M = -u; x <= e; x++, M += l) {
      h.push(-u, 0, M, u, 0, M), h.push(M, 0, -u, M, 0, u);
      const C = x === r ? n : a;
      C.toArray(p, _),
        (_ += 3),
        C.toArray(p, _),
        (_ += 3),
        C.toArray(p, _),
        (_ += 3),
        C.toArray(p, _),
        (_ += 3);
    }
    const m = new pn();
    m.setAttribute("position", new Pe(h, 3)),
      m.setAttribute("color", new Pe(p, 3));
    const v = new is({ vertexColors: !0, toneMapped: !1 });
    super(m, v), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class oL extends Ao {
  constructor(t = 10, e = 16, n = 8, a = 64, r = 4473924, l = 8947848) {
    (r = new Se(r)), (l = new Se(l));
    const u = [],
      h = [];
    if (e > 1)
      for (let v = 0; v < e; v++) {
        const x = (v / e) * (Math.PI * 2),
          _ = Math.sin(x) * t,
          M = Math.cos(x) * t;
        u.push(0, 0, 0), u.push(_, 0, M);
        const C = v & 1 ? r : l;
        h.push(C.r, C.g, C.b), h.push(C.r, C.g, C.b);
      }
    for (let v = 0; v < n; v++) {
      const x = v & 1 ? r : l,
        _ = t - (t / n) * v;
      for (let M = 0; M < a; M++) {
        let C = (M / a) * (Math.PI * 2),
          E = Math.sin(C) * _,
          S = Math.cos(C) * _;
        u.push(E, 0, S),
          h.push(x.r, x.g, x.b),
          (C = ((M + 1) / a) * (Math.PI * 2)),
          (E = Math.sin(C) * _),
          (S = Math.cos(C) * _),
          u.push(E, 0, S),
          h.push(x.r, x.g, x.b);
      }
    }
    const p = new pn();
    p.setAttribute("position", new Pe(u, 3)),
      p.setAttribute("color", new Pe(h, 3));
    const m = new is({ vertexColors: !0, toneMapped: !1 });
    super(p, m), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const gT = new Z(),
  ly = new Z(),
  vT = new Z();
class lL extends Dn {
  constructor(t, e, n) {
    super(),
      (this.light = t),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "DirectionalLightHelper"),
      e === void 0 && (e = 1);
    let a = new pn();
    a.setAttribute(
      "position",
      new Pe([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    );
    const r = new is({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new tc(a, r)),
      this.add(this.lightPlane),
      (a = new pn()),
      a.setAttribute("position", new Pe([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new tc(a, r)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      gT.setFromMatrixPosition(this.light.matrixWorld),
      ly.setFromMatrixPosition(this.light.target.matrixWorld),
      vT.subVectors(ly, gT),
      this.lightPlane.lookAt(ly),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(ly),
      (this.targetLine.scale.z = vT.length());
  }
}
const cy = new Z(),
  Gi = new kx();
class cL extends Ao {
  constructor(t) {
    const e = new pn(),
      n = new is({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      a = [],
      r = [],
      l = {};
    u("n1", "n2"),
      u("n2", "n4"),
      u("n4", "n3"),
      u("n3", "n1"),
      u("f1", "f2"),
      u("f2", "f4"),
      u("f4", "f3"),
      u("f3", "f1"),
      u("n1", "f1"),
      u("n2", "f2"),
      u("n3", "f3"),
      u("n4", "f4"),
      u("p", "n1"),
      u("p", "n2"),
      u("p", "n3"),
      u("p", "n4"),
      u("u1", "u2"),
      u("u2", "u3"),
      u("u3", "u1"),
      u("c", "t"),
      u("p", "c"),
      u("cn1", "cn2"),
      u("cn3", "cn4"),
      u("cf1", "cf2"),
      u("cf3", "cf4");
    function u(M, C) {
      h(M), h(C);
    }
    function h(M) {
      a.push(0, 0, 0),
        r.push(0, 0, 0),
        l[M] === void 0 && (l[M] = []),
        l[M].push(a.length / 3 - 1);
    }
    e.setAttribute("position", new Pe(a, 3)),
      e.setAttribute("color", new Pe(r, 3)),
      super(e, n),
      (this.type = "CameraHelper"),
      (this.camera = t),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = l),
      this.update();
    const p = new Se(16755200),
      m = new Se(16711680),
      v = new Se(43775),
      x = new Se(16777215),
      _ = new Se(3355443);
    this.setColors(p, m, v, x, _);
  }
  setColors(t, e, n, a, r) {
    const u = this.geometry.getAttribute("color");
    u.setXYZ(0, t.r, t.g, t.b),
      u.setXYZ(1, t.r, t.g, t.b),
      u.setXYZ(2, t.r, t.g, t.b),
      u.setXYZ(3, t.r, t.g, t.b),
      u.setXYZ(4, t.r, t.g, t.b),
      u.setXYZ(5, t.r, t.g, t.b),
      u.setXYZ(6, t.r, t.g, t.b),
      u.setXYZ(7, t.r, t.g, t.b),
      u.setXYZ(8, t.r, t.g, t.b),
      u.setXYZ(9, t.r, t.g, t.b),
      u.setXYZ(10, t.r, t.g, t.b),
      u.setXYZ(11, t.r, t.g, t.b),
      u.setXYZ(12, t.r, t.g, t.b),
      u.setXYZ(13, t.r, t.g, t.b),
      u.setXYZ(14, t.r, t.g, t.b),
      u.setXYZ(15, t.r, t.g, t.b),
      u.setXYZ(16, t.r, t.g, t.b),
      u.setXYZ(17, t.r, t.g, t.b),
      u.setXYZ(18, t.r, t.g, t.b),
      u.setXYZ(19, t.r, t.g, t.b),
      u.setXYZ(20, t.r, t.g, t.b),
      u.setXYZ(21, t.r, t.g, t.b),
      u.setXYZ(22, t.r, t.g, t.b),
      u.setXYZ(23, t.r, t.g, t.b),
      u.setXYZ(24, e.r, e.g, e.b),
      u.setXYZ(25, e.r, e.g, e.b),
      u.setXYZ(26, e.r, e.g, e.b),
      u.setXYZ(27, e.r, e.g, e.b),
      u.setXYZ(28, e.r, e.g, e.b),
      u.setXYZ(29, e.r, e.g, e.b),
      u.setXYZ(30, e.r, e.g, e.b),
      u.setXYZ(31, e.r, e.g, e.b),
      u.setXYZ(32, n.r, n.g, n.b),
      u.setXYZ(33, n.r, n.g, n.b),
      u.setXYZ(34, n.r, n.g, n.b),
      u.setXYZ(35, n.r, n.g, n.b),
      u.setXYZ(36, n.r, n.g, n.b),
      u.setXYZ(37, n.r, n.g, n.b),
      u.setXYZ(38, a.r, a.g, a.b),
      u.setXYZ(39, a.r, a.g, a.b),
      u.setXYZ(40, r.r, r.g, r.b),
      u.setXYZ(41, r.r, r.g, r.b),
      u.setXYZ(42, r.r, r.g, r.b),
      u.setXYZ(43, r.r, r.g, r.b),
      u.setXYZ(44, r.r, r.g, r.b),
      u.setXYZ(45, r.r, r.g, r.b),
      u.setXYZ(46, r.r, r.g, r.b),
      u.setXYZ(47, r.r, r.g, r.b),
      u.setXYZ(48, r.r, r.g, r.b),
      u.setXYZ(49, r.r, r.g, r.b),
      (u.needsUpdate = !0);
  }
  update() {
    const t = this.geometry,
      e = this.pointMap,
      n = 1,
      a = 1;
    Gi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const r = this.camera.coordinateSystem === Lr ? -1 : 0;
    Yi("c", e, t, Gi, 0, 0, r),
      Yi("t", e, t, Gi, 0, 0, 1),
      Yi("n1", e, t, Gi, -1, -1, r),
      Yi("n2", e, t, Gi, n, -1, r),
      Yi("n3", e, t, Gi, -1, a, r),
      Yi("n4", e, t, Gi, n, a, r),
      Yi("f1", e, t, Gi, -1, -1, 1),
      Yi("f2", e, t, Gi, n, -1, 1),
      Yi("f3", e, t, Gi, -1, a, 1),
      Yi("f4", e, t, Gi, n, a, 1),
      Yi("u1", e, t, Gi, n * 0.7, a * 1.1, r),
      Yi("u2", e, t, Gi, -1 * 0.7, a * 1.1, r),
      Yi("u3", e, t, Gi, 0, a * 2, r),
      Yi("cf1", e, t, Gi, -1, 0, 1),
      Yi("cf2", e, t, Gi, n, 0, 1),
      Yi("cf3", e, t, Gi, 0, -1, 1),
      Yi("cf4", e, t, Gi, 0, a, 1),
      Yi("cn1", e, t, Gi, -1, 0, r),
      Yi("cn2", e, t, Gi, n, 0, r),
      Yi("cn3", e, t, Gi, 0, -1, r),
      Yi("cn4", e, t, Gi, 0, a, r),
      (t.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Yi(i, t, e, n, a, r, l) {
  cy.set(a, r, l).unproject(n);
  const u = t[i];
  if (u !== void 0) {
    const h = e.getAttribute("position");
    for (let p = 0, m = u.length; p < m; p++) h.setXYZ(u[p], cy.x, cy.y, cy.z);
  }
}
const uy = new Ha();
class uL extends Ao {
  constructor(t, e = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      a = new Float32Array(8 * 3),
      r = new pn();
    r.setIndex(new Gn(n, 1)),
      r.setAttribute("position", new Gn(a, 3)),
      super(r, new is({ color: e, toneMapped: !1 })),
      (this.object = t),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update() {
    if ((this.object !== void 0 && uy.setFromObject(this.object), uy.isEmpty()))
      return;
    const t = uy.min,
      e = uy.max,
      n = this.geometry.attributes.position,
      a = n.array;
    (a[0] = e.x),
      (a[1] = e.y),
      (a[2] = e.z),
      (a[3] = t.x),
      (a[4] = e.y),
      (a[5] = e.z),
      (a[6] = t.x),
      (a[7] = t.y),
      (a[8] = e.z),
      (a[9] = e.x),
      (a[10] = t.y),
      (a[11] = e.z),
      (a[12] = e.x),
      (a[13] = e.y),
      (a[14] = t.z),
      (a[15] = t.x),
      (a[16] = e.y),
      (a[17] = t.z),
      (a[18] = t.x),
      (a[19] = t.y),
      (a[20] = t.z),
      (a[21] = e.x),
      (a[22] = t.y),
      (a[23] = t.z),
      (n.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(t) {
    return (this.object = t), this.update(), this;
  }
  copy(t, e) {
    return super.copy(t, e), (this.object = t.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class fL extends Ao {
  constructor(t, e = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      a = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      r = new pn();
    r.setIndex(new Gn(n, 1)),
      r.setAttribute("position", new Pe(a, 3)),
      super(r, new is({ color: e, toneMapped: !1 })),
      (this.box = t),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(t) {
    const e = this.box;
    e.isEmpty() ||
      (e.getCenter(this.position),
      e.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(t));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class hL extends tc {
  constructor(t, e = 1, n = 16776960) {
    const a = n,
      r = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      l = new pn();
    l.setAttribute("position", new Pe(r, 3)),
      l.computeBoundingSphere(),
      super(l, new is({ color: a, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = t),
      (this.size = e);
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      h = new pn();
    h.setAttribute("position", new Pe(u, 3)),
      h.computeBoundingSphere(),
      this.add(
        new Ti(
          h,
          new ks({
            color: a,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(t) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(t);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const yT = new Z();
let fy, G_;
class dL extends Dn {
  constructor(
    t = new Z(0, 0, 1),
    e = new Z(0, 0, 0),
    n = 1,
    a = 16776960,
    r = n * 0.2,
    l = r * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      fy === void 0 &&
        ((fy = new pn()),
        fy.setAttribute("position", new Pe([0, 0, 0, 0, 1, 0], 3)),
        (G_ = new z0(0.5, 1, 5, 1)),
        G_.translate(0, -0.5, 0)),
      this.position.copy(e),
      (this.line = new tc(fy, new is({ color: a, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Ti(G_, new ks({ color: a, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(t),
      this.setLength(n, r, l);
  }
  setDirection(t) {
    if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      yT.set(t.z, 0, -t.x).normalize();
      const e = Math.acos(t.y);
      this.quaternion.setFromAxisAngle(yT, e);
    }
  }
  setLength(t, e = t * 0.2, n = e * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, t - e), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(n, e, n),
      (this.cone.position.y = t),
      this.cone.updateMatrix();
  }
  setColor(t) {
    this.line.material.color.set(t), this.cone.material.color.set(t);
  }
  copy(t) {
    return (
      super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class pL extends Ao {
  constructor(t = 1) {
    const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      a = new pn();
    a.setAttribute("position", new Pe(e, 3)),
      a.setAttribute("color", new Pe(n, 3));
    const r = new is({ vertexColors: !0, toneMapped: !1 });
    super(a, r), (this.type = "AxesHelper");
  }
  setColors(t, e, n) {
    const a = new Se(),
      r = this.geometry.attributes.color.array;
    return (
      a.set(t),
      a.toArray(r, 0),
      a.toArray(r, 3),
      a.set(e),
      a.toArray(r, 6),
      a.toArray(r, 9),
      a.set(n),
      a.toArray(r, 12),
      a.toArray(r, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class mL {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Se()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(t, e) {
    return (
      (this.currentPath = new xx()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(t, e),
      this
    );
  }
  lineTo(t, e) {
    return this.currentPath.lineTo(t, e), this;
  }
  quadraticCurveTo(t, e, n, a) {
    return this.currentPath.quadraticCurveTo(t, e, n, a), this;
  }
  bezierCurveTo(t, e, n, a, r, l) {
    return this.currentPath.bezierCurveTo(t, e, n, a, r, l), this;
  }
  splineThru(t) {
    return this.currentPath.splineThru(t), this;
  }
  toShapes(t) {
    function e(S) {
      const R = [];
      for (let B = 0, D = S.length; B < D; B++) {
        const I = S[B],
          P = new Yf();
        (P.curves = I.curves), R.push(P);
      }
      return R;
    }
    function n(S, R) {
      const B = R.length;
      let D = !1;
      for (let I = B - 1, P = 0; P < B; I = P++) {
        let V = R[I],
          F = R[P],
          N = F.x - V.x,
          L = F.y - V.y;
        if (Math.abs(L) > Number.EPSILON) {
          if (
            (L < 0 && ((V = R[P]), (N = -N), (F = R[I]), (L = -L)),
            S.y < V.y || S.y > F.y)
          )
            continue;
          if (S.y === V.y) {
            if (S.x === V.x) return !0;
          } else {
            const Y = L * (S.x - V.x) - N * (S.y - V.y);
            if (Y === 0) return !0;
            if (Y < 0) continue;
            D = !D;
          }
        } else {
          if (S.y !== V.y) continue;
          if ((F.x <= S.x && S.x <= V.x) || (V.x <= S.x && S.x <= F.x))
            return !0;
        }
      }
      return D;
    }
    const a = xo.isClockWise,
      r = this.subPaths;
    if (r.length === 0) return [];
    let l, u, h;
    const p = [];
    if (r.length === 1)
      return (u = r[0]), (h = new Yf()), (h.curves = u.curves), p.push(h), p;
    let m = !a(r[0].getPoints());
    m = t ? !m : m;
    const v = [],
      x = [];
    let _ = [],
      M = 0,
      C;
    (x[M] = void 0), (_[M] = []);
    for (let S = 0, R = r.length; S < R; S++)
      (u = r[S]),
        (C = u.getPoints()),
        (l = a(C)),
        (l = t ? !l : l),
        l
          ? (!m && x[M] && M++,
            (x[M] = { s: new Yf(), p: C }),
            (x[M].s.curves = u.curves),
            m && M++,
            (_[M] = []))
          : _[M].push({ h: u, p: C[0] });
    if (!x[0]) return e(r);
    if (x.length > 1) {
      let S = !1,
        R = 0;
      for (let B = 0, D = x.length; B < D; B++) v[B] = [];
      for (let B = 0, D = x.length; B < D; B++) {
        const I = _[B];
        for (let P = 0; P < I.length; P++) {
          const V = I[P];
          let F = !0;
          for (let N = 0; N < x.length; N++)
            n(V.p, x[N].p) &&
              (B !== N && R++, F ? ((F = !1), v[N].push(V)) : (S = !0));
          F && v[B].push(V);
        }
      }
      R > 0 && S === !1 && (_ = v);
    }
    let E;
    for (let S = 0, R = x.length; S < R; S++) {
      (h = x[S].s), p.push(h), (E = _[S]);
      for (let B = 0, D = E.length; B < D; B++) h.holes.push(E[B].h);
    }
    return p;
  }
}
class gL extends ml {
  constructor(t, e = null) {
    super(),
      (this.object = t),
      (this.domElement = e),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect(t) {
    if (t === void 0) {
      console.warn("THREE.Controls: connect() now requires an element.");
      return;
    }
    this.domElement !== null && this.disconnect(), (this.domElement = t);
  }
  disconnect() {}
  dispose() {}
  update() {}
}
function vL(i, t) {
  const e = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return (
    e > t
      ? ((i.repeat.x = 1),
        (i.repeat.y = e / t),
        (i.offset.x = 0),
        (i.offset.y = (1 - i.repeat.y) / 2))
      : ((i.repeat.x = t / e),
        (i.repeat.y = 1),
        (i.offset.x = (1 - i.repeat.x) / 2),
        (i.offset.y = 0)),
    i
  );
}
function yL(i, t) {
  const e = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return (
    e > t
      ? ((i.repeat.x = t / e),
        (i.repeat.y = 1),
        (i.offset.x = (1 - i.repeat.x) / 2),
        (i.offset.y = 0))
      : ((i.repeat.x = 1),
        (i.repeat.y = e / t),
        (i.offset.x = 0),
        (i.offset.y = (1 - i.repeat.y) / 2)),
    i
  );
}
function xL(i) {
  return (
    (i.repeat.x = 1), (i.repeat.y = 1), (i.offset.x = 0), (i.offset.y = 0), i
  );
}
function qb(i, t, e, n) {
  const a = _L(n);
  switch (e) {
    case UA:
      return i * t;
    case D0:
      return ((i * t) / a.components) * a.byteLength;
    case U0:
      return ((i * t) / a.components) * a.byteLength;
    case NA:
      return ((i * t * 2) / a.components) * a.byteLength;
    case zx:
      return ((i * t * 2) / a.components) * a.byteLength;
    case OA:
      return ((i * t * 3) / a.components) * a.byteLength;
    case Ji:
      return ((i * t * 4) / a.components) * a.byteLength;
    case Fx:
      return ((i * t * 4) / a.components) * a.byteLength;
    case Ym:
    case qm:
      return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case Km:
    case Jm:
      return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case jy:
    case Wy:
      return (Math.max(i, 16) * Math.max(t, 8)) / 4;
    case ky:
    case Xy:
      return (Math.max(i, 8) * Math.max(t, 8)) / 2;
    case Yy:
    case qy:
      return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case Ky:
      return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case Jy:
      return Math.floor((i + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case Zy:
      return Math.floor((i + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case Qy:
      return Math.floor((i + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case $y:
      return Math.floor((i + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case tx:
      return Math.floor((i + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case ex:
      return Math.floor((i + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case nx:
      return Math.floor((i + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case ix:
      return Math.floor((i + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case ax:
      return Math.floor((i + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case sx:
      return Math.floor((i + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case rx:
      return Math.floor((i + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case ox:
      return Math.floor((i + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case lx:
      return Math.floor((i + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case cx:
      return Math.floor((i + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case Zm:
    case ux:
    case fx:
      return Math.ceil(i / 4) * Math.ceil(t / 4) * 16;
    case LA:
    case hx:
      return Math.ceil(i / 4) * Math.ceil(t / 4) * 8;
    case dx:
    case px:
      return Math.ceil(i / 4) * Math.ceil(t / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${e} format.`);
}
function _L(i) {
  switch (i) {
    case Es:
    case Nx:
      return { byteLength: 1, components: 1 };
    case jd:
    case Lx:
    case Ea:
      return { byteLength: 2, components: 1 };
    case Ix:
    case Px:
      return { byteLength: 2, components: 4 };
    case pl:
    case B0:
    case Pi:
      return { byteLength: 4, components: 1 };
    case DA:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${i}.`);
}
class bL {
  static contain(t, e) {
    return vL(t, e);
  }
  static cover(t, e) {
    return yL(t, e);
  }
  static fill(t) {
    return xL(t);
  }
  static getByteLength(t, e, n, a) {
    return qb(t, e, n, a);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: C0 } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = C0));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function NR() {
  let i = null,
    t = !1,
    e = null,
    n = null;
  function a(r, l) {
    e(r, l), (n = i.requestAnimationFrame(a));
  }
  return {
    start: function () {
      t !== !0 && e !== null && ((n = i.requestAnimationFrame(a)), (t = !0));
    },
    stop: function () {
      i.cancelAnimationFrame(n), (t = !1);
    },
    setAnimationLoop: function (r) {
      e = r;
    },
    setContext: function (r) {
      i = r;
    },
  };
}
function AL(i) {
  const t = new WeakMap();
  function e(u, h) {
    const p = u.array,
      m = u.usage,
      v = p.byteLength,
      x = i.createBuffer();
    i.bindBuffer(h, x), i.bufferData(h, p, m), u.onUploadCallback();
    let _;
    if (p instanceof Float32Array) _ = i.FLOAT;
    else if (p instanceof Uint16Array)
      u.isFloat16BufferAttribute ? (_ = i.HALF_FLOAT) : (_ = i.UNSIGNED_SHORT);
    else if (p instanceof Int16Array) _ = i.SHORT;
    else if (p instanceof Uint32Array) _ = i.UNSIGNED_INT;
    else if (p instanceof Int32Array) _ = i.INT;
    else if (p instanceof Int8Array) _ = i.BYTE;
    else if (p instanceof Uint8Array) _ = i.UNSIGNED_BYTE;
    else if (p instanceof Uint8ClampedArray) _ = i.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + p
      );
    return {
      buffer: x,
      type: _,
      bytesPerElement: p.BYTES_PER_ELEMENT,
      version: u.version,
      size: v,
    };
  }
  function n(u, h, p) {
    const m = h.array,
      v = h.updateRanges;
    if ((i.bindBuffer(p, u), v.length === 0)) i.bufferSubData(p, 0, m);
    else {
      v.sort((_, M) => _.start - M.start);
      let x = 0;
      for (let _ = 1; _ < v.length; _++) {
        const M = v[x],
          C = v[_];
        C.start <= M.start + M.count + 1
          ? (M.count = Math.max(M.count, C.start + C.count - M.start))
          : (++x, (v[x] = C));
      }
      v.length = x + 1;
      for (let _ = 0, M = v.length; _ < M; _++) {
        const C = v[_];
        i.bufferSubData(p, C.start * m.BYTES_PER_ELEMENT, m, C.start, C.count);
      }
      h.clearUpdateRanges();
    }
    h.onUploadCallback();
  }
  function a(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), t.get(u);
  }
  function r(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const h = t.get(u);
    h && (i.deleteBuffer(h.buffer), t.delete(u));
  }
  function l(u, h) {
    if (
      (u.isInterleavedBufferAttribute && (u = u.data), u.isGLBufferAttribute)
    ) {
      const m = t.get(u);
      (!m || m.version < u.version) &&
        t.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    const p = t.get(u);
    if (p === void 0) t.set(u, e(u, h));
    else if (p.version < u.version) {
      if (p.size !== u.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      n(p.buffer, u, h), (p.version = u.version);
    }
  }
  return { get: a, remove: r, update: l };
}
var SL = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  ML = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  EL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  TL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  wL = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  CL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  RL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  BL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  DL = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  UL = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  OL = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  NL = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  LL = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  IL = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  PL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  zL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  FL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  HL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  GL = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  VL = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  kL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  jL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  XL = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  WL = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  YL = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  qL = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  KL = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  JL = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  ZL = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  QL = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  $L = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  tI = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  eI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  nI = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  iI = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  aI = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  sI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  rI = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  oI = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  lI = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  cI = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  uI = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  fI = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  hI = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  dI = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  pI = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  mI = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  gI = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  vI = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  yI = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  xI = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  _I = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  bI = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  AI = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  SI = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  MI = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  EI = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  TI = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  wI = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  CI = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  RI = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  BI = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  DI = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  UI = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  OI = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  NI = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  LI = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  II = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  PI = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  zI = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  FI = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  HI = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  GI = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  VI = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  kI = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  jI = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  XI = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  WI = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  YI = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  qI = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  KI = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  JI = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  ZI = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  QI = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  $I = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  t4 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  e4 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  n4 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  i4 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  a4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  s4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  r4 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  o4 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  l4 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  c4 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  u4 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  f4 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  h4 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  d4 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  p4 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  m4 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  g4 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  v4 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  y4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  x4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  _4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  b4 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const A4 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  S4 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  M4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  E4 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  T4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  w4 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  C4 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  R4 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  B4 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  D4 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  U4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  O4 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  N4 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  L4 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  I4 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  P4 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  z4 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  F4 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  H4 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  G4 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  V4 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  k4 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  j4 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  X4 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  W4 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  Y4 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  q4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  K4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  J4 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  Z4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Q4 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  $4 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  tP = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  eP = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Sn = {
    alphahash_fragment: SL,
    alphahash_pars_fragment: ML,
    alphamap_fragment: EL,
    alphamap_pars_fragment: TL,
    alphatest_fragment: wL,
    alphatest_pars_fragment: CL,
    aomap_fragment: RL,
    aomap_pars_fragment: BL,
    batching_pars_vertex: DL,
    batching_vertex: UL,
    begin_vertex: OL,
    beginnormal_vertex: NL,
    bsdfs: LL,
    iridescence_fragment: IL,
    bumpmap_pars_fragment: PL,
    clipping_planes_fragment: zL,
    clipping_planes_pars_fragment: FL,
    clipping_planes_pars_vertex: HL,
    clipping_planes_vertex: GL,
    color_fragment: VL,
    color_pars_fragment: kL,
    color_pars_vertex: jL,
    color_vertex: XL,
    common: WL,
    cube_uv_reflection_fragment: YL,
    defaultnormal_vertex: qL,
    displacementmap_pars_vertex: KL,
    displacementmap_vertex: JL,
    emissivemap_fragment: ZL,
    emissivemap_pars_fragment: QL,
    colorspace_fragment: $L,
    colorspace_pars_fragment: tI,
    envmap_fragment: eI,
    envmap_common_pars_fragment: nI,
    envmap_pars_fragment: iI,
    envmap_pars_vertex: aI,
    envmap_physical_pars_fragment: mI,
    envmap_vertex: sI,
    fog_vertex: rI,
    fog_pars_vertex: oI,
    fog_fragment: lI,
    fog_pars_fragment: cI,
    gradientmap_pars_fragment: uI,
    lightmap_pars_fragment: fI,
    lights_lambert_fragment: hI,
    lights_lambert_pars_fragment: dI,
    lights_pars_begin: pI,
    lights_toon_fragment: gI,
    lights_toon_pars_fragment: vI,
    lights_phong_fragment: yI,
    lights_phong_pars_fragment: xI,
    lights_physical_fragment: _I,
    lights_physical_pars_fragment: bI,
    lights_fragment_begin: AI,
    lights_fragment_maps: SI,
    lights_fragment_end: MI,
    logdepthbuf_fragment: EI,
    logdepthbuf_pars_fragment: TI,
    logdepthbuf_pars_vertex: wI,
    logdepthbuf_vertex: CI,
    map_fragment: RI,
    map_pars_fragment: BI,
    map_particle_fragment: DI,
    map_particle_pars_fragment: UI,
    metalnessmap_fragment: OI,
    metalnessmap_pars_fragment: NI,
    morphinstance_vertex: LI,
    morphcolor_vertex: II,
    morphnormal_vertex: PI,
    morphtarget_pars_vertex: zI,
    morphtarget_vertex: FI,
    normal_fragment_begin: HI,
    normal_fragment_maps: GI,
    normal_pars_fragment: VI,
    normal_pars_vertex: kI,
    normal_vertex: jI,
    normalmap_pars_fragment: XI,
    clearcoat_normal_fragment_begin: WI,
    clearcoat_normal_fragment_maps: YI,
    clearcoat_pars_fragment: qI,
    iridescence_pars_fragment: KI,
    opaque_fragment: JI,
    packing: ZI,
    premultiplied_alpha_fragment: QI,
    project_vertex: $I,
    dithering_fragment: t4,
    dithering_pars_fragment: e4,
    roughnessmap_fragment: n4,
    roughnessmap_pars_fragment: i4,
    shadowmap_pars_fragment: a4,
    shadowmap_pars_vertex: s4,
    shadowmap_vertex: r4,
    shadowmask_pars_fragment: o4,
    skinbase_vertex: l4,
    skinning_pars_vertex: c4,
    skinning_vertex: u4,
    skinnormal_vertex: f4,
    specularmap_fragment: h4,
    specularmap_pars_fragment: d4,
    tonemapping_fragment: p4,
    tonemapping_pars_fragment: m4,
    transmission_fragment: g4,
    transmission_pars_fragment: v4,
    uv_pars_fragment: y4,
    uv_pars_vertex: x4,
    uv_vertex: _4,
    worldpos_vertex: b4,
    background_vert: A4,
    background_frag: S4,
    backgroundCube_vert: M4,
    backgroundCube_frag: E4,
    cube_vert: T4,
    cube_frag: w4,
    depth_vert: C4,
    depth_frag: R4,
    distanceRGBA_vert: B4,
    distanceRGBA_frag: D4,
    equirect_vert: U4,
    equirect_frag: O4,
    linedashed_vert: N4,
    linedashed_frag: L4,
    meshbasic_vert: I4,
    meshbasic_frag: P4,
    meshlambert_vert: z4,
    meshlambert_frag: F4,
    meshmatcap_vert: H4,
    meshmatcap_frag: G4,
    meshnormal_vert: V4,
    meshnormal_frag: k4,
    meshphong_vert: j4,
    meshphong_frag: X4,
    meshphysical_vert: W4,
    meshphysical_frag: Y4,
    meshtoon_vert: q4,
    meshtoon_frag: K4,
    points_vert: J4,
    points_frag: Z4,
    shadow_vert: Q4,
    shadow_frag: $4,
    sprite_vert: tP,
    sprite_frag: eP,
  },
  Ee = {
    common: {
      diffuse: { value: new Se(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new yn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new yn() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new yn() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new yn() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new yn() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new yn() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new yn() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new yn() },
      normalScale: { value: new Yt(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new yn() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new yn() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new yn() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new yn() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Se(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Se(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new yn() },
      alphaTest: { value: 0 },
      uvTransform: { value: new yn() },
    },
    sprite: {
      diffuse: { value: new Se(16777215) },
      opacity: { value: 1 },
      center: { value: new Yt(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new yn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new yn() },
      alphaTest: { value: 0 },
    },
  },
  yo = {
    basic: {
      uniforms: _s([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.fog,
      ]),
      vertexShader: Sn.meshbasic_vert,
      fragmentShader: Sn.meshbasic_frag,
    },
    lambert: {
      uniforms: _s([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        Ee.lights,
        { emissive: { value: new Se(0) } },
      ]),
      vertexShader: Sn.meshlambert_vert,
      fragmentShader: Sn.meshlambert_frag,
    },
    phong: {
      uniforms: _s([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        Ee.lights,
        {
          emissive: { value: new Se(0) },
          specular: { value: new Se(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Sn.meshphong_vert,
      fragmentShader: Sn.meshphong_frag,
    },
    standard: {
      uniforms: _s([
        Ee.common,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.roughnessmap,
        Ee.metalnessmap,
        Ee.fog,
        Ee.lights,
        {
          emissive: { value: new Se(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Sn.meshphysical_vert,
      fragmentShader: Sn.meshphysical_frag,
    },
    toon: {
      uniforms: _s([
        Ee.common,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.gradientmap,
        Ee.fog,
        Ee.lights,
        { emissive: { value: new Se(0) } },
      ]),
      vertexShader: Sn.meshtoon_vert,
      fragmentShader: Sn.meshtoon_frag,
    },
    matcap: {
      uniforms: _s([
        Ee.common,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Sn.meshmatcap_vert,
      fragmentShader: Sn.meshmatcap_frag,
    },
    points: {
      uniforms: _s([Ee.points, Ee.fog]),
      vertexShader: Sn.points_vert,
      fragmentShader: Sn.points_frag,
    },
    dashed: {
      uniforms: _s([
        Ee.common,
        Ee.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Sn.linedashed_vert,
      fragmentShader: Sn.linedashed_frag,
    },
    depth: {
      uniforms: _s([Ee.common, Ee.displacementmap]),
      vertexShader: Sn.depth_vert,
      fragmentShader: Sn.depth_frag,
    },
    normal: {
      uniforms: _s([
        Ee.common,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Sn.meshnormal_vert,
      fragmentShader: Sn.meshnormal_frag,
    },
    sprite: {
      uniforms: _s([Ee.sprite, Ee.fog]),
      vertexShader: Sn.sprite_vert,
      fragmentShader: Sn.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new yn() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Sn.background_vert,
      fragmentShader: Sn.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new yn() },
      },
      vertexShader: Sn.backgroundCube_vert,
      fragmentShader: Sn.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Sn.cube_vert,
      fragmentShader: Sn.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Sn.equirect_vert,
      fragmentShader: Sn.equirect_frag,
    },
    distanceRGBA: {
      uniforms: _s([
        Ee.common,
        Ee.displacementmap,
        {
          referencePosition: { value: new Z() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Sn.distanceRGBA_vert,
      fragmentShader: Sn.distanceRGBA_frag,
    },
    shadow: {
      uniforms: _s([
        Ee.lights,
        Ee.fog,
        { color: { value: new Se(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Sn.shadow_vert,
      fragmentShader: Sn.shadow_frag,
    },
  };
yo.physical = {
  uniforms: _s([
    yo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new yn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new yn() },
      clearcoatNormalScale: { value: new Yt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new yn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new yn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new yn() },
      sheen: { value: 0 },
      sheenColor: { value: new Se(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new yn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new yn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new yn() },
      transmissionSamplerSize: { value: new Yt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new yn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Se(0) },
      specularColor: { value: new Se(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new yn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new yn() },
      anisotropyVector: { value: new Yt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new yn() },
    },
  ]),
  vertexShader: Sn.meshphysical_vert,
  fragmentShader: Sn.meshphysical_frag,
};
const hy = { r: 0, b: 0, g: 0 },
  Tf = new cr(),
  nP = new Xe();
function iP(i, t, e, n, a, r, l) {
  const u = new Se(0);
  let h = r === !0 ? 0 : 1,
    p,
    m,
    v = null,
    x = 0,
    _ = null;
  function M(B) {
    let D = B.isScene === !0 ? B.background : null;
    return (
      D && D.isTexture && (D = (B.backgroundBlurriness > 0 ? e : t).get(D)), D
    );
  }
  function C(B) {
    let D = !1;
    const I = M(B);
    I === null ? S(u, h) : I && I.isColor && (S(I, 1), (D = !0));
    const P = i.xr.getEnvironmentBlendMode();
    P === "additive"
      ? n.buffers.color.setClear(0, 0, 0, 1, l)
      : P === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, l),
      (i.autoClear || D) &&
        (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
  }
  function E(B, D) {
    const I = M(D);
    I && (I.isCubeTexture || I.mapping === ip)
      ? (m === void 0 &&
          ((m = new Ti(
            new ah(1, 1, 1),
            new Xs({
              name: "BackgroundCubeMaterial",
              uniforms: Qd(yo.backgroundCube.uniforms),
              vertexShader: yo.backgroundCube.vertexShader,
              fragmentShader: yo.backgroundCube.fragmentShader,
              side: Ms,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          m.geometry.deleteAttribute("normal"),
          m.geometry.deleteAttribute("uv"),
          (m.onBeforeRender = function (P, V, F) {
            this.matrixWorld.copyPosition(F.matrixWorld);
          }),
          Object.defineProperty(m.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          a.update(m)),
        Tf.copy(D.backgroundRotation),
        (Tf.x *= -1),
        (Tf.y *= -1),
        (Tf.z *= -1),
        I.isCubeTexture &&
          I.isRenderTargetTexture === !1 &&
          ((Tf.y *= -1), (Tf.z *= -1)),
        (m.material.uniforms.envMap.value = I),
        (m.material.uniforms.flipEnvMap.value =
          I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1),
        (m.material.uniforms.backgroundBlurriness.value =
          D.backgroundBlurriness),
        (m.material.uniforms.backgroundIntensity.value = D.backgroundIntensity),
        m.material.uniforms.backgroundRotation.value.setFromMatrix4(
          nP.makeRotationFromEuler(Tf)
        ),
        (m.material.toneMapped = In.getTransfer(I.colorSpace) !== ai),
        (v !== I || x !== I.version || _ !== i.toneMapping) &&
          ((m.material.needsUpdate = !0),
          (v = I),
          (x = I.version),
          (_ = i.toneMapping)),
        m.layers.enableAll(),
        B.unshift(m, m.geometry, m.material, 0, 0, null))
      : I &&
        I.isTexture &&
        (p === void 0 &&
          ((p = new Ti(
            new xu(2, 2),
            new Xs({
              name: "BackgroundMaterial",
              uniforms: Qd(yo.background.uniforms),
              vertexShader: yo.background.vertexShader,
              fragmentShader: yo.background.fragmentShader,
              side: hl,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          p.geometry.deleteAttribute("normal"),
          Object.defineProperty(p.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          a.update(p)),
        (p.material.uniforms.t2D.value = I),
        (p.material.uniforms.backgroundIntensity.value = D.backgroundIntensity),
        (p.material.toneMapped = In.getTransfer(I.colorSpace) !== ai),
        I.matrixAutoUpdate === !0 && I.updateMatrix(),
        p.material.uniforms.uvTransform.value.copy(I.matrix),
        (v !== I || x !== I.version || _ !== i.toneMapping) &&
          ((p.material.needsUpdate = !0),
          (v = I),
          (x = I.version),
          (_ = i.toneMapping)),
        p.layers.enableAll(),
        B.unshift(p, p.geometry, p.material, 0, 0, null));
  }
  function S(B, D) {
    B.getRGB(hy, FC(i)), n.buffers.color.setClear(hy.r, hy.g, hy.b, D, l);
  }
  function R() {
    m !== void 0 && (m.geometry.dispose(), m.material.dispose(), (m = void 0)),
      p !== void 0 &&
        (p.geometry.dispose(), p.material.dispose(), (p = void 0));
  }
  return {
    getClearColor: function () {
      return u;
    },
    setClearColor: function (B, D = 1) {
      u.set(B), (h = D), S(u, h);
    },
    getClearAlpha: function () {
      return h;
    },
    setClearAlpha: function (B) {
      (h = B), S(u, h);
    },
    render: C,
    addToRenderList: E,
    dispose: R,
  };
}
function aP(i, t) {
  const e = i.getParameter(i.MAX_VERTEX_ATTRIBS),
    n = {},
    a = x(null);
  let r = a,
    l = !1;
  function u(L, Y, ct, nt, dt) {
    let pt = !1;
    const j = v(nt, ct, Y);
    r !== j && ((r = j), p(r.object)),
      (pt = _(L, nt, ct, dt)),
      pt && M(L, nt, ct, dt),
      dt !== null && t.update(dt, i.ELEMENT_ARRAY_BUFFER),
      (pt || l) &&
        ((l = !1),
        D(L, Y, ct, nt),
        dt !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.get(dt).buffer));
  }
  function h() {
    return i.createVertexArray();
  }
  function p(L) {
    return i.bindVertexArray(L);
  }
  function m(L) {
    return i.deleteVertexArray(L);
  }
  function v(L, Y, ct) {
    const nt = ct.wireframe === !0;
    let dt = n[L.id];
    dt === void 0 && ((dt = {}), (n[L.id] = dt));
    let pt = dt[Y.id];
    pt === void 0 && ((pt = {}), (dt[Y.id] = pt));
    let j = pt[nt];
    return j === void 0 && ((j = x(h())), (pt[nt] = j)), j;
  }
  function x(L) {
    const Y = [],
      ct = [],
      nt = [];
    for (let dt = 0; dt < e; dt++) (Y[dt] = 0), (ct[dt] = 0), (nt[dt] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Y,
      enabledAttributes: ct,
      attributeDivisors: nt,
      object: L,
      attributes: {},
      index: null,
    };
  }
  function _(L, Y, ct, nt) {
    const dt = r.attributes,
      pt = Y.attributes;
    let j = 0;
    const Q = ct.getAttributes();
    for (const et in Q)
      if (Q[et].location >= 0) {
        const X = dt[et];
        let ft = pt[et];
        if (
          (ft === void 0 &&
            (et === "instanceMatrix" &&
              L.instanceMatrix &&
              (ft = L.instanceMatrix),
            et === "instanceColor" &&
              L.instanceColor &&
              (ft = L.instanceColor)),
          X === void 0 || X.attribute !== ft || (ft && X.data !== ft.data))
        )
          return !0;
        j++;
      }
    return r.attributesNum !== j || r.index !== nt;
  }
  function M(L, Y, ct, nt) {
    const dt = {},
      pt = Y.attributes;
    let j = 0;
    const Q = ct.getAttributes();
    for (const et in Q)
      if (Q[et].location >= 0) {
        let X = pt[et];
        X === void 0 &&
          (et === "instanceMatrix" &&
            L.instanceMatrix &&
            (X = L.instanceMatrix),
          et === "instanceColor" && L.instanceColor && (X = L.instanceColor));
        const ft = {};
        (ft.attribute = X),
          X && X.data && (ft.data = X.data),
          (dt[et] = ft),
          j++;
      }
    (r.attributes = dt), (r.attributesNum = j), (r.index = nt);
  }
  function C() {
    const L = r.newAttributes;
    for (let Y = 0, ct = L.length; Y < ct; Y++) L[Y] = 0;
  }
  function E(L) {
    S(L, 0);
  }
  function S(L, Y) {
    const ct = r.newAttributes,
      nt = r.enabledAttributes,
      dt = r.attributeDivisors;
    (ct[L] = 1),
      nt[L] === 0 && (i.enableVertexAttribArray(L), (nt[L] = 1)),
      dt[L] !== Y && (i.vertexAttribDivisor(L, Y), (dt[L] = Y));
  }
  function R() {
    const L = r.newAttributes,
      Y = r.enabledAttributes;
    for (let ct = 0, nt = Y.length; ct < nt; ct++)
      Y[ct] !== L[ct] && (i.disableVertexAttribArray(ct), (Y[ct] = 0));
  }
  function B(L, Y, ct, nt, dt, pt, j) {
    j === !0
      ? i.vertexAttribIPointer(L, Y, ct, dt, pt)
      : i.vertexAttribPointer(L, Y, ct, nt, dt, pt);
  }
  function D(L, Y, ct, nt) {
    C();
    const dt = nt.attributes,
      pt = ct.getAttributes(),
      j = Y.defaultAttributeValues;
    for (const Q in pt) {
      const et = pt[Q];
      if (et.location >= 0) {
        let xt = dt[Q];
        if (
          (xt === void 0 &&
            (Q === "instanceMatrix" &&
              L.instanceMatrix &&
              (xt = L.instanceMatrix),
            Q === "instanceColor" && L.instanceColor && (xt = L.instanceColor)),
          xt !== void 0)
        ) {
          const X = xt.normalized,
            ft = xt.itemSize,
            At = t.get(xt);
          if (At === void 0) continue;
          const Rt = At.buffer,
            ht = At.type,
            It = At.bytesPerElement,
            Pt = ht === i.INT || ht === i.UNSIGNED_INT || xt.gpuType === B0;
          if (xt.isInterleavedBufferAttribute) {
            const re = xt.data,
              ie = re.stride,
              Fe = xt.offset;
            if (re.isInstancedInterleavedBuffer) {
              for (let Ae = 0; Ae < et.locationSize; Ae++)
                S(et.location + Ae, re.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                nt._maxInstanceCount === void 0 &&
                (nt._maxInstanceCount = re.meshPerAttribute * re.count);
            } else
              for (let Ae = 0; Ae < et.locationSize; Ae++) E(et.location + Ae);
            i.bindBuffer(i.ARRAY_BUFFER, Rt);
            for (let Ae = 0; Ae < et.locationSize; Ae++)
              B(
                et.location + Ae,
                ft / et.locationSize,
                ht,
                X,
                ie * It,
                (Fe + (ft / et.locationSize) * Ae) * It,
                Pt
              );
          } else {
            if (xt.isInstancedBufferAttribute) {
              for (let re = 0; re < et.locationSize; re++)
                S(et.location + re, xt.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                nt._maxInstanceCount === void 0 &&
                (nt._maxInstanceCount = xt.meshPerAttribute * xt.count);
            } else
              for (let re = 0; re < et.locationSize; re++) E(et.location + re);
            i.bindBuffer(i.ARRAY_BUFFER, Rt);
            for (let re = 0; re < et.locationSize; re++)
              B(
                et.location + re,
                ft / et.locationSize,
                ht,
                X,
                ft * It,
                (ft / et.locationSize) * re * It,
                Pt
              );
          }
        } else if (j !== void 0) {
          const X = j[Q];
          if (X !== void 0)
            switch (X.length) {
              case 2:
                i.vertexAttrib2fv(et.location, X);
                break;
              case 3:
                i.vertexAttrib3fv(et.location, X);
                break;
              case 4:
                i.vertexAttrib4fv(et.location, X);
                break;
              default:
                i.vertexAttrib1fv(et.location, X);
            }
        }
      }
    }
    R();
  }
  function I() {
    F();
    for (const L in n) {
      const Y = n[L];
      for (const ct in Y) {
        const nt = Y[ct];
        for (const dt in nt) m(nt[dt].object), delete nt[dt];
        delete Y[ct];
      }
      delete n[L];
    }
  }
  function P(L) {
    if (n[L.id] === void 0) return;
    const Y = n[L.id];
    for (const ct in Y) {
      const nt = Y[ct];
      for (const dt in nt) m(nt[dt].object), delete nt[dt];
      delete Y[ct];
    }
    delete n[L.id];
  }
  function V(L) {
    for (const Y in n) {
      const ct = n[Y];
      if (ct[L.id] === void 0) continue;
      const nt = ct[L.id];
      for (const dt in nt) m(nt[dt].object), delete nt[dt];
      delete ct[L.id];
    }
  }
  function F() {
    N(), (l = !0), r !== a && ((r = a), p(r.object));
  }
  function N() {
    (a.geometry = null), (a.program = null), (a.wireframe = !1);
  }
  return {
    setup: u,
    reset: F,
    resetDefaultState: N,
    dispose: I,
    releaseStatesOfGeometry: P,
    releaseStatesOfProgram: V,
    initAttributes: C,
    enableAttribute: E,
    disableUnusedAttributes: R,
  };
}
function sP(i, t, e) {
  let n;
  function a(p) {
    n = p;
  }
  function r(p, m) {
    i.drawArrays(n, p, m), e.update(m, n, 1);
  }
  function l(p, m, v) {
    v !== 0 && (i.drawArraysInstanced(n, p, m, v), e.update(m, n, v));
  }
  function u(p, m, v) {
    if (v === 0) return;
    t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, p, 0, m, 0, v);
    let _ = 0;
    for (let M = 0; M < v; M++) _ += m[M];
    e.update(_, n, 1);
  }
  function h(p, m, v, x) {
    if (v === 0) return;
    const _ = t.get("WEBGL_multi_draw");
    if (_ === null) for (let M = 0; M < p.length; M++) l(p[M], m[M], x[M]);
    else {
      _.multiDrawArraysInstancedWEBGL(n, p, 0, m, 0, x, 0, v);
      let M = 0;
      for (let C = 0; C < v; C++) M += m[C] * x[C];
      e.update(M, n, 1);
    }
  }
  (this.setMode = a),
    (this.render = r),
    (this.renderInstances = l),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = h);
}
function rP(i, t, e, n) {
  let a;
  function r() {
    if (a !== void 0) return a;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const V = t.get("EXT_texture_filter_anisotropic");
      a = i.getParameter(V.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else a = 0;
    return a;
  }
  function l(V) {
    return !(
      V !== Ji &&
      n.convert(V) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function u(V) {
    const F =
      V === Ea &&
      (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
    return !(
      V !== Es &&
      n.convert(V) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) &&
      V !== Pi &&
      !F
    );
  }
  function h(V) {
    if (V === "highp") {
      if (
        i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision >
          0 &&
        i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      V = "mediump";
    }
    return V === "mediump" &&
      i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision >
        0 &&
      i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let p = e.precision !== void 0 ? e.precision : "highp";
  const m = h(p);
  m !== p &&
    (console.warn(
      "THREE.WebGLRenderer:",
      p,
      "not supported, using",
      m,
      "instead."
    ),
    (p = m));
  const v = e.logarithmicDepthBuffer === !0,
    x = e.reverseDepthBuffer === !0 && t.has("EXT_clip_control"),
    _ = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),
    M = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    C = i.getParameter(i.MAX_TEXTURE_SIZE),
    E = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),
    S = i.getParameter(i.MAX_VERTEX_ATTRIBS),
    R = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),
    B = i.getParameter(i.MAX_VARYING_VECTORS),
    D = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),
    I = M > 0,
    P = i.getParameter(i.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: r,
    getMaxPrecision: h,
    textureFormatReadable: l,
    textureTypeReadable: u,
    precision: p,
    logarithmicDepthBuffer: v,
    reverseDepthBuffer: x,
    maxTextures: _,
    maxVertexTextures: M,
    maxTextureSize: C,
    maxCubemapSize: E,
    maxAttributes: S,
    maxVertexUniforms: R,
    maxVaryings: B,
    maxFragmentUniforms: D,
    vertexTextures: I,
    maxSamples: P,
  };
}
function oP(i) {
  const t = this;
  let e = null,
    n = 0,
    a = !1,
    r = !1;
  const l = new Yl(),
    u = new yn(),
    h = { value: null, needsUpdate: !1 };
  (this.uniform = h),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (v, x) {
      const _ = v.length !== 0 || x || n !== 0 || a;
      return (a = x), (n = v.length), _;
    }),
    (this.beginShadows = function () {
      (r = !0), m(null);
    }),
    (this.endShadows = function () {
      r = !1;
    }),
    (this.setGlobalState = function (v, x) {
      e = m(v, x, 0);
    }),
    (this.setState = function (v, x, _) {
      const M = v.clippingPlanes,
        C = v.clipIntersection,
        E = v.clipShadows,
        S = i.get(v);
      if (!a || M === null || M.length === 0 || (r && !E)) r ? m(null) : p();
      else {
        const R = r ? 0 : n,
          B = R * 4;
        let D = S.clippingState || null;
        (h.value = D), (D = m(M, x, B, _));
        for (let I = 0; I !== B; ++I) D[I] = e[I];
        (S.clippingState = D),
          (this.numIntersection = C ? this.numPlanes : 0),
          (this.numPlanes += R);
      }
    });
  function p() {
    h.value !== e && ((h.value = e), (h.needsUpdate = n > 0)),
      (t.numPlanes = n),
      (t.numIntersection = 0);
  }
  function m(v, x, _, M) {
    const C = v !== null ? v.length : 0;
    let E = null;
    if (C !== 0) {
      if (((E = h.value), M !== !0 || E === null)) {
        const S = _ + C * 4,
          R = x.matrixWorldInverse;
        u.getNormalMatrix(R),
          (E === null || E.length < S) && (E = new Float32Array(S));
        for (let B = 0, D = _; B !== C; ++B, D += 4)
          l.copy(v[B]).applyMatrix4(R, u),
            l.normal.toArray(E, D),
            (E[D + 3] = l.constant);
      }
      (h.value = E), (h.needsUpdate = !0);
    }
    return (t.numPlanes = C), (t.numIntersection = 0), E;
  }
}
function lP(i) {
  let t = new WeakMap();
  function e(l, u) {
    return u === Vd ? (l.mapping = dl) : u === l0 && (l.mapping = uu), l;
  }
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping;
      if (u === Vd || u === l0)
        if (t.has(l)) {
          const h = t.get(l).texture;
          return e(h, l.mapping);
        } else {
          const h = l.image;
          if (h && h.height > 0) {
            const p = new jA(h.height);
            return (
              p.fromEquirectangularTexture(i, l),
              t.set(l, p),
              l.addEventListener("dispose", a),
              e(p.texture, l.mapping)
            );
          } else return null;
        }
    }
    return l;
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a);
    const h = t.get(u);
    h !== void 0 && (t.delete(u), h.dispose());
  }
  function r() {
    t = new WeakMap();
  }
  return { get: n, dispose: r };
}
const Dd = 4,
  xT = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Lf = 20,
  V_ = new Ir(),
  _T = new Se();
let k_ = null,
  j_ = 0,
  X_ = 0,
  W_ = !1;
const Of = (1 + Math.sqrt(5)) / 2,
  Ed = 1 / Of,
  bT = [
    new Z(-Of, Ed, 0),
    new Z(Of, Ed, 0),
    new Z(-Ed, 0, Of),
    new Z(Ed, 0, Of),
    new Z(0, Of, -Ed),
    new Z(0, Of, Ed),
    new Z(-1, 1, -1),
    new Z(1, 1, -1),
    new Z(-1, 1, 1),
    new Z(1, 1, 1),
  ],
  cP = new Z();
class Kb {
  constructor(t) {
    (this._renderer = t),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(t, e = 0, n = 0.1, a = 100, r = {}) {
    const { size: l = 256, position: u = cP } = r;
    (k_ = this._renderer.getRenderTarget()),
      (j_ = this._renderer.getActiveCubeFace()),
      (X_ = this._renderer.getActiveMipmapLevel()),
      (W_ = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(l);
    const h = this._allocateTargets();
    return (
      (h.depthBuffer = !0),
      this._sceneToCubeUV(t, n, a, h, u),
      e > 0 && this._blur(h, 0, 0, e),
      this._applyPMREM(h),
      this._cleanup(h),
      h
    );
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = MT()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = ST()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(t) {
    (this._lodMax = Math.floor(Math.log2(t))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(k_, j_, X_),
      (this._renderer.xr.enabled = W_),
      (t.scissorTest = !1),
      dy(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === dl || t.mapping === uu
      ? this._setSize(
          t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width
        )
      : this._setSize(t.image.width / 4),
      (k_ = this._renderer.getRenderTarget()),
      (j_ = this._renderer.getActiveCubeFace()),
      (X_ = this._renderer.getActiveMipmapLevel()),
      (W_ = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const n = e || this._allocateTargets();
    return (
      this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112),
      e = 4 * this._cubeSize,
      n = {
        magFilter: Kn,
        minFilter: Kn,
        generateMipmaps: !1,
        type: Ea,
        format: Ji,
        colorSpace: bo,
        depthBuffer: !1,
      },
      a = AT(t, e, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== t ||
      this._pingPongRenderTarget.height !== e
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = AT(t, e, n));
      const { _lodMax: r } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = uP(r)),
        (this._blurMaterial = fP(r, t, e));
    }
    return a;
  }
  _compileMaterial(t) {
    const e = new Ti(this._lodPlanes[0], t);
    this._renderer.compile(e, V_);
  }
  _sceneToCubeUV(t, e, n, a, r) {
    const h = new Ei(90, 1, e, n),
      p = [1, -1, 1, 1, 1, 1],
      m = [1, 1, 1, -1, -1, -1],
      v = this._renderer,
      x = v.autoClear,
      _ = v.toneMapping;
    v.getClearColor(_T), (v.toneMapping = ll), (v.autoClear = !1);
    const M = new ks({
        name: "PMREM.Background",
        side: Ms,
        depthWrite: !1,
        depthTest: !1,
      }),
      C = new Ti(new ah(), M);
    let E = !1;
    const S = t.background;
    S
      ? S.isColor && (M.color.copy(S), (t.background = null), (E = !0))
      : (M.color.copy(_T), (E = !0));
    for (let R = 0; R < 6; R++) {
      const B = R % 3;
      B === 0
        ? (h.up.set(0, p[R], 0),
          h.position.set(r.x, r.y, r.z),
          h.lookAt(r.x + m[R], r.y, r.z))
        : B === 1
        ? (h.up.set(0, 0, p[R]),
          h.position.set(r.x, r.y, r.z),
          h.lookAt(r.x, r.y + m[R], r.z))
        : (h.up.set(0, p[R], 0),
          h.position.set(r.x, r.y, r.z),
          h.lookAt(r.x, r.y, r.z + m[R]));
      const D = this._cubeSize;
      dy(a, B * D, R > 2 ? D : 0, D, D),
        v.setRenderTarget(a),
        E && v.render(C, h),
        v.render(t, h);
    }
    C.geometry.dispose(),
      C.material.dispose(),
      (v.toneMapping = _),
      (v.autoClear = x),
      (t.background = S);
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer,
      a = t.mapping === dl || t.mapping === uu;
    a
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = MT()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          t.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = ST());
    const r = a ? this._cubemapMaterial : this._equirectMaterial,
      l = new Ti(this._lodPlanes[0], r),
      u = r.uniforms;
    u.envMap.value = t;
    const h = this._cubeSize;
    dy(e, 0, 0, 3 * h, 2 * h), n.setRenderTarget(e), n.render(l, V_);
  }
  _applyPMREM(t) {
    const e = this._renderer,
      n = e.autoClear;
    e.autoClear = !1;
    const a = this._lodPlanes.length;
    for (let r = 1; r < a; r++) {
      const l = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        u = bT[(a - r - 1) % bT.length];
      this._blur(t, r - 1, r, l, u);
    }
    e.autoClear = n;
  }
  _blur(t, e, n, a, r) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(t, l, e, n, a, "latitudinal", r),
      this._halfBlur(l, t, n, n, a, "longitudinal", r);
  }
  _halfBlur(t, e, n, a, r, l, u) {
    const h = this._renderer,
      p = this._blurMaterial;
    l !== "latitudinal" &&
      l !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const m = 3,
      v = new Ti(this._lodPlanes[a], p),
      x = p.uniforms,
      _ = this._sizeLods[n] - 1,
      M = isFinite(r) ? Math.PI / (2 * _) : (2 * Math.PI) / (2 * Lf - 1),
      C = r / M,
      E = isFinite(r) ? 1 + Math.floor(m * C) : Lf;
    E > Lf &&
      console.warn(
        `sigmaRadians, ${r}, is too large and will clip, as it requested ${E} samples when the maximum is set to ${Lf}`
      );
    const S = [];
    let R = 0;
    for (let V = 0; V < Lf; ++V) {
      const F = V / C,
        N = Math.exp((-F * F) / 2);
      S.push(N), V === 0 ? (R += N) : V < E && (R += 2 * N);
    }
    for (let V = 0; V < S.length; V++) S[V] = S[V] / R;
    (x.envMap.value = t.texture),
      (x.samples.value = E),
      (x.weights.value = S),
      (x.latitudinal.value = l === "latitudinal"),
      u && (x.poleAxis.value = u);
    const { _lodMax: B } = this;
    (x.dTheta.value = M), (x.mipInt.value = B - n);
    const D = this._sizeLods[a],
      I = 3 * D * (a > B - Dd ? a - B + Dd : 0),
      P = 4 * (this._cubeSize - D);
    dy(e, I, P, 3 * D, 2 * D), h.setRenderTarget(e), h.render(v, V_);
  }
}
function uP(i) {
  const t = [],
    e = [],
    n = [];
  let a = i;
  const r = i - Dd + 1 + xT.length;
  for (let l = 0; l < r; l++) {
    const u = Math.pow(2, a);
    e.push(u);
    let h = 1 / u;
    l > i - Dd ? (h = xT[l - i + Dd - 1]) : l === 0 && (h = 0), n.push(h);
    const p = 1 / (u - 2),
      m = -p,
      v = 1 + p,
      x = [m, m, v, m, v, v, m, m, v, v, m, v],
      _ = 6,
      M = 6,
      C = 3,
      E = 2,
      S = 1,
      R = new Float32Array(C * M * _),
      B = new Float32Array(E * M * _),
      D = new Float32Array(S * M * _);
    for (let P = 0; P < _; P++) {
      const V = ((P % 3) * 2) / 3 - 1,
        F = P > 2 ? 0 : -1,
        N = [
          V,
          F,
          0,
          V + 2 / 3,
          F,
          0,
          V + 2 / 3,
          F + 1,
          0,
          V,
          F,
          0,
          V + 2 / 3,
          F + 1,
          0,
          V,
          F + 1,
          0,
        ];
      R.set(N, C * M * P), B.set(x, E * M * P);
      const L = [P, P, P, P, P, P];
      D.set(L, S * M * P);
    }
    const I = new pn();
    I.setAttribute("position", new Gn(R, C)),
      I.setAttribute("uv", new Gn(B, E)),
      I.setAttribute("faceIndex", new Gn(D, S)),
      t.push(I),
      a > Dd && a--;
  }
  return { lodPlanes: t, sizeLods: e, sigmas: n };
}
function AT(i, t, e) {
  const n = new zr(i, t, e);
  return (
    (n.texture.mapping = ip),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function dy(i, t, e, n, a) {
  i.viewport.set(t, e, n, a), i.scissor.set(t, e, n, a);
}
function fP(i, t, e) {
  const n = new Float32Array(Lf),
    a = new Z(0, 1, 0);
  return new Xs({
    name: "SphericalGaussianBlur",
    defines: {
      n: Lf,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${i}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: a },
    },
    vertexShader: bS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: ol,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ST() {
  return new Xs({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: bS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: ol,
    depthTest: !1,
    depthWrite: !1,
  });
}
function MT() {
  return new Xs({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: bS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: ol,
    depthTest: !1,
    depthWrite: !1,
  });
}
function bS() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function hP(i) {
  let t = new WeakMap(),
    e = null;
  function n(u) {
    if (u && u.isTexture) {
      const h = u.mapping,
        p = h === Vd || h === l0,
        m = h === dl || h === uu;
      if (p || m) {
        let v = t.get(u);
        const x = v !== void 0 ? v.texture.pmremVersion : 0;
        if (u.isRenderTargetTexture && u.pmremVersion !== x)
          return (
            e === null && (e = new Kb(i)),
            (v = p ? e.fromEquirectangular(u, v) : e.fromCubemap(u, v)),
            (v.texture.pmremVersion = u.pmremVersion),
            t.set(u, v),
            v.texture
          );
        if (v !== void 0) return v.texture;
        {
          const _ = u.image;
          return (p && _ && _.height > 0) || (m && _ && a(_))
            ? (e === null && (e = new Kb(i)),
              (v = p ? e.fromEquirectangular(u) : e.fromCubemap(u)),
              (v.texture.pmremVersion = u.pmremVersion),
              t.set(u, v),
              u.addEventListener("dispose", r),
              v.texture)
            : null;
        }
      }
    }
    return u;
  }
  function a(u) {
    let h = 0;
    const p = 6;
    for (let m = 0; m < p; m++) u[m] !== void 0 && h++;
    return h === p;
  }
  function r(u) {
    const h = u.target;
    h.removeEventListener("dispose", r);
    const p = t.get(h);
    p !== void 0 && (t.delete(h), p.dispose());
  }
  function l() {
    (t = new WeakMap()), e !== null && (e.dispose(), (e = null));
  }
  return { get: n, dispose: l };
}
function dP(i) {
  const t = {};
  function e(n) {
    if (t[n] !== void 0) return t[n];
    let a;
    switch (n) {
      case "WEBGL_depth_texture":
        a =
          i.getExtension("WEBGL_depth_texture") ||
          i.getExtension("MOZ_WEBGL_depth_texture") ||
          i.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        a =
          i.getExtension("EXT_texture_filter_anisotropic") ||
          i.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        a =
          i.getExtension("WEBGL_compressed_texture_s3tc") ||
          i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        a =
          i.getExtension("WEBGL_compressed_texture_pvrtc") ||
          i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        a = i.getExtension(n);
    }
    return (t[n] = a), a;
  }
  return {
    has: function (n) {
      return e(n) !== null;
    },
    init: function () {
      e("EXT_color_buffer_float"),
        e("WEBGL_clip_cull_distance"),
        e("OES_texture_float_linear"),
        e("EXT_color_buffer_half_float"),
        e("WEBGL_multisampled_render_to_texture"),
        e("WEBGL_render_shared_exponent");
    },
    get: function (n) {
      const a = e(n);
      return (
        a === null &&
          zd("THREE.WebGLRenderer: " + n + " extension not supported."),
        a
      );
    },
  };
}
function pP(i, t, e, n) {
  const a = {},
    r = new WeakMap();
  function l(v) {
    const x = v.target;
    x.index !== null && t.remove(x.index);
    for (const M in x.attributes) t.remove(x.attributes[M]);
    x.removeEventListener("dispose", l), delete a[x.id];
    const _ = r.get(x);
    _ && (t.remove(_), r.delete(x)),
      n.releaseStatesOfGeometry(x),
      x.isInstancedBufferGeometry === !0 && delete x._maxInstanceCount,
      e.memory.geometries--;
  }
  function u(v, x) {
    return (
      a[x.id] === !0 ||
        (x.addEventListener("dispose", l),
        (a[x.id] = !0),
        e.memory.geometries++),
      x
    );
  }
  function h(v) {
    const x = v.attributes;
    for (const _ in x) t.update(x[_], i.ARRAY_BUFFER);
  }
  function p(v) {
    const x = [],
      _ = v.index,
      M = v.attributes.position;
    let C = 0;
    if (_ !== null) {
      const R = _.array;
      C = _.version;
      for (let B = 0, D = R.length; B < D; B += 3) {
        const I = R[B + 0],
          P = R[B + 1],
          V = R[B + 2];
        x.push(I, P, P, V, V, I);
      }
    } else if (M !== void 0) {
      const R = M.array;
      C = M.version;
      for (let B = 0, D = R.length / 3 - 1; B < D; B += 3) {
        const I = B + 0,
          P = B + 1,
          V = B + 2;
        x.push(I, P, P, V, V, I);
      }
    } else return;
    const E = new (LC(x) ? kA : VA)(x, 1);
    E.version = C;
    const S = r.get(v);
    S && t.remove(S), r.set(v, E);
  }
  function m(v) {
    const x = r.get(v);
    if (x) {
      const _ = v.index;
      _ !== null && x.version < _.version && p(v);
    } else p(v);
    return r.get(v);
  }
  return { get: u, update: h, getWireframeAttribute: m };
}
function mP(i, t, e) {
  let n;
  function a(x) {
    n = x;
  }
  let r, l;
  function u(x) {
    (r = x.type), (l = x.bytesPerElement);
  }
  function h(x, _) {
    i.drawElements(n, _, r, x * l), e.update(_, n, 1);
  }
  function p(x, _, M) {
    M !== 0 && (i.drawElementsInstanced(n, _, r, x * l, M), e.update(_, n, M));
  }
  function m(x, _, M) {
    if (M === 0) return;
    t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, _, 0, r, x, 0, M);
    let E = 0;
    for (let S = 0; S < M; S++) E += _[S];
    e.update(E, n, 1);
  }
  function v(x, _, M, C) {
    if (M === 0) return;
    const E = t.get("WEBGL_multi_draw");
    if (E === null) for (let S = 0; S < x.length; S++) p(x[S] / l, _[S], C[S]);
    else {
      E.multiDrawElementsInstancedWEBGL(n, _, 0, r, x, 0, C, 0, M);
      let S = 0;
      for (let R = 0; R < M; R++) S += _[R] * C[R];
      e.update(S, n, 1);
    }
  }
  (this.setMode = a),
    (this.setIndex = u),
    (this.render = h),
    (this.renderInstances = p),
    (this.renderMultiDraw = m),
    (this.renderMultiDrawInstances = v);
}
function gP(i) {
  const t = { geometries: 0, textures: 0 },
    e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(r, l, u) {
    switch ((e.calls++, l)) {
      case i.TRIANGLES:
        e.triangles += u * (r / 3);
        break;
      case i.LINES:
        e.lines += u * (r / 2);
        break;
      case i.LINE_STRIP:
        e.lines += u * (r - 1);
        break;
      case i.LINE_LOOP:
        e.lines += u * r;
        break;
      case i.POINTS:
        e.points += u * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function a() {
    (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
  }
  return {
    memory: t,
    render: e,
    programs: null,
    autoReset: !0,
    reset: a,
    update: n,
  };
}
function vP(i, t, e) {
  const n = new WeakMap(),
    a = new Hn();
  function r(l, u, h) {
    const p = l.morphTargetInfluences,
      m =
        u.morphAttributes.position ||
        u.morphAttributes.normal ||
        u.morphAttributes.color,
      v = m !== void 0 ? m.length : 0;
    let x = n.get(u);
    if (x === void 0 || x.count !== v) {
      let L = function () {
        F.dispose(), n.delete(u), u.removeEventListener("dispose", L);
      };
      var _ = L;
      x !== void 0 && x.texture.dispose();
      const M = u.morphAttributes.position !== void 0,
        C = u.morphAttributes.normal !== void 0,
        E = u.morphAttributes.color !== void 0,
        S = u.morphAttributes.position || [],
        R = u.morphAttributes.normal || [],
        B = u.morphAttributes.color || [];
      let D = 0;
      M === !0 && (D = 1), C === !0 && (D = 2), E === !0 && (D = 3);
      let I = u.attributes.position.count * D,
        P = 1;
      I > t.maxTextureSize &&
        ((P = Math.ceil(I / t.maxTextureSize)), (I = t.maxTextureSize));
      const V = new Float32Array(I * P * 4 * v),
        F = new Gx(V, I, P, v);
      (F.type = Pi), (F.needsUpdate = !0);
      const N = D * 4;
      for (let Y = 0; Y < v; Y++) {
        const ct = S[Y],
          nt = R[Y],
          dt = B[Y],
          pt = I * P * 4 * Y;
        for (let j = 0; j < ct.count; j++) {
          const Q = j * N;
          M === !0 &&
            (a.fromBufferAttribute(ct, j),
            (V[pt + Q + 0] = a.x),
            (V[pt + Q + 1] = a.y),
            (V[pt + Q + 2] = a.z),
            (V[pt + Q + 3] = 0)),
            C === !0 &&
              (a.fromBufferAttribute(nt, j),
              (V[pt + Q + 4] = a.x),
              (V[pt + Q + 5] = a.y),
              (V[pt + Q + 6] = a.z),
              (V[pt + Q + 7] = 0)),
            E === !0 &&
              (a.fromBufferAttribute(dt, j),
              (V[pt + Q + 8] = a.x),
              (V[pt + Q + 9] = a.y),
              (V[pt + Q + 10] = a.z),
              (V[pt + Q + 11] = dt.itemSize === 4 ? a.w : 1));
        }
      }
      (x = { count: v, texture: F, size: new Yt(I, P) }),
        n.set(u, x),
        u.addEventListener("dispose", L);
    }
    if (l.isInstancedMesh === !0 && l.morphTexture !== null)
      h.getUniforms().setValue(i, "morphTexture", l.morphTexture, e);
    else {
      let M = 0;
      for (let E = 0; E < p.length; E++) M += p[E];
      const C = u.morphTargetsRelative ? 1 : 1 - M;
      h.getUniforms().setValue(i, "morphTargetBaseInfluence", C),
        h.getUniforms().setValue(i, "morphTargetInfluences", p);
    }
    h.getUniforms().setValue(i, "morphTargetsTexture", x.texture, e),
      h.getUniforms().setValue(i, "morphTargetsTextureSize", x.size);
  }
  return { update: r };
}
function yP(i, t, e, n) {
  let a = new WeakMap();
  function r(h) {
    const p = n.render.frame,
      m = h.geometry,
      v = t.get(h, m);
    if (
      (a.get(v) !== p && (t.update(v), a.set(v, p)),
      h.isInstancedMesh &&
        (h.hasEventListener("dispose", u) === !1 &&
          h.addEventListener("dispose", u),
        a.get(h) !== p &&
          (e.update(h.instanceMatrix, i.ARRAY_BUFFER),
          h.instanceColor !== null && e.update(h.instanceColor, i.ARRAY_BUFFER),
          a.set(h, p))),
      h.isSkinnedMesh)
    ) {
      const x = h.skeleton;
      a.get(x) !== p && (x.update(), a.set(x, p));
    }
    return v;
  }
  function l() {
    a = new WeakMap();
  }
  function u(h) {
    const p = h.target;
    p.removeEventListener("dispose", u),
      e.remove(p.instanceMatrix),
      p.instanceColor !== null && e.remove(p.instanceColor);
  }
  return { update: r, dispose: l };
}
const LR = new Zn(),
  ET = new JA(1, 1),
  IR = new Gx(),
  PR = new Vx(),
  zR = new O0(),
  TT = [],
  wT = [],
  CT = new Float32Array(16),
  RT = new Float32Array(9),
  BT = new Float32Array(4);
function rp(i, t, e) {
  const n = i[0];
  if (n <= 0 || n > 0) return i;
  const a = t * e;
  let r = TT[a];
  if ((r === void 0 && ((r = new Float32Array(a)), (TT[a] = r)), t !== 0)) {
    n.toArray(r, 0);
    for (let l = 1, u = 0; l !== t; ++l) (u += e), i[l].toArray(r, u);
  }
  return r;
}
function ga(i, t) {
  if (i.length !== t.length) return !1;
  for (let e = 0, n = i.length; e < n; e++) if (i[e] !== t[e]) return !1;
  return !0;
}
function va(i, t) {
  for (let e = 0, n = t.length; e < n; e++) i[e] = t[e];
}
function u1(i, t) {
  let e = wT[t];
  e === void 0 && ((e = new Int32Array(t)), (wT[t] = e));
  for (let n = 0; n !== t; ++n) e[n] = i.allocateTextureUnit();
  return e;
}
function xP(i, t) {
  const e = this.cache;
  e[0] !== t && (i.uniform1f(this.addr, t), (e[0] = t));
}
function _P(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (i.uniform2f(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
  else {
    if (ga(e, t)) return;
    i.uniform2fv(this.addr, t), va(e, t);
  }
}
function bP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (i.uniform3f(this.addr, t.x, t.y, t.z),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z));
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) &&
      (i.uniform3f(this.addr, t.r, t.g, t.b),
      (e[0] = t.r),
      (e[1] = t.g),
      (e[2] = t.b));
  else {
    if (ga(e, t)) return;
    i.uniform3fv(this.addr, t), va(e, t);
  }
}
function AP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (i.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w));
  else {
    if (ga(e, t)) return;
    i.uniform4fv(this.addr, t), va(e, t);
  }
}
function SP(i, t) {
  const e = this.cache,
    n = t.elements;
  if (n === void 0) {
    if (ga(e, t)) return;
    i.uniformMatrix2fv(this.addr, !1, t), va(e, t);
  } else {
    if (ga(e, n)) return;
    BT.set(n), i.uniformMatrix2fv(this.addr, !1, BT), va(e, n);
  }
}
function MP(i, t) {
  const e = this.cache,
    n = t.elements;
  if (n === void 0) {
    if (ga(e, t)) return;
    i.uniformMatrix3fv(this.addr, !1, t), va(e, t);
  } else {
    if (ga(e, n)) return;
    RT.set(n), i.uniformMatrix3fv(this.addr, !1, RT), va(e, n);
  }
}
function EP(i, t) {
  const e = this.cache,
    n = t.elements;
  if (n === void 0) {
    if (ga(e, t)) return;
    i.uniformMatrix4fv(this.addr, !1, t), va(e, t);
  } else {
    if (ga(e, n)) return;
    CT.set(n), i.uniformMatrix4fv(this.addr, !1, CT), va(e, n);
  }
}
function TP(i, t) {
  const e = this.cache;
  e[0] !== t && (i.uniform1i(this.addr, t), (e[0] = t));
}
function wP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (i.uniform2i(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
  else {
    if (ga(e, t)) return;
    i.uniform2iv(this.addr, t), va(e, t);
  }
}
function CP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (i.uniform3i(this.addr, t.x, t.y, t.z),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z));
  else {
    if (ga(e, t)) return;
    i.uniform3iv(this.addr, t), va(e, t);
  }
}
function RP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (i.uniform4i(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w));
  else {
    if (ga(e, t)) return;
    i.uniform4iv(this.addr, t), va(e, t);
  }
}
function BP(i, t) {
  const e = this.cache;
  e[0] !== t && (i.uniform1ui(this.addr, t), (e[0] = t));
}
function DP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (i.uniform2ui(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
  else {
    if (ga(e, t)) return;
    i.uniform2uiv(this.addr, t), va(e, t);
  }
}
function UP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (i.uniform3ui(this.addr, t.x, t.y, t.z),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z));
  else {
    if (ga(e, t)) return;
    i.uniform3uiv(this.addr, t), va(e, t);
  }
}
function OP(i, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (i.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w));
  else {
    if (ga(e, t)) return;
    i.uniform4uiv(this.addr, t), va(e, t);
  }
}
function NP(i, t, e) {
  const n = this.cache,
    a = e.allocateTextureUnit();
  n[0] !== a && (i.uniform1i(this.addr, a), (n[0] = a));
  let r;
  this.type === i.SAMPLER_2D_SHADOW
    ? ((ET.compareFunction = FA), (r = ET))
    : (r = LR),
    e.setTexture2D(t || r, a);
}
function LP(i, t, e) {
  const n = this.cache,
    a = e.allocateTextureUnit();
  n[0] !== a && (i.uniform1i(this.addr, a), (n[0] = a)),
    e.setTexture3D(t || PR, a);
}
function IP(i, t, e) {
  const n = this.cache,
    a = e.allocateTextureUnit();
  n[0] !== a && (i.uniform1i(this.addr, a), (n[0] = a)),
    e.setTextureCube(t || zR, a);
}
function PP(i, t, e) {
  const n = this.cache,
    a = e.allocateTextureUnit();
  n[0] !== a && (i.uniform1i(this.addr, a), (n[0] = a)),
    e.setTexture2DArray(t || IR, a);
}
function zP(i) {
  switch (i) {
    case 5126:
      return xP;
    case 35664:
      return _P;
    case 35665:
      return bP;
    case 35666:
      return AP;
    case 35674:
      return SP;
    case 35675:
      return MP;
    case 35676:
      return EP;
    case 5124:
    case 35670:
      return TP;
    case 35667:
    case 35671:
      return wP;
    case 35668:
    case 35672:
      return CP;
    case 35669:
    case 35673:
      return RP;
    case 5125:
      return BP;
    case 36294:
      return DP;
    case 36295:
      return UP;
    case 36296:
      return OP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return NP;
    case 35679:
    case 36299:
    case 36307:
      return LP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return IP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return PP;
  }
}
function FP(i, t) {
  i.uniform1fv(this.addr, t);
}
function HP(i, t) {
  const e = rp(t, this.size, 2);
  i.uniform2fv(this.addr, e);
}
function GP(i, t) {
  const e = rp(t, this.size, 3);
  i.uniform3fv(this.addr, e);
}
function VP(i, t) {
  const e = rp(t, this.size, 4);
  i.uniform4fv(this.addr, e);
}
function kP(i, t) {
  const e = rp(t, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, e);
}
function jP(i, t) {
  const e = rp(t, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, e);
}
function XP(i, t) {
  const e = rp(t, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, e);
}
function WP(i, t) {
  i.uniform1iv(this.addr, t);
}
function YP(i, t) {
  i.uniform2iv(this.addr, t);
}
function qP(i, t) {
  i.uniform3iv(this.addr, t);
}
function KP(i, t) {
  i.uniform4iv(this.addr, t);
}
function JP(i, t) {
  i.uniform1uiv(this.addr, t);
}
function ZP(i, t) {
  i.uniform2uiv(this.addr, t);
}
function QP(i, t) {
  i.uniform3uiv(this.addr, t);
}
function $P(i, t) {
  i.uniform4uiv(this.addr, t);
}
function t5(i, t, e) {
  const n = this.cache,
    a = t.length,
    r = u1(e, a);
  ga(n, r) || (i.uniform1iv(this.addr, r), va(n, r));
  for (let l = 0; l !== a; ++l) e.setTexture2D(t[l] || LR, r[l]);
}
function e5(i, t, e) {
  const n = this.cache,
    a = t.length,
    r = u1(e, a);
  ga(n, r) || (i.uniform1iv(this.addr, r), va(n, r));
  for (let l = 0; l !== a; ++l) e.setTexture3D(t[l] || PR, r[l]);
}
function n5(i, t, e) {
  const n = this.cache,
    a = t.length,
    r = u1(e, a);
  ga(n, r) || (i.uniform1iv(this.addr, r), va(n, r));
  for (let l = 0; l !== a; ++l) e.setTextureCube(t[l] || zR, r[l]);
}
function i5(i, t, e) {
  const n = this.cache,
    a = t.length,
    r = u1(e, a);
  ga(n, r) || (i.uniform1iv(this.addr, r), va(n, r));
  for (let l = 0; l !== a; ++l) e.setTexture2DArray(t[l] || IR, r[l]);
}
function a5(i) {
  switch (i) {
    case 5126:
      return FP;
    case 35664:
      return HP;
    case 35665:
      return GP;
    case 35666:
      return VP;
    case 35674:
      return kP;
    case 35675:
      return jP;
    case 35676:
      return XP;
    case 5124:
    case 35670:
      return WP;
    case 35667:
    case 35671:
      return YP;
    case 35668:
    case 35672:
      return qP;
    case 35669:
    case 35673:
      return KP;
    case 5125:
      return JP;
    case 36294:
      return ZP;
    case 36295:
      return QP;
    case 36296:
      return $P;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return t5;
    case 35679:
    case 36299:
    case 36307:
      return e5;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return n5;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return i5;
  }
}
class s5 {
  constructor(t, e, n) {
    (this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.type = e.type),
      (this.setValue = zP(e.type));
  }
}
class r5 {
  constructor(t, e, n) {
    (this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.type = e.type),
      (this.size = e.size),
      (this.setValue = a5(e.type));
  }
}
class o5 {
  constructor(t) {
    (this.id = t), (this.seq = []), (this.map = {});
  }
  setValue(t, e, n) {
    const a = this.seq;
    for (let r = 0, l = a.length; r !== l; ++r) {
      const u = a[r];
      u.setValue(t, e[u.id], n);
    }
  }
}
const Y_ = /(\w+)(\])?(\[|\.)?/g;
function DT(i, t) {
  i.seq.push(t), (i.map[t.id] = t);
}
function l5(i, t, e) {
  const n = i.name,
    a = n.length;
  for (Y_.lastIndex = 0; ; ) {
    const r = Y_.exec(n),
      l = Y_.lastIndex;
    let u = r[1];
    const h = r[2] === "]",
      p = r[3];
    if ((h && (u = u | 0), p === void 0 || (p === "[" && l + 2 === a))) {
      DT(e, p === void 0 ? new s5(u, i, t) : new r5(u, i, t));
      break;
    } else {
      let v = e.map[u];
      v === void 0 && ((v = new o5(u)), DT(e, v)), (e = v);
    }
  }
}
class wy {
  constructor(t, e) {
    (this.seq = []), (this.map = {});
    const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let a = 0; a < n; ++a) {
      const r = t.getActiveUniform(e, a),
        l = t.getUniformLocation(e, r.name);
      l5(r, l, this);
    }
  }
  setValue(t, e, n, a) {
    const r = this.map[e];
    r !== void 0 && r.setValue(t, n, a);
  }
  setOptional(t, e, n) {
    const a = e[n];
    a !== void 0 && this.setValue(t, n, a);
  }
  static upload(t, e, n, a) {
    for (let r = 0, l = e.length; r !== l; ++r) {
      const u = e[r],
        h = n[u.id];
      h.needsUpdate !== !1 && u.setValue(t, h.value, a);
    }
  }
  static seqWithValue(t, e) {
    const n = [];
    for (let a = 0, r = t.length; a !== r; ++a) {
      const l = t[a];
      l.id in e && n.push(l);
    }
    return n;
  }
}
function UT(i, t, e) {
  const n = i.createShader(t);
  return i.shaderSource(n, e), i.compileShader(n), n;
}
const c5 = 37297;
let u5 = 0;
function f5(i, t) {
  const e = i.split(`
`),
    n = [],
    a = Math.max(t - 6, 0),
    r = Math.min(t + 6, e.length);
  for (let l = a; l < r; l++) {
    const u = l + 1;
    n.push(`${u === t ? ">" : " "} ${u}: ${e[l]}`);
  }
  return n.join(`
`);
}
const OT = new yn();
function h5(i) {
  In._getMatrix(OT, In.workingColorSpace, i);
  const t = `mat3( ${OT.elements.map((e) => e.toFixed(4))} )`;
  switch (In.getTransfer(i)) {
    case u0:
      return [t, "LinearTransferOETF"];
    case ai:
      return [t, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", i),
        [t, "LinearTransferOETF"]
      );
  }
}
function NT(i, t, e) {
  const n = i.getShaderParameter(t, i.COMPILE_STATUS),
    a = i.getShaderInfoLog(t).trim();
  if (n && a === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(a);
  if (r) {
    const l = parseInt(r[1]);
    return (
      e.toUpperCase() +
      `

` +
      a +
      `

` +
      f5(i.getShaderSource(t), l)
    );
  } else return a;
}
function d5(i, t) {
  const e = h5(t);
  return [
    `vec4 ${i}( vec4 value ) {`,
    `	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function p5(i, t) {
  let e;
  switch (t) {
    case pC:
      e = "Linear";
      break;
    case mC:
      e = "Reinhard";
      break;
    case gC:
      e = "Cineon";
      break;
    case BA:
      e = "ACESFilmic";
      break;
    case yC:
      e = "AgX";
      break;
    case xC:
      e = "Neutral";
      break;
    case vC:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
        (e = "Linear");
  }
  return (
    "vec3 " + i + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
  );
}
const py = new Z();
function m5() {
  In.getLuminanceCoefficients(py);
  const i = py.x.toFixed(4),
    t = py.y.toFixed(4),
    e = py.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${i}, ${t}, ${e} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function g5(i) {
  return [
    i.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(jm).join(`
`);
}
function v5(i) {
  const t = [];
  for (const e in i) {
    const n = i[e];
    n !== !1 && t.push("#define " + e + " " + n);
  }
  return t.join(`
`);
}
function y5(i, t) {
  const e = {},
    n = i.getProgramParameter(t, i.ACTIVE_ATTRIBUTES);
  for (let a = 0; a < n; a++) {
    const r = i.getActiveAttrib(t, a),
      l = r.name;
    let u = 1;
    r.type === i.FLOAT_MAT2 && (u = 2),
      r.type === i.FLOAT_MAT3 && (u = 3),
      r.type === i.FLOAT_MAT4 && (u = 4),
      (e[l] = {
        type: r.type,
        location: i.getAttribLocation(t, l),
        locationSize: u,
      });
  }
  return e;
}
function jm(i) {
  return i !== "";
}
function LT(i, t) {
  const e =
    t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return i
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, e)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function IT(i, t) {
  return i
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      t.numClippingPlanes - t.numClipIntersection
    );
}
const x5 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Jb(i) {
  return i.replace(x5, b5);
}
const _5 = new Map();
function b5(i, t) {
  let e = Sn[t];
  if (e === void 0) {
    const n = _5.get(t);
    if (n !== void 0)
      (e = Sn[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          t,
          n
        );
    else throw new Error("Can not resolve #include <" + t + ">");
  }
  return Jb(e);
}
const A5 =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function PT(i) {
  return i.replace(A5, S5);
}
function S5(i, t, e, n) {
  let a = "";
  for (let r = parseInt(t); r < parseInt(e); r++)
    a += n
      .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, r);
  return a;
}
function zT(i) {
  let t = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
  return (
    i.precision === "highp"
      ? (t += `
#define HIGH_PRECISION`)
      : i.precision === "mediump"
      ? (t += `
#define MEDIUM_PRECISION`)
      : i.precision === "lowp" &&
        (t += `
#define LOW_PRECISION`),
    t
  );
}
function M5(i) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return (
    i.shadowMapType === Ux
      ? (t = "SHADOWMAP_TYPE_PCF")
      : i.shadowMapType === Wm
      ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
      : i.shadowMapType === vo && (t = "SHADOWMAP_TYPE_VSM"),
    t
  );
}
function E5(i) {
  let t = "ENVMAP_TYPE_CUBE";
  if (i.envMap)
    switch (i.envMapMode) {
      case dl:
      case uu:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case ip:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return t;
}
function T5(i) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (i.envMap)
    switch (i.envMapMode) {
      case uu:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
function w5(i) {
  let t = "ENVMAP_BLENDING_NONE";
  if (i.envMap)
    switch (i.combine) {
      case R0:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case hC:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case dC:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
function C5(i) {
  const t = i.envMapCubeUVHeight;
  if (t === null) return null;
  const e = Math.log2(t) - 2,
    n = 1 / t;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
    texelHeight: n,
    maxMip: e,
  };
}
function R5(i, t, e, n) {
  const a = i.getContext(),
    r = e.defines;
  let l = e.vertexShader,
    u = e.fragmentShader;
  const h = M5(e),
    p = E5(e),
    m = T5(e),
    v = w5(e),
    x = C5(e),
    _ = g5(e),
    M = v5(r),
    C = a.createProgram();
  let E,
    S,
    R = e.glslVersion
      ? "#version " +
        e.glslVersion +
        `
`
      : "";
  e.isRawShaderMaterial
    ? ((E = [
        "#define SHADER_TYPE " + e.shaderType,
        "#define SHADER_NAME " + e.shaderName,
        M,
      ].filter(jm).join(`
`)),
      E.length > 0 &&
        (E += `
`),
      (S = [
        "#define SHADER_TYPE " + e.shaderType,
        "#define SHADER_NAME " + e.shaderName,
        M,
      ].filter(jm).join(`
`)),
      S.length > 0 &&
        (S += `
`))
    : ((E = [
        zT(e),
        "#define SHADER_TYPE " + e.shaderType,
        "#define SHADER_NAME " + e.shaderName,
        M,
        e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        e.batching ? "#define USE_BATCHING" : "",
        e.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        e.instancing ? "#define USE_INSTANCING" : "",
        e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        e.useFog && e.fog ? "#define USE_FOG" : "",
        e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
        e.map ? "#define USE_MAP" : "",
        e.envMap ? "#define USE_ENVMAP" : "",
        e.envMap ? "#define " + m : "",
        e.lightMap ? "#define USE_LIGHTMAP" : "",
        e.aoMap ? "#define USE_AOMAP" : "",
        e.bumpMap ? "#define USE_BUMPMAP" : "",
        e.normalMap ? "#define USE_NORMALMAP" : "",
        e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        e.anisotropy ? "#define USE_ANISOTROPY" : "",
        e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        e.specularMap ? "#define USE_SPECULARMAP" : "",
        e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        e.metalnessMap ? "#define USE_METALNESSMAP" : "",
        e.alphaMap ? "#define USE_ALPHAMAP" : "",
        e.alphaHash ? "#define USE_ALPHAHASH" : "",
        e.transmission ? "#define USE_TRANSMISSION" : "",
        e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        e.mapUv ? "#define MAP_UV " + e.mapUv : "",
        e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
        e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
        e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
        e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
        e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
        e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
        e.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv
          : "",
        e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
        e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
        e.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv
          : "",
        e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
        e.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv
          : "",
        e.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv
          : "",
        e.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv
          : "",
        e.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv
          : "",
        e.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv
          : "",
        e.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv
          : "",
        e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
        e.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv
          : "",
        e.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv
          : "",
        e.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv
          : "",
        e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
        e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
        e.vertexColors ? "#define USE_COLOR" : "",
        e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        e.vertexUv1s ? "#define USE_UV1" : "",
        e.vertexUv2s ? "#define USE_UV2" : "",
        e.vertexUv3s ? "#define USE_UV3" : "",
        e.pointsUvs ? "#define USE_POINTS_UV" : "",
        e.flatShading ? "#define FLAT_SHADED" : "",
        e.skinning ? "#define USE_SKINNING" : "",
        e.morphTargets ? "#define USE_MORPHTARGETS" : "",
        e.morphNormals && e.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        e.morphColors ? "#define USE_MORPHCOLORS" : "",
        e.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride
          : "",
        e.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount
          : "",
        e.doubleSided ? "#define DOUBLE_SIDED" : "",
        e.flipSided ? "#define FLIP_SIDED" : "",
        e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        e.shadowMapEnabled ? "#define " + h : "",
        e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(jm).join(`
`)),
      (S = [
        zT(e),
        "#define SHADER_TYPE " + e.shaderType,
        "#define SHADER_NAME " + e.shaderName,
        M,
        e.useFog && e.fog ? "#define USE_FOG" : "",
        e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
        e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        e.map ? "#define USE_MAP" : "",
        e.matcap ? "#define USE_MATCAP" : "",
        e.envMap ? "#define USE_ENVMAP" : "",
        e.envMap ? "#define " + p : "",
        e.envMap ? "#define " + m : "",
        e.envMap ? "#define " + v : "",
        x ? "#define CUBEUV_TEXEL_WIDTH " + x.texelWidth : "",
        x ? "#define CUBEUV_TEXEL_HEIGHT " + x.texelHeight : "",
        x ? "#define CUBEUV_MAX_MIP " + x.maxMip + ".0" : "",
        e.lightMap ? "#define USE_LIGHTMAP" : "",
        e.aoMap ? "#define USE_AOMAP" : "",
        e.bumpMap ? "#define USE_BUMPMAP" : "",
        e.normalMap ? "#define USE_NORMALMAP" : "",
        e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        e.anisotropy ? "#define USE_ANISOTROPY" : "",
        e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        e.clearcoat ? "#define USE_CLEARCOAT" : "",
        e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        e.dispersion ? "#define USE_DISPERSION" : "",
        e.iridescence ? "#define USE_IRIDESCENCE" : "",
        e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        e.specularMap ? "#define USE_SPECULARMAP" : "",
        e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        e.metalnessMap ? "#define USE_METALNESSMAP" : "",
        e.alphaMap ? "#define USE_ALPHAMAP" : "",
        e.alphaTest ? "#define USE_ALPHATEST" : "",
        e.alphaHash ? "#define USE_ALPHAHASH" : "",
        e.sheen ? "#define USE_SHEEN" : "",
        e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        e.transmission ? "#define USE_TRANSMISSION" : "",
        e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
        e.vertexColors || e.instancingColor || e.batchingColor
          ? "#define USE_COLOR"
          : "",
        e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        e.vertexUv1s ? "#define USE_UV1" : "",
        e.vertexUv2s ? "#define USE_UV2" : "",
        e.vertexUv3s ? "#define USE_UV3" : "",
        e.pointsUvs ? "#define USE_POINTS_UV" : "",
        e.gradientMap ? "#define USE_GRADIENTMAP" : "",
        e.flatShading ? "#define FLAT_SHADED" : "",
        e.doubleSided ? "#define DOUBLE_SIDED" : "",
        e.flipSided ? "#define FLIP_SIDED" : "",
        e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        e.shadowMapEnabled ? "#define " + h : "",
        e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        e.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        e.toneMapping !== ll ? "#define TONE_MAPPING" : "",
        e.toneMapping !== ll ? Sn.tonemapping_pars_fragment : "",
        e.toneMapping !== ll ? p5("toneMapping", e.toneMapping) : "",
        e.dithering ? "#define DITHERING" : "",
        e.opaque ? "#define OPAQUE" : "",
        Sn.colorspace_pars_fragment,
        d5("linearToOutputTexel", e.outputColorSpace),
        m5(),
        e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
        `
`,
      ].filter(jm).join(`
`))),
    (l = Jb(l)),
    (l = LT(l, e)),
    (l = IT(l, e)),
    (u = Jb(u)),
    (u = LT(u, e)),
    (u = IT(u, e)),
    (l = PT(l)),
    (u = PT(u)),
    e.isRawShaderMaterial !== !0 &&
      ((R = `#version 300 es
`),
      (E =
        [
          _,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        E),
      (S =
        [
          "#define varying in",
          e.glslVersion === Gb
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          e.glslVersion === Gb ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        S));
  const B = R + E + l,
    D = R + S + u,
    I = UT(a, a.VERTEX_SHADER, B),
    P = UT(a, a.FRAGMENT_SHADER, D);
  a.attachShader(C, I),
    a.attachShader(C, P),
    e.index0AttributeName !== void 0
      ? a.bindAttribLocation(C, 0, e.index0AttributeName)
      : e.morphTargets === !0 && a.bindAttribLocation(C, 0, "position"),
    a.linkProgram(C);
  function V(Y) {
    if (i.debug.checkShaderErrors) {
      const ct = a.getProgramInfoLog(C).trim(),
        nt = a.getShaderInfoLog(I).trim(),
        dt = a.getShaderInfoLog(P).trim();
      let pt = !0,
        j = !0;
      if (a.getProgramParameter(C, a.LINK_STATUS) === !1)
        if (((pt = !1), typeof i.debug.onShaderError == "function"))
          i.debug.onShaderError(a, C, I, P);
        else {
          const Q = NT(a, I, "vertex"),
            et = NT(a, P, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              a.getError() +
              " - VALIDATE_STATUS " +
              a.getProgramParameter(C, a.VALIDATE_STATUS) +
              `

Material Name: ` +
              Y.name +
              `
Material Type: ` +
              Y.type +
              `

Program Info Log: ` +
              ct +
              `
` +
              Q +
              `
` +
              et
          );
        }
      else
        ct !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", ct)
          : (nt === "" || dt === "") && (j = !1);
      j &&
        (Y.diagnostics = {
          runnable: pt,
          programLog: ct,
          vertexShader: { log: nt, prefix: E },
          fragmentShader: { log: dt, prefix: S },
        });
    }
    a.deleteShader(I), a.deleteShader(P), (F = new wy(a, C)), (N = y5(a, C));
  }
  let F;
  this.getUniforms = function () {
    return F === void 0 && V(this), F;
  };
  let N;
  this.getAttributes = function () {
    return N === void 0 && V(this), N;
  };
  let L = e.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return L === !1 && (L = a.getProgramParameter(C, c5)), L;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        a.deleteProgram(C),
        (this.program = void 0);
    }),
    (this.type = e.shaderType),
    (this.name = e.shaderName),
    (this.id = u5++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = C),
    (this.vertexShader = I),
    (this.fragmentShader = P),
    this
  );
}
let B5 = 0;
class D5 {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(t) {
    const e = t.vertexShader,
      n = t.fragmentShader,
      a = this._getShaderStage(e),
      r = this._getShaderStage(n),
      l = this._getShaderCacheForMaterial(t);
    return (
      l.has(a) === !1 && (l.add(a), a.usedTimes++),
      l.has(r) === !1 && (l.add(r), r.usedTimes++),
      this
    );
  }
  remove(t) {
    const e = this.materialCache.get(t);
    for (const n of e)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache;
    let n = e.get(t);
    return n === void 0 && ((n = new Set()), e.set(t, n)), n;
  }
  _getShaderStage(t) {
    const e = this.shaderCache;
    let n = e.get(t);
    return n === void 0 && ((n = new U5(t)), e.set(t, n)), n;
  }
}
class U5 {
  constructor(t) {
    (this.id = B5++), (this.code = t), (this.usedTimes = 0);
  }
}
function O5(i, t, e, n, a, r, l) {
  const u = new Zd(),
    h = new D5(),
    p = new Set(),
    m = [],
    v = a.logarithmicDepthBuffer,
    x = a.vertexTextures;
  let _ = a.precision;
  const M = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function C(N) {
    return p.add(N), N === 0 ? "uv" : `uv${N}`;
  }
  function E(N, L, Y, ct, nt) {
    const dt = ct.fog,
      pt = nt.geometry,
      j = N.isMeshStandardMaterial ? ct.environment : null,
      Q = (N.isMeshStandardMaterial ? e : t).get(N.envMap || j),
      et = Q && Q.mapping === ip ? Q.image.height : null,
      xt = M[N.type];
    N.precision !== null &&
      ((_ = a.getMaxPrecision(N.precision)),
      _ !== N.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          N.precision,
          "not supported, using",
          _,
          "instead."
        ));
    const X =
        pt.morphAttributes.position ||
        pt.morphAttributes.normal ||
        pt.morphAttributes.color,
      ft = X !== void 0 ? X.length : 0;
    let At = 0;
    pt.morphAttributes.position !== void 0 && (At = 1),
      pt.morphAttributes.normal !== void 0 && (At = 2),
      pt.morphAttributes.color !== void 0 && (At = 3);
    let Rt, ht, It, Pt;
    if (xt) {
      const ln = yo[xt];
      (Rt = ln.vertexShader), (ht = ln.fragmentShader);
    } else
      (Rt = N.vertexShader),
        (ht = N.fragmentShader),
        h.update(N),
        (It = h.getVertexShaderID(N)),
        (Pt = h.getFragmentShaderID(N));
    const re = i.getRenderTarget(),
      ie = i.state.buffers.depth.getReversed(),
      Fe = nt.isInstancedMesh === !0,
      Ae = nt.isBatchedMesh === !0,
      De = !!N.map,
      je = !!N.matcap,
      Ue = !!Q,
      J = !!N.aoMap,
      le = !!N.lightMap,
      se = !!N.bumpMap,
      $t = !!N.normalMap,
      kt = !!N.displacementMap,
      ye = !!N.emissiveMap,
      te = !!N.metalnessMap,
      pe = !!N.roughnessMap,
      Ye = N.anisotropy > 0,
      $ = N.clearcoat > 0,
      k = N.dispersion > 0,
      Mt = N.iridescence > 0,
      Ft = N.sheen > 0,
      Gt = N.transmission > 0,
      zt = Ye && !!N.anisotropyMap,
      me = $ && !!N.clearcoatMap,
      de = $ && !!N.clearcoatNormalMap,
      we = $ && !!N.clearcoatRoughnessMap,
      Ce = Mt && !!N.iridescenceMap,
      jt = Mt && !!N.iridescenceThicknessMap,
      ce = Ft && !!N.sheenColorMap,
      Re = Ft && !!N.sheenRoughnessMap,
      it = !!N.specularMap,
      yt = !!N.specularColorMap,
      Qt = !!N.specularIntensityMap,
      st = Gt && !!N.transmissionMap,
      Et = Gt && !!N.thicknessMap,
      qt = !!N.gradientMap,
      ge = !!N.alphaMap,
      oe = N.alphaTest > 0,
      Kt = !!N.alphaHash,
      be = !!N.extensions;
    let Le = ll;
    N.toneMapped &&
      (re === null || re.isXRRenderTarget === !0) &&
      (Le = i.toneMapping);
    const mn = {
      shaderID: xt,
      shaderType: N.type,
      shaderName: N.name,
      vertexShader: Rt,
      fragmentShader: ht,
      defines: N.defines,
      customVertexShaderID: It,
      customFragmentShaderID: Pt,
      isRawShaderMaterial: N.isRawShaderMaterial === !0,
      glslVersion: N.glslVersion,
      precision: _,
      batching: Ae,
      batchingColor: Ae && nt._colorsTexture !== null,
      instancing: Fe,
      instancingColor: Fe && nt.instanceColor !== null,
      instancingMorph: Fe && nt.morphTexture !== null,
      supportsVertexTextures: x,
      outputColorSpace:
        re === null
          ? i.outputColorSpace
          : re.isXRRenderTarget === !0
          ? re.texture.colorSpace
          : bo,
      alphaToCoverage: !!N.alphaToCoverage,
      map: De,
      matcap: je,
      envMap: Ue,
      envMapMode: Ue && Q.mapping,
      envMapCubeUVHeight: et,
      aoMap: J,
      lightMap: le,
      bumpMap: se,
      normalMap: $t,
      displacementMap: x && kt,
      emissiveMap: ye,
      normalMapObjectSpace: $t && N.normalMapType === TC,
      normalMapTangentSpace: $t && N.normalMapType === vu,
      metalnessMap: te,
      roughnessMap: pe,
      anisotropy: Ye,
      anisotropyMap: zt,
      clearcoat: $,
      clearcoatMap: me,
      clearcoatNormalMap: de,
      clearcoatRoughnessMap: we,
      dispersion: k,
      iridescence: Mt,
      iridescenceMap: Ce,
      iridescenceThicknessMap: jt,
      sheen: Ft,
      sheenColorMap: ce,
      sheenRoughnessMap: Re,
      specularMap: it,
      specularColorMap: yt,
      specularIntensityMap: Qt,
      transmission: Gt,
      transmissionMap: st,
      thicknessMap: Et,
      gradientMap: qt,
      opaque:
        N.transparent === !1 && N.blending === Xf && N.alphaToCoverage === !1,
      alphaMap: ge,
      alphaTest: oe,
      alphaHash: Kt,
      combine: N.combine,
      mapUv: De && C(N.map.channel),
      aoMapUv: J && C(N.aoMap.channel),
      lightMapUv: le && C(N.lightMap.channel),
      bumpMapUv: se && C(N.bumpMap.channel),
      normalMapUv: $t && C(N.normalMap.channel),
      displacementMapUv: kt && C(N.displacementMap.channel),
      emissiveMapUv: ye && C(N.emissiveMap.channel),
      metalnessMapUv: te && C(N.metalnessMap.channel),
      roughnessMapUv: pe && C(N.roughnessMap.channel),
      anisotropyMapUv: zt && C(N.anisotropyMap.channel),
      clearcoatMapUv: me && C(N.clearcoatMap.channel),
      clearcoatNormalMapUv: de && C(N.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: we && C(N.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ce && C(N.iridescenceMap.channel),
      iridescenceThicknessMapUv: jt && C(N.iridescenceThicknessMap.channel),
      sheenColorMapUv: ce && C(N.sheenColorMap.channel),
      sheenRoughnessMapUv: Re && C(N.sheenRoughnessMap.channel),
      specularMapUv: it && C(N.specularMap.channel),
      specularColorMapUv: yt && C(N.specularColorMap.channel),
      specularIntensityMapUv: Qt && C(N.specularIntensityMap.channel),
      transmissionMapUv: st && C(N.transmissionMap.channel),
      thicknessMapUv: Et && C(N.thicknessMap.channel),
      alphaMapUv: ge && C(N.alphaMap.channel),
      vertexTangents: !!pt.attributes.tangent && ($t || Ye),
      vertexColors: N.vertexColors,
      vertexAlphas:
        N.vertexColors === !0 &&
        !!pt.attributes.color &&
        pt.attributes.color.itemSize === 4,
      pointsUvs: nt.isPoints === !0 && !!pt.attributes.uv && (De || ge),
      fog: !!dt,
      useFog: N.fog === !0,
      fogExp2: !!dt && dt.isFogExp2,
      flatShading: N.flatShading === !0,
      sizeAttenuation: N.sizeAttenuation === !0,
      logarithmicDepthBuffer: v,
      reverseDepthBuffer: ie,
      skinning: nt.isSkinnedMesh === !0,
      morphTargets: pt.morphAttributes.position !== void 0,
      morphNormals: pt.morphAttributes.normal !== void 0,
      morphColors: pt.morphAttributes.color !== void 0,
      morphTargetsCount: ft,
      morphTextureStride: At,
      numDirLights: L.directional.length,
      numPointLights: L.point.length,
      numSpotLights: L.spot.length,
      numSpotLightMaps: L.spotLightMap.length,
      numRectAreaLights: L.rectArea.length,
      numHemiLights: L.hemi.length,
      numDirLightShadows: L.directionalShadowMap.length,
      numPointLightShadows: L.pointShadowMap.length,
      numSpotLightShadows: L.spotShadowMap.length,
      numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
      numLightProbes: L.numLightProbes,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: N.dithering,
      shadowMapEnabled: i.shadowMap.enabled && Y.length > 0,
      shadowMapType: i.shadowMap.type,
      toneMapping: Le,
      decodeVideoTexture:
        De &&
        N.map.isVideoTexture === !0 &&
        In.getTransfer(N.map.colorSpace) === ai,
      decodeVideoTextureEmissive:
        ye &&
        N.emissiveMap.isVideoTexture === !0 &&
        In.getTransfer(N.emissiveMap.colorSpace) === ai,
      premultipliedAlpha: N.premultipliedAlpha,
      doubleSided: N.side === or,
      flipSided: N.side === Ms,
      useDepthPacking: N.depthPacking >= 0,
      depthPacking: N.depthPacking || 0,
      index0AttributeName: N.index0AttributeName,
      extensionClipCullDistance:
        be &&
        N.extensions.clipCullDistance === !0 &&
        n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((be && N.extensions.multiDraw === !0) || Ae) &&
        n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: N.customProgramCacheKey(),
    };
    return (
      (mn.vertexUv1s = p.has(1)),
      (mn.vertexUv2s = p.has(2)),
      (mn.vertexUv3s = p.has(3)),
      p.clear(),
      mn
    );
  }
  function S(N) {
    const L = [];
    if (
      (N.shaderID
        ? L.push(N.shaderID)
        : (L.push(N.customVertexShaderID), L.push(N.customFragmentShaderID)),
      N.defines !== void 0)
    )
      for (const Y in N.defines) L.push(Y), L.push(N.defines[Y]);
    return (
      N.isRawShaderMaterial === !1 &&
        (R(L, N), B(L, N), L.push(i.outputColorSpace)),
      L.push(N.customProgramCacheKey),
      L.join()
    );
  }
  function R(N, L) {
    N.push(L.precision),
      N.push(L.outputColorSpace),
      N.push(L.envMapMode),
      N.push(L.envMapCubeUVHeight),
      N.push(L.mapUv),
      N.push(L.alphaMapUv),
      N.push(L.lightMapUv),
      N.push(L.aoMapUv),
      N.push(L.bumpMapUv),
      N.push(L.normalMapUv),
      N.push(L.displacementMapUv),
      N.push(L.emissiveMapUv),
      N.push(L.metalnessMapUv),
      N.push(L.roughnessMapUv),
      N.push(L.anisotropyMapUv),
      N.push(L.clearcoatMapUv),
      N.push(L.clearcoatNormalMapUv),
      N.push(L.clearcoatRoughnessMapUv),
      N.push(L.iridescenceMapUv),
      N.push(L.iridescenceThicknessMapUv),
      N.push(L.sheenColorMapUv),
      N.push(L.sheenRoughnessMapUv),
      N.push(L.specularMapUv),
      N.push(L.specularColorMapUv),
      N.push(L.specularIntensityMapUv),
      N.push(L.transmissionMapUv),
      N.push(L.thicknessMapUv),
      N.push(L.combine),
      N.push(L.fogExp2),
      N.push(L.sizeAttenuation),
      N.push(L.morphTargetsCount),
      N.push(L.morphAttributeCount),
      N.push(L.numDirLights),
      N.push(L.numPointLights),
      N.push(L.numSpotLights),
      N.push(L.numSpotLightMaps),
      N.push(L.numHemiLights),
      N.push(L.numRectAreaLights),
      N.push(L.numDirLightShadows),
      N.push(L.numPointLightShadows),
      N.push(L.numSpotLightShadows),
      N.push(L.numSpotLightShadowsWithMaps),
      N.push(L.numLightProbes),
      N.push(L.shadowMapType),
      N.push(L.toneMapping),
      N.push(L.numClippingPlanes),
      N.push(L.numClipIntersection),
      N.push(L.depthPacking);
  }
  function B(N, L) {
    u.disableAll(),
      L.supportsVertexTextures && u.enable(0),
      L.instancing && u.enable(1),
      L.instancingColor && u.enable(2),
      L.instancingMorph && u.enable(3),
      L.matcap && u.enable(4),
      L.envMap && u.enable(5),
      L.normalMapObjectSpace && u.enable(6),
      L.normalMapTangentSpace && u.enable(7),
      L.clearcoat && u.enable(8),
      L.iridescence && u.enable(9),
      L.alphaTest && u.enable(10),
      L.vertexColors && u.enable(11),
      L.vertexAlphas && u.enable(12),
      L.vertexUv1s && u.enable(13),
      L.vertexUv2s && u.enable(14),
      L.vertexUv3s && u.enable(15),
      L.vertexTangents && u.enable(16),
      L.anisotropy && u.enable(17),
      L.alphaHash && u.enable(18),
      L.batching && u.enable(19),
      L.dispersion && u.enable(20),
      L.batchingColor && u.enable(21),
      N.push(u.mask),
      u.disableAll(),
      L.fog && u.enable(0),
      L.useFog && u.enable(1),
      L.flatShading && u.enable(2),
      L.logarithmicDepthBuffer && u.enable(3),
      L.reverseDepthBuffer && u.enable(4),
      L.skinning && u.enable(5),
      L.morphTargets && u.enable(6),
      L.morphNormals && u.enable(7),
      L.morphColors && u.enable(8),
      L.premultipliedAlpha && u.enable(9),
      L.shadowMapEnabled && u.enable(10),
      L.doubleSided && u.enable(11),
      L.flipSided && u.enable(12),
      L.useDepthPacking && u.enable(13),
      L.dithering && u.enable(14),
      L.transmission && u.enable(15),
      L.sheen && u.enable(16),
      L.opaque && u.enable(17),
      L.pointsUvs && u.enable(18),
      L.decodeVideoTexture && u.enable(19),
      L.decodeVideoTextureEmissive && u.enable(20),
      L.alphaToCoverage && u.enable(21),
      N.push(u.mask);
  }
  function D(N) {
    const L = M[N.type];
    let Y;
    if (L) {
      const ct = yo[L];
      Y = HC.clone(ct.uniforms);
    } else Y = N.uniforms;
    return Y;
  }
  function I(N, L) {
    let Y;
    for (let ct = 0, nt = m.length; ct < nt; ct++) {
      const dt = m[ct];
      if (dt.cacheKey === L) {
        (Y = dt), ++Y.usedTimes;
        break;
      }
    }
    return Y === void 0 && ((Y = new R5(i, L, N, r)), m.push(Y)), Y;
  }
  function P(N) {
    if (--N.usedTimes === 0) {
      const L = m.indexOf(N);
      (m[L] = m[m.length - 1]), m.pop(), N.destroy();
    }
  }
  function V(N) {
    h.remove(N);
  }
  function F() {
    h.dispose();
  }
  return {
    getParameters: E,
    getProgramCacheKey: S,
    getUniforms: D,
    acquireProgram: I,
    releaseProgram: P,
    releaseShaderCache: V,
    programs: m,
    dispose: F,
  };
}
function N5() {
  let i = new WeakMap();
  function t(l) {
    return i.has(l);
  }
  function e(l) {
    let u = i.get(l);
    return u === void 0 && ((u = {}), i.set(l, u)), u;
  }
  function n(l) {
    i.delete(l);
  }
  function a(l, u, h) {
    i.get(l)[u] = h;
  }
  function r() {
    i = new WeakMap();
  }
  return { has: t, get: e, remove: n, update: a, dispose: r };
}
function L5(i, t) {
  return i.groupOrder !== t.groupOrder
    ? i.groupOrder - t.groupOrder
    : i.renderOrder !== t.renderOrder
    ? i.renderOrder - t.renderOrder
    : i.material.id !== t.material.id
    ? i.material.id - t.material.id
    : i.z !== t.z
    ? i.z - t.z
    : i.id - t.id;
}
function FT(i, t) {
  return i.groupOrder !== t.groupOrder
    ? i.groupOrder - t.groupOrder
    : i.renderOrder !== t.renderOrder
    ? i.renderOrder - t.renderOrder
    : i.z !== t.z
    ? t.z - i.z
    : i.id - t.id;
}
function HT() {
  const i = [];
  let t = 0;
  const e = [],
    n = [],
    a = [];
  function r() {
    (t = 0), (e.length = 0), (n.length = 0), (a.length = 0);
  }
  function l(v, x, _, M, C, E) {
    let S = i[t];
    return (
      S === void 0
        ? ((S = {
            id: v.id,
            object: v,
            geometry: x,
            material: _,
            groupOrder: M,
            renderOrder: v.renderOrder,
            z: C,
            group: E,
          }),
          (i[t] = S))
        : ((S.id = v.id),
          (S.object = v),
          (S.geometry = x),
          (S.material = _),
          (S.groupOrder = M),
          (S.renderOrder = v.renderOrder),
          (S.z = C),
          (S.group = E)),
      t++,
      S
    );
  }
  function u(v, x, _, M, C, E) {
    const S = l(v, x, _, M, C, E);
    _.transmission > 0
      ? n.push(S)
      : _.transparent === !0
      ? a.push(S)
      : e.push(S);
  }
  function h(v, x, _, M, C, E) {
    const S = l(v, x, _, M, C, E);
    _.transmission > 0
      ? n.unshift(S)
      : _.transparent === !0
      ? a.unshift(S)
      : e.unshift(S);
  }
  function p(v, x) {
    e.length > 1 && e.sort(v || L5),
      n.length > 1 && n.sort(x || FT),
      a.length > 1 && a.sort(x || FT);
  }
  function m() {
    for (let v = t, x = i.length; v < x; v++) {
      const _ = i[v];
      if (_.id === null) break;
      (_.id = null),
        (_.object = null),
        (_.geometry = null),
        (_.material = null),
        (_.group = null);
    }
  }
  return {
    opaque: e,
    transmissive: n,
    transparent: a,
    init: r,
    push: u,
    unshift: h,
    finish: m,
    sort: p,
  };
}
function I5() {
  let i = new WeakMap();
  function t(n, a) {
    const r = i.get(n);
    let l;
    return (
      r === void 0
        ? ((l = new HT()), i.set(n, [l]))
        : a >= r.length
        ? ((l = new HT()), r.push(l))
        : (l = r[a]),
      l
    );
  }
  function e() {
    i = new WeakMap();
  }
  return { get: t, dispose: e };
}
function P5() {
  const i = {};
  return {
    get: function (t) {
      if (i[t.id] !== void 0) return i[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = { direction: new Z(), color: new Se() };
          break;
        case "SpotLight":
          e = {
            position: new Z(),
            direction: new Z(),
            color: new Se(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          e = { position: new Z(), color: new Se(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          e = { direction: new Z(), skyColor: new Se(), groundColor: new Se() };
          break;
        case "RectAreaLight":
          e = {
            color: new Se(),
            position: new Z(),
            halfWidth: new Z(),
            halfHeight: new Z(),
          };
          break;
      }
      return (i[t.id] = e), e;
    },
  };
}
function z5() {
  const i = {};
  return {
    get: function (t) {
      if (i[t.id] !== void 0) return i[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Yt(),
          };
          break;
        case "SpotLight":
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Yt(),
          };
          break;
        case "PointLight":
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Yt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (i[t.id] = e), e;
    },
  };
}
let F5 = 0;
function H5(i, t) {
  return (
    (t.castShadow ? 2 : 0) -
    (i.castShadow ? 2 : 0) +
    (t.map ? 1 : 0) -
    (i.map ? 1 : 0)
  );
}
function G5(i) {
  const t = new P5(),
    e = z5(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let p = 0; p < 9; p++) n.probe.push(new Z());
  const a = new Z(),
    r = new Xe(),
    l = new Xe();
  function u(p) {
    let m = 0,
      v = 0,
      x = 0;
    for (let N = 0; N < 9; N++) n.probe[N].set(0, 0, 0);
    let _ = 0,
      M = 0,
      C = 0,
      E = 0,
      S = 0,
      R = 0,
      B = 0,
      D = 0,
      I = 0,
      P = 0,
      V = 0;
    p.sort(H5);
    for (let N = 0, L = p.length; N < L; N++) {
      const Y = p[N],
        ct = Y.color,
        nt = Y.intensity,
        dt = Y.distance,
        pt = Y.shadow && Y.shadow.map ? Y.shadow.map.texture : null;
      if (Y.isAmbientLight)
        (m += ct.r * nt), (v += ct.g * nt), (x += ct.b * nt);
      else if (Y.isLightProbe) {
        for (let j = 0; j < 9; j++)
          n.probe[j].addScaledVector(Y.sh.coefficients[j], nt);
        V++;
      } else if (Y.isDirectionalLight) {
        const j = t.get(Y);
        if ((j.color.copy(Y.color).multiplyScalar(Y.intensity), Y.castShadow)) {
          const Q = Y.shadow,
            et = e.get(Y);
          (et.shadowIntensity = Q.intensity),
            (et.shadowBias = Q.bias),
            (et.shadowNormalBias = Q.normalBias),
            (et.shadowRadius = Q.radius),
            (et.shadowMapSize = Q.mapSize),
            (n.directionalShadow[_] = et),
            (n.directionalShadowMap[_] = pt),
            (n.directionalShadowMatrix[_] = Y.shadow.matrix),
            R++;
        }
        (n.directional[_] = j), _++;
      } else if (Y.isSpotLight) {
        const j = t.get(Y);
        j.position.setFromMatrixPosition(Y.matrixWorld),
          j.color.copy(ct).multiplyScalar(nt),
          (j.distance = dt),
          (j.coneCos = Math.cos(Y.angle)),
          (j.penumbraCos = Math.cos(Y.angle * (1 - Y.penumbra))),
          (j.decay = Y.decay),
          (n.spot[C] = j);
        const Q = Y.shadow;
        if (
          (Y.map &&
            ((n.spotLightMap[I] = Y.map),
            I++,
            Q.updateMatrices(Y),
            Y.castShadow && P++),
          (n.spotLightMatrix[C] = Q.matrix),
          Y.castShadow)
        ) {
          const et = e.get(Y);
          (et.shadowIntensity = Q.intensity),
            (et.shadowBias = Q.bias),
            (et.shadowNormalBias = Q.normalBias),
            (et.shadowRadius = Q.radius),
            (et.shadowMapSize = Q.mapSize),
            (n.spotShadow[C] = et),
            (n.spotShadowMap[C] = pt),
            D++;
        }
        C++;
      } else if (Y.isRectAreaLight) {
        const j = t.get(Y);
        j.color.copy(ct).multiplyScalar(nt),
          j.halfWidth.set(Y.width * 0.5, 0, 0),
          j.halfHeight.set(0, Y.height * 0.5, 0),
          (n.rectArea[E] = j),
          E++;
      } else if (Y.isPointLight) {
        const j = t.get(Y);
        if (
          (j.color.copy(Y.color).multiplyScalar(Y.intensity),
          (j.distance = Y.distance),
          (j.decay = Y.decay),
          Y.castShadow)
        ) {
          const Q = Y.shadow,
            et = e.get(Y);
          (et.shadowIntensity = Q.intensity),
            (et.shadowBias = Q.bias),
            (et.shadowNormalBias = Q.normalBias),
            (et.shadowRadius = Q.radius),
            (et.shadowMapSize = Q.mapSize),
            (et.shadowCameraNear = Q.camera.near),
            (et.shadowCameraFar = Q.camera.far),
            (n.pointShadow[M] = et),
            (n.pointShadowMap[M] = pt),
            (n.pointShadowMatrix[M] = Y.shadow.matrix),
            B++;
        }
        (n.point[M] = j), M++;
      } else if (Y.isHemisphereLight) {
        const j = t.get(Y);
        j.skyColor.copy(Y.color).multiplyScalar(nt),
          j.groundColor.copy(Y.groundColor).multiplyScalar(nt),
          (n.hemi[S] = j),
          S++;
      }
    }
    E > 0 &&
      (i.has("OES_texture_float_linear") === !0
        ? ((n.rectAreaLTC1 = Ee.LTC_FLOAT_1), (n.rectAreaLTC2 = Ee.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = Ee.LTC_HALF_1), (n.rectAreaLTC2 = Ee.LTC_HALF_2))),
      (n.ambient[0] = m),
      (n.ambient[1] = v),
      (n.ambient[2] = x);
    const F = n.hash;
    (F.directionalLength !== _ ||
      F.pointLength !== M ||
      F.spotLength !== C ||
      F.rectAreaLength !== E ||
      F.hemiLength !== S ||
      F.numDirectionalShadows !== R ||
      F.numPointShadows !== B ||
      F.numSpotShadows !== D ||
      F.numSpotMaps !== I ||
      F.numLightProbes !== V) &&
      ((n.directional.length = _),
      (n.spot.length = C),
      (n.rectArea.length = E),
      (n.point.length = M),
      (n.hemi.length = S),
      (n.directionalShadow.length = R),
      (n.directionalShadowMap.length = R),
      (n.pointShadow.length = B),
      (n.pointShadowMap.length = B),
      (n.spotShadow.length = D),
      (n.spotShadowMap.length = D),
      (n.directionalShadowMatrix.length = R),
      (n.pointShadowMatrix.length = B),
      (n.spotLightMatrix.length = D + I - P),
      (n.spotLightMap.length = I),
      (n.numSpotLightShadowsWithMaps = P),
      (n.numLightProbes = V),
      (F.directionalLength = _),
      (F.pointLength = M),
      (F.spotLength = C),
      (F.rectAreaLength = E),
      (F.hemiLength = S),
      (F.numDirectionalShadows = R),
      (F.numPointShadows = B),
      (F.numSpotShadows = D),
      (F.numSpotMaps = I),
      (F.numLightProbes = V),
      (n.version = F5++));
  }
  function h(p, m) {
    let v = 0,
      x = 0,
      _ = 0,
      M = 0,
      C = 0;
    const E = m.matrixWorldInverse;
    for (let S = 0, R = p.length; S < R; S++) {
      const B = p[S];
      if (B.isDirectionalLight) {
        const D = n.directional[v];
        D.direction.setFromMatrixPosition(B.matrixWorld),
          a.setFromMatrixPosition(B.target.matrixWorld),
          D.direction.sub(a),
          D.direction.transformDirection(E),
          v++;
      } else if (B.isSpotLight) {
        const D = n.spot[_];
        D.position.setFromMatrixPosition(B.matrixWorld),
          D.position.applyMatrix4(E),
          D.direction.setFromMatrixPosition(B.matrixWorld),
          a.setFromMatrixPosition(B.target.matrixWorld),
          D.direction.sub(a),
          D.direction.transformDirection(E),
          _++;
      } else if (B.isRectAreaLight) {
        const D = n.rectArea[M];
        D.position.setFromMatrixPosition(B.matrixWorld),
          D.position.applyMatrix4(E),
          l.identity(),
          r.copy(B.matrixWorld),
          r.premultiply(E),
          l.extractRotation(r),
          D.halfWidth.set(B.width * 0.5, 0, 0),
          D.halfHeight.set(0, B.height * 0.5, 0),
          D.halfWidth.applyMatrix4(l),
          D.halfHeight.applyMatrix4(l),
          M++;
      } else if (B.isPointLight) {
        const D = n.point[x];
        D.position.setFromMatrixPosition(B.matrixWorld),
          D.position.applyMatrix4(E),
          x++;
      } else if (B.isHemisphereLight) {
        const D = n.hemi[C];
        D.direction.setFromMatrixPosition(B.matrixWorld),
          D.direction.transformDirection(E),
          C++;
      }
    }
  }
  return { setup: u, setupView: h, state: n };
}
function GT(i) {
  const t = new G5(i),
    e = [],
    n = [];
  function a(m) {
    (p.camera = m), (e.length = 0), (n.length = 0);
  }
  function r(m) {
    e.push(m);
  }
  function l(m) {
    n.push(m);
  }
  function u() {
    t.setup(e);
  }
  function h(m) {
    t.setupView(e, m);
  }
  const p = {
    lightsArray: e,
    shadowsArray: n,
    camera: null,
    lights: t,
    transmissionRenderTarget: {},
  };
  return {
    init: a,
    state: p,
    setupLights: u,
    setupLightsView: h,
    pushLight: r,
    pushShadow: l,
  };
}
function V5(i) {
  let t = new WeakMap();
  function e(a, r = 0) {
    const l = t.get(a);
    let u;
    return (
      l === void 0
        ? ((u = new GT(i)), t.set(a, [u]))
        : r >= l.length
        ? ((u = new GT(i)), l.push(u))
        : (u = l[r]),
      u
    );
  }
  function n() {
    t = new WeakMap();
  }
  return { get: e, dispose: n };
}
const k5 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  j5 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function X5(i, t, e) {
  let n = new ap();
  const a = new Yt(),
    r = new Yt(),
    l = new Hn(),
    u = new iS({ depthPacking: EC }),
    h = new aS(),
    p = {},
    m = e.maxTextureSize,
    v = { [hl]: Ms, [Ms]: hl, [or]: or },
    x = new Xs({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Yt() },
        radius: { value: 4 },
      },
      vertexShader: k5,
      fragmentShader: j5,
    }),
    _ = x.clone();
  _.defines.HORIZONTAL_PASS = 1;
  const M = new pn();
  M.setAttribute(
    "position",
    new Gn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const C = new Ti(M, x),
    E = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Ux);
  let S = this.type;
  this.render = function (P, V, F) {
    if (
      E.enabled === !1 ||
      (E.autoUpdate === !1 && E.needsUpdate === !1) ||
      P.length === 0
    )
      return;
    const N = i.getRenderTarget(),
      L = i.getActiveCubeFace(),
      Y = i.getActiveMipmapLevel(),
      ct = i.state;
    ct.setBlending(ol),
      ct.buffers.color.setClear(1, 1, 1, 1),
      ct.buffers.depth.setTest(!0),
      ct.setScissorTest(!1);
    const nt = S !== vo && this.type === vo,
      dt = S === vo && this.type !== vo;
    for (let pt = 0, j = P.length; pt < j; pt++) {
      const Q = P[pt],
        et = Q.shadow;
      if (et === void 0) {
        console.warn("THREE.WebGLShadowMap:", Q, "has no shadow.");
        continue;
      }
      if (et.autoUpdate === !1 && et.needsUpdate === !1) continue;
      a.copy(et.mapSize);
      const xt = et.getFrameExtents();
      if (
        (a.multiply(xt),
        r.copy(et.mapSize),
        (a.x > m || a.y > m) &&
          (a.x > m &&
            ((r.x = Math.floor(m / xt.x)),
            (a.x = r.x * xt.x),
            (et.mapSize.x = r.x)),
          a.y > m &&
            ((r.y = Math.floor(m / xt.y)),
            (a.y = r.y * xt.y),
            (et.mapSize.y = r.y))),
        et.map === null || nt === !0 || dt === !0)
      ) {
        const ft = this.type !== vo ? { minFilter: Ta, magFilter: Ta } : {};
        et.map !== null && et.map.dispose(),
          (et.map = new zr(a.x, a.y, ft)),
          (et.map.texture.name = Q.name + ".shadowMap"),
          et.camera.updateProjectionMatrix();
      }
      i.setRenderTarget(et.map), i.clear();
      const X = et.getViewportCount();
      for (let ft = 0; ft < X; ft++) {
        const At = et.getViewport(ft);
        l.set(r.x * At.x, r.y * At.y, r.x * At.z, r.y * At.w),
          ct.viewport(l),
          et.updateMatrices(Q, ft),
          (n = et.getFrustum()),
          D(V, F, et.camera, Q, this.type);
      }
      et.isPointLightShadow !== !0 && this.type === vo && R(et, F),
        (et.needsUpdate = !1);
    }
    (S = this.type), (E.needsUpdate = !1), i.setRenderTarget(N, L, Y);
  };
  function R(P, V) {
    const F = t.update(C);
    x.defines.VSM_SAMPLES !== P.blurSamples &&
      ((x.defines.VSM_SAMPLES = P.blurSamples),
      (_.defines.VSM_SAMPLES = P.blurSamples),
      (x.needsUpdate = !0),
      (_.needsUpdate = !0)),
      P.mapPass === null && (P.mapPass = new zr(a.x, a.y)),
      (x.uniforms.shadow_pass.value = P.map.texture),
      (x.uniforms.resolution.value = P.mapSize),
      (x.uniforms.radius.value = P.radius),
      i.setRenderTarget(P.mapPass),
      i.clear(),
      i.renderBufferDirect(V, null, F, x, C, null),
      (_.uniforms.shadow_pass.value = P.mapPass.texture),
      (_.uniforms.resolution.value = P.mapSize),
      (_.uniforms.radius.value = P.radius),
      i.setRenderTarget(P.map),
      i.clear(),
      i.renderBufferDirect(V, null, F, _, C, null);
  }
  function B(P, V, F, N) {
    let L = null;
    const Y =
      F.isPointLight === !0 ? P.customDistanceMaterial : P.customDepthMaterial;
    if (Y !== void 0) L = Y;
    else if (
      ((L = F.isPointLight === !0 ? h : u),
      (i.localClippingEnabled &&
        V.clipShadows === !0 &&
        Array.isArray(V.clippingPlanes) &&
        V.clippingPlanes.length !== 0) ||
        (V.displacementMap && V.displacementScale !== 0) ||
        (V.alphaMap && V.alphaTest > 0) ||
        (V.map && V.alphaTest > 0) ||
        V.alphaToCoverage === !0)
    ) {
      const ct = L.uuid,
        nt = V.uuid;
      let dt = p[ct];
      dt === void 0 && ((dt = {}), (p[ct] = dt));
      let pt = dt[nt];
      pt === void 0 &&
        ((pt = L.clone()), (dt[nt] = pt), V.addEventListener("dispose", I)),
        (L = pt);
    }
    if (
      ((L.visible = V.visible),
      (L.wireframe = V.wireframe),
      N === vo
        ? (L.side = V.shadowSide !== null ? V.shadowSide : V.side)
        : (L.side = V.shadowSide !== null ? V.shadowSide : v[V.side]),
      (L.alphaMap = V.alphaMap),
      (L.alphaTest = V.alphaToCoverage === !0 ? 0.5 : V.alphaTest),
      (L.map = V.map),
      (L.clipShadows = V.clipShadows),
      (L.clippingPlanes = V.clippingPlanes),
      (L.clipIntersection = V.clipIntersection),
      (L.displacementMap = V.displacementMap),
      (L.displacementScale = V.displacementScale),
      (L.displacementBias = V.displacementBias),
      (L.wireframeLinewidth = V.wireframeLinewidth),
      (L.linewidth = V.linewidth),
      F.isPointLight === !0 && L.isMeshDistanceMaterial === !0)
    ) {
      const ct = i.properties.get(L);
      ct.light = F;
    }
    return L;
  }
  function D(P, V, F, N, L) {
    if (P.visible === !1) return;
    if (
      P.layers.test(V.layers) &&
      (P.isMesh || P.isLine || P.isPoints) &&
      (P.castShadow || (P.receiveShadow && L === vo)) &&
      (!P.frustumCulled || n.intersectsObject(P))
    ) {
      P.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, P.matrixWorld);
      const nt = t.update(P),
        dt = P.material;
      if (Array.isArray(dt)) {
        const pt = nt.groups;
        for (let j = 0, Q = pt.length; j < Q; j++) {
          const et = pt[j],
            xt = dt[et.materialIndex];
          if (xt && xt.visible) {
            const X = B(P, xt, N, L);
            P.onBeforeShadow(i, P, V, F, nt, X, et),
              i.renderBufferDirect(F, null, nt, X, P, et),
              P.onAfterShadow(i, P, V, F, nt, X, et);
          }
        }
      } else if (dt.visible) {
        const pt = B(P, dt, N, L);
        P.onBeforeShadow(i, P, V, F, nt, pt, null),
          i.renderBufferDirect(F, null, nt, pt, P, null),
          P.onAfterShadow(i, P, V, F, nt, pt, null);
      }
    }
    const ct = P.children;
    for (let nt = 0, dt = ct.length; nt < dt; nt++) D(ct[nt], V, F, N, L);
  }
  function I(P) {
    P.target.removeEventListener("dispose", I);
    for (const F in p) {
      const N = p[F],
        L = P.target.uuid;
      L in N && (N[L].dispose(), delete N[L]);
    }
  }
}
const W5 = {
  [Iy]: Py,
  [zy]: Gy,
  [Fy]: Vy,
  [Jf]: Hy,
  [Py]: Iy,
  [Gy]: zy,
  [Vy]: Fy,
  [Hy]: Jf,
};
function Y5(i, t) {
  function e() {
    let st = !1;
    const Et = new Hn();
    let qt = null;
    const ge = new Hn(0, 0, 0, 0);
    return {
      setMask: function (oe) {
        qt !== oe && !st && (i.colorMask(oe, oe, oe, oe), (qt = oe));
      },
      setLocked: function (oe) {
        st = oe;
      },
      setClear: function (oe, Kt, be, Le, mn) {
        mn === !0 && ((oe *= Le), (Kt *= Le), (be *= Le)),
          Et.set(oe, Kt, be, Le),
          ge.equals(Et) === !1 && (i.clearColor(oe, Kt, be, Le), ge.copy(Et));
      },
      reset: function () {
        (st = !1), (qt = null), ge.set(-1, 0, 0, 0);
      },
    };
  }
  function n() {
    let st = !1,
      Et = !1,
      qt = null,
      ge = null,
      oe = null;
    return {
      setReversed: function (Kt) {
        if (Et !== Kt) {
          const be = t.get("EXT_clip_control");
          Kt
            ? be.clipControlEXT(be.LOWER_LEFT_EXT, be.ZERO_TO_ONE_EXT)
            : be.clipControlEXT(be.LOWER_LEFT_EXT, be.NEGATIVE_ONE_TO_ONE_EXT),
            (Et = Kt);
          const Le = oe;
          (oe = null), this.setClear(Le);
        }
      },
      getReversed: function () {
        return Et;
      },
      setTest: function (Kt) {
        Kt ? re(i.DEPTH_TEST) : ie(i.DEPTH_TEST);
      },
      setMask: function (Kt) {
        qt !== Kt && !st && (i.depthMask(Kt), (qt = Kt));
      },
      setFunc: function (Kt) {
        if ((Et && (Kt = W5[Kt]), ge !== Kt)) {
          switch (Kt) {
            case Iy:
              i.depthFunc(i.NEVER);
              break;
            case Py:
              i.depthFunc(i.ALWAYS);
              break;
            case zy:
              i.depthFunc(i.LESS);
              break;
            case Jf:
              i.depthFunc(i.LEQUAL);
              break;
            case Fy:
              i.depthFunc(i.EQUAL);
              break;
            case Hy:
              i.depthFunc(i.GEQUAL);
              break;
            case Gy:
              i.depthFunc(i.GREATER);
              break;
            case Vy:
              i.depthFunc(i.NOTEQUAL);
              break;
            default:
              i.depthFunc(i.LEQUAL);
          }
          ge = Kt;
        }
      },
      setLocked: function (Kt) {
        st = Kt;
      },
      setClear: function (Kt) {
        oe !== Kt && (Et && (Kt = 1 - Kt), i.clearDepth(Kt), (oe = Kt));
      },
      reset: function () {
        (st = !1), (qt = null), (ge = null), (oe = null), (Et = !1);
      },
    };
  }
  function a() {
    let st = !1,
      Et = null,
      qt = null,
      ge = null,
      oe = null,
      Kt = null,
      be = null,
      Le = null,
      mn = null;
    return {
      setTest: function (ln) {
        st || (ln ? re(i.STENCIL_TEST) : ie(i.STENCIL_TEST));
      },
      setMask: function (ln) {
        Et !== ln && !st && (i.stencilMask(ln), (Et = ln));
      },
      setFunc: function (ln, yi, si) {
        (qt !== ln || ge !== yi || oe !== si) &&
          (i.stencilFunc(ln, yi, si), (qt = ln), (ge = yi), (oe = si));
      },
      setOp: function (ln, yi, si) {
        (Kt !== ln || be !== yi || Le !== si) &&
          (i.stencilOp(ln, yi, si), (Kt = ln), (be = yi), (Le = si));
      },
      setLocked: function (ln) {
        st = ln;
      },
      setClear: function (ln) {
        mn !== ln && (i.clearStencil(ln), (mn = ln));
      },
      reset: function () {
        (st = !1),
          (Et = null),
          (qt = null),
          (ge = null),
          (oe = null),
          (Kt = null),
          (be = null),
          (Le = null),
          (mn = null);
      },
    };
  }
  const r = new e(),
    l = new n(),
    u = new a(),
    h = new WeakMap(),
    p = new WeakMap();
  let m = {},
    v = {},
    x = new WeakMap(),
    _ = [],
    M = null,
    C = !1,
    E = null,
    S = null,
    R = null,
    B = null,
    D = null,
    I = null,
    P = null,
    V = new Se(0, 0, 0),
    F = 0,
    N = !1,
    L = null,
    Y = null,
    ct = null,
    nt = null,
    dt = null;
  const pt = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let j = !1,
    Q = 0;
  const et = i.getParameter(i.VERSION);
  et.indexOf("WebGL") !== -1
    ? ((Q = parseFloat(/^WebGL (\d)/.exec(et)[1])), (j = Q >= 1))
    : et.indexOf("OpenGL ES") !== -1 &&
      ((Q = parseFloat(/^OpenGL ES (\d)/.exec(et)[1])), (j = Q >= 2));
  let xt = null,
    X = {};
  const ft = i.getParameter(i.SCISSOR_BOX),
    At = i.getParameter(i.VIEWPORT),
    Rt = new Hn().fromArray(ft),
    ht = new Hn().fromArray(At);
  function It(st, Et, qt, ge) {
    const oe = new Uint8Array(4),
      Kt = i.createTexture();
    i.bindTexture(st, Kt),
      i.texParameteri(st, i.TEXTURE_MIN_FILTER, i.NEAREST),
      i.texParameteri(st, i.TEXTURE_MAG_FILTER, i.NEAREST);
    for (let be = 0; be < qt; be++)
      st === i.TEXTURE_3D || st === i.TEXTURE_2D_ARRAY
        ? i.texImage3D(Et, 0, i.RGBA, 1, 1, ge, 0, i.RGBA, i.UNSIGNED_BYTE, oe)
        : i.texImage2D(
            Et + be,
            0,
            i.RGBA,
            1,
            1,
            0,
            i.RGBA,
            i.UNSIGNED_BYTE,
            oe
          );
    return Kt;
  }
  const Pt = {};
  (Pt[i.TEXTURE_2D] = It(i.TEXTURE_2D, i.TEXTURE_2D, 1)),
    (Pt[i.TEXTURE_CUBE_MAP] = It(
      i.TEXTURE_CUBE_MAP,
      i.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (Pt[i.TEXTURE_2D_ARRAY] = It(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1)),
    (Pt[i.TEXTURE_3D] = It(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)),
    r.setClear(0, 0, 0, 1),
    l.setClear(1),
    u.setClear(0),
    re(i.DEPTH_TEST),
    l.setFunc(Jf),
    se(!1),
    $t(Nb),
    re(i.CULL_FACE),
    J(ol);
  function re(st) {
    m[st] !== !0 && (i.enable(st), (m[st] = !0));
  }
  function ie(st) {
    m[st] !== !1 && (i.disable(st), (m[st] = !1));
  }
  function Fe(st, Et) {
    return v[st] !== Et
      ? (i.bindFramebuffer(st, Et),
        (v[st] = Et),
        st === i.DRAW_FRAMEBUFFER && (v[i.FRAMEBUFFER] = Et),
        st === i.FRAMEBUFFER && (v[i.DRAW_FRAMEBUFFER] = Et),
        !0)
      : !1;
  }
  function Ae(st, Et) {
    let qt = _,
      ge = !1;
    if (st) {
      (qt = x.get(Et)), qt === void 0 && ((qt = []), x.set(Et, qt));
      const oe = st.textures;
      if (qt.length !== oe.length || qt[0] !== i.COLOR_ATTACHMENT0) {
        for (let Kt = 0, be = oe.length; Kt < be; Kt++)
          qt[Kt] = i.COLOR_ATTACHMENT0 + Kt;
        (qt.length = oe.length), (ge = !0);
      }
    } else qt[0] !== i.BACK && ((qt[0] = i.BACK), (ge = !0));
    ge && i.drawBuffers(qt);
  }
  function De(st) {
    return M !== st ? (i.useProgram(st), (M = st), !0) : !1;
  }
  const je = {
    [su]: i.FUNC_ADD,
    [K2]: i.FUNC_SUBTRACT,
    [J2]: i.FUNC_REVERSE_SUBTRACT,
  };
  (je[Z2] = i.MIN), (je[Q2] = i.MAX);
  const Ue = {
    [$2]: i.ZERO,
    [tC]: i.ONE,
    [eC]: i.SRC_COLOR,
    [Ny]: i.SRC_ALPHA,
    [oC]: i.SRC_ALPHA_SATURATE,
    [sC]: i.DST_COLOR,
    [iC]: i.DST_ALPHA,
    [nC]: i.ONE_MINUS_SRC_COLOR,
    [Ly]: i.ONE_MINUS_SRC_ALPHA,
    [rC]: i.ONE_MINUS_DST_COLOR,
    [aC]: i.ONE_MINUS_DST_ALPHA,
    [lC]: i.CONSTANT_COLOR,
    [cC]: i.ONE_MINUS_CONSTANT_COLOR,
    [uC]: i.CONSTANT_ALPHA,
    [fC]: i.ONE_MINUS_CONSTANT_ALPHA,
  };
  function J(st, Et, qt, ge, oe, Kt, be, Le, mn, ln) {
    if (st === ol) {
      C === !0 && (ie(i.BLEND), (C = !1));
      return;
    }
    if ((C === !1 && (re(i.BLEND), (C = !0)), st !== q2)) {
      if (st !== E || ln !== N) {
        if (
          ((S !== su || D !== su) &&
            (i.blendEquation(i.FUNC_ADD), (S = su), (D = su)),
          ln)
        )
          switch (st) {
            case Xf:
              i.blendFuncSeparate(
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA,
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Lb:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case Ib:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case Pb:
              i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", st);
              break;
          }
        else
          switch (st) {
            case Xf:
              i.blendFuncSeparate(
                i.SRC_ALPHA,
                i.ONE_MINUS_SRC_ALPHA,
                i.ONE,
                i.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Lb:
              i.blendFunc(i.SRC_ALPHA, i.ONE);
              break;
            case Ib:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case Pb:
              i.blendFunc(i.ZERO, i.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", st);
              break;
          }
        (R = null),
          (B = null),
          (I = null),
          (P = null),
          V.set(0, 0, 0),
          (F = 0),
          (E = st),
          (N = ln);
      }
      return;
    }
    (oe = oe || Et),
      (Kt = Kt || qt),
      (be = be || ge),
      (Et !== S || oe !== D) &&
        (i.blendEquationSeparate(je[Et], je[oe]), (S = Et), (D = oe)),
      (qt !== R || ge !== B || Kt !== I || be !== P) &&
        (i.blendFuncSeparate(Ue[qt], Ue[ge], Ue[Kt], Ue[be]),
        (R = qt),
        (B = ge),
        (I = Kt),
        (P = be)),
      (Le.equals(V) === !1 || mn !== F) &&
        (i.blendColor(Le.r, Le.g, Le.b, mn), V.copy(Le), (F = mn)),
      (E = st),
      (N = !1);
  }
  function le(st, Et) {
    st.side === or ? ie(i.CULL_FACE) : re(i.CULL_FACE);
    let qt = st.side === Ms;
    Et && (qt = !qt),
      se(qt),
      st.blending === Xf && st.transparent === !1
        ? J(ol)
        : J(
            st.blending,
            st.blendEquation,
            st.blendSrc,
            st.blendDst,
            st.blendEquationAlpha,
            st.blendSrcAlpha,
            st.blendDstAlpha,
            st.blendColor,
            st.blendAlpha,
            st.premultipliedAlpha
          ),
      l.setFunc(st.depthFunc),
      l.setTest(st.depthTest),
      l.setMask(st.depthWrite),
      r.setMask(st.colorWrite);
    const ge = st.stencilWrite;
    u.setTest(ge),
      ge &&
        (u.setMask(st.stencilWriteMask),
        u.setFunc(st.stencilFunc, st.stencilRef, st.stencilFuncMask),
        u.setOp(st.stencilFail, st.stencilZFail, st.stencilZPass)),
      ye(st.polygonOffset, st.polygonOffsetFactor, st.polygonOffsetUnits),
      st.alphaToCoverage === !0
        ? re(i.SAMPLE_ALPHA_TO_COVERAGE)
        : ie(i.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function se(st) {
    L !== st && (st ? i.frontFace(i.CW) : i.frontFace(i.CCW), (L = st));
  }
  function $t(st) {
    st !== X2
      ? (re(i.CULL_FACE),
        st !== Y &&
          (st === Nb
            ? i.cullFace(i.BACK)
            : st === W2
            ? i.cullFace(i.FRONT)
            : i.cullFace(i.FRONT_AND_BACK)))
      : ie(i.CULL_FACE),
      (Y = st);
  }
  function kt(st) {
    st !== ct && (j && i.lineWidth(st), (ct = st));
  }
  function ye(st, Et, qt) {
    st
      ? (re(i.POLYGON_OFFSET_FILL),
        (nt !== Et || dt !== qt) &&
          (i.polygonOffset(Et, qt), (nt = Et), (dt = qt)))
      : ie(i.POLYGON_OFFSET_FILL);
  }
  function te(st) {
    st ? re(i.SCISSOR_TEST) : ie(i.SCISSOR_TEST);
  }
  function pe(st) {
    st === void 0 && (st = i.TEXTURE0 + pt - 1),
      xt !== st && (i.activeTexture(st), (xt = st));
  }
  function Ye(st, Et, qt) {
    qt === void 0 && (xt === null ? (qt = i.TEXTURE0 + pt - 1) : (qt = xt));
    let ge = X[qt];
    ge === void 0 && ((ge = { type: void 0, texture: void 0 }), (X[qt] = ge)),
      (ge.type !== st || ge.texture !== Et) &&
        (xt !== qt && (i.activeTexture(qt), (xt = qt)),
        i.bindTexture(st, Et || Pt[st]),
        (ge.type = st),
        (ge.texture = Et));
  }
  function $() {
    const st = X[xt];
    st !== void 0 &&
      st.type !== void 0 &&
      (i.bindTexture(st.type, null), (st.type = void 0), (st.texture = void 0));
  }
  function k() {
    try {
      i.compressedTexImage2D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function Mt() {
    try {
      i.compressedTexImage3D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function Ft() {
    try {
      i.texSubImage2D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function Gt() {
    try {
      i.texSubImage3D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function zt() {
    try {
      i.compressedTexSubImage2D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function me() {
    try {
      i.compressedTexSubImage3D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function de() {
    try {
      i.texStorage2D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function we() {
    try {
      i.texStorage3D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function Ce() {
    try {
      i.texImage2D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function jt() {
    try {
      i.texImage3D(...arguments);
    } catch (st) {
      console.error("THREE.WebGLState:", st);
    }
  }
  function ce(st) {
    Rt.equals(st) === !1 && (i.scissor(st.x, st.y, st.z, st.w), Rt.copy(st));
  }
  function Re(st) {
    ht.equals(st) === !1 && (i.viewport(st.x, st.y, st.z, st.w), ht.copy(st));
  }
  function it(st, Et) {
    let qt = p.get(Et);
    qt === void 0 && ((qt = new WeakMap()), p.set(Et, qt));
    let ge = qt.get(st);
    ge === void 0 &&
      ((ge = i.getUniformBlockIndex(Et, st.name)), qt.set(st, ge));
  }
  function yt(st, Et) {
    const ge = p.get(Et).get(st);
    h.get(Et) !== ge &&
      (i.uniformBlockBinding(Et, ge, st.__bindingPointIndex), h.set(Et, ge));
  }
  function Qt() {
    i.disable(i.BLEND),
      i.disable(i.CULL_FACE),
      i.disable(i.DEPTH_TEST),
      i.disable(i.POLYGON_OFFSET_FILL),
      i.disable(i.SCISSOR_TEST),
      i.disable(i.STENCIL_TEST),
      i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
      i.blendEquation(i.FUNC_ADD),
      i.blendFunc(i.ONE, i.ZERO),
      i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
      i.blendColor(0, 0, 0, 0),
      i.colorMask(!0, !0, !0, !0),
      i.clearColor(0, 0, 0, 0),
      i.depthMask(!0),
      i.depthFunc(i.LESS),
      l.setReversed(!1),
      i.clearDepth(1),
      i.stencilMask(4294967295),
      i.stencilFunc(i.ALWAYS, 0, 4294967295),
      i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
      i.clearStencil(0),
      i.cullFace(i.BACK),
      i.frontFace(i.CCW),
      i.polygonOffset(0, 0),
      i.activeTexture(i.TEXTURE0),
      i.bindFramebuffer(i.FRAMEBUFFER, null),
      i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
      i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
      i.useProgram(null),
      i.lineWidth(1),
      i.scissor(0, 0, i.canvas.width, i.canvas.height),
      i.viewport(0, 0, i.canvas.width, i.canvas.height),
      (m = {}),
      (xt = null),
      (X = {}),
      (v = {}),
      (x = new WeakMap()),
      (_ = []),
      (M = null),
      (C = !1),
      (E = null),
      (S = null),
      (R = null),
      (B = null),
      (D = null),
      (I = null),
      (P = null),
      (V = new Se(0, 0, 0)),
      (F = 0),
      (N = !1),
      (L = null),
      (Y = null),
      (ct = null),
      (nt = null),
      (dt = null),
      Rt.set(0, 0, i.canvas.width, i.canvas.height),
      ht.set(0, 0, i.canvas.width, i.canvas.height),
      r.reset(),
      l.reset(),
      u.reset();
  }
  return {
    buffers: { color: r, depth: l, stencil: u },
    enable: re,
    disable: ie,
    bindFramebuffer: Fe,
    drawBuffers: Ae,
    useProgram: De,
    setBlending: J,
    setMaterial: le,
    setFlipSided: se,
    setCullFace: $t,
    setLineWidth: kt,
    setPolygonOffset: ye,
    setScissorTest: te,
    activeTexture: pe,
    bindTexture: Ye,
    unbindTexture: $,
    compressedTexImage2D: k,
    compressedTexImage3D: Mt,
    texImage2D: Ce,
    texImage3D: jt,
    updateUBOMapping: it,
    uniformBlockBinding: yt,
    texStorage2D: de,
    texStorage3D: we,
    texSubImage2D: Ft,
    texSubImage3D: Gt,
    compressedTexSubImage2D: zt,
    compressedTexSubImage3D: me,
    scissor: ce,
    viewport: Re,
    reset: Qt,
  };
}
function q5(i, t, e, n, a, r, l) {
  const u = t.has("WEBGL_multisampled_render_to_texture")
      ? t.get("WEBGL_multisampled_render_to_texture")
      : null,
    h =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    p = new Yt(),
    m = new WeakMap();
  let v;
  const x = new WeakMap();
  let _ = !1;
  try {
    _ =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function M($, k) {
    return _ ? new OffscreenCanvas($, k) : d0("canvas");
  }
  function C($, k, Mt) {
    let Ft = 1;
    const Gt = Ye($);
    if (
      ((Gt.width > Mt || Gt.height > Mt) &&
        (Ft = Mt / Math.max(Gt.width, Gt.height)),
      Ft < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && $ instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && $ instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && $ instanceof VideoFrame)
      ) {
        const zt = Math.floor(Ft * Gt.width),
          me = Math.floor(Ft * Gt.height);
        v === void 0 && (v = M(zt, me));
        const de = k ? M(zt, me) : v;
        return (
          (de.width = zt),
          (de.height = me),
          de.getContext("2d").drawImage($, 0, 0, zt, me),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              Gt.width +
              "x" +
              Gt.height +
              ") to (" +
              zt +
              "x" +
              me +
              ")."
          ),
          de
        );
      } else
        return (
          "data" in $ &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                Gt.width +
                "x" +
                Gt.height +
                ")."
            ),
          $
        );
    return $;
  }
  function E($) {
    return $.generateMipmaps;
  }
  function S($) {
    i.generateMipmap($);
  }
  function R($) {
    return $.isWebGLCubeRenderTarget
      ? i.TEXTURE_CUBE_MAP
      : $.isWebGL3DRenderTarget
      ? i.TEXTURE_3D
      : $.isWebGLArrayRenderTarget || $.isCompressedArrayTexture
      ? i.TEXTURE_2D_ARRAY
      : i.TEXTURE_2D;
  }
  function B($, k, Mt, Ft, Gt = !1) {
    if ($ !== null) {
      if (i[$] !== void 0) return i[$];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          $ +
          "'"
      );
    }
    let zt = k;
    if (
      (k === i.RED &&
        (Mt === i.FLOAT && (zt = i.R32F),
        Mt === i.HALF_FLOAT && (zt = i.R16F),
        Mt === i.UNSIGNED_BYTE && (zt = i.R8)),
      k === i.RED_INTEGER &&
        (Mt === i.UNSIGNED_BYTE && (zt = i.R8UI),
        Mt === i.UNSIGNED_SHORT && (zt = i.R16UI),
        Mt === i.UNSIGNED_INT && (zt = i.R32UI),
        Mt === i.BYTE && (zt = i.R8I),
        Mt === i.SHORT && (zt = i.R16I),
        Mt === i.INT && (zt = i.R32I)),
      k === i.RG &&
        (Mt === i.FLOAT && (zt = i.RG32F),
        Mt === i.HALF_FLOAT && (zt = i.RG16F),
        Mt === i.UNSIGNED_BYTE && (zt = i.RG8)),
      k === i.RG_INTEGER &&
        (Mt === i.UNSIGNED_BYTE && (zt = i.RG8UI),
        Mt === i.UNSIGNED_SHORT && (zt = i.RG16UI),
        Mt === i.UNSIGNED_INT && (zt = i.RG32UI),
        Mt === i.BYTE && (zt = i.RG8I),
        Mt === i.SHORT && (zt = i.RG16I),
        Mt === i.INT && (zt = i.RG32I)),
      k === i.RGB_INTEGER &&
        (Mt === i.UNSIGNED_BYTE && (zt = i.RGB8UI),
        Mt === i.UNSIGNED_SHORT && (zt = i.RGB16UI),
        Mt === i.UNSIGNED_INT && (zt = i.RGB32UI),
        Mt === i.BYTE && (zt = i.RGB8I),
        Mt === i.SHORT && (zt = i.RGB16I),
        Mt === i.INT && (zt = i.RGB32I)),
      k === i.RGBA_INTEGER &&
        (Mt === i.UNSIGNED_BYTE && (zt = i.RGBA8UI),
        Mt === i.UNSIGNED_SHORT && (zt = i.RGBA16UI),
        Mt === i.UNSIGNED_INT && (zt = i.RGBA32UI),
        Mt === i.BYTE && (zt = i.RGBA8I),
        Mt === i.SHORT && (zt = i.RGBA16I),
        Mt === i.INT && (zt = i.RGBA32I)),
      k === i.RGB && Mt === i.UNSIGNED_INT_5_9_9_9_REV && (zt = i.RGB9_E5),
      k === i.RGBA)
    ) {
      const me = Gt ? u0 : In.getTransfer(Ft);
      Mt === i.FLOAT && (zt = i.RGBA32F),
        Mt === i.HALF_FLOAT && (zt = i.RGBA16F),
        Mt === i.UNSIGNED_BYTE && (zt = me === ai ? i.SRGB8_ALPHA8 : i.RGBA8),
        Mt === i.UNSIGNED_SHORT_4_4_4_4 && (zt = i.RGBA4),
        Mt === i.UNSIGNED_SHORT_5_5_5_1 && (zt = i.RGB5_A1);
    }
    return (
      (zt === i.R16F ||
        zt === i.R32F ||
        zt === i.RG16F ||
        zt === i.RG32F ||
        zt === i.RGBA16F ||
        zt === i.RGBA32F) &&
        t.get("EXT_color_buffer_float"),
      zt
    );
  }
  function D($, k) {
    let Mt;
    return (
      $
        ? k === null || k === pl || k === Xd
          ? (Mt = i.DEPTH24_STENCIL8)
          : k === Pi
          ? (Mt = i.DEPTH32F_STENCIL8)
          : k === jd &&
            ((Mt = i.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : k === null || k === pl || k === Xd
        ? (Mt = i.DEPTH_COMPONENT24)
        : k === Pi
        ? (Mt = i.DEPTH_COMPONENT32F)
        : k === jd && (Mt = i.DEPTH_COMPONENT16),
      Mt
    );
  }
  function I($, k) {
    return E($) === !0 ||
      ($.isFramebufferTexture && $.minFilter !== Ta && $.minFilter !== Kn)
      ? Math.log2(Math.max(k.width, k.height)) + 1
      : $.mipmaps !== void 0 && $.mipmaps.length > 0
      ? $.mipmaps.length
      : $.isCompressedTexture && Array.isArray($.image)
      ? k.mipmaps.length
      : 1;
  }
  function P($) {
    const k = $.target;
    k.removeEventListener("dispose", P), F(k), k.isVideoTexture && m.delete(k);
  }
  function V($) {
    const k = $.target;
    k.removeEventListener("dispose", V), L(k);
  }
  function F($) {
    const k = n.get($);
    if (k.__webglInit === void 0) return;
    const Mt = $.source,
      Ft = x.get(Mt);
    if (Ft) {
      const Gt = Ft[k.__cacheKey];
      Gt.usedTimes--,
        Gt.usedTimes === 0 && N($),
        Object.keys(Ft).length === 0 && x.delete(Mt);
    }
    n.remove($);
  }
  function N($) {
    const k = n.get($);
    i.deleteTexture(k.__webglTexture);
    const Mt = $.source,
      Ft = x.get(Mt);
    delete Ft[k.__cacheKey], l.memory.textures--;
  }
  function L($) {
    const k = n.get($);
    if (
      ($.depthTexture && ($.depthTexture.dispose(), n.remove($.depthTexture)),
      $.isWebGLCubeRenderTarget)
    )
      for (let Ft = 0; Ft < 6; Ft++) {
        if (Array.isArray(k.__webglFramebuffer[Ft]))
          for (let Gt = 0; Gt < k.__webglFramebuffer[Ft].length; Gt++)
            i.deleteFramebuffer(k.__webglFramebuffer[Ft][Gt]);
        else i.deleteFramebuffer(k.__webglFramebuffer[Ft]);
        k.__webglDepthbuffer && i.deleteRenderbuffer(k.__webglDepthbuffer[Ft]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let Ft = 0; Ft < k.__webglFramebuffer.length; Ft++)
          i.deleteFramebuffer(k.__webglFramebuffer[Ft]);
      else i.deleteFramebuffer(k.__webglFramebuffer);
      if (
        (k.__webglDepthbuffer && i.deleteRenderbuffer(k.__webglDepthbuffer),
        k.__webglMultisampledFramebuffer &&
          i.deleteFramebuffer(k.__webglMultisampledFramebuffer),
        k.__webglColorRenderbuffer)
      )
        for (let Ft = 0; Ft < k.__webglColorRenderbuffer.length; Ft++)
          k.__webglColorRenderbuffer[Ft] &&
            i.deleteRenderbuffer(k.__webglColorRenderbuffer[Ft]);
      k.__webglDepthRenderbuffer &&
        i.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const Mt = $.textures;
    for (let Ft = 0, Gt = Mt.length; Ft < Gt; Ft++) {
      const zt = n.get(Mt[Ft]);
      zt.__webglTexture &&
        (i.deleteTexture(zt.__webglTexture), l.memory.textures--),
        n.remove(Mt[Ft]);
    }
    n.remove($);
  }
  let Y = 0;
  function ct() {
    Y = 0;
  }
  function nt() {
    const $ = Y;
    return (
      $ >= a.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            $ +
            " texture units while this GPU supports only " +
            a.maxTextures
        ),
      (Y += 1),
      $
    );
  }
  function dt($) {
    const k = [];
    return (
      k.push($.wrapS),
      k.push($.wrapT),
      k.push($.wrapR || 0),
      k.push($.magFilter),
      k.push($.minFilter),
      k.push($.anisotropy),
      k.push($.internalFormat),
      k.push($.format),
      k.push($.type),
      k.push($.generateMipmaps),
      k.push($.premultiplyAlpha),
      k.push($.flipY),
      k.push($.unpackAlignment),
      k.push($.colorSpace),
      k.join()
    );
  }
  function pt($, k) {
    const Mt = n.get($);
    if (
      ($.isVideoTexture && te($),
      $.isRenderTargetTexture === !1 &&
        $.version > 0 &&
        Mt.__version !== $.version)
    ) {
      const Ft = $.image;
      if (Ft === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Ft.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Pt(Mt, $, k);
        return;
      }
    }
    e.bindTexture(i.TEXTURE_2D, Mt.__webglTexture, i.TEXTURE0 + k);
  }
  function j($, k) {
    const Mt = n.get($);
    if ($.version > 0 && Mt.__version !== $.version) {
      Pt(Mt, $, k);
      return;
    }
    e.bindTexture(i.TEXTURE_2D_ARRAY, Mt.__webglTexture, i.TEXTURE0 + k);
  }
  function Q($, k) {
    const Mt = n.get($);
    if ($.version > 0 && Mt.__version !== $.version) {
      Pt(Mt, $, k);
      return;
    }
    e.bindTexture(i.TEXTURE_3D, Mt.__webglTexture, i.TEXTURE0 + k);
  }
  function et($, k) {
    const Mt = n.get($);
    if ($.version > 0 && Mt.__version !== $.version) {
      re(Mt, $, k);
      return;
    }
    e.bindTexture(i.TEXTURE_CUBE_MAP, Mt.__webglTexture, i.TEXTURE0 + k);
  }
  const xt = { [fu]: i.REPEAT, [Ki]: i.CLAMP_TO_EDGE, [kd]: i.MIRRORED_REPEAT },
    X = {
      [Ta]: i.NEAREST,
      [Ox]: i.NEAREST_MIPMAP_NEAREST,
      [If]: i.NEAREST_MIPMAP_LINEAR,
      [Kn]: i.LINEAR,
      [Pd]: i.LINEAR_MIPMAP_NEAREST,
      [Nr]: i.LINEAR_MIPMAP_LINEAR,
    },
    ft = {
      [wC]: i.NEVER,
      [OC]: i.ALWAYS,
      [CC]: i.LESS,
      [FA]: i.LEQUAL,
      [RC]: i.EQUAL,
      [UC]: i.GEQUAL,
      [BC]: i.GREATER,
      [DC]: i.NOTEQUAL,
    };
  function At($, k) {
    if (
      (k.type === Pi &&
        t.has("OES_texture_float_linear") === !1 &&
        (k.magFilter === Kn ||
          k.magFilter === Pd ||
          k.magFilter === If ||
          k.magFilter === Nr ||
          k.minFilter === Kn ||
          k.minFilter === Pd ||
          k.minFilter === If ||
          k.minFilter === Nr) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      i.texParameteri($, i.TEXTURE_WRAP_S, xt[k.wrapS]),
      i.texParameteri($, i.TEXTURE_WRAP_T, xt[k.wrapT]),
      ($ === i.TEXTURE_3D || $ === i.TEXTURE_2D_ARRAY) &&
        i.texParameteri($, i.TEXTURE_WRAP_R, xt[k.wrapR]),
      i.texParameteri($, i.TEXTURE_MAG_FILTER, X[k.magFilter]),
      i.texParameteri($, i.TEXTURE_MIN_FILTER, X[k.minFilter]),
      k.compareFunction &&
        (i.texParameteri($, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE),
        i.texParameteri($, i.TEXTURE_COMPARE_FUNC, ft[k.compareFunction])),
      t.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        k.magFilter === Ta ||
        (k.minFilter !== If && k.minFilter !== Nr) ||
        (k.type === Pi && t.has("OES_texture_float_linear") === !1)
      )
        return;
      if (k.anisotropy > 1 || n.get(k).__currentAnisotropy) {
        const Mt = t.get("EXT_texture_filter_anisotropic");
        i.texParameterf(
          $,
          Mt.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(k.anisotropy, a.getMaxAnisotropy())
        ),
          (n.get(k).__currentAnisotropy = k.anisotropy);
      }
    }
  }
  function Rt($, k) {
    let Mt = !1;
    $.__webglInit === void 0 &&
      (($.__webglInit = !0), k.addEventListener("dispose", P));
    const Ft = k.source;
    let Gt = x.get(Ft);
    Gt === void 0 && ((Gt = {}), x.set(Ft, Gt));
    const zt = dt(k);
    if (zt !== $.__cacheKey) {
      Gt[zt] === void 0 &&
        ((Gt[zt] = { texture: i.createTexture(), usedTimes: 0 }),
        l.memory.textures++,
        (Mt = !0)),
        Gt[zt].usedTimes++;
      const me = Gt[$.__cacheKey];
      me !== void 0 &&
        (Gt[$.__cacheKey].usedTimes--, me.usedTimes === 0 && N(k)),
        ($.__cacheKey = zt),
        ($.__webglTexture = Gt[zt].texture);
    }
    return Mt;
  }
  function ht($, k, Mt) {
    return Math.floor(Math.floor($ / Mt) / k);
  }
  function It($, k, Mt, Ft) {
    const zt = $.updateRanges;
    if (zt.length === 0)
      e.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, k.width, k.height, Mt, Ft, k.data);
    else {
      zt.sort((jt, ce) => jt.start - ce.start);
      let me = 0;
      for (let jt = 1; jt < zt.length; jt++) {
        const ce = zt[me],
          Re = zt[jt],
          it = ce.start + ce.count,
          yt = ht(Re.start, k.width, 4),
          Qt = ht(ce.start, k.width, 4);
        Re.start <= it + 1 &&
        yt === Qt &&
        ht(Re.start + Re.count - 1, k.width, 4) === yt
          ? (ce.count = Math.max(ce.count, Re.start + Re.count - ce.start))
          : (++me, (zt[me] = Re));
      }
      zt.length = me + 1;
      const de = i.getParameter(i.UNPACK_ROW_LENGTH),
        we = i.getParameter(i.UNPACK_SKIP_PIXELS),
        Ce = i.getParameter(i.UNPACK_SKIP_ROWS);
      i.pixelStorei(i.UNPACK_ROW_LENGTH, k.width);
      for (let jt = 0, ce = zt.length; jt < ce; jt++) {
        const Re = zt[jt],
          it = Math.floor(Re.start / 4),
          yt = Math.ceil(Re.count / 4),
          Qt = it % k.width,
          st = Math.floor(it / k.width),
          Et = yt,
          qt = 1;
        i.pixelStorei(i.UNPACK_SKIP_PIXELS, Qt),
          i.pixelStorei(i.UNPACK_SKIP_ROWS, st),
          e.texSubImage2D(i.TEXTURE_2D, 0, Qt, st, Et, qt, Mt, Ft, k.data);
      }
      $.clearUpdateRanges(),
        i.pixelStorei(i.UNPACK_ROW_LENGTH, de),
        i.pixelStorei(i.UNPACK_SKIP_PIXELS, we),
        i.pixelStorei(i.UNPACK_SKIP_ROWS, Ce);
    }
  }
  function Pt($, k, Mt) {
    let Ft = i.TEXTURE_2D;
    (k.isDataArrayTexture || k.isCompressedArrayTexture) &&
      (Ft = i.TEXTURE_2D_ARRAY),
      k.isData3DTexture && (Ft = i.TEXTURE_3D);
    const Gt = Rt($, k),
      zt = k.source;
    e.bindTexture(Ft, $.__webglTexture, i.TEXTURE0 + Mt);
    const me = n.get(zt);
    if (zt.version !== me.__version || Gt === !0) {
      e.activeTexture(i.TEXTURE0 + Mt);
      const de = In.getPrimaries(In.workingColorSpace),
        we = k.colorSpace === ql ? null : In.getPrimaries(k.colorSpace),
        Ce =
          k.colorSpace === ql || de === we ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, k.flipY),
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        i.pixelStorei(i.UNPACK_ALIGNMENT, k.unpackAlignment),
        i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ce);
      let jt = C(k.image, !1, a.maxTextureSize);
      jt = pe(k, jt);
      const ce = r.convert(k.format, k.colorSpace),
        Re = r.convert(k.type);
      let it = B(k.internalFormat, ce, Re, k.colorSpace, k.isVideoTexture);
      At(Ft, k);
      let yt;
      const Qt = k.mipmaps,
        st = k.isVideoTexture !== !0,
        Et = me.__version === void 0 || Gt === !0,
        qt = zt.dataReady,
        ge = I(k, jt);
      if (k.isDepthTexture)
        (it = D(k.format === Yd, k.type)),
          Et &&
            (st
              ? e.texStorage2D(i.TEXTURE_2D, 1, it, jt.width, jt.height)
              : e.texImage2D(
                  i.TEXTURE_2D,
                  0,
                  it,
                  jt.width,
                  jt.height,
                  0,
                  ce,
                  Re,
                  null
                ));
      else if (k.isDataTexture)
        if (Qt.length > 0) {
          st &&
            Et &&
            e.texStorage2D(i.TEXTURE_2D, ge, it, Qt[0].width, Qt[0].height);
          for (let oe = 0, Kt = Qt.length; oe < Kt; oe++)
            (yt = Qt[oe]),
              st
                ? qt &&
                  e.texSubImage2D(
                    i.TEXTURE_2D,
                    oe,
                    0,
                    0,
                    yt.width,
                    yt.height,
                    ce,
                    Re,
                    yt.data
                  )
                : e.texImage2D(
                    i.TEXTURE_2D,
                    oe,
                    it,
                    yt.width,
                    yt.height,
                    0,
                    ce,
                    Re,
                    yt.data
                  );
          k.generateMipmaps = !1;
        } else
          st
            ? (Et && e.texStorage2D(i.TEXTURE_2D, ge, it, jt.width, jt.height),
              qt && It(k, jt, ce, Re))
            : e.texImage2D(
                i.TEXTURE_2D,
                0,
                it,
                jt.width,
                jt.height,
                0,
                ce,
                Re,
                jt.data
              );
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          st &&
            Et &&
            e.texStorage3D(
              i.TEXTURE_2D_ARRAY,
              ge,
              it,
              Qt[0].width,
              Qt[0].height,
              jt.depth
            );
          for (let oe = 0, Kt = Qt.length; oe < Kt; oe++)
            if (((yt = Qt[oe]), k.format !== Ji))
              if (ce !== null)
                if (st) {
                  if (qt)
                    if (k.layerUpdates.size > 0) {
                      const be = qb(yt.width, yt.height, k.format, k.type);
                      for (const Le of k.layerUpdates) {
                        const mn = yt.data.subarray(
                          (Le * be) / yt.data.BYTES_PER_ELEMENT,
                          ((Le + 1) * be) / yt.data.BYTES_PER_ELEMENT
                        );
                        e.compressedTexSubImage3D(
                          i.TEXTURE_2D_ARRAY,
                          oe,
                          0,
                          0,
                          Le,
                          yt.width,
                          yt.height,
                          1,
                          ce,
                          mn
                        );
                      }
                      k.clearLayerUpdates();
                    } else
                      e.compressedTexSubImage3D(
                        i.TEXTURE_2D_ARRAY,
                        oe,
                        0,
                        0,
                        0,
                        yt.width,
                        yt.height,
                        jt.depth,
                        ce,
                        yt.data
                      );
                } else
                  e.compressedTexImage3D(
                    i.TEXTURE_2D_ARRAY,
                    oe,
                    it,
                    yt.width,
                    yt.height,
                    jt.depth,
                    0,
                    yt.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              st
                ? qt &&
                  e.texSubImage3D(
                    i.TEXTURE_2D_ARRAY,
                    oe,
                    0,
                    0,
                    0,
                    yt.width,
                    yt.height,
                    jt.depth,
                    ce,
                    Re,
                    yt.data
                  )
                : e.texImage3D(
                    i.TEXTURE_2D_ARRAY,
                    oe,
                    it,
                    yt.width,
                    yt.height,
                    jt.depth,
                    0,
                    ce,
                    Re,
                    yt.data
                  );
        } else {
          st &&
            Et &&
            e.texStorage2D(i.TEXTURE_2D, ge, it, Qt[0].width, Qt[0].height);
          for (let oe = 0, Kt = Qt.length; oe < Kt; oe++)
            (yt = Qt[oe]),
              k.format !== Ji
                ? ce !== null
                  ? st
                    ? qt &&
                      e.compressedTexSubImage2D(
                        i.TEXTURE_2D,
                        oe,
                        0,
                        0,
                        yt.width,
                        yt.height,
                        ce,
                        yt.data
                      )
                    : e.compressedTexImage2D(
                        i.TEXTURE_2D,
                        oe,
                        it,
                        yt.width,
                        yt.height,
                        0,
                        yt.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : st
                ? qt &&
                  e.texSubImage2D(
                    i.TEXTURE_2D,
                    oe,
                    0,
                    0,
                    yt.width,
                    yt.height,
                    ce,
                    Re,
                    yt.data
                  )
                : e.texImage2D(
                    i.TEXTURE_2D,
                    oe,
                    it,
                    yt.width,
                    yt.height,
                    0,
                    ce,
                    Re,
                    yt.data
                  );
        }
      else if (k.isDataArrayTexture)
        if (st) {
          if (
            (Et &&
              e.texStorage3D(
                i.TEXTURE_2D_ARRAY,
                ge,
                it,
                jt.width,
                jt.height,
                jt.depth
              ),
            qt)
          )
            if (k.layerUpdates.size > 0) {
              const oe = qb(jt.width, jt.height, k.format, k.type);
              for (const Kt of k.layerUpdates) {
                const be = jt.data.subarray(
                  (Kt * oe) / jt.data.BYTES_PER_ELEMENT,
                  ((Kt + 1) * oe) / jt.data.BYTES_PER_ELEMENT
                );
                e.texSubImage3D(
                  i.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Kt,
                  jt.width,
                  jt.height,
                  1,
                  ce,
                  Re,
                  be
                );
              }
              k.clearLayerUpdates();
            } else
              e.texSubImage3D(
                i.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                jt.width,
                jt.height,
                jt.depth,
                ce,
                Re,
                jt.data
              );
        } else
          e.texImage3D(
            i.TEXTURE_2D_ARRAY,
            0,
            it,
            jt.width,
            jt.height,
            jt.depth,
            0,
            ce,
            Re,
            jt.data
          );
      else if (k.isData3DTexture)
        st
          ? (Et &&
              e.texStorage3D(
                i.TEXTURE_3D,
                ge,
                it,
                jt.width,
                jt.height,
                jt.depth
              ),
            qt &&
              e.texSubImage3D(
                i.TEXTURE_3D,
                0,
                0,
                0,
                0,
                jt.width,
                jt.height,
                jt.depth,
                ce,
                Re,
                jt.data
              ))
          : e.texImage3D(
              i.TEXTURE_3D,
              0,
              it,
              jt.width,
              jt.height,
              jt.depth,
              0,
              ce,
              Re,
              jt.data
            );
      else if (k.isFramebufferTexture) {
        if (Et)
          if (st) e.texStorage2D(i.TEXTURE_2D, ge, it, jt.width, jt.height);
          else {
            let oe = jt.width,
              Kt = jt.height;
            for (let be = 0; be < ge; be++)
              e.texImage2D(i.TEXTURE_2D, be, it, oe, Kt, 0, ce, Re, null),
                (oe >>= 1),
                (Kt >>= 1);
          }
      } else if (Qt.length > 0) {
        if (st && Et) {
          const oe = Ye(Qt[0]);
          e.texStorage2D(i.TEXTURE_2D, ge, it, oe.width, oe.height);
        }
        for (let oe = 0, Kt = Qt.length; oe < Kt; oe++)
          (yt = Qt[oe]),
            st
              ? qt && e.texSubImage2D(i.TEXTURE_2D, oe, 0, 0, ce, Re, yt)
              : e.texImage2D(i.TEXTURE_2D, oe, it, ce, Re, yt);
        k.generateMipmaps = !1;
      } else if (st) {
        if (Et) {
          const oe = Ye(jt);
          e.texStorage2D(i.TEXTURE_2D, ge, it, oe.width, oe.height);
        }
        qt && e.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ce, Re, jt);
      } else e.texImage2D(i.TEXTURE_2D, 0, it, ce, Re, jt);
      E(k) && S(Ft), (me.__version = zt.version), k.onUpdate && k.onUpdate(k);
    }
    $.__version = k.version;
  }
  function re($, k, Mt) {
    if (k.image.length !== 6) return;
    const Ft = Rt($, k),
      Gt = k.source;
    e.bindTexture(i.TEXTURE_CUBE_MAP, $.__webglTexture, i.TEXTURE0 + Mt);
    const zt = n.get(Gt);
    if (Gt.version !== zt.__version || Ft === !0) {
      e.activeTexture(i.TEXTURE0 + Mt);
      const me = In.getPrimaries(In.workingColorSpace),
        de = k.colorSpace === ql ? null : In.getPrimaries(k.colorSpace),
        we =
          k.colorSpace === ql || me === de ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, k.flipY),
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        i.pixelStorei(i.UNPACK_ALIGNMENT, k.unpackAlignment),
        i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, we);
      const Ce = k.isCompressedTexture || k.image[0].isCompressedTexture,
        jt = k.image[0] && k.image[0].isDataTexture,
        ce = [];
      for (let Kt = 0; Kt < 6; Kt++)
        !Ce && !jt
          ? (ce[Kt] = C(k.image[Kt], !0, a.maxCubemapSize))
          : (ce[Kt] = jt ? k.image[Kt].image : k.image[Kt]),
          (ce[Kt] = pe(k, ce[Kt]));
      const Re = ce[0],
        it = r.convert(k.format, k.colorSpace),
        yt = r.convert(k.type),
        Qt = B(k.internalFormat, it, yt, k.colorSpace),
        st = k.isVideoTexture !== !0,
        Et = zt.__version === void 0 || Ft === !0,
        qt = Gt.dataReady;
      let ge = I(k, Re);
      At(i.TEXTURE_CUBE_MAP, k);
      let oe;
      if (Ce) {
        st &&
          Et &&
          e.texStorage2D(i.TEXTURE_CUBE_MAP, ge, Qt, Re.width, Re.height);
        for (let Kt = 0; Kt < 6; Kt++) {
          oe = ce[Kt].mipmaps;
          for (let be = 0; be < oe.length; be++) {
            const Le = oe[be];
            k.format !== Ji
              ? it !== null
                ? st
                  ? qt &&
                    e.compressedTexSubImage2D(
                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                      be,
                      0,
                      0,
                      Le.width,
                      Le.height,
                      it,
                      Le.data
                    )
                  : e.compressedTexImage2D(
                      i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                      be,
                      Qt,
                      Le.width,
                      Le.height,
                      0,
                      Le.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : st
              ? qt &&
                e.texSubImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                  be,
                  0,
                  0,
                  Le.width,
                  Le.height,
                  it,
                  yt,
                  Le.data
                )
              : e.texImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                  be,
                  Qt,
                  Le.width,
                  Le.height,
                  0,
                  it,
                  yt,
                  Le.data
                );
          }
        }
      } else {
        if (((oe = k.mipmaps), st && Et)) {
          oe.length > 0 && ge++;
          const Kt = Ye(ce[0]);
          e.texStorage2D(i.TEXTURE_CUBE_MAP, ge, Qt, Kt.width, Kt.height);
        }
        for (let Kt = 0; Kt < 6; Kt++)
          if (jt) {
            st
              ? qt &&
                e.texSubImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                  0,
                  0,
                  0,
                  ce[Kt].width,
                  ce[Kt].height,
                  it,
                  yt,
                  ce[Kt].data
                )
              : e.texImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                  0,
                  Qt,
                  ce[Kt].width,
                  ce[Kt].height,
                  0,
                  it,
                  yt,
                  ce[Kt].data
                );
            for (let be = 0; be < oe.length; be++) {
              const mn = oe[be].image[Kt].image;
              st
                ? qt &&
                  e.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                    be + 1,
                    0,
                    0,
                    mn.width,
                    mn.height,
                    it,
                    yt,
                    mn.data
                  )
                : e.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                    be + 1,
                    Qt,
                    mn.width,
                    mn.height,
                    0,
                    it,
                    yt,
                    mn.data
                  );
            }
          } else {
            st
              ? qt &&
                e.texSubImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                  0,
                  0,
                  0,
                  it,
                  yt,
                  ce[Kt]
                )
              : e.texImage2D(
                  i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                  0,
                  Qt,
                  it,
                  yt,
                  ce[Kt]
                );
            for (let be = 0; be < oe.length; be++) {
              const Le = oe[be];
              st
                ? qt &&
                  e.texSubImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                    be + 1,
                    0,
                    0,
                    it,
                    yt,
                    Le.image[Kt]
                  )
                : e.texImage2D(
                    i.TEXTURE_CUBE_MAP_POSITIVE_X + Kt,
                    be + 1,
                    Qt,
                    it,
                    yt,
                    Le.image[Kt]
                  );
            }
          }
      }
      E(k) && S(i.TEXTURE_CUBE_MAP),
        (zt.__version = Gt.version),
        k.onUpdate && k.onUpdate(k);
    }
    $.__version = k.version;
  }
  function ie($, k, Mt, Ft, Gt, zt) {
    const me = r.convert(Mt.format, Mt.colorSpace),
      de = r.convert(Mt.type),
      we = B(Mt.internalFormat, me, de, Mt.colorSpace),
      Ce = n.get(k),
      jt = n.get(Mt);
    if (((jt.__renderTarget = k), !Ce.__hasExternalTextures)) {
      const ce = Math.max(1, k.width >> zt),
        Re = Math.max(1, k.height >> zt);
      Gt === i.TEXTURE_3D || Gt === i.TEXTURE_2D_ARRAY
        ? e.texImage3D(Gt, zt, we, ce, Re, k.depth, 0, me, de, null)
        : e.texImage2D(Gt, zt, we, ce, Re, 0, me, de, null);
    }
    e.bindFramebuffer(i.FRAMEBUFFER, $),
      ye(k)
        ? u.framebufferTexture2DMultisampleEXT(
            i.FRAMEBUFFER,
            Ft,
            Gt,
            jt.__webglTexture,
            0,
            kt(k)
          )
        : (Gt === i.TEXTURE_2D ||
            (Gt >= i.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Gt <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          i.framebufferTexture2D(i.FRAMEBUFFER, Ft, Gt, jt.__webglTexture, zt),
      e.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function Fe($, k, Mt) {
    if ((i.bindRenderbuffer(i.RENDERBUFFER, $), k.depthBuffer)) {
      const Ft = k.depthTexture,
        Gt = Ft && Ft.isDepthTexture ? Ft.type : null,
        zt = D(k.stencilBuffer, Gt),
        me = k.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT,
        de = kt(k);
      ye(k)
        ? u.renderbufferStorageMultisampleEXT(
            i.RENDERBUFFER,
            de,
            zt,
            k.width,
            k.height
          )
        : Mt
        ? i.renderbufferStorageMultisample(
            i.RENDERBUFFER,
            de,
            zt,
            k.width,
            k.height
          )
        : i.renderbufferStorage(i.RENDERBUFFER, zt, k.width, k.height),
        i.framebufferRenderbuffer(i.FRAMEBUFFER, me, i.RENDERBUFFER, $);
    } else {
      const Ft = k.textures;
      for (let Gt = 0; Gt < Ft.length; Gt++) {
        const zt = Ft[Gt],
          me = r.convert(zt.format, zt.colorSpace),
          de = r.convert(zt.type),
          we = B(zt.internalFormat, me, de, zt.colorSpace),
          Ce = kt(k);
        Mt && ye(k) === !1
          ? i.renderbufferStorageMultisample(
              i.RENDERBUFFER,
              Ce,
              we,
              k.width,
              k.height
            )
          : ye(k)
          ? u.renderbufferStorageMultisampleEXT(
              i.RENDERBUFFER,
              Ce,
              we,
              k.width,
              k.height
            )
          : i.renderbufferStorage(i.RENDERBUFFER, we, k.width, k.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function Ae($, k) {
    if (k && k.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (e.bindFramebuffer(i.FRAMEBUFFER, $),
      !(k.depthTexture && k.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    const Ft = n.get(k.depthTexture);
    (Ft.__renderTarget = k),
      (!Ft.__webglTexture ||
        k.depthTexture.image.width !== k.width ||
        k.depthTexture.image.height !== k.height) &&
        ((k.depthTexture.image.width = k.width),
        (k.depthTexture.image.height = k.height),
        (k.depthTexture.needsUpdate = !0)),
      pt(k.depthTexture, 0);
    const Gt = Ft.__webglTexture,
      zt = kt(k);
    if (k.depthTexture.format === Wd)
      ye(k)
        ? u.framebufferTexture2DMultisampleEXT(
            i.FRAMEBUFFER,
            i.DEPTH_ATTACHMENT,
            i.TEXTURE_2D,
            Gt,
            0,
            zt
          )
        : i.framebufferTexture2D(
            i.FRAMEBUFFER,
            i.DEPTH_ATTACHMENT,
            i.TEXTURE_2D,
            Gt,
            0
          );
    else if (k.depthTexture.format === Yd)
      ye(k)
        ? u.framebufferTexture2DMultisampleEXT(
            i.FRAMEBUFFER,
            i.DEPTH_STENCIL_ATTACHMENT,
            i.TEXTURE_2D,
            Gt,
            0,
            zt
          )
        : i.framebufferTexture2D(
            i.FRAMEBUFFER,
            i.DEPTH_STENCIL_ATTACHMENT,
            i.TEXTURE_2D,
            Gt,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function De($) {
    const k = n.get($),
      Mt = $.isWebGLCubeRenderTarget === !0;
    if (k.__boundDepthTexture !== $.depthTexture) {
      const Ft = $.depthTexture;
      if ((k.__depthDisposeCallback && k.__depthDisposeCallback(), Ft)) {
        const Gt = () => {
          delete k.__boundDepthTexture,
            delete k.__depthDisposeCallback,
            Ft.removeEventListener("dispose", Gt);
        };
        Ft.addEventListener("dispose", Gt), (k.__depthDisposeCallback = Gt);
      }
      k.__boundDepthTexture = Ft;
    }
    if ($.depthTexture && !k.__autoAllocateDepthBuffer) {
      if (Mt)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      const Ft = $.texture.mipmaps;
      Ft && Ft.length > 0
        ? Ae(k.__webglFramebuffer[0], $)
        : Ae(k.__webglFramebuffer, $);
    } else if (Mt) {
      k.__webglDepthbuffer = [];
      for (let Ft = 0; Ft < 6; Ft++)
        if (
          (e.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer[Ft]),
          k.__webglDepthbuffer[Ft] === void 0)
        )
          (k.__webglDepthbuffer[Ft] = i.createRenderbuffer()),
            Fe(k.__webglDepthbuffer[Ft], $, !1);
        else {
          const Gt = $.stencilBuffer
              ? i.DEPTH_STENCIL_ATTACHMENT
              : i.DEPTH_ATTACHMENT,
            zt = k.__webglDepthbuffer[Ft];
          i.bindRenderbuffer(i.RENDERBUFFER, zt),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, Gt, i.RENDERBUFFER, zt);
        }
    } else {
      const Ft = $.texture.mipmaps;
      if (
        (Ft && Ft.length > 0
          ? e.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer[0])
          : e.bindFramebuffer(i.FRAMEBUFFER, k.__webglFramebuffer),
        k.__webglDepthbuffer === void 0)
      )
        (k.__webglDepthbuffer = i.createRenderbuffer()),
          Fe(k.__webglDepthbuffer, $, !1);
      else {
        const Gt = $.stencilBuffer
            ? i.DEPTH_STENCIL_ATTACHMENT
            : i.DEPTH_ATTACHMENT,
          zt = k.__webglDepthbuffer;
        i.bindRenderbuffer(i.RENDERBUFFER, zt),
          i.framebufferRenderbuffer(i.FRAMEBUFFER, Gt, i.RENDERBUFFER, zt);
      }
    }
    e.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function je($, k, Mt) {
    const Ft = n.get($);
    k !== void 0 &&
      ie(
        Ft.__webglFramebuffer,
        $,
        $.texture,
        i.COLOR_ATTACHMENT0,
        i.TEXTURE_2D,
        0
      ),
      Mt !== void 0 && De($);
  }
  function Ue($) {
    const k = $.texture,
      Mt = n.get($),
      Ft = n.get(k);
    $.addEventListener("dispose", V);
    const Gt = $.textures,
      zt = $.isWebGLCubeRenderTarget === !0,
      me = Gt.length > 1;
    if (
      (me ||
        (Ft.__webglTexture === void 0 &&
          (Ft.__webglTexture = i.createTexture()),
        (Ft.__version = k.version),
        l.memory.textures++),
      zt)
    ) {
      Mt.__webglFramebuffer = [];
      for (let de = 0; de < 6; de++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          Mt.__webglFramebuffer[de] = [];
          for (let we = 0; we < k.mipmaps.length; we++)
            Mt.__webglFramebuffer[de][we] = i.createFramebuffer();
        } else Mt.__webglFramebuffer[de] = i.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        Mt.__webglFramebuffer = [];
        for (let de = 0; de < k.mipmaps.length; de++)
          Mt.__webglFramebuffer[de] = i.createFramebuffer();
      } else Mt.__webglFramebuffer = i.createFramebuffer();
      if (me)
        for (let de = 0, we = Gt.length; de < we; de++) {
          const Ce = n.get(Gt[de]);
          Ce.__webglTexture === void 0 &&
            ((Ce.__webglTexture = i.createTexture()), l.memory.textures++);
        }
      if ($.samples > 0 && ye($) === !1) {
        (Mt.__webglMultisampledFramebuffer = i.createFramebuffer()),
          (Mt.__webglColorRenderbuffer = []),
          e.bindFramebuffer(i.FRAMEBUFFER, Mt.__webglMultisampledFramebuffer);
        for (let de = 0; de < Gt.length; de++) {
          const we = Gt[de];
          (Mt.__webglColorRenderbuffer[de] = i.createRenderbuffer()),
            i.bindRenderbuffer(i.RENDERBUFFER, Mt.__webglColorRenderbuffer[de]);
          const Ce = r.convert(we.format, we.colorSpace),
            jt = r.convert(we.type),
            ce = B(
              we.internalFormat,
              Ce,
              jt,
              we.colorSpace,
              $.isXRRenderTarget === !0
            ),
            Re = kt($);
          i.renderbufferStorageMultisample(
            i.RENDERBUFFER,
            Re,
            ce,
            $.width,
            $.height
          ),
            i.framebufferRenderbuffer(
              i.FRAMEBUFFER,
              i.COLOR_ATTACHMENT0 + de,
              i.RENDERBUFFER,
              Mt.__webglColorRenderbuffer[de]
            );
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null),
          $.depthBuffer &&
            ((Mt.__webglDepthRenderbuffer = i.createRenderbuffer()),
            Fe(Mt.__webglDepthRenderbuffer, $, !0)),
          e.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    }
    if (zt) {
      e.bindTexture(i.TEXTURE_CUBE_MAP, Ft.__webglTexture),
        At(i.TEXTURE_CUBE_MAP, k);
      for (let de = 0; de < 6; de++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let we = 0; we < k.mipmaps.length; we++)
            ie(
              Mt.__webglFramebuffer[de][we],
              $,
              k,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_CUBE_MAP_POSITIVE_X + de,
              we
            );
        else
          ie(
            Mt.__webglFramebuffer[de],
            $,
            k,
            i.COLOR_ATTACHMENT0,
            i.TEXTURE_CUBE_MAP_POSITIVE_X + de,
            0
          );
      E(k) && S(i.TEXTURE_CUBE_MAP), e.unbindTexture();
    } else if (me) {
      for (let de = 0, we = Gt.length; de < we; de++) {
        const Ce = Gt[de],
          jt = n.get(Ce);
        e.bindTexture(i.TEXTURE_2D, jt.__webglTexture),
          At(i.TEXTURE_2D, Ce),
          ie(
            Mt.__webglFramebuffer,
            $,
            Ce,
            i.COLOR_ATTACHMENT0 + de,
            i.TEXTURE_2D,
            0
          ),
          E(Ce) && S(i.TEXTURE_2D);
      }
      e.unbindTexture();
    } else {
      let de = i.TEXTURE_2D;
      if (
        (($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) &&
          (de = $.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY),
        e.bindTexture(de, Ft.__webglTexture),
        At(de, k),
        k.mipmaps && k.mipmaps.length > 0)
      )
        for (let we = 0; we < k.mipmaps.length; we++)
          ie(Mt.__webglFramebuffer[we], $, k, i.COLOR_ATTACHMENT0, de, we);
      else ie(Mt.__webglFramebuffer, $, k, i.COLOR_ATTACHMENT0, de, 0);
      E(k) && S(de), e.unbindTexture();
    }
    $.depthBuffer && De($);
  }
  function J($) {
    const k = $.textures;
    for (let Mt = 0, Ft = k.length; Mt < Ft; Mt++) {
      const Gt = k[Mt];
      if (E(Gt)) {
        const zt = R($),
          me = n.get(Gt).__webglTexture;
        e.bindTexture(zt, me), S(zt), e.unbindTexture();
      }
    }
  }
  const le = [],
    se = [];
  function $t($) {
    if ($.samples > 0) {
      if (ye($) === !1) {
        const k = $.textures,
          Mt = $.width,
          Ft = $.height;
        let Gt = i.COLOR_BUFFER_BIT;
        const zt = $.stencilBuffer
            ? i.DEPTH_STENCIL_ATTACHMENT
            : i.DEPTH_ATTACHMENT,
          me = n.get($),
          de = k.length > 1;
        if (de)
          for (let Ce = 0; Ce < k.length; Ce++)
            e.bindFramebuffer(i.FRAMEBUFFER, me.__webglMultisampledFramebuffer),
              i.framebufferRenderbuffer(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + Ce,
                i.RENDERBUFFER,
                null
              ),
              e.bindFramebuffer(i.FRAMEBUFFER, me.__webglFramebuffer),
              i.framebufferTexture2D(
                i.DRAW_FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + Ce,
                i.TEXTURE_2D,
                null,
                0
              );
        e.bindFramebuffer(
          i.READ_FRAMEBUFFER,
          me.__webglMultisampledFramebuffer
        );
        const we = $.texture.mipmaps;
        we && we.length > 0
          ? e.bindFramebuffer(i.DRAW_FRAMEBUFFER, me.__webglFramebuffer[0])
          : e.bindFramebuffer(i.DRAW_FRAMEBUFFER, me.__webglFramebuffer);
        for (let Ce = 0; Ce < k.length; Ce++) {
          if (
            ($.resolveDepthBuffer &&
              ($.depthBuffer && (Gt |= i.DEPTH_BUFFER_BIT),
              $.stencilBuffer &&
                $.resolveStencilBuffer &&
                (Gt |= i.STENCIL_BUFFER_BIT)),
            de)
          ) {
            i.framebufferRenderbuffer(
              i.READ_FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.RENDERBUFFER,
              me.__webglColorRenderbuffer[Ce]
            );
            const jt = n.get(k[Ce]).__webglTexture;
            i.framebufferTexture2D(
              i.DRAW_FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.TEXTURE_2D,
              jt,
              0
            );
          }
          i.blitFramebuffer(0, 0, Mt, Ft, 0, 0, Mt, Ft, Gt, i.NEAREST),
            h === !0 &&
              ((le.length = 0),
              (se.length = 0),
              le.push(i.COLOR_ATTACHMENT0 + Ce),
              $.depthBuffer &&
                $.resolveDepthBuffer === !1 &&
                (le.push(zt),
                se.push(zt),
                i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, se)),
              i.invalidateFramebuffer(i.READ_FRAMEBUFFER, le));
        }
        if (
          (e.bindFramebuffer(i.READ_FRAMEBUFFER, null),
          e.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
          de)
        )
          for (let Ce = 0; Ce < k.length; Ce++) {
            e.bindFramebuffer(i.FRAMEBUFFER, me.__webglMultisampledFramebuffer),
              i.framebufferRenderbuffer(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + Ce,
                i.RENDERBUFFER,
                me.__webglColorRenderbuffer[Ce]
              );
            const jt = n.get(k[Ce]).__webglTexture;
            e.bindFramebuffer(i.FRAMEBUFFER, me.__webglFramebuffer),
              i.framebufferTexture2D(
                i.DRAW_FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + Ce,
                i.TEXTURE_2D,
                jt,
                0
              );
          }
        e.bindFramebuffer(
          i.DRAW_FRAMEBUFFER,
          me.__webglMultisampledFramebuffer
        );
      } else if ($.depthBuffer && $.resolveDepthBuffer === !1 && h) {
        const k = $.stencilBuffer
          ? i.DEPTH_STENCIL_ATTACHMENT
          : i.DEPTH_ATTACHMENT;
        i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function kt($) {
    return Math.min(a.maxSamples, $.samples);
  }
  function ye($) {
    const k = n.get($);
    return (
      $.samples > 0 &&
      t.has("WEBGL_multisampled_render_to_texture") === !0 &&
      k.__useRenderToTexture !== !1
    );
  }
  function te($) {
    const k = l.render.frame;
    m.get($) !== k && (m.set($, k), $.update());
  }
  function pe($, k) {
    const Mt = $.colorSpace,
      Ft = $.format,
      Gt = $.type;
    return (
      $.isCompressedTexture === !0 ||
        $.isVideoTexture === !0 ||
        (Mt !== bo &&
          Mt !== ql &&
          (In.getTransfer(Mt) === ai
            ? (Ft !== Ji || Gt !== Es) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                Mt
              ))),
      k
    );
  }
  function Ye($) {
    return (
      typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement
        ? ((p.width = $.naturalWidth || $.width),
          (p.height = $.naturalHeight || $.height))
        : typeof VideoFrame < "u" && $ instanceof VideoFrame
        ? ((p.width = $.displayWidth), (p.height = $.displayHeight))
        : ((p.width = $.width), (p.height = $.height)),
      p
    );
  }
  (this.allocateTextureUnit = nt),
    (this.resetTextureUnits = ct),
    (this.setTexture2D = pt),
    (this.setTexture2DArray = j),
    (this.setTexture3D = Q),
    (this.setTextureCube = et),
    (this.rebindTextures = je),
    (this.setupRenderTarget = Ue),
    (this.updateRenderTargetMipmap = J),
    (this.updateMultisampleRenderTarget = $t),
    (this.setupDepthRenderbuffer = De),
    (this.setupFrameBufferTexture = ie),
    (this.useMultisampledRTT = ye);
}
function FR(i, t) {
  function e(n, a = ql) {
    let r;
    const l = In.getTransfer(a);
    if (n === Es) return i.UNSIGNED_BYTE;
    if (n === Ix) return i.UNSIGNED_SHORT_4_4_4_4;
    if (n === Px) return i.UNSIGNED_SHORT_5_5_5_1;
    if (n === DA) return i.UNSIGNED_INT_5_9_9_9_REV;
    if (n === Nx) return i.BYTE;
    if (n === Lx) return i.SHORT;
    if (n === jd) return i.UNSIGNED_SHORT;
    if (n === B0) return i.INT;
    if (n === pl) return i.UNSIGNED_INT;
    if (n === Pi) return i.FLOAT;
    if (n === Ea) return i.HALF_FLOAT;
    if (n === UA) return i.ALPHA;
    if (n === OA) return i.RGB;
    if (n === Ji) return i.RGBA;
    if (n === Wd) return i.DEPTH_COMPONENT;
    if (n === Yd) return i.DEPTH_STENCIL;
    if (n === D0) return i.RED;
    if (n === U0) return i.RED_INTEGER;
    if (n === NA) return i.RG;
    if (n === zx) return i.RG_INTEGER;
    if (n === Fx) return i.RGBA_INTEGER;
    if (n === Ym || n === qm || n === Km || n === Jm)
      if (l === ai)
        if (((r = t.get("WEBGL_compressed_texture_s3tc_srgb")), r !== null)) {
          if (n === Ym) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === qm) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Km) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Jm) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((r = t.get("WEBGL_compressed_texture_s3tc")), r !== null)) {
        if (n === Ym) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === qm) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Km) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Jm) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (n === ky || n === jy || n === Xy || n === Wy)
      if (((r = t.get("WEBGL_compressed_texture_pvrtc")), r !== null)) {
        if (n === ky) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === jy) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === Xy) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === Wy) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (n === Yy || n === qy || n === Ky)
      if (((r = t.get("WEBGL_compressed_texture_etc")), r !== null)) {
        if (n === Yy || n === qy)
          return l === ai ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (n === Ky)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      n === Jy ||
      n === Zy ||
      n === Qy ||
      n === $y ||
      n === tx ||
      n === ex ||
      n === nx ||
      n === ix ||
      n === ax ||
      n === sx ||
      n === rx ||
      n === ox ||
      n === lx ||
      n === cx
    )
      if (((r = t.get("WEBGL_compressed_texture_astc")), r !== null)) {
        if (n === Jy)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === Zy)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === Qy)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === $y)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === tx)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === ex)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === nx)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === ix)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === ax)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === sx)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === rx)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === ox)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === lx)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === cx)
          return l === ai
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (n === Zm || n === ux || n === fx)
      if (((r = t.get("EXT_texture_compression_bptc")), r !== null)) {
        if (n === Zm)
          return l === ai
            ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === ux) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === fx) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (n === LA || n === hx || n === dx || n === px)
      if (((r = t.get("EXT_texture_compression_rgtc")), r !== null)) {
        if (n === Zm) return r.COMPRESSED_RED_RGTC1_EXT;
        if (n === hx) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === dx) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === px) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return n === Xd ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
  }
  return { convert: e };
}
const K5 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  J5 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class Z5 {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(t, e, n) {
    if (this.texture === null) {
      const a = new Zn(),
        r = t.properties.get(a);
      (r.__webglTexture = e.texture),
        (e.depthNear !== n.depthNear || e.depthFar !== n.depthFar) &&
          ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
        (this.texture = a);
    }
  }
  getMesh(t) {
    if (this.texture !== null && this.mesh === null) {
      const e = t.cameras[0].viewport,
        n = new Xs({
          vertexShader: K5,
          fragmentShader: J5,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: e.z },
            depthHeight: { value: e.w },
          },
        });
      this.mesh = new Ti(new xu(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class Q5 extends ml {
  constructor(t, e) {
    super();
    const n = this;
    let a = null,
      r = 1,
      l = null,
      u = "local-floor",
      h = 1,
      p = null,
      m = null,
      v = null,
      x = null,
      _ = null,
      M = null;
    const C = new Z5(),
      E = e.getContextAttributes();
    let S = null,
      R = null;
    const B = [],
      D = [],
      I = new Yt();
    let P = null;
    const V = new Ei();
    V.viewport = new Hn();
    const F = new Ei();
    F.viewport = new Hn();
    const N = [V, F],
      L = new CR();
    let Y = null,
      ct = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (ht) {
        let It = B[ht];
        return (
          It === void 0 && ((It = new Ty()), (B[ht] = It)),
          It.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (ht) {
        let It = B[ht];
        return (
          It === void 0 && ((It = new Ty()), (B[ht] = It)), It.getGripSpace()
        );
      }),
      (this.getHand = function (ht) {
        let It = B[ht];
        return (
          It === void 0 && ((It = new Ty()), (B[ht] = It)), It.getHandSpace()
        );
      });
    function nt(ht) {
      const It = D.indexOf(ht.inputSource);
      if (It === -1) return;
      const Pt = B[It];
      Pt !== void 0 &&
        (Pt.update(ht.inputSource, ht.frame, p || l),
        Pt.dispatchEvent({ type: ht.type, data: ht.inputSource }));
    }
    function dt() {
      a.removeEventListener("select", nt),
        a.removeEventListener("selectstart", nt),
        a.removeEventListener("selectend", nt),
        a.removeEventListener("squeeze", nt),
        a.removeEventListener("squeezestart", nt),
        a.removeEventListener("squeezeend", nt),
        a.removeEventListener("end", dt),
        a.removeEventListener("inputsourceschange", pt);
      for (let ht = 0; ht < B.length; ht++) {
        const It = D[ht];
        It !== null && ((D[ht] = null), B[ht].disconnect(It));
      }
      (Y = null),
        (ct = null),
        C.reset(),
        t.setRenderTarget(S),
        (_ = null),
        (x = null),
        (v = null),
        (a = null),
        (R = null),
        Rt.stop(),
        (n.isPresenting = !1),
        t.setPixelRatio(P),
        t.setSize(I.width, I.height, !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (ht) {
      (r = ht),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (ht) {
        (u = ht),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return p || l;
      }),
      (this.setReferenceSpace = function (ht) {
        p = ht;
      }),
      (this.getBaseLayer = function () {
        return x !== null ? x : _;
      }),
      (this.getBinding = function () {
        return v;
      }),
      (this.getFrame = function () {
        return M;
      }),
      (this.getSession = function () {
        return a;
      }),
      (this.setSession = async function (ht) {
        if (((a = ht), a !== null)) {
          if (
            ((S = t.getRenderTarget()),
            a.addEventListener("select", nt),
            a.addEventListener("selectstart", nt),
            a.addEventListener("selectend", nt),
            a.addEventListener("squeeze", nt),
            a.addEventListener("squeezestart", nt),
            a.addEventListener("squeezeend", nt),
            a.addEventListener("end", dt),
            a.addEventListener("inputsourceschange", pt),
            E.xrCompatible !== !0 && (await e.makeXRCompatible()),
            (P = t.getPixelRatio()),
            t.getSize(I),
            typeof XRWebGLBinding < "u" &&
              "createProjectionLayer" in XRWebGLBinding.prototype)
          ) {
            let Pt = null,
              re = null,
              ie = null;
            E.depth &&
              ((ie = E.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
              (Pt = E.stencil ? Yd : Wd),
              (re = E.stencil ? Xd : pl));
            const Fe = {
              colorFormat: e.RGBA8,
              depthFormat: ie,
              scaleFactor: r,
            };
            (v = new XRWebGLBinding(a, e)),
              (x = v.createProjectionLayer(Fe)),
              a.updateRenderState({ layers: [x] }),
              t.setPixelRatio(1),
              t.setSize(x.textureWidth, x.textureHeight, !1),
              (R = new zr(x.textureWidth, x.textureHeight, {
                format: Ji,
                type: Es,
                depthTexture: new JA(
                  x.textureWidth,
                  x.textureHeight,
                  re,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Pt
                ),
                stencilBuffer: E.stencil,
                colorSpace: t.outputColorSpace,
                samples: E.antialias ? 4 : 0,
                resolveDepthBuffer: x.ignoreDepthValues === !1,
                resolveStencilBuffer: x.ignoreDepthValues === !1,
              }));
          } else {
            const Pt = {
              antialias: E.antialias,
              alpha: !0,
              depth: E.depth,
              stencil: E.stencil,
              framebufferScaleFactor: r,
            };
            (_ = new XRWebGLLayer(a, e, Pt)),
              a.updateRenderState({ baseLayer: _ }),
              t.setPixelRatio(1),
              t.setSize(_.framebufferWidth, _.framebufferHeight, !1),
              (R = new zr(_.framebufferWidth, _.framebufferHeight, {
                format: Ji,
                type: Es,
                colorSpace: t.outputColorSpace,
                stencilBuffer: E.stencil,
                resolveDepthBuffer: _.ignoreDepthValues === !1,
                resolveStencilBuffer: _.ignoreDepthValues === !1,
              }));
          }
          (R.isXRRenderTarget = !0),
            this.setFoveation(h),
            (p = null),
            (l = await a.requestReferenceSpace(u)),
            Rt.setContext(a),
            Rt.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (a !== null) return a.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return C.getDepthTexture();
      });
    function pt(ht) {
      for (let It = 0; It < ht.removed.length; It++) {
        const Pt = ht.removed[It],
          re = D.indexOf(Pt);
        re >= 0 && ((D[re] = null), B[re].disconnect(Pt));
      }
      for (let It = 0; It < ht.added.length; It++) {
        const Pt = ht.added[It];
        let re = D.indexOf(Pt);
        if (re === -1) {
          for (let Fe = 0; Fe < B.length; Fe++)
            if (Fe >= D.length) {
              D.push(Pt), (re = Fe);
              break;
            } else if (D[Fe] === null) {
              (D[Fe] = Pt), (re = Fe);
              break;
            }
          if (re === -1) break;
        }
        const ie = B[re];
        ie && ie.connect(Pt);
      }
    }
    const j = new Z(),
      Q = new Z();
    function et(ht, It, Pt) {
      j.setFromMatrixPosition(It.matrixWorld),
        Q.setFromMatrixPosition(Pt.matrixWorld);
      const re = j.distanceTo(Q),
        ie = It.projectionMatrix.elements,
        Fe = Pt.projectionMatrix.elements,
        Ae = ie[14] / (ie[10] - 1),
        De = ie[14] / (ie[10] + 1),
        je = (ie[9] + 1) / ie[5],
        Ue = (ie[9] - 1) / ie[5],
        J = (ie[8] - 1) / ie[0],
        le = (Fe[8] + 1) / Fe[0],
        se = Ae * J,
        $t = Ae * le,
        kt = re / (-J + le),
        ye = kt * -J;
      if (
        (It.matrixWorld.decompose(ht.position, ht.quaternion, ht.scale),
        ht.translateX(ye),
        ht.translateZ(kt),
        ht.matrixWorld.compose(ht.position, ht.quaternion, ht.scale),
        ht.matrixWorldInverse.copy(ht.matrixWorld).invert(),
        ie[10] === -1)
      )
        ht.projectionMatrix.copy(It.projectionMatrix),
          ht.projectionMatrixInverse.copy(It.projectionMatrixInverse);
      else {
        const te = Ae + kt,
          pe = De + kt,
          Ye = se - ye,
          $ = $t + (re - ye),
          k = ((je * De) / pe) * te,
          Mt = ((Ue * De) / pe) * te;
        ht.projectionMatrix.makePerspective(Ye, $, k, Mt, te, pe),
          ht.projectionMatrixInverse.copy(ht.projectionMatrix).invert();
      }
    }
    function xt(ht, It) {
      It === null
        ? ht.matrixWorld.copy(ht.matrix)
        : ht.matrixWorld.multiplyMatrices(It.matrixWorld, ht.matrix),
        ht.matrixWorldInverse.copy(ht.matrixWorld).invert();
    }
    this.updateCamera = function (ht) {
      if (a === null) return;
      let It = ht.near,
        Pt = ht.far;
      C.texture !== null &&
        (C.depthNear > 0 && (It = C.depthNear),
        C.depthFar > 0 && (Pt = C.depthFar)),
        (L.near = F.near = V.near = It),
        (L.far = F.far = V.far = Pt),
        (Y !== L.near || ct !== L.far) &&
          (a.updateRenderState({ depthNear: L.near, depthFar: L.far }),
          (Y = L.near),
          (ct = L.far)),
        (V.layers.mask = ht.layers.mask | 2),
        (F.layers.mask = ht.layers.mask | 4),
        (L.layers.mask = V.layers.mask | F.layers.mask);
      const re = ht.parent,
        ie = L.cameras;
      xt(L, re);
      for (let Fe = 0; Fe < ie.length; Fe++) xt(ie[Fe], re);
      ie.length === 2
        ? et(L, V, F)
        : L.projectionMatrix.copy(V.projectionMatrix),
        X(ht, L, re);
    };
    function X(ht, It, Pt) {
      Pt === null
        ? ht.matrix.copy(It.matrixWorld)
        : (ht.matrix.copy(Pt.matrixWorld),
          ht.matrix.invert(),
          ht.matrix.multiply(It.matrixWorld)),
        ht.matrix.decompose(ht.position, ht.quaternion, ht.scale),
        ht.updateMatrixWorld(!0),
        ht.projectionMatrix.copy(It.projectionMatrix),
        ht.projectionMatrixInverse.copy(It.projectionMatrixInverse),
        ht.isPerspectiveCamera &&
          ((ht.fov = Jd * 2 * Math.atan(1 / ht.projectionMatrix.elements[5])),
          (ht.zoom = 1));
    }
    (this.getCamera = function () {
      return L;
    }),
      (this.getFoveation = function () {
        if (!(x === null && _ === null)) return h;
      }),
      (this.setFoveation = function (ht) {
        (h = ht),
          x !== null && (x.fixedFoveation = ht),
          _ !== null && _.fixedFoveation !== void 0 && (_.fixedFoveation = ht);
      }),
      (this.hasDepthSensing = function () {
        return C.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return C.getMesh(L);
      });
    let ft = null;
    function At(ht, It) {
      if (((m = It.getViewerPose(p || l)), (M = It), m !== null)) {
        const Pt = m.views;
        _ !== null &&
          (t.setRenderTargetFramebuffer(R, _.framebuffer),
          t.setRenderTarget(R));
        let re = !1;
        Pt.length !== L.cameras.length && ((L.cameras.length = 0), (re = !0));
        for (let Ae = 0; Ae < Pt.length; Ae++) {
          const De = Pt[Ae];
          let je = null;
          if (_ !== null) je = _.getViewport(De);
          else {
            const J = v.getViewSubImage(x, De);
            (je = J.viewport),
              Ae === 0 &&
                (t.setRenderTargetTextures(
                  R,
                  J.colorTexture,
                  J.depthStencilTexture
                ),
                t.setRenderTarget(R));
          }
          let Ue = N[Ae];
          Ue === void 0 &&
            ((Ue = new Ei()),
            Ue.layers.enable(Ae),
            (Ue.viewport = new Hn()),
            (N[Ae] = Ue)),
            Ue.matrix.fromArray(De.transform.matrix),
            Ue.matrix.decompose(Ue.position, Ue.quaternion, Ue.scale),
            Ue.projectionMatrix.fromArray(De.projectionMatrix),
            Ue.projectionMatrixInverse.copy(Ue.projectionMatrix).invert(),
            Ue.viewport.set(je.x, je.y, je.width, je.height),
            Ae === 0 &&
              (L.matrix.copy(Ue.matrix),
              L.matrix.decompose(L.position, L.quaternion, L.scale)),
            re === !0 && L.cameras.push(Ue);
        }
        const ie = a.enabledFeatures;
        if (
          ie &&
          ie.includes("depth-sensing") &&
          a.depthUsage == "gpu-optimized" &&
          v
        ) {
          const Ae = v.getDepthInformation(Pt[0]);
          Ae && Ae.isValid && Ae.texture && C.init(t, Ae, a.renderState);
        }
      }
      for (let Pt = 0; Pt < B.length; Pt++) {
        const re = D[Pt],
          ie = B[Pt];
        re !== null && ie !== void 0 && ie.update(re, It, p || l);
      }
      ft && ft(ht, It),
        It.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: It }),
        (M = null);
    }
    const Rt = new NR();
    Rt.setAnimationLoop(At),
      (this.setAnimationLoop = function (ht) {
        ft = ht;
      }),
      (this.dispose = function () {});
  }
}
const wf = new cr(),
  $5 = new Xe();
function tz(i, t) {
  function e(E, S) {
    E.matrixAutoUpdate === !0 && E.updateMatrix(), S.value.copy(E.matrix);
  }
  function n(E, S) {
    S.color.getRGB(E.fogColor.value, FC(i)),
      S.isFog
        ? ((E.fogNear.value = S.near), (E.fogFar.value = S.far))
        : S.isFogExp2 && (E.fogDensity.value = S.density);
  }
  function a(E, S, R, B, D) {
    S.isMeshBasicMaterial || S.isMeshLambertMaterial
      ? r(E, S)
      : S.isMeshToonMaterial
      ? (r(E, S), v(E, S))
      : S.isMeshPhongMaterial
      ? (r(E, S), m(E, S))
      : S.isMeshStandardMaterial
      ? (r(E, S), x(E, S), S.isMeshPhysicalMaterial && _(E, S, D))
      : S.isMeshMatcapMaterial
      ? (r(E, S), M(E, S))
      : S.isMeshDepthMaterial
      ? r(E, S)
      : S.isMeshDistanceMaterial
      ? (r(E, S), C(E, S))
      : S.isMeshNormalMaterial
      ? r(E, S)
      : S.isLineBasicMaterial
      ? (l(E, S), S.isLineDashedMaterial && u(E, S))
      : S.isPointsMaterial
      ? h(E, S, R, B)
      : S.isSpriteMaterial
      ? p(E, S)
      : S.isShadowMaterial
      ? (E.color.value.copy(S.color), (E.opacity.value = S.opacity))
      : S.isShaderMaterial && (S.uniformsNeedUpdate = !1);
  }
  function r(E, S) {
    (E.opacity.value = S.opacity),
      S.color && E.diffuse.value.copy(S.color),
      S.emissive &&
        E.emissive.value.copy(S.emissive).multiplyScalar(S.emissiveIntensity),
      S.map && ((E.map.value = S.map), e(S.map, E.mapTransform)),
      S.alphaMap &&
        ((E.alphaMap.value = S.alphaMap), e(S.alphaMap, E.alphaMapTransform)),
      S.bumpMap &&
        ((E.bumpMap.value = S.bumpMap),
        e(S.bumpMap, E.bumpMapTransform),
        (E.bumpScale.value = S.bumpScale),
        S.side === Ms && (E.bumpScale.value *= -1)),
      S.normalMap &&
        ((E.normalMap.value = S.normalMap),
        e(S.normalMap, E.normalMapTransform),
        E.normalScale.value.copy(S.normalScale),
        S.side === Ms && E.normalScale.value.negate()),
      S.displacementMap &&
        ((E.displacementMap.value = S.displacementMap),
        e(S.displacementMap, E.displacementMapTransform),
        (E.displacementScale.value = S.displacementScale),
        (E.displacementBias.value = S.displacementBias)),
      S.emissiveMap &&
        ((E.emissiveMap.value = S.emissiveMap),
        e(S.emissiveMap, E.emissiveMapTransform)),
      S.specularMap &&
        ((E.specularMap.value = S.specularMap),
        e(S.specularMap, E.specularMapTransform)),
      S.alphaTest > 0 && (E.alphaTest.value = S.alphaTest);
    const R = t.get(S),
      B = R.envMap,
      D = R.envMapRotation;
    B &&
      ((E.envMap.value = B),
      wf.copy(D),
      (wf.x *= -1),
      (wf.y *= -1),
      (wf.z *= -1),
      B.isCubeTexture &&
        B.isRenderTargetTexture === !1 &&
        ((wf.y *= -1), (wf.z *= -1)),
      E.envMapRotation.value.setFromMatrix4($5.makeRotationFromEuler(wf)),
      (E.flipEnvMap.value =
        B.isCubeTexture && B.isRenderTargetTexture === !1 ? -1 : 1),
      (E.reflectivity.value = S.reflectivity),
      (E.ior.value = S.ior),
      (E.refractionRatio.value = S.refractionRatio)),
      S.lightMap &&
        ((E.lightMap.value = S.lightMap),
        (E.lightMapIntensity.value = S.lightMapIntensity),
        e(S.lightMap, E.lightMapTransform)),
      S.aoMap &&
        ((E.aoMap.value = S.aoMap),
        (E.aoMapIntensity.value = S.aoMapIntensity),
        e(S.aoMap, E.aoMapTransform));
  }
  function l(E, S) {
    E.diffuse.value.copy(S.color),
      (E.opacity.value = S.opacity),
      S.map && ((E.map.value = S.map), e(S.map, E.mapTransform));
  }
  function u(E, S) {
    (E.dashSize.value = S.dashSize),
      (E.totalSize.value = S.dashSize + S.gapSize),
      (E.scale.value = S.scale);
  }
  function h(E, S, R, B) {
    E.diffuse.value.copy(S.color),
      (E.opacity.value = S.opacity),
      (E.size.value = S.size * R),
      (E.scale.value = B * 0.5),
      S.map && ((E.map.value = S.map), e(S.map, E.uvTransform)),
      S.alphaMap &&
        ((E.alphaMap.value = S.alphaMap), e(S.alphaMap, E.alphaMapTransform)),
      S.alphaTest > 0 && (E.alphaTest.value = S.alphaTest);
  }
  function p(E, S) {
    E.diffuse.value.copy(S.color),
      (E.opacity.value = S.opacity),
      (E.rotation.value = S.rotation),
      S.map && ((E.map.value = S.map), e(S.map, E.mapTransform)),
      S.alphaMap &&
        ((E.alphaMap.value = S.alphaMap), e(S.alphaMap, E.alphaMapTransform)),
      S.alphaTest > 0 && (E.alphaTest.value = S.alphaTest);
  }
  function m(E, S) {
    E.specular.value.copy(S.specular),
      (E.shininess.value = Math.max(S.shininess, 1e-4));
  }
  function v(E, S) {
    S.gradientMap && (E.gradientMap.value = S.gradientMap);
  }
  function x(E, S) {
    (E.metalness.value = S.metalness),
      S.metalnessMap &&
        ((E.metalnessMap.value = S.metalnessMap),
        e(S.metalnessMap, E.metalnessMapTransform)),
      (E.roughness.value = S.roughness),
      S.roughnessMap &&
        ((E.roughnessMap.value = S.roughnessMap),
        e(S.roughnessMap, E.roughnessMapTransform)),
      S.envMap && (E.envMapIntensity.value = S.envMapIntensity);
  }
  function _(E, S, R) {
    (E.ior.value = S.ior),
      S.sheen > 0 &&
        (E.sheenColor.value.copy(S.sheenColor).multiplyScalar(S.sheen),
        (E.sheenRoughness.value = S.sheenRoughness),
        S.sheenColorMap &&
          ((E.sheenColorMap.value = S.sheenColorMap),
          e(S.sheenColorMap, E.sheenColorMapTransform)),
        S.sheenRoughnessMap &&
          ((E.sheenRoughnessMap.value = S.sheenRoughnessMap),
          e(S.sheenRoughnessMap, E.sheenRoughnessMapTransform))),
      S.clearcoat > 0 &&
        ((E.clearcoat.value = S.clearcoat),
        (E.clearcoatRoughness.value = S.clearcoatRoughness),
        S.clearcoatMap &&
          ((E.clearcoatMap.value = S.clearcoatMap),
          e(S.clearcoatMap, E.clearcoatMapTransform)),
        S.clearcoatRoughnessMap &&
          ((E.clearcoatRoughnessMap.value = S.clearcoatRoughnessMap),
          e(S.clearcoatRoughnessMap, E.clearcoatRoughnessMapTransform)),
        S.clearcoatNormalMap &&
          ((E.clearcoatNormalMap.value = S.clearcoatNormalMap),
          e(S.clearcoatNormalMap, E.clearcoatNormalMapTransform),
          E.clearcoatNormalScale.value.copy(S.clearcoatNormalScale),
          S.side === Ms && E.clearcoatNormalScale.value.negate())),
      S.dispersion > 0 && (E.dispersion.value = S.dispersion),
      S.iridescence > 0 &&
        ((E.iridescence.value = S.iridescence),
        (E.iridescenceIOR.value = S.iridescenceIOR),
        (E.iridescenceThicknessMinimum.value = S.iridescenceThicknessRange[0]),
        (E.iridescenceThicknessMaximum.value = S.iridescenceThicknessRange[1]),
        S.iridescenceMap &&
          ((E.iridescenceMap.value = S.iridescenceMap),
          e(S.iridescenceMap, E.iridescenceMapTransform)),
        S.iridescenceThicknessMap &&
          ((E.iridescenceThicknessMap.value = S.iridescenceThicknessMap),
          e(S.iridescenceThicknessMap, E.iridescenceThicknessMapTransform))),
      S.transmission > 0 &&
        ((E.transmission.value = S.transmission),
        (E.transmissionSamplerMap.value = R.texture),
        E.transmissionSamplerSize.value.set(R.width, R.height),
        S.transmissionMap &&
          ((E.transmissionMap.value = S.transmissionMap),
          e(S.transmissionMap, E.transmissionMapTransform)),
        (E.thickness.value = S.thickness),
        S.thicknessMap &&
          ((E.thicknessMap.value = S.thicknessMap),
          e(S.thicknessMap, E.thicknessMapTransform)),
        (E.attenuationDistance.value = S.attenuationDistance),
        E.attenuationColor.value.copy(S.attenuationColor)),
      S.anisotropy > 0 &&
        (E.anisotropyVector.value.set(
          S.anisotropy * Math.cos(S.anisotropyRotation),
          S.anisotropy * Math.sin(S.anisotropyRotation)
        ),
        S.anisotropyMap &&
          ((E.anisotropyMap.value = S.anisotropyMap),
          e(S.anisotropyMap, E.anisotropyMapTransform))),
      (E.specularIntensity.value = S.specularIntensity),
      E.specularColor.value.copy(S.specularColor),
      S.specularColorMap &&
        ((E.specularColorMap.value = S.specularColorMap),
        e(S.specularColorMap, E.specularColorMapTransform)),
      S.specularIntensityMap &&
        ((E.specularIntensityMap.value = S.specularIntensityMap),
        e(S.specularIntensityMap, E.specularIntensityMapTransform));
  }
  function M(E, S) {
    S.matcap && (E.matcap.value = S.matcap);
  }
  function C(E, S) {
    const R = t.get(S).light;
    E.referencePosition.value.setFromMatrixPosition(R.matrixWorld),
      (E.nearDistance.value = R.shadow.camera.near),
      (E.farDistance.value = R.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: a };
}
function ez(i, t, e, n) {
  let a = {},
    r = {},
    l = [];
  const u = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
  function h(R, B) {
    const D = B.program;
    n.uniformBlockBinding(R, D);
  }
  function p(R, B) {
    let D = a[R.id];
    D === void 0 &&
      (M(R), (D = m(R)), (a[R.id] = D), R.addEventListener("dispose", E));
    const I = B.program;
    n.updateUBOMapping(R, I);
    const P = t.render.frame;
    r[R.id] !== P && (x(R), (r[R.id] = P));
  }
  function m(R) {
    const B = v();
    R.__bindingPointIndex = B;
    const D = i.createBuffer(),
      I = R.__size,
      P = R.usage;
    return (
      i.bindBuffer(i.UNIFORM_BUFFER, D),
      i.bufferData(i.UNIFORM_BUFFER, I, P),
      i.bindBuffer(i.UNIFORM_BUFFER, null),
      i.bindBufferBase(i.UNIFORM_BUFFER, B, D),
      D
    );
  }
  function v() {
    for (let R = 0; R < u; R++) if (l.indexOf(R) === -1) return l.push(R), R;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function x(R) {
    const B = a[R.id],
      D = R.uniforms,
      I = R.__cache;
    i.bindBuffer(i.UNIFORM_BUFFER, B);
    for (let P = 0, V = D.length; P < V; P++) {
      const F = Array.isArray(D[P]) ? D[P] : [D[P]];
      for (let N = 0, L = F.length; N < L; N++) {
        const Y = F[N];
        if (_(Y, P, N, I) === !0) {
          const ct = Y.__offset,
            nt = Array.isArray(Y.value) ? Y.value : [Y.value];
          let dt = 0;
          for (let pt = 0; pt < nt.length; pt++) {
            const j = nt[pt],
              Q = C(j);
            typeof j == "number" || typeof j == "boolean"
              ? ((Y.__data[0] = j),
                i.bufferSubData(i.UNIFORM_BUFFER, ct + dt, Y.__data))
              : j.isMatrix3
              ? ((Y.__data[0] = j.elements[0]),
                (Y.__data[1] = j.elements[1]),
                (Y.__data[2] = j.elements[2]),
                (Y.__data[3] = 0),
                (Y.__data[4] = j.elements[3]),
                (Y.__data[5] = j.elements[4]),
                (Y.__data[6] = j.elements[5]),
                (Y.__data[7] = 0),
                (Y.__data[8] = j.elements[6]),
                (Y.__data[9] = j.elements[7]),
                (Y.__data[10] = j.elements[8]),
                (Y.__data[11] = 0))
              : (j.toArray(Y.__data, dt),
                (dt += Q.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          i.bufferSubData(i.UNIFORM_BUFFER, ct, Y.__data);
        }
      }
    }
    i.bindBuffer(i.UNIFORM_BUFFER, null);
  }
  function _(R, B, D, I) {
    const P = R.value,
      V = B + "_" + D;
    if (I[V] === void 0)
      return (
        typeof P == "number" || typeof P == "boolean"
          ? (I[V] = P)
          : (I[V] = P.clone()),
        !0
      );
    {
      const F = I[V];
      if (typeof P == "number" || typeof P == "boolean") {
        if (F !== P) return (I[V] = P), !0;
      } else if (F.equals(P) === !1) return F.copy(P), !0;
    }
    return !1;
  }
  function M(R) {
    const B = R.uniforms;
    let D = 0;
    const I = 16;
    for (let V = 0, F = B.length; V < F; V++) {
      const N = Array.isArray(B[V]) ? B[V] : [B[V]];
      for (let L = 0, Y = N.length; L < Y; L++) {
        const ct = N[L],
          nt = Array.isArray(ct.value) ? ct.value : [ct.value];
        for (let dt = 0, pt = nt.length; dt < pt; dt++) {
          const j = nt[dt],
            Q = C(j),
            et = D % I,
            xt = et % Q.boundary,
            X = et + xt;
          (D += xt),
            X !== 0 && I - X < Q.storage && (D += I - X),
            (ct.__data = new Float32Array(
              Q.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (ct.__offset = D),
            (D += Q.storage);
        }
      }
    }
    const P = D % I;
    return P > 0 && (D += I - P), (R.__size = D), (R.__cache = {}), this;
  }
  function C(R) {
    const B = { boundary: 0, storage: 0 };
    return (
      typeof R == "number" || typeof R == "boolean"
        ? ((B.boundary = 4), (B.storage = 4))
        : R.isVector2
        ? ((B.boundary = 8), (B.storage = 8))
        : R.isVector3 || R.isColor
        ? ((B.boundary = 16), (B.storage = 12))
        : R.isVector4
        ? ((B.boundary = 16), (B.storage = 16))
        : R.isMatrix3
        ? ((B.boundary = 48), (B.storage = 48))
        : R.isMatrix4
        ? ((B.boundary = 64), (B.storage = 64))
        : R.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            R
          ),
      B
    );
  }
  function E(R) {
    const B = R.target;
    B.removeEventListener("dispose", E);
    const D = l.indexOf(B.__bindingPointIndex);
    l.splice(D, 1), i.deleteBuffer(a[B.id]), delete a[B.id], delete r[B.id];
  }
  function S() {
    for (const R in a) i.deleteBuffer(a[R]);
    (l = []), (a = {}), (r = {});
  }
  return { bind: h, update: p, dispose: S };
}
class AS {
  constructor(t = {}) {
    const {
      canvas: e = IC(),
      context: n = null,
      depth: a = !0,
      stencil: r = !1,
      alpha: l = !1,
      antialias: u = !1,
      premultipliedAlpha: h = !0,
      preserveDrawingBuffer: p = !1,
      powerPreference: m = "default",
      failIfMajorPerformanceCaveat: v = !1,
      reverseDepthBuffer: x = !1,
    } = t;
    this.isWebGLRenderer = !0;
    let _;
    if (n !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        n instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      _ = n.getContextAttributes().alpha;
    } else _ = l;
    const M = new Uint32Array(4),
      C = new Int32Array(4);
    let E = null,
      S = null;
    const R = [],
      B = [];
    (this.domElement = e),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.toneMapping = ll),
      (this.toneMappingExposure = 1),
      (this.transmissionResolutionScale = 1);
    const D = this;
    let I = !1;
    this._outputColorSpace = Fa;
    let P = 0,
      V = 0,
      F = null,
      N = -1,
      L = null;
    const Y = new Hn(),
      ct = new Hn();
    let nt = null;
    const dt = new Se(0);
    let pt = 0,
      j = e.width,
      Q = e.height,
      et = 1,
      xt = null,
      X = null;
    const ft = new Hn(0, 0, j, Q),
      At = new Hn(0, 0, j, Q);
    let Rt = !1;
    const ht = new ap();
    let It = !1,
      Pt = !1;
    const re = new Xe(),
      ie = new Xe(),
      Fe = new Z(),
      Ae = new Hn(),
      De = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let je = !1;
    function Ue() {
      return F === null ? et : 1;
    }
    let J = n;
    function le(H, tt) {
      return e.getContext(H, tt);
    }
    try {
      const H = {
        alpha: !0,
        depth: a,
        stencil: r,
        antialias: u,
        premultipliedAlpha: h,
        preserveDrawingBuffer: p,
        powerPreference: m,
        failIfMajorPerformanceCaveat: v,
      };
      if (
        ("setAttribute" in e &&
          e.setAttribute("data-engine", `three.js r${C0}`),
        e.addEventListener("webglcontextlost", ge, !1),
        e.addEventListener("webglcontextrestored", oe, !1),
        e.addEventListener("webglcontextcreationerror", Kt, !1),
        J === null)
      ) {
        const tt = "webgl2";
        if (((J = le(tt, H)), J === null))
          throw le(tt)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (H) {
      throw (console.error("THREE.WebGLRenderer: " + H.message), H);
    }
    let se,
      $t,
      kt,
      ye,
      te,
      pe,
      Ye,
      $,
      k,
      Mt,
      Ft,
      Gt,
      zt,
      me,
      de,
      we,
      Ce,
      jt,
      ce,
      Re,
      it,
      yt,
      Qt,
      st;
    function Et() {
      (se = new dP(J)),
        se.init(),
        (yt = new FR(J, se)),
        ($t = new rP(J, se, t, yt)),
        (kt = new Y5(J, se)),
        $t.reverseDepthBuffer && x && kt.buffers.depth.setReversed(!0),
        (ye = new gP(J)),
        (te = new N5()),
        (pe = new q5(J, se, kt, te, $t, yt, ye)),
        (Ye = new lP(D)),
        ($ = new hP(D)),
        (k = new AL(J)),
        (Qt = new aP(J, k)),
        (Mt = new pP(J, k, ye, Qt)),
        (Ft = new yP(J, Mt, k, ye)),
        (ce = new vP(J, $t, pe)),
        (we = new oP(te)),
        (Gt = new O5(D, Ye, $, se, $t, Qt, we)),
        (zt = new tz(D, te)),
        (me = new I5()),
        (de = new V5(se)),
        (jt = new iP(D, Ye, $, kt, Ft, _, h)),
        (Ce = new X5(D, Ft, $t)),
        (st = new ez(J, ye, $t, kt)),
        (Re = new sP(J, se, ye)),
        (it = new mP(J, se, ye)),
        (ye.programs = Gt.programs),
        (D.capabilities = $t),
        (D.extensions = se),
        (D.properties = te),
        (D.renderLists = me),
        (D.shadowMap = Ce),
        (D.state = kt),
        (D.info = ye);
    }
    Et();
    const qt = new Q5(D, J);
    (this.xr = qt),
      (this.getContext = function () {
        return J;
      }),
      (this.getContextAttributes = function () {
        return J.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const H = se.get("WEBGL_lose_context");
        H && H.loseContext();
      }),
      (this.forceContextRestore = function () {
        const H = se.get("WEBGL_lose_context");
        H && H.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return et;
      }),
      (this.setPixelRatio = function (H) {
        H !== void 0 && ((et = H), this.setSize(j, Q, !1));
      }),
      (this.getSize = function (H) {
        return H.set(j, Q);
      }),
      (this.setSize = function (H, tt, rt = !0) {
        if (qt.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (j = H),
          (Q = tt),
          (e.width = Math.floor(H * et)),
          (e.height = Math.floor(tt * et)),
          rt === !0 &&
            ((e.style.width = H + "px"), (e.style.height = tt + "px")),
          this.setViewport(0, 0, H, tt);
      }),
      (this.getDrawingBufferSize = function (H) {
        return H.set(j * et, Q * et).floor();
      }),
      (this.setDrawingBufferSize = function (H, tt, rt) {
        (j = H),
          (Q = tt),
          (et = rt),
          (e.width = Math.floor(H * rt)),
          (e.height = Math.floor(tt * rt)),
          this.setViewport(0, 0, H, tt);
      }),
      (this.getCurrentViewport = function (H) {
        return H.copy(Y);
      }),
      (this.getViewport = function (H) {
        return H.copy(ft);
      }),
      (this.setViewport = function (H, tt, rt, ot) {
        H.isVector4 ? ft.set(H.x, H.y, H.z, H.w) : ft.set(H, tt, rt, ot),
          kt.viewport(Y.copy(ft).multiplyScalar(et).round());
      }),
      (this.getScissor = function (H) {
        return H.copy(At);
      }),
      (this.setScissor = function (H, tt, rt, ot) {
        H.isVector4 ? At.set(H.x, H.y, H.z, H.w) : At.set(H, tt, rt, ot),
          kt.scissor(ct.copy(At).multiplyScalar(et).round());
      }),
      (this.getScissorTest = function () {
        return Rt;
      }),
      (this.setScissorTest = function (H) {
        kt.setScissorTest((Rt = H));
      }),
      (this.setOpaqueSort = function (H) {
        xt = H;
      }),
      (this.setTransparentSort = function (H) {
        X = H;
      }),
      (this.getClearColor = function (H) {
        return H.copy(jt.getClearColor());
      }),
      (this.setClearColor = function () {
        jt.setClearColor(...arguments);
      }),
      (this.getClearAlpha = function () {
        return jt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        jt.setClearAlpha(...arguments);
      }),
      (this.clear = function (H = !0, tt = !0, rt = !0) {
        let ot = 0;
        if (H) {
          let gt = !1;
          if (F !== null) {
            const wt = F.texture.format;
            gt = wt === Fx || wt === zx || wt === U0;
          }
          if (gt) {
            const wt = F.texture.type,
              Vt =
                wt === Es ||
                wt === pl ||
                wt === jd ||
                wt === Xd ||
                wt === Ix ||
                wt === Px,
              Jt = jt.getClearColor(),
              ee = jt.getClearAlpha(),
              xe = Jt.r,
              ve = Jt.g,
              _e = Jt.b;
            Vt
              ? ((M[0] = xe),
                (M[1] = ve),
                (M[2] = _e),
                (M[3] = ee),
                J.clearBufferuiv(J.COLOR, 0, M))
              : ((C[0] = xe),
                (C[1] = ve),
                (C[2] = _e),
                (C[3] = ee),
                J.clearBufferiv(J.COLOR, 0, C));
          } else ot |= J.COLOR_BUFFER_BIT;
        }
        tt && (ot |= J.DEPTH_BUFFER_BIT),
          rt &&
            ((ot |= J.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          J.clear(ot);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        e.removeEventListener("webglcontextlost", ge, !1),
          e.removeEventListener("webglcontextrestored", oe, !1),
          e.removeEventListener("webglcontextcreationerror", Kt, !1),
          jt.dispose(),
          me.dispose(),
          de.dispose(),
          te.dispose(),
          Ye.dispose(),
          $.dispose(),
          Ft.dispose(),
          Qt.dispose(),
          st.dispose(),
          Gt.dispose(),
          qt.dispose(),
          qt.removeEventListener("sessionstart", xi),
          qt.removeEventListener("sessionend", Ci),
          Ri.stop();
      });
    function ge(H) {
      H.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (I = !0);
    }
    function oe() {
      console.log("THREE.WebGLRenderer: Context Restored."), (I = !1);
      const H = ye.autoReset,
        tt = Ce.enabled,
        rt = Ce.autoUpdate,
        ot = Ce.needsUpdate,
        gt = Ce.type;
      Et(),
        (ye.autoReset = H),
        (Ce.enabled = tt),
        (Ce.autoUpdate = rt),
        (Ce.needsUpdate = ot),
        (Ce.type = gt);
    }
    function Kt(H) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        H.statusMessage
      );
    }
    function be(H) {
      const tt = H.target;
      tt.removeEventListener("dispose", be), Le(tt);
    }
    function Le(H) {
      mn(H), te.remove(H);
    }
    function mn(H) {
      const tt = te.get(H).programs;
      tt !== void 0 &&
        (tt.forEach(function (rt) {
          Gt.releaseProgram(rt);
        }),
        H.isShaderMaterial && Gt.releaseShaderCache(H));
    }
    this.renderBufferDirect = function (H, tt, rt, ot, gt, wt) {
      tt === null && (tt = De);
      const Vt = gt.isMesh && gt.matrixWorld.determinant() < 0,
        Jt = ut(H, tt, rt, ot, gt);
      kt.setMaterial(ot, Vt);
      let ee = rt.index,
        xe = 1;
      if (ot.wireframe === !0) {
        if (((ee = Mt.getWireframeAttribute(rt)), ee === void 0)) return;
        xe = 2;
      }
      const ve = rt.drawRange,
        _e = rt.attributes.position;
      let He = ve.start * xe,
        ze = (ve.start + ve.count) * xe;
      wt !== null &&
        ((He = Math.max(He, wt.start * xe)),
        (ze = Math.min(ze, (wt.start + wt.count) * xe))),
        ee !== null
          ? ((He = Math.max(He, 0)), (ze = Math.min(ze, ee.count)))
          : _e != null &&
            ((He = Math.max(He, 0)), (ze = Math.min(ze, _e.count)));
      const Mn = ze - He;
      if (Mn < 0 || Mn === 1 / 0) return;
      Qt.setup(gt, ot, Jt, rt, ee);
      let Oe,
        Ve = Re;
      if (
        (ee !== null && ((Oe = k.get(ee)), (Ve = it), Ve.setIndex(Oe)),
        gt.isMesh)
      )
        ot.wireframe === !0
          ? (kt.setLineWidth(ot.wireframeLinewidth * Ue()), Ve.setMode(J.LINES))
          : Ve.setMode(J.TRIANGLES);
      else if (gt.isLine) {
        let Ne = ot.linewidth;
        Ne === void 0 && (Ne = 1),
          kt.setLineWidth(Ne * Ue()),
          gt.isLineSegments
            ? Ve.setMode(J.LINES)
            : gt.isLineLoop
            ? Ve.setMode(J.LINE_LOOP)
            : Ve.setMode(J.LINE_STRIP);
      } else
        gt.isPoints
          ? Ve.setMode(J.POINTS)
          : gt.isSprite && Ve.setMode(J.TRIANGLES);
      if (gt.isBatchedMesh)
        if (gt._multiDrawInstances !== null)
          zd(
            "THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
          ),
            Ve.renderMultiDrawInstances(
              gt._multiDrawStarts,
              gt._multiDrawCounts,
              gt._multiDrawCount,
              gt._multiDrawInstances
            );
        else if (se.get("WEBGL_multi_draw"))
          Ve.renderMultiDraw(
            gt._multiDrawStarts,
            gt._multiDrawCounts,
            gt._multiDrawCount
          );
        else {
          const Ne = gt._multiDrawStarts,
            Yn = gt._multiDrawCounts,
            en = gt._multiDrawCount,
            on = ee ? k.get(ee).bytesPerElement : 1,
            Qn = te.get(ot).currentProgram.getUniforms();
          for (let qe = 0; qe < en; qe++)
            Qn.setValue(J, "_gl_DrawID", qe), Ve.render(Ne[qe] / on, Yn[qe]);
        }
      else if (gt.isInstancedMesh) Ve.renderInstances(He, Mn, gt.count);
      else if (rt.isInstancedBufferGeometry) {
        const Ne =
            rt._maxInstanceCount !== void 0 ? rt._maxInstanceCount : 1 / 0,
          Yn = Math.min(rt.instanceCount, Ne);
        Ve.renderInstances(He, Mn, Yn);
      } else Ve.render(He, Mn);
    };
    function ln(H, tt, rt) {
      H.transparent === !0 && H.side === or && H.forceSinglePass === !1
        ? ((H.side = Ms),
          (H.needsUpdate = !0),
          Vn(H, tt, rt),
          (H.side = hl),
          (H.needsUpdate = !0),
          Vn(H, tt, rt),
          (H.side = or))
        : Vn(H, tt, rt);
    }
    (this.compile = function (H, tt, rt = null) {
      rt === null && (rt = H),
        (S = de.get(rt)),
        S.init(tt),
        B.push(S),
        rt.traverseVisible(function (gt) {
          gt.isLight &&
            gt.layers.test(tt.layers) &&
            (S.pushLight(gt), gt.castShadow && S.pushShadow(gt));
        }),
        H !== rt &&
          H.traverseVisible(function (gt) {
            gt.isLight &&
              gt.layers.test(tt.layers) &&
              (S.pushLight(gt), gt.castShadow && S.pushShadow(gt));
          }),
        S.setupLights();
      const ot = new Set();
      return (
        H.traverse(function (gt) {
          if (!(gt.isMesh || gt.isPoints || gt.isLine || gt.isSprite)) return;
          const wt = gt.material;
          if (wt)
            if (Array.isArray(wt))
              for (let Vt = 0; Vt < wt.length; Vt++) {
                const Jt = wt[Vt];
                ln(Jt, rt, gt), ot.add(Jt);
              }
            else ln(wt, rt, gt), ot.add(wt);
        }),
        (S = B.pop()),
        ot
      );
    }),
      (this.compileAsync = function (H, tt, rt = null) {
        const ot = this.compile(H, tt, rt);
        return new Promise((gt) => {
          function wt() {
            if (
              (ot.forEach(function (Vt) {
                te.get(Vt).currentProgram.isReady() && ot.delete(Vt);
              }),
              ot.size === 0)
            ) {
              gt(H);
              return;
            }
            setTimeout(wt, 10);
          }
          se.get("KHR_parallel_shader_compile") !== null
            ? wt()
            : setTimeout(wt, 10);
        });
      });
    let yi = null;
    function si(H) {
      yi && yi(H);
    }
    function xi() {
      Ri.stop();
    }
    function Ci() {
      Ri.start();
    }
    const Ri = new NR();
    Ri.setAnimationLoop(si),
      typeof self < "u" && Ri.setContext(self),
      (this.setAnimationLoop = function (H) {
        (yi = H), qt.setAnimationLoop(H), H === null ? Ri.stop() : Ri.start();
      }),
      qt.addEventListener("sessionstart", xi),
      qt.addEventListener("sessionend", Ci),
      (this.render = function (H, tt) {
        if (tt !== void 0 && tt.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (I === !0) return;
        if (
          (H.matrixWorldAutoUpdate === !0 && H.updateMatrixWorld(),
          tt.parent === null &&
            tt.matrixWorldAutoUpdate === !0 &&
            tt.updateMatrixWorld(),
          qt.enabled === !0 &&
            qt.isPresenting === !0 &&
            (qt.cameraAutoUpdate === !0 && qt.updateCamera(tt),
            (tt = qt.getCamera())),
          H.isScene === !0 && H.onBeforeRender(D, H, tt, F),
          (S = de.get(H, B.length)),
          S.init(tt),
          B.push(S),
          ie.multiplyMatrices(tt.projectionMatrix, tt.matrixWorldInverse),
          ht.setFromProjectionMatrix(ie),
          (Pt = this.localClippingEnabled),
          (It = we.init(this.clippingPlanes, Pt)),
          (E = me.get(H, R.length)),
          E.init(),
          R.push(E),
          qt.enabled === !0 && qt.isPresenting === !0)
        ) {
          const wt = D.xr.getDepthSensingMesh();
          wt !== null && ya(wt, tt, -1 / 0, D.sortObjects);
        }
        ya(H, tt, 0, D.sortObjects),
          E.finish(),
          D.sortObjects === !0 && E.sort(xt, X),
          (je =
            qt.enabled === !1 ||
            qt.isPresenting === !1 ||
            qt.hasDepthSensing() === !1),
          je && jt.addToRenderList(E, H),
          this.info.render.frame++,
          It === !0 && we.beginShadows();
        const rt = S.state.shadowsArray;
        Ce.render(rt, H, tt),
          It === !0 && we.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const ot = E.opaque,
          gt = E.transmissive;
        if ((S.setupLights(), tt.isArrayCamera)) {
          const wt = tt.cameras;
          if (gt.length > 0)
            for (let Vt = 0, Jt = wt.length; Vt < Jt; Vt++) {
              const ee = wt[Vt];
              sa(ot, gt, H, ee);
            }
          je && jt.render(H);
          for (let Vt = 0, Jt = wt.length; Vt < Jt; Vt++) {
            const ee = wt[Vt];
            Ws(E, H, ee, ee.viewport);
          }
        } else
          gt.length > 0 && sa(ot, gt, H, tt), je && jt.render(H), Ws(E, H, tt);
        F !== null &&
          V === 0 &&
          (pe.updateMultisampleRenderTarget(F), pe.updateRenderTargetMipmap(F)),
          H.isScene === !0 && H.onAfterRender(D, H, tt),
          Qt.resetDefaultState(),
          (N = -1),
          (L = null),
          B.pop(),
          B.length > 0
            ? ((S = B[B.length - 1]),
              It === !0 && we.setGlobalState(D.clippingPlanes, S.state.camera))
            : (S = null),
          R.pop(),
          R.length > 0 ? (E = R[R.length - 1]) : (E = null);
      });
    function ya(H, tt, rt, ot) {
      if (H.visible === !1) return;
      if (H.layers.test(tt.layers)) {
        if (H.isGroup) rt = H.renderOrder;
        else if (H.isLOD) H.autoUpdate === !0 && H.update(tt);
        else if (H.isLight) S.pushLight(H), H.castShadow && S.pushShadow(H);
        else if (H.isSprite) {
          if (!H.frustumCulled || ht.intersectsSprite(H)) {
            ot && Ae.setFromMatrixPosition(H.matrixWorld).applyMatrix4(ie);
            const Vt = Ft.update(H),
              Jt = H.material;
            Jt.visible && E.push(H, Vt, Jt, rt, Ae.z, null);
          }
        } else if (
          (H.isMesh || H.isLine || H.isPoints) &&
          (!H.frustumCulled || ht.intersectsObject(H))
        ) {
          const Vt = Ft.update(H),
            Jt = H.material;
          if (
            (ot &&
              (H.boundingSphere !== void 0
                ? (H.boundingSphere === null && H.computeBoundingSphere(),
                  Ae.copy(H.boundingSphere.center))
                : (Vt.boundingSphere === null && Vt.computeBoundingSphere(),
                  Ae.copy(Vt.boundingSphere.center)),
              Ae.applyMatrix4(H.matrixWorld).applyMatrix4(ie)),
            Array.isArray(Jt))
          ) {
            const ee = Vt.groups;
            for (let xe = 0, ve = ee.length; xe < ve; xe++) {
              const _e = ee[xe],
                He = Jt[_e.materialIndex];
              He && He.visible && E.push(H, Vt, He, rt, Ae.z, _e);
            }
          } else Jt.visible && E.push(H, Vt, Jt, rt, Ae.z, null);
        }
      }
      const wt = H.children;
      for (let Vt = 0, Jt = wt.length; Vt < Jt; Vt++) ya(wt[Vt], tt, rt, ot);
    }
    function Ws(H, tt, rt, ot) {
      const gt = H.opaque,
        wt = H.transmissive,
        Vt = H.transparent;
      S.setupLightsView(rt),
        It === !0 && we.setGlobalState(D.clippingPlanes, rt),
        ot && kt.viewport(Y.copy(ot)),
        gt.length > 0 && Ke(gt, tt, rt),
        wt.length > 0 && Ke(wt, tt, rt),
        Vt.length > 0 && Ke(Vt, tt, rt),
        kt.buffers.depth.setTest(!0),
        kt.buffers.depth.setMask(!0),
        kt.buffers.color.setMask(!0),
        kt.setPolygonOffset(!1);
    }
    function sa(H, tt, rt, ot) {
      if ((rt.isScene === !0 ? rt.overrideMaterial : null) !== null) return;
      S.state.transmissionRenderTarget[ot.id] === void 0 &&
        (S.state.transmissionRenderTarget[ot.id] = new zr(1, 1, {
          generateMipmaps: !0,
          type:
            se.has("EXT_color_buffer_half_float") ||
            se.has("EXT_color_buffer_float")
              ? Ea
              : Es,
          minFilter: Nr,
          samples: 4,
          stencilBuffer: r,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: In.workingColorSpace,
        }));
      const wt = S.state.transmissionRenderTarget[ot.id],
        Vt = ot.viewport || Y;
      wt.setSize(
        Vt.z * D.transmissionResolutionScale,
        Vt.w * D.transmissionResolutionScale
      );
      const Jt = D.getRenderTarget();
      D.setRenderTarget(wt),
        D.getClearColor(dt),
        (pt = D.getClearAlpha()),
        pt < 1 && D.setClearColor(16777215, 0.5),
        D.clear(),
        je && jt.render(rt);
      const ee = D.toneMapping;
      D.toneMapping = ll;
      const xe = ot.viewport;
      if (
        (ot.viewport !== void 0 && (ot.viewport = void 0),
        S.setupLightsView(ot),
        It === !0 && we.setGlobalState(D.clippingPlanes, ot),
        Ke(H, rt, ot),
        pe.updateMultisampleRenderTarget(wt),
        pe.updateRenderTargetMipmap(wt),
        se.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let ve = !1;
        for (let _e = 0, He = tt.length; _e < He; _e++) {
          const ze = tt[_e],
            Mn = ze.object,
            Oe = ze.geometry,
            Ve = ze.material,
            Ne = ze.group;
          if (Ve.side === or && Mn.layers.test(ot.layers)) {
            const Yn = Ve.side;
            (Ve.side = Ms),
              (Ve.needsUpdate = !0),
              ka(Mn, rt, ot, Oe, Ve, Ne),
              (Ve.side = Yn),
              (Ve.needsUpdate = !0),
              (ve = !0);
          }
        }
        ve === !0 &&
          (pe.updateMultisampleRenderTarget(wt),
          pe.updateRenderTargetMipmap(wt));
      }
      D.setRenderTarget(Jt),
        D.setClearColor(dt, pt),
        xe !== void 0 && (ot.viewport = xe),
        (D.toneMapping = ee);
    }
    function Ke(H, tt, rt) {
      const ot = tt.isScene === !0 ? tt.overrideMaterial : null;
      for (let gt = 0, wt = H.length; gt < wt; gt++) {
        const Vt = H[gt],
          Jt = Vt.object,
          ee = Vt.geometry,
          xe = Vt.group;
        let ve = Vt.material;
        ve.allowOverride === !0 && ot !== null && (ve = ot),
          Jt.layers.test(rt.layers) && ka(Jt, tt, rt, ee, ve, xe);
      }
    }
    function ka(H, tt, rt, ot, gt, wt) {
      H.onBeforeRender(D, tt, rt, ot, gt, wt),
        H.modelViewMatrix.multiplyMatrices(
          rt.matrixWorldInverse,
          H.matrixWorld
        ),
        H.normalMatrix.getNormalMatrix(H.modelViewMatrix),
        gt.onBeforeRender(D, tt, rt, ot, H, wt),
        gt.transparent === !0 && gt.side === or && gt.forceSinglePass === !1
          ? ((gt.side = Ms),
            (gt.needsUpdate = !0),
            D.renderBufferDirect(rt, tt, ot, gt, H, wt),
            (gt.side = hl),
            (gt.needsUpdate = !0),
            D.renderBufferDirect(rt, tt, ot, gt, H, wt),
            (gt.side = or))
          : D.renderBufferDirect(rt, tt, ot, gt, H, wt),
        H.onAfterRender(D, tt, rt, ot, gt, wt);
    }
    function Vn(H, tt, rt) {
      tt.isScene !== !0 && (tt = De);
      const ot = te.get(H),
        gt = S.state.lights,
        wt = S.state.shadowsArray,
        Vt = gt.state.version,
        Jt = Gt.getParameters(H, gt.state, wt, tt, rt),
        ee = Gt.getProgramCacheKey(Jt);
      let xe = ot.programs;
      (ot.environment = H.isMeshStandardMaterial ? tt.environment : null),
        (ot.fog = tt.fog),
        (ot.envMap = (H.isMeshStandardMaterial ? $ : Ye).get(
          H.envMap || ot.environment
        )),
        (ot.envMapRotation =
          ot.environment !== null && H.envMap === null
            ? tt.environmentRotation
            : H.envMapRotation),
        xe === void 0 &&
          (H.addEventListener("dispose", be),
          (xe = new Map()),
          (ot.programs = xe));
      let ve = xe.get(ee);
      if (ve !== void 0) {
        if (ot.currentProgram === ve && ot.lightsStateVersion === Vt)
          return K(H, Jt), ve;
      } else
        (Jt.uniforms = Gt.getUniforms(H)),
          H.onBeforeCompile(Jt, D),
          (ve = Gt.acquireProgram(Jt, ee)),
          xe.set(ee, ve),
          (ot.uniforms = Jt.uniforms);
      const _e = ot.uniforms;
      return (
        ((!H.isShaderMaterial && !H.isRawShaderMaterial) ||
          H.clipping === !0) &&
          (_e.clippingPlanes = we.uniform),
        K(H, Jt),
        (ot.needsLights = Ut(H)),
        (ot.lightsStateVersion = Vt),
        ot.needsLights &&
          ((_e.ambientLightColor.value = gt.state.ambient),
          (_e.lightProbe.value = gt.state.probe),
          (_e.directionalLights.value = gt.state.directional),
          (_e.directionalLightShadows.value = gt.state.directionalShadow),
          (_e.spotLights.value = gt.state.spot),
          (_e.spotLightShadows.value = gt.state.spotShadow),
          (_e.rectAreaLights.value = gt.state.rectArea),
          (_e.ltc_1.value = gt.state.rectAreaLTC1),
          (_e.ltc_2.value = gt.state.rectAreaLTC2),
          (_e.pointLights.value = gt.state.point),
          (_e.pointLightShadows.value = gt.state.pointShadow),
          (_e.hemisphereLights.value = gt.state.hemi),
          (_e.directionalShadowMap.value = gt.state.directionalShadowMap),
          (_e.directionalShadowMatrix.value = gt.state.directionalShadowMatrix),
          (_e.spotShadowMap.value = gt.state.spotShadowMap),
          (_e.spotLightMatrix.value = gt.state.spotLightMatrix),
          (_e.spotLightMap.value = gt.state.spotLightMap),
          (_e.pointShadowMap.value = gt.state.pointShadowMap),
          (_e.pointShadowMatrix.value = gt.state.pointShadowMatrix)),
        (ot.currentProgram = ve),
        (ot.uniformsList = null),
        ve
      );
    }
    function G(H) {
      if (H.uniformsList === null) {
        const tt = H.currentProgram.getUniforms();
        H.uniformsList = wy.seqWithValue(tt.seq, H.uniforms);
      }
      return H.uniformsList;
    }
    function K(H, tt) {
      const rt = te.get(H);
      (rt.outputColorSpace = tt.outputColorSpace),
        (rt.batching = tt.batching),
        (rt.batchingColor = tt.batchingColor),
        (rt.instancing = tt.instancing),
        (rt.instancingColor = tt.instancingColor),
        (rt.instancingMorph = tt.instancingMorph),
        (rt.skinning = tt.skinning),
        (rt.morphTargets = tt.morphTargets),
        (rt.morphNormals = tt.morphNormals),
        (rt.morphColors = tt.morphColors),
        (rt.morphTargetsCount = tt.morphTargetsCount),
        (rt.numClippingPlanes = tt.numClippingPlanes),
        (rt.numIntersection = tt.numClipIntersection),
        (rt.vertexAlphas = tt.vertexAlphas),
        (rt.vertexTangents = tt.vertexTangents),
        (rt.toneMapping = tt.toneMapping);
    }
    function ut(H, tt, rt, ot, gt) {
      tt.isScene !== !0 && (tt = De), pe.resetTextureUnits();
      const wt = tt.fog,
        Vt = ot.isMeshStandardMaterial ? tt.environment : null,
        Jt =
          F === null
            ? D.outputColorSpace
            : F.isXRRenderTarget === !0
            ? F.texture.colorSpace
            : bo,
        ee = (ot.isMeshStandardMaterial ? $ : Ye).get(ot.envMap || Vt),
        xe =
          ot.vertexColors === !0 &&
          !!rt.attributes.color &&
          rt.attributes.color.itemSize === 4,
        ve = !!rt.attributes.tangent && (!!ot.normalMap || ot.anisotropy > 0),
        _e = !!rt.morphAttributes.position,
        He = !!rt.morphAttributes.normal,
        ze = !!rt.morphAttributes.color;
      let Mn = ll;
      ot.toneMapped &&
        (F === null || F.isXRRenderTarget === !0) &&
        (Mn = D.toneMapping);
      const Oe =
          rt.morphAttributes.position ||
          rt.morphAttributes.normal ||
          rt.morphAttributes.color,
        Ve = Oe !== void 0 ? Oe.length : 0,
        Ne = te.get(ot),
        Yn = S.state.lights;
      if (It === !0 && (Pt === !0 || H !== L)) {
        const $n = H === L && ot.id === N;
        we.setState(ot, H, $n);
      }
      let en = !1;
      ot.version === Ne.__version
        ? ((Ne.needsLights && Ne.lightsStateVersion !== Yn.state.version) ||
            Ne.outputColorSpace !== Jt ||
            (gt.isBatchedMesh && Ne.batching === !1) ||
            (!gt.isBatchedMesh && Ne.batching === !0) ||
            (gt.isBatchedMesh &&
              Ne.batchingColor === !0 &&
              gt.colorTexture === null) ||
            (gt.isBatchedMesh &&
              Ne.batchingColor === !1 &&
              gt.colorTexture !== null) ||
            (gt.isInstancedMesh && Ne.instancing === !1) ||
            (!gt.isInstancedMesh && Ne.instancing === !0) ||
            (gt.isSkinnedMesh && Ne.skinning === !1) ||
            (!gt.isSkinnedMesh && Ne.skinning === !0) ||
            (gt.isInstancedMesh &&
              Ne.instancingColor === !0 &&
              gt.instanceColor === null) ||
            (gt.isInstancedMesh &&
              Ne.instancingColor === !1 &&
              gt.instanceColor !== null) ||
            (gt.isInstancedMesh &&
              Ne.instancingMorph === !0 &&
              gt.morphTexture === null) ||
            (gt.isInstancedMesh &&
              Ne.instancingMorph === !1 &&
              gt.morphTexture !== null) ||
            Ne.envMap !== ee ||
            (ot.fog === !0 && Ne.fog !== wt) ||
            (Ne.numClippingPlanes !== void 0 &&
              (Ne.numClippingPlanes !== we.numPlanes ||
                Ne.numIntersection !== we.numIntersection)) ||
            Ne.vertexAlphas !== xe ||
            Ne.vertexTangents !== ve ||
            Ne.morphTargets !== _e ||
            Ne.morphNormals !== He ||
            Ne.morphColors !== ze ||
            Ne.toneMapping !== Mn ||
            Ne.morphTargetsCount !== Ve) &&
          (en = !0)
        : ((en = !0), (Ne.__version = ot.version));
      let on = Ne.currentProgram;
      en === !0 && (on = Vn(ot, tt, gt));
      let Qn = !1,
        qe = !1,
        xn = !1;
      const gn = on.getUniforms(),
        fi = Ne.uniforms;
      if (
        (kt.useProgram(on.program) && ((Qn = !0), (qe = !0), (xn = !0)),
        ot.id !== N && ((N = ot.id), (qe = !0)),
        Qn || L !== H)
      ) {
        kt.buffers.depth.getReversed()
          ? (re.copy(H.projectionMatrix),
            ZU(re),
            QU(re),
            gn.setValue(J, "projectionMatrix", re))
          : gn.setValue(J, "projectionMatrix", H.projectionMatrix),
          gn.setValue(J, "viewMatrix", H.matrixWorldInverse);
        const Zi = gn.map.cameraPosition;
        Zi !== void 0 &&
          Zi.setValue(J, Fe.setFromMatrixPosition(H.matrixWorld)),
          $t.logarithmicDepthBuffer &&
            gn.setValue(
              J,
              "logDepthBufFC",
              2 / (Math.log(H.far + 1) / Math.LN2)
            ),
          (ot.isMeshPhongMaterial ||
            ot.isMeshToonMaterial ||
            ot.isMeshLambertMaterial ||
            ot.isMeshBasicMaterial ||
            ot.isMeshStandardMaterial ||
            ot.isShaderMaterial) &&
            gn.setValue(J, "isOrthographic", H.isOrthographicCamera === !0),
          L !== H && ((L = H), (qe = !0), (xn = !0));
      }
      if (gt.isSkinnedMesh) {
        gn.setOptional(J, gt, "bindMatrix"),
          gn.setOptional(J, gt, "bindMatrixInverse");
        const $n = gt.skeleton;
        $n &&
          ($n.boneTexture === null && $n.computeBoneTexture(),
          gn.setValue(J, "boneTexture", $n.boneTexture, pe));
      }
      gt.isBatchedMesh &&
        (gn.setOptional(J, gt, "batchingTexture"),
        gn.setValue(J, "batchingTexture", gt._matricesTexture, pe),
        gn.setOptional(J, gt, "batchingIdTexture"),
        gn.setValue(J, "batchingIdTexture", gt._indirectTexture, pe),
        gn.setOptional(J, gt, "batchingColorTexture"),
        gt._colorsTexture !== null &&
          gn.setValue(J, "batchingColorTexture", gt._colorsTexture, pe));
      const Un = rt.morphAttributes;
      if (
        ((Un.position !== void 0 ||
          Un.normal !== void 0 ||
          Un.color !== void 0) &&
          ce.update(gt, rt, on),
        (qe || Ne.receiveShadow !== gt.receiveShadow) &&
          ((Ne.receiveShadow = gt.receiveShadow),
          gn.setValue(J, "receiveShadow", gt.receiveShadow)),
        ot.isMeshGouraudMaterial &&
          ot.envMap !== null &&
          ((fi.envMap.value = ee),
          (fi.flipEnvMap.value =
            ee.isCubeTexture && ee.isRenderTargetTexture === !1 ? -1 : 1)),
        ot.isMeshStandardMaterial &&
          ot.envMap === null &&
          tt.environment !== null &&
          (fi.envMapIntensity.value = tt.environmentIntensity),
        qe &&
          (gn.setValue(J, "toneMappingExposure", D.toneMappingExposure),
          Ne.needsLights && Bt(fi, xn),
          wt && ot.fog === !0 && zt.refreshFogUniforms(fi, wt),
          zt.refreshMaterialUniforms(
            fi,
            ot,
            et,
            Q,
            S.state.transmissionRenderTarget[H.id]
          ),
          wy.upload(J, G(Ne), fi, pe)),
        ot.isShaderMaterial &&
          ot.uniformsNeedUpdate === !0 &&
          (wy.upload(J, G(Ne), fi, pe), (ot.uniformsNeedUpdate = !1)),
        ot.isSpriteMaterial && gn.setValue(J, "center", gt.center),
        gn.setValue(J, "modelViewMatrix", gt.modelViewMatrix),
        gn.setValue(J, "normalMatrix", gt.normalMatrix),
        gn.setValue(J, "modelMatrix", gt.matrixWorld),
        ot.isShaderMaterial || ot.isRawShaderMaterial)
      ) {
        const $n = ot.uniformsGroups;
        for (let Zi = 0, Ca = $n.length; Zi < Ca; Zi++) {
          const ur = $n[Zi];
          st.update(ur, on), st.bind(ur, on);
        }
      }
      return on;
    }
    function Bt(H, tt) {
      (H.ambientLightColor.needsUpdate = tt),
        (H.lightProbe.needsUpdate = tt),
        (H.directionalLights.needsUpdate = tt),
        (H.directionalLightShadows.needsUpdate = tt),
        (H.pointLights.needsUpdate = tt),
        (H.pointLightShadows.needsUpdate = tt),
        (H.spotLights.needsUpdate = tt),
        (H.spotLightShadows.needsUpdate = tt),
        (H.rectAreaLights.needsUpdate = tt),
        (H.hemisphereLights.needsUpdate = tt);
    }
    function Ut(H) {
      return (
        H.isMeshLambertMaterial ||
        H.isMeshToonMaterial ||
        H.isMeshPhongMaterial ||
        H.isMeshStandardMaterial ||
        H.isShadowMaterial ||
        (H.isShaderMaterial && H.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return P;
    }),
      (this.getActiveMipmapLevel = function () {
        return V;
      }),
      (this.getRenderTarget = function () {
        return F;
      }),
      (this.setRenderTargetTextures = function (H, tt, rt) {
        const ot = te.get(H);
        (ot.__autoAllocateDepthBuffer = H.resolveDepthBuffer === !1),
          ot.__autoAllocateDepthBuffer === !1 && (ot.__useRenderToTexture = !1),
          (te.get(H.texture).__webglTexture = tt),
          (te.get(H.depthTexture).__webglTexture = ot.__autoAllocateDepthBuffer
            ? void 0
            : rt),
          (ot.__hasExternalTextures = !0);
      }),
      (this.setRenderTargetFramebuffer = function (H, tt) {
        const rt = te.get(H);
        (rt.__webglFramebuffer = tt),
          (rt.__useDefaultFramebuffer = tt === void 0);
      });
    const Ht = J.createFramebuffer();
    (this.setRenderTarget = function (H, tt = 0, rt = 0) {
      (F = H), (P = tt), (V = rt);
      let ot = !0,
        gt = null,
        wt = !1,
        Vt = !1;
      if (H) {
        const ee = te.get(H);
        if (ee.__useDefaultFramebuffer !== void 0)
          kt.bindFramebuffer(J.FRAMEBUFFER, null), (ot = !1);
        else if (ee.__webglFramebuffer === void 0) pe.setupRenderTarget(H);
        else if (ee.__hasExternalTextures)
          pe.rebindTextures(
            H,
            te.get(H.texture).__webglTexture,
            te.get(H.depthTexture).__webglTexture
          );
        else if (H.depthBuffer) {
          const _e = H.depthTexture;
          if (ee.__boundDepthTexture !== _e) {
            if (
              _e !== null &&
              te.has(_e) &&
              (H.width !== _e.image.width || H.height !== _e.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
              );
            pe.setupDepthRenderbuffer(H);
          }
        }
        const xe = H.texture;
        (xe.isData3DTexture ||
          xe.isDataArrayTexture ||
          xe.isCompressedArrayTexture) &&
          (Vt = !0);
        const ve = te.get(H).__webglFramebuffer;
        H.isWebGLCubeRenderTarget
          ? (Array.isArray(ve[tt]) ? (gt = ve[tt][rt]) : (gt = ve[tt]),
            (wt = !0))
          : H.samples > 0 && pe.useMultisampledRTT(H) === !1
          ? (gt = te.get(H).__webglMultisampledFramebuffer)
          : Array.isArray(ve)
          ? (gt = ve[rt])
          : (gt = ve),
          Y.copy(H.viewport),
          ct.copy(H.scissor),
          (nt = H.scissorTest);
      } else
        Y.copy(ft).multiplyScalar(et).floor(),
          ct.copy(At).multiplyScalar(et).floor(),
          (nt = Rt);
      if (
        (rt !== 0 && (gt = Ht),
        kt.bindFramebuffer(J.FRAMEBUFFER, gt) && ot && kt.drawBuffers(H, gt),
        kt.viewport(Y),
        kt.scissor(ct),
        kt.setScissorTest(nt),
        wt)
      ) {
        const ee = te.get(H.texture);
        J.framebufferTexture2D(
          J.FRAMEBUFFER,
          J.COLOR_ATTACHMENT0,
          J.TEXTURE_CUBE_MAP_POSITIVE_X + tt,
          ee.__webglTexture,
          rt
        );
      } else if (Vt) {
        const ee = te.get(H.texture),
          xe = tt;
        J.framebufferTextureLayer(
          J.FRAMEBUFFER,
          J.COLOR_ATTACHMENT0,
          ee.__webglTexture,
          rt,
          xe
        );
      } else if (H !== null && rt !== 0) {
        const ee = te.get(H.texture);
        J.framebufferTexture2D(
          J.FRAMEBUFFER,
          J.COLOR_ATTACHMENT0,
          J.TEXTURE_2D,
          ee.__webglTexture,
          rt
        );
      }
      N = -1;
    }),
      (this.readRenderTargetPixels = function (
        H,
        tt,
        rt,
        ot,
        gt,
        wt,
        Vt,
        Jt = 0
      ) {
        if (!(H && H.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let ee = te.get(H).__webglFramebuffer;
        if ((H.isWebGLCubeRenderTarget && Vt !== void 0 && (ee = ee[Vt]), ee)) {
          kt.bindFramebuffer(J.FRAMEBUFFER, ee);
          try {
            const xe = H.textures[Jt],
              ve = xe.format,
              _e = xe.type;
            if (!$t.textureFormatReadable(ve)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!$t.textureTypeReadable(_e)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            tt >= 0 &&
              tt <= H.width - ot &&
              rt >= 0 &&
              rt <= H.height - gt &&
              (H.textures.length > 1 && J.readBuffer(J.COLOR_ATTACHMENT0 + Jt),
              J.readPixels(tt, rt, ot, gt, yt.convert(ve), yt.convert(_e), wt));
          } finally {
            const xe = F !== null ? te.get(F).__webglFramebuffer : null;
            kt.bindFramebuffer(J.FRAMEBUFFER, xe);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        H,
        tt,
        rt,
        ot,
        gt,
        wt,
        Vt,
        Jt = 0
      ) {
        if (!(H && H.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let ee = te.get(H).__webglFramebuffer;
        if ((H.isWebGLCubeRenderTarget && Vt !== void 0 && (ee = ee[Vt]), ee))
          if (tt >= 0 && tt <= H.width - ot && rt >= 0 && rt <= H.height - gt) {
            kt.bindFramebuffer(J.FRAMEBUFFER, ee);
            const xe = H.textures[Jt],
              ve = xe.format,
              _e = xe.type;
            if (!$t.textureFormatReadable(ve))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!$t.textureTypeReadable(_e))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            const He = J.createBuffer();
            J.bindBuffer(J.PIXEL_PACK_BUFFER, He),
              J.bufferData(J.PIXEL_PACK_BUFFER, wt.byteLength, J.STREAM_READ),
              H.textures.length > 1 && J.readBuffer(J.COLOR_ATTACHMENT0 + Jt),
              J.readPixels(tt, rt, ot, gt, yt.convert(ve), yt.convert(_e), 0);
            const ze = F !== null ? te.get(F).__webglFramebuffer : null;
            kt.bindFramebuffer(J.FRAMEBUFFER, ze);
            const Mn = J.fenceSync(J.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              J.flush(),
              await JU(J, Mn, 4),
              J.bindBuffer(J.PIXEL_PACK_BUFFER, He),
              J.getBufferSubData(J.PIXEL_PACK_BUFFER, 0, wt),
              J.deleteBuffer(He),
              J.deleteSync(Mn),
              wt
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
      }),
      (this.copyFramebufferToTexture = function (H, tt = null, rt = 0) {
        const ot = Math.pow(2, -rt),
          gt = Math.floor(H.image.width * ot),
          wt = Math.floor(H.image.height * ot),
          Vt = tt !== null ? tt.x : 0,
          Jt = tt !== null ? tt.y : 0;
        pe.setTexture2D(H, 0),
          J.copyTexSubImage2D(J.TEXTURE_2D, rt, 0, 0, Vt, Jt, gt, wt),
          kt.unbindTexture();
      });
    const ue = J.createFramebuffer(),
      ae = J.createFramebuffer();
    (this.copyTextureToTexture = function (
      H,
      tt,
      rt = null,
      ot = null,
      gt = 0,
      wt = null
    ) {
      wt === null &&
        (gt !== 0
          ? (zd(
              "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."
            ),
            (wt = gt),
            (gt = 0))
          : (wt = 0));
      let Vt, Jt, ee, xe, ve, _e, He, ze, Mn;
      const Oe = H.isCompressedTexture ? H.mipmaps[wt] : H.image;
      if (rt !== null)
        (Vt = rt.max.x - rt.min.x),
          (Jt = rt.max.y - rt.min.y),
          (ee = rt.isBox3 ? rt.max.z - rt.min.z : 1),
          (xe = rt.min.x),
          (ve = rt.min.y),
          (_e = rt.isBox3 ? rt.min.z : 0);
      else {
        const Un = Math.pow(2, -gt);
        (Vt = Math.floor(Oe.width * Un)),
          (Jt = Math.floor(Oe.height * Un)),
          H.isDataArrayTexture
            ? (ee = Oe.depth)
            : H.isData3DTexture
            ? (ee = Math.floor(Oe.depth * Un))
            : (ee = 1),
          (xe = 0),
          (ve = 0),
          (_e = 0);
      }
      ot !== null
        ? ((He = ot.x), (ze = ot.y), (Mn = ot.z))
        : ((He = 0), (ze = 0), (Mn = 0));
      const Ve = yt.convert(tt.format),
        Ne = yt.convert(tt.type);
      let Yn;
      tt.isData3DTexture
        ? (pe.setTexture3D(tt, 0), (Yn = J.TEXTURE_3D))
        : tt.isDataArrayTexture || tt.isCompressedArrayTexture
        ? (pe.setTexture2DArray(tt, 0), (Yn = J.TEXTURE_2D_ARRAY))
        : (pe.setTexture2D(tt, 0), (Yn = J.TEXTURE_2D)),
        J.pixelStorei(J.UNPACK_FLIP_Y_WEBGL, tt.flipY),
        J.pixelStorei(J.UNPACK_PREMULTIPLY_ALPHA_WEBGL, tt.premultiplyAlpha),
        J.pixelStorei(J.UNPACK_ALIGNMENT, tt.unpackAlignment);
      const en = J.getParameter(J.UNPACK_ROW_LENGTH),
        on = J.getParameter(J.UNPACK_IMAGE_HEIGHT),
        Qn = J.getParameter(J.UNPACK_SKIP_PIXELS),
        qe = J.getParameter(J.UNPACK_SKIP_ROWS),
        xn = J.getParameter(J.UNPACK_SKIP_IMAGES);
      J.pixelStorei(J.UNPACK_ROW_LENGTH, Oe.width),
        J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, Oe.height),
        J.pixelStorei(J.UNPACK_SKIP_PIXELS, xe),
        J.pixelStorei(J.UNPACK_SKIP_ROWS, ve),
        J.pixelStorei(J.UNPACK_SKIP_IMAGES, _e);
      const gn = H.isDataArrayTexture || H.isData3DTexture,
        fi = tt.isDataArrayTexture || tt.isData3DTexture;
      if (H.isDepthTexture) {
        const Un = te.get(H),
          $n = te.get(tt),
          Zi = te.get(Un.__renderTarget),
          Ca = te.get($n.__renderTarget);
        kt.bindFramebuffer(J.READ_FRAMEBUFFER, Zi.__webglFramebuffer),
          kt.bindFramebuffer(J.DRAW_FRAMEBUFFER, Ca.__webglFramebuffer);
        for (let ur = 0; ur < ee; ur++)
          gn &&
            (J.framebufferTextureLayer(
              J.READ_FRAMEBUFFER,
              J.COLOR_ATTACHMENT0,
              te.get(H).__webglTexture,
              gt,
              _e + ur
            ),
            J.framebufferTextureLayer(
              J.DRAW_FRAMEBUFFER,
              J.COLOR_ATTACHMENT0,
              te.get(tt).__webglTexture,
              wt,
              Mn + ur
            )),
            J.blitFramebuffer(
              xe,
              ve,
              Vt,
              Jt,
              He,
              ze,
              Vt,
              Jt,
              J.DEPTH_BUFFER_BIT,
              J.NEAREST
            );
        kt.bindFramebuffer(J.READ_FRAMEBUFFER, null),
          kt.bindFramebuffer(J.DRAW_FRAMEBUFFER, null);
      } else if (gt !== 0 || H.isRenderTargetTexture || te.has(H)) {
        const Un = te.get(H),
          $n = te.get(tt);
        kt.bindFramebuffer(J.READ_FRAMEBUFFER, ue),
          kt.bindFramebuffer(J.DRAW_FRAMEBUFFER, ae);
        for (let Zi = 0; Zi < ee; Zi++)
          gn
            ? J.framebufferTextureLayer(
                J.READ_FRAMEBUFFER,
                J.COLOR_ATTACHMENT0,
                Un.__webglTexture,
                gt,
                _e + Zi
              )
            : J.framebufferTexture2D(
                J.READ_FRAMEBUFFER,
                J.COLOR_ATTACHMENT0,
                J.TEXTURE_2D,
                Un.__webglTexture,
                gt
              ),
            fi
              ? J.framebufferTextureLayer(
                  J.DRAW_FRAMEBUFFER,
                  J.COLOR_ATTACHMENT0,
                  $n.__webglTexture,
                  wt,
                  Mn + Zi
                )
              : J.framebufferTexture2D(
                  J.DRAW_FRAMEBUFFER,
                  J.COLOR_ATTACHMENT0,
                  J.TEXTURE_2D,
                  $n.__webglTexture,
                  wt
                ),
            gt !== 0
              ? J.blitFramebuffer(
                  xe,
                  ve,
                  Vt,
                  Jt,
                  He,
                  ze,
                  Vt,
                  Jt,
                  J.COLOR_BUFFER_BIT,
                  J.NEAREST
                )
              : fi
              ? J.copyTexSubImage3D(Yn, wt, He, ze, Mn + Zi, xe, ve, Vt, Jt)
              : J.copyTexSubImage2D(Yn, wt, He, ze, xe, ve, Vt, Jt);
        kt.bindFramebuffer(J.READ_FRAMEBUFFER, null),
          kt.bindFramebuffer(J.DRAW_FRAMEBUFFER, null);
      } else
        fi
          ? H.isDataTexture || H.isData3DTexture
            ? J.texSubImage3D(Yn, wt, He, ze, Mn, Vt, Jt, ee, Ve, Ne, Oe.data)
            : tt.isCompressedArrayTexture
            ? J.compressedTexSubImage3D(
                Yn,
                wt,
                He,
                ze,
                Mn,
                Vt,
                Jt,
                ee,
                Ve,
                Oe.data
              )
            : J.texSubImage3D(Yn, wt, He, ze, Mn, Vt, Jt, ee, Ve, Ne, Oe)
          : H.isDataTexture
          ? J.texSubImage2D(J.TEXTURE_2D, wt, He, ze, Vt, Jt, Ve, Ne, Oe.data)
          : H.isCompressedTexture
          ? J.compressedTexSubImage2D(
              J.TEXTURE_2D,
              wt,
              He,
              ze,
              Oe.width,
              Oe.height,
              Ve,
              Oe.data
            )
          : J.texSubImage2D(J.TEXTURE_2D, wt, He, ze, Vt, Jt, Ve, Ne, Oe);
      J.pixelStorei(J.UNPACK_ROW_LENGTH, en),
        J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, on),
        J.pixelStorei(J.UNPACK_SKIP_PIXELS, Qn),
        J.pixelStorei(J.UNPACK_SKIP_ROWS, qe),
        J.pixelStorei(J.UNPACK_SKIP_IMAGES, xn),
        wt === 0 && tt.generateMipmaps && J.generateMipmap(Yn),
        kt.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (
        H,
        tt,
        rt = null,
        ot = null,
        gt = 0
      ) {
        return (
          zd(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(H, tt, rt, ot, gt)
        );
      }),
      (this.initRenderTarget = function (H) {
        te.get(H).__webglFramebuffer === void 0 && pe.setupRenderTarget(H);
      }),
      (this.initTexture = function (H) {
        H.isCubeTexture
          ? pe.setTextureCube(H, 0)
          : H.isData3DTexture
          ? pe.setTexture3D(H, 0)
          : H.isDataArrayTexture || H.isCompressedArrayTexture
          ? pe.setTexture2DArray(H, 0)
          : pe.setTexture2D(H, 0),
          kt.unbindTexture();
      }),
      (this.resetState = function () {
        (P = 0), (V = 0), (F = null), kt.reset(), Qt.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Lr;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t;
    const e = this.getContext();
    (e.drawingBufferColorSpace = In._getDrawingBufferColorSpace(t)),
      (e.unpackColorSpace = In._getUnpackColorSpace());
  }
}
const nz = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: BA,
      AddEquation: su,
      AddOperation: dC,
      AdditiveAnimationBlendMode: PA,
      AdditiveBlending: Lb,
      AgXToneMapping: yC,
      AlphaFormat: UA,
      AlwaysCompare: OC,
      AlwaysDepth: Py,
      AlwaysStencilFunc: Hb,
      AmbientLight: bR,
      AnimationAction: DR,
      AnimationClip: th,
      AnimationLoader: SN,
      AnimationMixer: vS,
      AnimationObjectGroup: WN,
      AnimationUtils: xN,
      ArcCurve: qC,
      ArrayCamera: CR,
      ArrowHelper: dL,
      AttachedBindMode: zb,
      Audio: RR,
      AudioAnalyser: IN,
      AudioContext: dS,
      AudioListener: ON,
      AudioLoader: BN,
      AxesHelper: pL,
      BackSide: Ms,
      BasicDepthPacking: MC,
      BasicShadowMap: Y2,
      BatchedMesh: XC,
      Bone: Wx,
      BooleanKeyframeTrack: sh,
      Box2: tL,
      Box3: Ha,
      Box3Helper: fL,
      BoxGeometry: ah,
      BoxHelper: uL,
      BufferAttribute: Gn,
      BufferGeometry: pn,
      BufferGeometryLoader: TR,
      ByteType: Nx,
      Cache: Zl,
      Camera: kx,
      CameraHelper: cL,
      CanvasTexture: VO,
      CapsuleGeometry: Jx,
      CatmullRomCurve3: KC,
      CineonToneMapping: gC,
      CircleGeometry: Zx,
      ClampToEdgeWrapping: Ki,
      Clock: pS,
      Color: Se,
      ColorKeyframeTrack: oS,
      ColorManagement: In,
      CompressedArrayTexture: HO,
      CompressedCubeTexture: GO,
      CompressedTexture: Kx,
      CompressedTextureLoader: MN,
      ConeGeometry: z0,
      ConstantAlphaFactor: uC,
      ConstantColorFactor: lC,
      Controls: gL,
      CubeCamera: GC,
      CubeReflectionMapping: dl,
      CubeRefractionMapping: uu,
      CubeTexture: O0,
      CubeTextureLoader: yR,
      CubeUVReflectionMapping: ip,
      CubicBezierCurve: QA,
      CubicBezierCurve3: JC,
      CubicInterpolant: pR,
      CullFaceBack: Nb,
      CullFaceFront: W2,
      CullFaceFrontBack: tU,
      CullFaceNone: X2,
      Curve: So,
      CurvePath: QC,
      CustomBlending: q2,
      CustomToneMapping: vC,
      CylinderGeometry: P0,
      Cylindrical: $N,
      Data3DTexture: Vx,
      DataArrayTexture: Gx,
      DataTexture: _o,
      DataTextureLoader: lS,
      DataUtils: Ff,
      DecrementStencilOp: uU,
      DecrementWrapStencilOp: hU,
      DefaultLoadingManager: vR,
      DepthFormat: Wd,
      DepthStencilFormat: Yd,
      DepthTexture: JA,
      DetachedBindMode: _C,
      DirectionalLight: hS,
      DirectionalLightHelper: lL,
      DiscreteInterpolant: mR,
      DodecahedronGeometry: Qx,
      DoubleSide: or,
      DstAlphaFactor: iC,
      DstColorFactor: sC,
      DynamicCopyUsage: wU,
      DynamicDrawUsage: bU,
      DynamicReadUsage: MU,
      EdgesGeometry: YC,
      EllipseCurve: $x,
      EqualCompare: RC,
      EqualDepth: Fy,
      EqualStencilFunc: gU,
      EquirectangularReflectionMapping: Vd,
      EquirectangularRefractionMapping: l0,
      Euler: cr,
      EventDispatcher: ml,
      ExtrudeGeometry: t1,
      FileLoader: Ga,
      Float16BufferAttribute: xO,
      Float32BufferAttribute: Pe,
      FloatType: Pi,
      Fog: Xx,
      FogExp2: jx,
      FramebufferTexture: FO,
      FrontSide: hl,
      Frustum: ap,
      FrustumArray: Yx,
      GLBufferAttribute: QN,
      GLSL1: RU,
      GLSL3: Gb,
      GreaterCompare: BC,
      GreaterDepth: Gy,
      GreaterEqualCompare: UC,
      GreaterEqualDepth: Hy,
      GreaterEqualStencilFunc: _U,
      GreaterStencilFunc: yU,
      GridHelper: rL,
      Group: Jl,
      HalfFloatType: Ea,
      HemisphereLight: _R,
      HemisphereLightHelper: sL,
      IcosahedronGeometry: F0,
      ImageBitmapLoader: wR,
      ImageLoader: v0,
      ImageUtils: PC,
      IncrementStencilOp: cU,
      IncrementWrapStencilOp: fU,
      InstancedBufferAttribute: Zf,
      InstancedBufferGeometry: ER,
      InstancedInterleavedBuffer: ZN,
      InstancedMesh: YA,
      Int16BufferAttribute: vO,
      Int32BufferAttribute: yO,
      Int8BufferAttribute: pO,
      IntType: B0,
      InterleavedBuffer: L0,
      InterleavedBufferAttribute: hu,
      Interpolant: sp,
      InterpolateDiscrete: qd,
      InterpolateLinear: Kd,
      InterpolateSmooth: Ey,
      InterpolationSamplingMode: UU,
      InterpolationSamplingType: DU,
      InvertStencilOp: dU,
      KeepStencilOp: Uf,
      KeyframeTrack: Hr,
      LOD: jC,
      LatheGeometry: e1,
      Layers: Zd,
      LessCompare: CC,
      LessDepth: zy,
      LessEqualCompare: FA,
      LessEqualDepth: Jf,
      LessEqualStencilFunc: vU,
      LessStencilFunc: mU,
      Light: _u,
      LightProbe: MR,
      Line: tc,
      Line3: eL,
      LineBasicMaterial: is,
      LineCurve: $A,
      LineCurve3: ZC,
      LineDashedMaterial: fR,
      LineLoop: qA,
      LineSegments: Ao,
      LinearFilter: Kn,
      LinearInterpolant: rS,
      LinearMipMapLinearFilter: Fb,
      LinearMipMapNearestFilter: iU,
      LinearMipmapLinearFilter: Nr,
      LinearMipmapNearestFilter: Pd,
      LinearSRGBColorSpace: bo,
      LinearToneMapping: pC,
      LinearTransfer: u0,
      Loader: Va,
      LoaderUtils: lu,
      LoadingManager: l1,
      LoopOnce: bC,
      LoopPingPong: AC,
      LoopRepeat: IA,
      MOUSE: Bf,
      Material: ma,
      MaterialLoader: c1,
      MathUtils: NC,
      Matrix2: _S,
      Matrix3: yn,
      Matrix4: Xe,
      MaxEquation: Q2,
      Mesh: Ti,
      MeshBasicMaterial: ks,
      MeshDepthMaterial: iS,
      MeshDistanceMaterial: aS,
      MeshLambertMaterial: cR,
      MeshMatcapMaterial: uR,
      MeshNormalMaterial: lR,
      MeshPhongMaterial: rR,
      MeshPhysicalMaterial: Fr,
      MeshStandardMaterial: V0,
      MeshToonMaterial: oR,
      MinEquation: Z2,
      MirroredRepeatWrapping: kd,
      MixOperation: hC,
      MultiplyBlending: Pb,
      MultiplyOperation: R0,
      NearestFilter: Ta,
      NearestMipMapLinearFilter: nU,
      NearestMipMapNearestFilter: eU,
      NearestMipmapLinearFilter: If,
      NearestMipmapNearestFilter: Ox,
      NeutralToneMapping: xC,
      NeverCompare: wC,
      NeverDepth: Iy,
      NeverStencilFunc: pU,
      NoBlending: ol,
      NoColorSpace: ql,
      NoToneMapping: ll,
      NormalAnimationBlendMode: Hx,
      NormalBlending: Xf,
      NotEqualCompare: DC,
      NotEqualDepth: Vy,
      NotEqualStencilFunc: xU,
      NumberKeyframeTrack: $f,
      Object3D: Dn,
      ObjectLoader: CN,
      ObjectSpaceNormalMap: TC,
      OctahedronGeometry: H0,
      OneFactor: tC,
      OneMinusConstantAlphaFactor: fC,
      OneMinusConstantColorFactor: cC,
      OneMinusDstAlphaFactor: aC,
      OneMinusDstColorFactor: rC,
      OneMinusSrcAlphaFactor: Ly,
      OneMinusSrcColorFactor: nC,
      OrthographicCamera: Ir,
      PCFShadowMap: Ux,
      PCFSoftShadowMap: Wm,
      PMREMGenerator: Kb,
      Path: xx,
      PerspectiveCamera: Ei,
      Plane: Yl,
      PlaneGeometry: xu,
      PlaneHelper: hL,
      PointLight: fS,
      PointLightHelper: iL,
      Points: KA,
      PointsMaterial: qx,
      PolarGridHelper: oL,
      PolyhedronGeometry: yu,
      PositionalAudio: LN,
      PropertyBinding: Fn,
      PropertyMixer: BR,
      QuadraticBezierCurve: tS,
      QuadraticBezierCurve3: eS,
      Quaternion: pa,
      QuaternionKeyframeTrack: du,
      QuaternionLinearInterpolant: gR,
      RED_GREEN_RGTC2_Format: dx,
      RED_RGTC1_Format: LA,
      REVISION: C0,
      RGBADepthPacking: EC,
      RGBAFormat: Ji,
      RGBAIntegerFormat: Fx,
      RGBA_ASTC_10x10_Format: ox,
      RGBA_ASTC_10x5_Format: ax,
      RGBA_ASTC_10x6_Format: sx,
      RGBA_ASTC_10x8_Format: rx,
      RGBA_ASTC_12x10_Format: lx,
      RGBA_ASTC_12x12_Format: cx,
      RGBA_ASTC_4x4_Format: Jy,
      RGBA_ASTC_5x4_Format: Zy,
      RGBA_ASTC_5x5_Format: Qy,
      RGBA_ASTC_6x5_Format: $y,
      RGBA_ASTC_6x6_Format: tx,
      RGBA_ASTC_8x5_Format: ex,
      RGBA_ASTC_8x6_Format: nx,
      RGBA_ASTC_8x8_Format: ix,
      RGBA_BPTC_Format: Zm,
      RGBA_ETC2_EAC_Format: Ky,
      RGBA_PVRTC_2BPPV1_Format: Wy,
      RGBA_PVRTC_4BPPV1_Format: Xy,
      RGBA_S3TC_DXT1_Format: qm,
      RGBA_S3TC_DXT3_Format: Km,
      RGBA_S3TC_DXT5_Format: Jm,
      RGBDepthPacking: sU,
      RGBFormat: OA,
      RGBIntegerFormat: aU,
      RGB_BPTC_SIGNED_Format: ux,
      RGB_BPTC_UNSIGNED_Format: fx,
      RGB_ETC1_Format: Yy,
      RGB_ETC2_Format: qy,
      RGB_PVRTC_2BPPV1_Format: jy,
      RGB_PVRTC_4BPPV1_Format: ky,
      RGB_S3TC_DXT1_Format: Ym,
      RGDepthPacking: rU,
      RGFormat: NA,
      RGIntegerFormat: zx,
      RawShaderMaterial: sR,
      Ray: ih,
      Raycaster: xS,
      RectAreaLight: AR,
      RedFormat: D0,
      RedIntegerFormat: U0,
      ReinhardToneMapping: mC,
      RenderTarget: GA,
      RenderTarget3D: qN,
      RepeatWrapping: fu,
      ReplaceStencilOp: lU,
      ReverseSubtractEquation: J2,
      RingGeometry: n1,
      SIGNED_RED_GREEN_RGTC2_Format: px,
      SIGNED_RED_RGTC1_Format: hx,
      SRGBColorSpace: Fa,
      SRGBTransfer: ai,
      Scene: N0,
      ShaderChunk: Sn,
      ShaderLib: yo,
      ShaderMaterial: Xs,
      ShadowMaterial: aR,
      Shape: Yf,
      ShapeGeometry: i1,
      ShapePath: mL,
      ShapeUtils: xo,
      ShortType: Lx,
      Skeleton: I0,
      SkeletonHelper: UR,
      SkinnedMesh: WA,
      Source: ru,
      Sphere: wa,
      SphereGeometry: G0,
      Spherical: Yb,
      SphericalHarmonics3: SR,
      SplineCurve: nS,
      SpotLight: uS,
      SpotLightHelper: nL,
      Sprite: kC,
      SpriteMaterial: XA,
      SrcAlphaFactor: Ny,
      SrcAlphaSaturateFactor: oC,
      SrcColorFactor: eC,
      StaticCopyUsage: TU,
      StaticDrawUsage: f0,
      StaticReadUsage: SU,
      StereoCamera: DN,
      StreamCopyUsage: CU,
      StreamDrawUsage: AU,
      StreamReadUsage: EU,
      StringKeyframeTrack: rh,
      SubtractEquation: K2,
      SubtractiveBlending: Ib,
      TOUCH: Df,
      TangentSpaceNormalMap: vu,
      TetrahedronGeometry: a1,
      Texture: Zn,
      TextureLoader: xR,
      TextureUtils: bL,
      TimestampQuery: BU,
      TorusGeometry: s1,
      TorusKnotGeometry: r1,
      Triangle: Vs,
      TriangleFanDrawMode: mx,
      TriangleStripDrawMode: zA,
      TrianglesDrawMode: SC,
      TubeGeometry: o1,
      UVMapping: cu,
      Uint16BufferAttribute: VA,
      Uint32BufferAttribute: kA,
      Uint8BufferAttribute: mO,
      Uint8ClampedBufferAttribute: gO,
      Uniform: yS,
      UniformsGroup: JN,
      UniformsLib: Ee,
      UniformsUtils: HC,
      UnsignedByteType: Es,
      UnsignedInt248Type: Xd,
      UnsignedInt5999Type: DA,
      UnsignedIntType: pl,
      UnsignedShort4444Type: Ix,
      UnsignedShort5551Type: Px,
      UnsignedShortType: jd,
      VSMShadowMap: vo,
      Vector2: Yt,
      Vector3: Z,
      Vector4: Hn,
      VectorKeyframeTrack: pu,
      VideoFrameTexture: zO,
      VideoTexture: WC,
      WebGL3DRenderTarget: iO,
      WebGLArrayRenderTarget: nO,
      WebGLCoordinateSystem: Lr,
      WebGLCubeRenderTarget: jA,
      WebGLRenderTarget: zr,
      WebGLRenderer: AS,
      WebGLUtils: FR,
      WebGPUCoordinateSystem: h0,
      WebXRController: Ty,
      WireframeGeometry: iR,
      WrapAroundEnding: c0,
      ZeroCurvatureEnding: Pf,
      ZeroFactor: $2,
      ZeroSlopeEnding: zf,
      ZeroStencilOp: oU,
      createCanvasElement: IC,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var q_ = { exports: {} },
  Xl = {};
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var VT;
function iz() {
  return (
    VT ||
      ((VT = 1),
      (Xl.ConcurrentRoot = 1),
      (Xl.ContinuousEventPriority = 8),
      (Xl.DefaultEventPriority = 32),
      (Xl.DiscreteEventPriority = 2),
      (Xl.IdleEventPriority = 268435456),
      (Xl.LegacyRoot = 0),
      (Xl.NoEventPriority = 0)),
    Xl
  );
}
var kT;
function az() {
  return kT || ((kT = 1), (q_.exports = iz())), q_.exports;
}
var Cy = az(),
  K_ = { exports: {} },
  J_ = {},
  Z_ = { exports: {} },
  Q_ = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var jT;
function sz() {
  if (jT) return Q_;
  jT = 1;
  var i = nh();
  function t(v, x) {
    return (v === x && (v !== 0 || 1 / v === 1 / x)) || (v !== v && x !== x);
  }
  var e = typeof Object.is == "function" ? Object.is : t,
    n = i.useState,
    a = i.useEffect,
    r = i.useLayoutEffect,
    l = i.useDebugValue;
  function u(v, x) {
    var _ = x(),
      M = n({ inst: { value: _, getSnapshot: x } }),
      C = M[0].inst,
      E = M[1];
    return (
      r(
        function () {
          (C.value = _), (C.getSnapshot = x), h(C) && E({ inst: C });
        },
        [v, _, x]
      ),
      a(
        function () {
          return (
            h(C) && E({ inst: C }),
            v(function () {
              h(C) && E({ inst: C });
            })
          );
        },
        [v]
      ),
      l(_),
      _
    );
  }
  function h(v) {
    var x = v.getSnapshot;
    v = v.value;
    try {
      var _ = x();
      return !e(v, _);
    } catch {
      return !0;
    }
  }
  function p(v, x) {
    return x();
  }
  var m =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? p
      : u;
  return (
    (Q_.useSyncExternalStore =
      i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : m),
    Q_
  );
}
var XT;
function rz() {
  return XT || ((XT = 1), (Z_.exports = sz())), Z_.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var WT;
function oz() {
  if (WT) return J_;
  WT = 1;
  var i = nh(),
    t = rz();
  function e(p, m) {
    return (p === m && (p !== 0 || 1 / p === 1 / m)) || (p !== p && m !== m);
  }
  var n = typeof Object.is == "function" ? Object.is : e,
    a = t.useSyncExternalStore,
    r = i.useRef,
    l = i.useEffect,
    u = i.useMemo,
    h = i.useDebugValue;
  return (
    (J_.useSyncExternalStoreWithSelector = function (p, m, v, x, _) {
      var M = r(null);
      if (M.current === null) {
        var C = { hasValue: !1, value: null };
        M.current = C;
      } else C = M.current;
      M = u(
        function () {
          function S(P) {
            if (!R) {
              if (((R = !0), (B = P), (P = x(P)), _ !== void 0 && C.hasValue)) {
                var V = C.value;
                if (_(V, P)) return (D = V);
              }
              return (D = P);
            }
            if (((V = D), n(B, P))) return V;
            var F = x(P);
            return _ !== void 0 && _(V, F) ? ((B = P), V) : ((B = P), (D = F));
          }
          var R = !1,
            B,
            D,
            I = v === void 0 ? null : v;
          return [
            function () {
              return S(m());
            },
            I === null
              ? void 0
              : function () {
                  return S(I());
                },
          ];
        },
        [m, v, x, _]
      );
      var E = a(p, M[0], M[1]);
      return (
        l(
          function () {
            (C.hasValue = !0), (C.value = E);
          },
          [E]
        ),
        h(E),
        E
      );
    }),
    J_
  );
}
var YT;
function lz() {
  return YT || ((YT = 1), (K_.exports = oz())), K_.exports;
}
var cz = lz();
const uz = CA(cz),
  qT = (i) => {
    let t;
    const e = new Set(),
      n = (p, m) => {
        const v = typeof p == "function" ? p(t) : p;
        if (!Object.is(v, t)) {
          const x = t;
          (t =
            m ?? (typeof v != "object" || v === null)
              ? v
              : Object.assign({}, t, v)),
            e.forEach((_) => _(t, x));
        }
      },
      a = () => t,
      u = {
        setState: n,
        getState: a,
        getInitialState: () => h,
        subscribe: (p) => (e.add(p), () => e.delete(p)),
      },
      h = (t = i(n, a, u));
    return u;
  },
  fz = (i) => (i ? qT(i) : qT),
  { useSyncExternalStoreWithSelector: hz } = uz,
  dz = (i) => i;
function pz(i, t = dz, e) {
  const n = hz(i.subscribe, i.getState, i.getInitialState, t, e);
  return RA.useDebugValue(n), n;
}
const KT = (i, t) => {
    const e = fz(i),
      n = (a, r = t) => pz(e, a, r);
    return Object.assign(n, e), n;
  },
  HR = (i, t) => (i ? KT(i, t) : KT);
var $_ = { exports: {} },
  tb = { exports: {} },
  eb = { exports: {} },
  nb = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var JT;
function mz() {
  return (
    JT ||
      ((JT = 1),
      (function (i) {
        function t(j, Q) {
          var et = j.length;
          j.push(Q);
          t: for (; 0 < et; ) {
            var xt = (et - 1) >>> 1,
              X = j[xt];
            if (0 < a(X, Q)) (j[xt] = Q), (j[et] = X), (et = xt);
            else break t;
          }
        }
        function e(j) {
          return j.length === 0 ? null : j[0];
        }
        function n(j) {
          if (j.length === 0) return null;
          var Q = j[0],
            et = j.pop();
          if (et !== Q) {
            j[0] = et;
            t: for (var xt = 0, X = j.length, ft = X >>> 1; xt < ft; ) {
              var At = 2 * (xt + 1) - 1,
                Rt = j[At],
                ht = At + 1,
                It = j[ht];
              if (0 > a(Rt, et))
                ht < X && 0 > a(It, Rt)
                  ? ((j[xt] = It), (j[ht] = et), (xt = ht))
                  : ((j[xt] = Rt), (j[At] = et), (xt = At));
              else if (ht < X && 0 > a(It, et))
                (j[xt] = It), (j[ht] = et), (xt = ht);
              else break t;
            }
          }
          return Q;
        }
        function a(j, Q) {
          var et = j.sortIndex - Q.sortIndex;
          return et !== 0 ? et : j.id - Q.id;
        }
        if (
          ((i.unstable_now = void 0),
          typeof performance == "object" &&
            typeof performance.now == "function")
        ) {
          var r = performance;
          i.unstable_now = function () {
            return r.now();
          };
        } else {
          var l = Date,
            u = l.now();
          i.unstable_now = function () {
            return l.now() - u;
          };
        }
        var h = [],
          p = [],
          m = 1,
          v = null,
          x = 3,
          _ = !1,
          M = !1,
          C = !1,
          E = typeof setTimeout == "function" ? setTimeout : null,
          S = typeof clearTimeout == "function" ? clearTimeout : null,
          R = typeof setImmediate < "u" ? setImmediate : null;
        function B(j) {
          for (var Q = e(p); Q !== null; ) {
            if (Q.callback === null) n(p);
            else if (Q.startTime <= j)
              n(p), (Q.sortIndex = Q.expirationTime), t(h, Q);
            else break;
            Q = e(p);
          }
        }
        function D(j) {
          if (((C = !1), B(j), !M))
            if (e(h) !== null) (M = !0), dt();
            else {
              var Q = e(p);
              Q !== null && pt(D, Q.startTime - j);
            }
        }
        var I = !1,
          P = -1,
          V = 5,
          F = -1;
        function N() {
          return !(i.unstable_now() - F < V);
        }
        function L() {
          if (I) {
            var j = i.unstable_now();
            F = j;
            var Q = !0;
            try {
              t: {
                (M = !1), C && ((C = !1), S(P), (P = -1)), (_ = !0);
                var et = x;
                try {
                  e: {
                    for (
                      B(j), v = e(h);
                      v !== null && !(v.expirationTime > j && N());

                    ) {
                      var xt = v.callback;
                      if (typeof xt == "function") {
                        (v.callback = null), (x = v.priorityLevel);
                        var X = xt(v.expirationTime <= j);
                        if (((j = i.unstable_now()), typeof X == "function")) {
                          (v.callback = X), B(j), (Q = !0);
                          break e;
                        }
                        v === e(h) && n(h), B(j);
                      } else n(h);
                      v = e(h);
                    }
                    if (v !== null) Q = !0;
                    else {
                      var ft = e(p);
                      ft !== null && pt(D, ft.startTime - j), (Q = !1);
                    }
                  }
                  break t;
                } finally {
                  (v = null), (x = et), (_ = !1);
                }
                Q = void 0;
              }
            } finally {
              Q ? Y() : (I = !1);
            }
          }
        }
        var Y;
        if (typeof R == "function")
          Y = function () {
            R(L);
          };
        else if (typeof MessageChannel < "u") {
          var ct = new MessageChannel(),
            nt = ct.port2;
          (ct.port1.onmessage = L),
            (Y = function () {
              nt.postMessage(null);
            });
        } else
          Y = function () {
            E(L, 0);
          };
        function dt() {
          I || ((I = !0), Y());
        }
        function pt(j, Q) {
          P = E(function () {
            j(i.unstable_now());
          }, Q);
        }
        (i.unstable_IdlePriority = 5),
          (i.unstable_ImmediatePriority = 1),
          (i.unstable_LowPriority = 4),
          (i.unstable_NormalPriority = 3),
          (i.unstable_Profiling = null),
          (i.unstable_UserBlockingPriority = 2),
          (i.unstable_cancelCallback = function (j) {
            j.callback = null;
          }),
          (i.unstable_continueExecution = function () {
            M || _ || ((M = !0), dt());
          }),
          (i.unstable_forceFrameRate = function (j) {
            0 > j || 125 < j
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (V = 0 < j ? Math.floor(1e3 / j) : 5);
          }),
          (i.unstable_getCurrentPriorityLevel = function () {
            return x;
          }),
          (i.unstable_getFirstCallbackNode = function () {
            return e(h);
          }),
          (i.unstable_next = function (j) {
            switch (x) {
              case 1:
              case 2:
              case 3:
                var Q = 3;
                break;
              default:
                Q = x;
            }
            var et = x;
            x = Q;
            try {
              return j();
            } finally {
              x = et;
            }
          }),
          (i.unstable_pauseExecution = function () {}),
          (i.unstable_requestPaint = function () {}),
          (i.unstable_runWithPriority = function (j, Q) {
            switch (j) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                j = 3;
            }
            var et = x;
            x = j;
            try {
              return Q();
            } finally {
              x = et;
            }
          }),
          (i.unstable_scheduleCallback = function (j, Q, et) {
            var xt = i.unstable_now();
            switch (
              (typeof et == "object" && et !== null
                ? ((et = et.delay),
                  (et = typeof et == "number" && 0 < et ? xt + et : xt))
                : (et = xt),
              j)
            ) {
              case 1:
                var X = -1;
                break;
              case 2:
                X = 250;
                break;
              case 5:
                X = 1073741823;
                break;
              case 4:
                X = 1e4;
                break;
              default:
                X = 5e3;
            }
            return (
              (X = et + X),
              (j = {
                id: m++,
                callback: Q,
                priorityLevel: j,
                startTime: et,
                expirationTime: X,
                sortIndex: -1,
              }),
              et > xt
                ? ((j.sortIndex = et),
                  t(p, j),
                  e(h) === null &&
                    j === e(p) &&
                    (C ? (S(P), (P = -1)) : (C = !0), pt(D, et - xt)))
                : ((j.sortIndex = X), t(h, j), M || _ || ((M = !0), dt())),
              j
            );
          }),
          (i.unstable_shouldYield = N),
          (i.unstable_wrapCallback = function (j) {
            var Q = x;
            return function () {
              var et = x;
              x = Q;
              try {
                return j.apply(this, arguments);
              } finally {
                x = et;
              }
            };
          });
      })(nb)),
    nb
  );
}
var ZT;
function GR() {
  return ZT || ((ZT = 1), (eb.exports = mz())), eb.exports;
}
/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var QT;
function gz() {
  return (
    QT ||
      ((QT = 1),
      (function (i) {
        (i.exports = function (t) {
          function e(c, f, y, A) {
            return new Fp(c, f, y, A);
          }
          function n() {}
          function a(c) {
            var f = "https://react.dev/errors/" + c;
            if (1 < arguments.length) {
              f += "?args[]=" + encodeURIComponent(arguments[1]);
              for (var y = 2; y < arguments.length; y++)
                f += "&args[]=" + encodeURIComponent(arguments[y]);
            }
            return (
              "Minified React error #" +
              c +
              "; visit " +
              f +
              " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            );
          }
          function r(c) {
            return c === null || typeof c != "object"
              ? null
              : ((c = ($r && c[$r]) || c["@@iterator"]),
                typeof c == "function" ? c : null);
          }
          function l(c) {
            if (c == null) return null;
            if (typeof c == "function")
              return c.$$typeof === kp ? null : c.displayName || c.name || null;
            if (typeof c == "string") return c;
            switch (c) {
              case Fo:
                return "Fragment";
              case Rs:
                return "Portal";
              case Bh:
                return "Profiler";
              case Ku:
                return "StrictMode";
              case Dh:
                return "Suspense";
              case Sc:
                return "SuspenseList";
            }
            if (typeof c == "object")
              switch (c.$$typeof) {
                case Ks:
                  return (c.displayName || "Context") + ".Provider";
                case Gp:
                  return (c._context.displayName || "Context") + ".Consumer";
                case Zu:
                  var f = c.render;
                  return (
                    (c = c.displayName),
                    c ||
                      ((c = f.displayName || f.name || ""),
                      (c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
                    c
                  );
                case Uh:
                  return (
                    (f = c.displayName || null),
                    f !== null ? f : l(c.type) || "Memo"
                  );
                case Bs:
                  (f = c._payload), (c = c._init);
                  try {
                    return l(c(f));
                  } catch {}
              }
            return null;
          }
          function u(c) {
            if (mr === void 0)
              try {
                throw Error();
              } catch (y) {
                var f = y.stack.trim().match(/\n( *(at )?)/);
                (mr = (f && f[1]) || ""),
                  (to =
                    -1 <
                    y.stack.indexOf(`
    at`)
                      ? " (<anonymous>)"
                      : -1 < y.stack.indexOf("@")
                      ? "@unknown:0:0"
                      : "");
              }
            return (
              `
` +
              mr +
              c +
              to
            );
          }
          function h(c, f) {
            if (!c || _l) return "";
            _l = !0;
            var y = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
              var A = {
                DetermineComponentFrameRoot: function () {
                  try {
                    if (f) {
                      var Me = function () {
                        throw Error();
                      };
                      if (
                        (Object.defineProperty(Me.prototype, "props", {
                          set: function () {
                            throw Error();
                          },
                        }),
                        typeof Reflect == "object" && Reflect.construct)
                      ) {
                        try {
                          Reflect.construct(Me, []);
                        } catch (un) {
                          var Te = un;
                        }
                        Reflect.construct(c, [], Me);
                      } else {
                        try {
                          Me.call();
                        } catch (un) {
                          Te = un;
                        }
                        c.call(Me.prototype);
                      }
                    } else {
                      try {
                        throw Error();
                      } catch (un) {
                        Te = un;
                      }
                      (Me = c()) &&
                        typeof Me.catch == "function" &&
                        Me.catch(function () {});
                    }
                  } catch (un) {
                    if (un && Te && typeof un.stack == "string")
                      return [un.stack, Te.stack];
                  }
                  return [null, null];
                },
              };
              A.DetermineComponentFrameRoot.displayName =
                "DetermineComponentFrameRoot";
              var w = Object.getOwnPropertyDescriptor(
                A.DetermineComponentFrameRoot,
                "name"
              );
              w &&
                w.configurable &&
                Object.defineProperty(A.DetermineComponentFrameRoot, "name", {
                  value: "DetermineComponentFrameRoot",
                });
              var U = A.DetermineComponentFrameRoot(),
                q = U[0],
                lt = U[1];
              if (q && lt) {
                var St = q.split(`
`),
                  Xt = lt.split(`
`);
                for (
                  w = A = 0;
                  A < St.length &&
                  !St[A].includes("DetermineComponentFrameRoot");

                )
                  A++;
                for (
                  ;
                  w < Xt.length &&
                  !Xt[w].includes("DetermineComponentFrameRoot");

                )
                  w++;
                if (A === St.length || w === Xt.length)
                  for (
                    A = St.length - 1, w = Xt.length - 1;
                    1 <= A && 0 <= w && St[A] !== Xt[w];

                  )
                    w--;
                for (; 1 <= A && 0 <= w; A--, w--)
                  if (St[A] !== Xt[w]) {
                    if (A !== 1 || w !== 1)
                      do
                        if ((A--, w--, 0 > w || St[A] !== Xt[w])) {
                          var he =
                            `
` + St[A].replace(" at new ", " at ");
                          return (
                            c.displayName &&
                              he.includes("<anonymous>") &&
                              (he = he.replace("<anonymous>", c.displayName)),
                            he
                          );
                        }
                      while (1 <= A && 0 <= w);
                    break;
                  }
              }
            } finally {
              (_l = !1), (Error.prepareStackTrace = y);
            }
            return (y = c ? c.displayName || c.name : "") ? u(y) : "";
          }
          function p(c) {
            switch (c.tag) {
              case 26:
              case 27:
              case 5:
                return u(c.type);
              case 16:
                return u("Lazy");
              case 13:
                return u("Suspense");
              case 19:
                return u("SuspenseList");
              case 0:
              case 15:
                return (c = h(c.type, !1)), c;
              case 11:
                return (c = h(c.type.render, !1)), c;
              case 1:
                return (c = h(c.type, !0)), c;
              default:
                return "";
            }
          }
          function m(c) {
            try {
              var f = "";
              do (f += p(c)), (c = c.return);
              while (c);
              return f;
            } catch (y) {
              return (
                `
Error generating stack: ` +
                y.message +
                `
` +
                y.stack
              );
            }
          }
          function v(c) {
            var f = c,
              y = c;
            if (c.alternate) for (; f.return; ) f = f.return;
            else {
              c = f;
              do
                (f = c),
                  (f.flags & 4098) !== 0 && (y = f.return),
                  (c = f.return);
              while (c);
            }
            return f.tag === 3 ? y : null;
          }
          function x(c) {
            if (v(c) !== c) throw Error(a(188));
          }
          function _(c) {
            var f = c.alternate;
            if (!f) {
              if (((f = v(c)), f === null)) throw Error(a(188));
              return f !== c ? null : c;
            }
            for (var y = c, A = f; ; ) {
              var w = y.return;
              if (w === null) break;
              var U = w.alternate;
              if (U === null) {
                if (((A = w.return), A !== null)) {
                  y = A;
                  continue;
                }
                break;
              }
              if (w.child === U.child) {
                for (U = w.child; U; ) {
                  if (U === y) return x(w), c;
                  if (U === A) return x(w), f;
                  U = U.sibling;
                }
                throw Error(a(188));
              }
              if (y.return !== A.return) (y = w), (A = U);
              else {
                for (var q = !1, lt = w.child; lt; ) {
                  if (lt === y) {
                    (q = !0), (y = w), (A = U);
                    break;
                  }
                  if (lt === A) {
                    (q = !0), (A = w), (y = U);
                    break;
                  }
                  lt = lt.sibling;
                }
                if (!q) {
                  for (lt = U.child; lt; ) {
                    if (lt === y) {
                      (q = !0), (y = U), (A = w);
                      break;
                    }
                    if (lt === A) {
                      (q = !0), (A = U), (y = w);
                      break;
                    }
                    lt = lt.sibling;
                  }
                  if (!q) throw Error(a(189));
                }
              }
              if (y.alternate !== A) throw Error(a(190));
            }
            if (y.tag !== 3) throw Error(a(188));
            return y.stateNode.current === y ? c : f;
          }
          function M(c) {
            var f = c.tag;
            if (f === 5 || f === 26 || f === 27 || f === 6) return c;
            for (c = c.child; c !== null; ) {
              if (((f = M(c)), f !== null)) return f;
              c = c.sibling;
            }
            return null;
          }
          function C(c) {
            var f = c.tag;
            if (f === 5 || f === 26 || f === 27 || f === 6) return c;
            for (c = c.child; c !== null; ) {
              if (c.tag !== 4 && ((f = C(c)), f !== null)) return f;
              c = c.sibling;
            }
            return null;
          }
          function E(c) {
            return { current: c };
          }
          function S(c) {
            0 > ao || ((c.current = Ui[ao]), (Ui[ao] = null), ao--);
          }
          function R(c, f) {
            ao++, (Ui[ao] = c.current), (c.current = f);
          }
          function B(c) {
            return (c >>>= 0), c === 0 ? 32 : (31 - ((ev(c) / nv) | 0)) | 0;
          }
          function D(c) {
            var f = c & 42;
            if (f !== 0) return f;
            switch (c & -c) {
              case 1:
                return 1;
              case 2:
                return 2;
              case 4:
                return 4;
              case 8:
                return 8;
              case 16:
                return 16;
              case 32:
                return 32;
              case 64:
                return 64;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return c & 4194176;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return c & 62914560;
              case 67108864:
                return 67108864;
              case 134217728:
                return 134217728;
              case 268435456:
                return 268435456;
              case 536870912:
                return 536870912;
              case 1073741824:
                return 0;
              default:
                return c;
            }
          }
          function I(c, f) {
            var y = c.pendingLanes;
            if (y === 0) return 0;
            var A = 0,
              w = c.suspendedLanes,
              U = c.pingedLanes,
              q = c.warmLanes;
            c = c.finishedLanes !== 0;
            var lt = y & 134217727;
            return (
              lt !== 0
                ? ((y = lt & ~w),
                  y !== 0
                    ? (A = D(y))
                    : ((U &= lt),
                      U !== 0
                        ? (A = D(U))
                        : c || ((q = lt & ~q), q !== 0 && (A = D(q)))))
                : ((lt = y & ~w),
                  lt !== 0
                    ? (A = D(lt))
                    : U !== 0
                    ? (A = D(U))
                    : c || ((q = y & ~q), q !== 0 && (A = D(q)))),
              A === 0
                ? 0
                : f !== 0 &&
                  f !== A &&
                  (f & w) === 0 &&
                  ((w = A & -A),
                  (q = f & -f),
                  w >= q || (w === 32 && (q & 4194176) !== 0))
                ? f
                : A
            );
          }
          function P(c, f) {
            return (
              (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & f) === 0
            );
          }
          function V(c, f) {
            switch (c) {
              case 1:
              case 2:
              case 4:
              case 8:
                return f + 250;
              case 16:
              case 32:
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return f + 5e3;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return -1;
              case 67108864:
              case 134217728:
              case 268435456:
              case 536870912:
              case 1073741824:
                return -1;
              default:
                return -1;
            }
          }
          function F() {
            var c = vr;
            return (vr <<= 1), (vr & 4194176) === 0 && (vr = 128), c;
          }
          function N() {
            var c = Sl;
            return (Sl <<= 1), (Sl & 62914560) === 0 && (Sl = 4194304), c;
          }
          function L(c) {
            for (var f = [], y = 0; 31 > y; y++) f.push(c);
            return f;
          }
          function Y(c, f) {
            (c.pendingLanes |= f),
              f !== 268435456 &&
                ((c.suspendedLanes = 0),
                (c.pingedLanes = 0),
                (c.warmLanes = 0));
          }
          function ct(c, f, y, A, w, U) {
            var q = c.pendingLanes;
            (c.pendingLanes = y),
              (c.suspendedLanes = 0),
              (c.pingedLanes = 0),
              (c.warmLanes = 0),
              (c.expiredLanes &= y),
              (c.entangledLanes &= y),
              (c.errorRecoveryDisabledLanes &= y),
              (c.shellSuspendCounter = 0);
            var lt = c.entanglements,
              St = c.expirationTimes,
              Xt = c.hiddenUpdates;
            for (y = q & ~y; 0 < y; ) {
              var he = 31 - Na(y),
                Me = 1 << he;
              (lt[he] = 0), (St[he] = -1);
              var Te = Xt[he];
              if (Te !== null)
                for (Xt[he] = null, he = 0; he < Te.length; he++) {
                  var un = Te[he];
                  un !== null && (un.lane &= -536870913);
                }
              y &= ~Me;
            }
            A !== 0 && nt(c, A, 0),
              U !== 0 &&
                w === 0 &&
                c.tag !== 0 &&
                (c.suspendedLanes |= U & ~(q & ~f));
          }
          function nt(c, f, y) {
            (c.pendingLanes |= f), (c.suspendedLanes &= ~f);
            var A = 31 - Na(f);
            (c.entangledLanes |= f),
              (c.entanglements[A] =
                c.entanglements[A] | 1073741824 | (y & 4194218));
          }
          function dt(c, f) {
            var y = (c.entangledLanes |= f);
            for (c = c.entanglements; y; ) {
              var A = 31 - Na(y),
                w = 1 << A;
              (w & f) | (c[A] & f) && (c[A] |= f), (y &= ~w);
            }
          }
          function pt(c) {
            return (
              (c &= -c),
              2 < c ? (8 < c ? ((c & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
            );
          }
          function j(c) {
            if (Ja && typeof Ja.onCommitFiberRoot == "function")
              try {
                Ja.onCommitFiberRoot(
                  Oi,
                  c,
                  void 0,
                  (c.current.flags & 128) === 128
                );
              } catch {}
          }
          function Q(c) {
            if (
              (typeof sv == "function" && ta(c),
              Ja && typeof Ja.setStrictMode == "function")
            )
              try {
                Ja.setStrictMode(Oi, c);
              } catch {}
          }
          function et(c, f) {
            return (
              (c === f && (c !== 0 || 1 / c === 1 / f)) || (c !== c && f !== f)
            );
          }
          function xt(c, f) {
            if (typeof c == "object" && c !== null) {
              var y = lm.get(c);
              return y !== void 0
                ? y
                : ((f = { value: c, source: f, stack: m(f) }), lm.set(c, f), f);
            }
            return { value: c, source: f, stack: m(f) };
          }
          function X(c, f) {
            (Ml[El++] = Uc), (Ml[El++] = Tl), (Tl = c), (Uc = f);
          }
          function ft(c, f, y) {
            (ls[cs++] = Qs), (ls[cs++] = $s), (ls[cs++] = Wo), (Wo = c);
            var A = Qs;
            c = $s;
            var w = 32 - Na(A) - 1;
            (A &= ~(1 << w)), (y += 1);
            var U = 32 - Na(f) + w;
            if (30 < U) {
              var q = w - (w % 5);
              (U = (A & ((1 << q) - 1)).toString(32)),
                (A >>= q),
                (w -= q),
                (Qs = (1 << (32 - Na(f) + w)) | (y << w) | A),
                ($s = U + c);
            } else (Qs = (1 << U) | (y << w) | A), ($s = c);
          }
          function At(c) {
            c.return !== null && (X(c, 1), ft(c, 1, 0));
          }
          function Rt(c) {
            for (; c === Tl; )
              (Tl = Ml[--El]),
                (Ml[El] = null),
                (Uc = Ml[--El]),
                (Ml[El] = null);
            for (; c === Wo; )
              (Wo = ls[--cs]),
                (ls[cs] = null),
                ($s = ls[--cs]),
                (ls[cs] = null),
                (Qs = ls[--cs]),
                (ls[cs] = null);
          }
          function ht(c, f) {
            R(yr, f), R(Oc, c), R(ji, null), (c = _g(f)), S(ji), R(ji, c);
          }
          function It() {
            S(ji), S(Oc), S(yr);
          }
          function Pt(c) {
            c.memoizedState !== null && R(wl, c);
            var f = ji.current,
              y = wc(f, c.type);
            f !== y && (R(Oc, c), R(ji, y));
          }
          function re(c) {
            Oc.current === c && (S(ji), S(Oc)),
              wl.current === c &&
                (S(wl),
                Ua ? (Js._currentValue = Go) : (Js._currentValue2 = Go));
          }
          function ie(c) {
            var f = Error(a(418, ""));
            throw (Ue(xt(f, c)), of);
          }
          function Fe(c, f) {
            if (!fa) throw Error(a(175));
            Xg(c.stateNode, c.type, c.memoizedProps, f, c) || ie(c);
          }
          function Ae(c) {
            for (ha = c.return; ha; )
              switch (ha.tag) {
                case 3:
                case 27:
                  ea = !0;
                  return;
                case 5:
                case 13:
                  ea = !1;
                  return;
                default:
                  ha = ha.return;
              }
          }
          function De(c) {
            if (!fa || c !== ha) return !1;
            if (!On) return Ae(c), (On = !0), !1;
            var f = !1;
            if (
              (ti
                ? c.tag !== 3 &&
                  c.tag !== 27 &&
                  (c.tag !== 5 ||
                    (Gh(c.type) && !hn(c.type, c.memoizedProps))) &&
                  (f = !0)
                : c.tag !== 3 &&
                  (c.tag !== 5 ||
                    (Gh(c.type) && !hn(c.type, c.memoizedProps))) &&
                  (f = !0),
              f && da && ie(c),
              Ae(c),
              c.tag === 13)
            ) {
              if (!fa) throw Error(a(316));
              if (
                ((c = c.memoizedState),
                (c = c !== null ? c.dehydrated : null),
                !c)
              )
                throw Error(a(317));
              da = Yg(c);
            } else da = ha ? am(c.stateNode) : null;
            return !0;
          }
          function je() {
            fa && ((da = ha = null), (On = !1));
          }
          function Ue(c) {
            Os === null ? (Os = [c]) : Os.push(c);
          }
          function J() {
            for (var c = Cl, f = (tr = Cl = 0); f < c; ) {
              var y = Ns[f];
              Ns[f++] = null;
              var A = Ns[f];
              Ns[f++] = null;
              var w = Ns[f];
              Ns[f++] = null;
              var U = Ns[f];
              if (((Ns[f++] = null), A !== null && w !== null)) {
                var q = A.pending;
                q === null ? (w.next = w) : ((w.next = q.next), (q.next = w)),
                  (A.pending = w);
              }
              U !== 0 && kt(y, w, U);
            }
          }
          function le(c, f, y, A) {
            (Ns[Cl++] = c),
              (Ns[Cl++] = f),
              (Ns[Cl++] = y),
              (Ns[Cl++] = A),
              (tr |= A),
              (c.lanes |= A),
              (c = c.alternate),
              c !== null && (c.lanes |= A);
          }
          function se(c, f, y, A) {
            return le(c, f, y, A), ye(c);
          }
          function $t(c, f) {
            return le(c, null, null, f), ye(c);
          }
          function kt(c, f, y) {
            c.lanes |= y;
            var A = c.alternate;
            A !== null && (A.lanes |= y);
            for (var w = !1, U = c.return; U !== null; )
              (U.childLanes |= y),
                (A = U.alternate),
                A !== null && (A.childLanes |= y),
                U.tag === 22 &&
                  ((c = U.stateNode),
                  c === null || c._visibility & 1 || (w = !0)),
                (c = U),
                (U = U.return);
            w &&
              f !== null &&
              c.tag === 3 &&
              ((U = c.stateNode),
              (w = 31 - Na(y)),
              (U = U.hiddenUpdates),
              (c = U[w]),
              c === null ? (U[w] = [f]) : c.push(f),
              (f.lane = y | 536870912));
          }
          function ye(c) {
            if (50 < Vc) throw ((Vc = 0), (nd = null), Error(a(185)));
            for (var f = c.return; f !== null; ) (c = f), (f = c.return);
            return c.tag === 3 ? c.stateNode : null;
          }
          function te(c) {
            c !== so &&
              c.next === null &&
              (so === null ? (lf = so = c) : (so = so.next = c)),
              (ri = !0),
              Rl || ((Rl = !0), Ft(Ye));
          }
          function pe(c, f) {
            if (!cm && ri) {
              cm = !0;
              do
                for (var y = !1, A = lf; A !== null; ) {
                  if (c !== 0) {
                    var w = A.pendingLanes;
                    if (w === 0) var U = 0;
                    else {
                      var q = A.suspendedLanes,
                        lt = A.pingedLanes;
                      (U = (1 << (31 - Na(42 | c) + 1)) - 1),
                        (U &= w & ~(q & ~lt)),
                        (U =
                          U & 201326677 ? (U & 201326677) | 1 : U ? U | 2 : 0);
                    }
                    U !== 0 && ((y = !0), Mt(A, U));
                  } else
                    (U = wn),
                      (U = I(A, A === Xn ? U : 0)),
                      (U & 3) === 0 || P(A, U) || ((y = !0), Mt(A, U));
                  A = A.next;
                }
              while (y);
              cm = !1;
            }
          }
          function Ye() {
            ri = Rl = !1;
            var c = 0;
            Nc !== 0 && (Mg() && (c = Nc), (Nc = 0));
            for (var f = Us(), y = null, A = lf; A !== null; ) {
              var w = A.next,
                U = $(A, f);
              U === 0
                ? ((A.next = null),
                  y === null ? (lf = w) : (y.next = w),
                  w === null && (so = y))
                : ((y = A), (c !== 0 || (U & 3) !== 0) && (ri = !0)),
                (A = w);
            }
            pe(c);
          }
          function $(c, f) {
            for (
              var y = c.suspendedLanes,
                A = c.pingedLanes,
                w = c.expirationTimes,
                U = c.pendingLanes & -62914561;
              0 < U;

            ) {
              var q = 31 - Na(U),
                lt = 1 << q,
                St = w[q];
              St === -1
                ? ((lt & y) === 0 || (lt & A) !== 0) && (w[q] = V(lt, f))
                : St <= f && (c.expiredLanes |= lt),
                (U &= ~lt);
            }
            if (
              ((f = Xn),
              (y = wn),
              (y = I(c, c === f ? y : 0)),
              (A = c.callbackNode),
              y === 0 ||
                (c === f && Jn === 2) ||
                c.cancelPendingCommit !== null)
            )
              return (
                A !== null && A !== null && Xh(A),
                (c.callbackNode = null),
                (c.callbackPriority = 0)
              );
            if ((y & 3) === 0 || P(c, y)) {
              if (((f = y & -y), f === c.callbackPriority)) return f;
              switch ((A !== null && Xh(A), pt(y))) {
                case 2:
                case 8:
                  y = av;
                  break;
                case 32:
                  y = qh;
                  break;
                case 268435456:
                  y = C1;
                  break;
                default:
                  y = qh;
              }
              return (
                (A = k.bind(null, c)),
                (y = rf(y, A)),
                (c.callbackPriority = f),
                (c.callbackNode = y),
                f
              );
            }
            return (
              A !== null && A !== null && Xh(A),
              (c.callbackPriority = 2),
              (c.callbackNode = null),
              2
            );
          }
          function k(c, f) {
            var y = c.callbackNode;
            if (qs() && c.callbackNode !== y) return null;
            var A = wn;
            return (
              (A = I(c, c === Xn ? A : 0)),
              A === 0
                ? null
                : (No(c, A, f),
                  $(c, Us()),
                  c.callbackNode != null && c.callbackNode === y
                    ? k.bind(null, c)
                    : null)
            );
          }
          function Mt(c, f) {
            if (qs()) return null;
            No(c, f, !0);
          }
          function Ft(c) {
            qp
              ? io(function () {
                  (Ln & 6) !== 0 ? rf(Yh, c) : c();
                })
              : rf(Yh, c);
          }
          function Gt() {
            return Nc === 0 && (Nc = F()), Nc;
          }
          function zt(c, f) {
            if (Lc === null) {
              var y = (Lc = []);
              (Bl = 0),
                (us = Gt()),
                (Dl = {
                  status: "pending",
                  value: void 0,
                  then: function (A) {
                    y.push(A);
                  },
                });
            }
            return Bl++, f.then(me, me), f;
          }
          function me() {
            if (--Bl === 0 && Lc !== null) {
              Dl !== null && (Dl.status = "fulfilled");
              var c = Lc;
              (Lc = null), (us = 0), (Dl = null);
              for (var f = 0; f < c.length; f++) (0, c[f])();
            }
          }
          function de(c, f) {
            var y = [],
              A = {
                status: "pending",
                value: null,
                reason: null,
                then: function (w) {
                  y.push(w);
                },
              };
            return (
              c.then(
                function () {
                  (A.status = "fulfilled"), (A.value = f);
                  for (var w = 0; w < y.length; w++) (0, y[w])(f);
                },
                function (w) {
                  for (
                    A.status = "rejected", A.reason = w, w = 0;
                    w < y.length;
                    w++
                  )
                    (0, y[w])(void 0);
                }
              ),
              A
            );
          }
          function we(c) {
            c.updateQueue = {
              baseState: c.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: { pending: null, lanes: 0, hiddenCallbacks: null },
              callbacks: null,
            };
          }
          function Ce(c, f) {
            (c = c.updateQueue),
              f.updateQueue === c &&
                (f.updateQueue = {
                  baseState: c.baseState,
                  firstBaseUpdate: c.firstBaseUpdate,
                  lastBaseUpdate: c.lastBaseUpdate,
                  shared: c.shared,
                  callbacks: null,
                });
          }
          function jt(c) {
            return {
              lane: c,
              tag: 0,
              payload: null,
              callback: null,
              next: null,
            };
          }
          function ce(c, f, y) {
            var A = c.updateQueue;
            if (A === null) return null;
            if (((A = A.shared), (Ln & 2) !== 0)) {
              var w = A.pending;
              return (
                w === null ? (f.next = f) : ((f.next = w.next), (w.next = f)),
                (A.pending = f),
                (f = ye(c)),
                kt(c, null, y),
                f
              );
            }
            return le(c, A, f, y), ye(c);
          }
          function Re(c, f, y) {
            if (
              ((f = f.updateQueue),
              f !== null && ((f = f.shared), (y & 4194176) !== 0))
            ) {
              var A = f.lanes;
              (A &= c.pendingLanes), (y |= A), (f.lanes = y), dt(c, y);
            }
          }
          function it(c, f) {
            var y = c.updateQueue,
              A = c.alternate;
            if (A !== null && ((A = A.updateQueue), y === A)) {
              var w = null,
                U = null;
              if (((y = y.firstBaseUpdate), y !== null)) {
                do {
                  var q = {
                    lane: y.lane,
                    tag: y.tag,
                    payload: y.payload,
                    callback: null,
                    next: null,
                  };
                  U === null ? (w = U = q) : (U = U.next = q), (y = y.next);
                } while (y !== null);
                U === null ? (w = U = f) : (U = U.next = f);
              } else w = U = f;
              (y = {
                baseState: A.baseState,
                firstBaseUpdate: w,
                lastBaseUpdate: U,
                shared: A.shared,
                callbacks: A.callbacks,
              }),
                (c.updateQueue = y);
              return;
            }
            (c = y.lastBaseUpdate),
              c === null ? (y.firstBaseUpdate = f) : (c.next = f),
              (y.lastBaseUpdate = f);
          }
          function yt() {
            if (Ul) {
              var c = Dl;
              if (c !== null) throw c;
            }
          }
          function Qt(c, f, y, A) {
            Ul = !1;
            var w = c.updateQueue;
            ro = !1;
            var U = w.firstBaseUpdate,
              q = w.lastBaseUpdate,
              lt = w.shared.pending;
            if (lt !== null) {
              w.shared.pending = null;
              var St = lt,
                Xt = St.next;
              (St.next = null), q === null ? (U = Xt) : (q.next = Xt), (q = St);
              var he = c.alternate;
              he !== null &&
                ((he = he.updateQueue),
                (lt = he.lastBaseUpdate),
                lt !== q &&
                  (lt === null ? (he.firstBaseUpdate = Xt) : (lt.next = Xt),
                  (he.lastBaseUpdate = St)));
            }
            if (U !== null) {
              var Me = w.baseState;
              (q = 0), (he = Xt = St = null), (lt = U);
              do {
                var Te = lt.lane & -536870913,
                  un = Te !== lt.lane;
                if (un ? (wn & Te) === Te : (A & Te) === Te) {
                  Te !== 0 && Te === us && (Ul = !0),
                    he !== null &&
                      (he = he.next =
                        {
                          lane: 0,
                          tag: lt.tag,
                          payload: lt.payload,
                          callback: null,
                          next: null,
                        });
                  t: {
                    var ys = c,
                      el = lt;
                    Te = f;
                    var nl = y;
                    switch (el.tag) {
                      case 1:
                        if (((ys = el.payload), typeof ys == "function")) {
                          Me = ys.call(nl, Me, Te);
                          break t;
                        }
                        Me = ys;
                        break t;
                      case 3:
                        ys.flags = (ys.flags & -65537) | 128;
                      case 0:
                        if (
                          ((ys = el.payload),
                          (Te =
                            typeof ys == "function" ? ys.call(nl, Me, Te) : ys),
                          Te == null)
                        )
                          break t;
                        Me = Rh({}, Me, Te);
                        break t;
                      case 2:
                        ro = !0;
                    }
                  }
                  (Te = lt.callback),
                    Te !== null &&
                      ((c.flags |= 64),
                      un && (c.flags |= 8192),
                      (un = w.callbacks),
                      un === null ? (w.callbacks = [Te]) : un.push(Te));
                } else
                  (un = {
                    lane: Te,
                    tag: lt.tag,
                    payload: lt.payload,
                    callback: lt.callback,
                    next: null,
                  }),
                    he === null
                      ? ((Xt = he = un), (St = Me))
                      : (he = he.next = un),
                    (q |= Te);
                if (((lt = lt.next), lt === null)) {
                  if (((lt = w.shared.pending), lt === null)) break;
                  (un = lt),
                    (lt = un.next),
                    (un.next = null),
                    (w.lastBaseUpdate = un),
                    (w.shared.pending = null);
                }
              } while (!0);
              he === null && (St = Me),
                (w.baseState = St),
                (w.firstBaseUpdate = Xt),
                (w.lastBaseUpdate = he),
                U === null && (w.shared.lanes = 0),
                (gs |= q),
                (c.lanes = q),
                (c.memoizedState = Me);
            }
          }
          function st(c, f) {
            if (typeof c != "function") throw Error(a(191, c));
            c.call(f);
          }
          function Et(c, f) {
            var y = c.callbacks;
            if (y !== null)
              for (c.callbacks = null, c = 0; c < y.length; c++) st(y[c], f);
          }
          function qt(c, f) {
            if (Za(c, f)) return !0;
            if (
              typeof c != "object" ||
              c === null ||
              typeof f != "object" ||
              f === null
            )
              return !1;
            var y = Object.keys(c),
              A = Object.keys(f);
            if (y.length !== A.length) return !1;
            for (A = 0; A < y.length; A++) {
              var w = y[A];
              if (!xr.call(f, w) || !Za(c[w], f[w])) return !1;
            }
            return !0;
          }
          function ge(c) {
            return (c = c.status), c === "fulfilled" || c === "rejected";
          }
          function oe() {}
          function Kt(c, f, y) {
            switch (
              ((y = c[y]),
              y === void 0 ? c.push(f) : y !== f && (f.then(oe, oe), (f = y)),
              f.status)
            ) {
              case "fulfilled":
                return f.value;
              case "rejected":
                throw ((c = f.reason), c === Ic ? Error(a(483)) : c);
              default:
                if (typeof f.status == "string") f.then(oe, oe);
                else {
                  if (((c = Xn), c !== null && 100 < c.shellSuspendCounter))
                    throw Error(a(482));
                  (c = f),
                    (c.status = "pending"),
                    c.then(
                      function (A) {
                        if (f.status === "pending") {
                          var w = f;
                          (w.status = "fulfilled"), (w.value = A);
                        }
                      },
                      function (A) {
                        if (f.status === "pending") {
                          var w = f;
                          (w.status = "rejected"), (w.reason = A);
                        }
                      }
                    );
                }
                switch (f.status) {
                  case "fulfilled":
                    return f.value;
                  case "rejected":
                    throw ((c = f.reason), c === Ic ? Error(a(483)) : c);
                }
                throw ((Yo = f), Ic);
            }
          }
          function be() {
            if (Yo === null) throw Error(a(459));
            var c = Yo;
            return (Yo = null), c;
          }
          function Le(c) {
            var f = Ko;
            return (Ko += 1), qo === null && (qo = []), Kt(qo, c, f);
          }
          function mn(c, f) {
            (f = f.props.ref), (c.ref = f !== void 0 ? f : null);
          }
          function ln(c, f) {
            throw f.$$typeof === b1
              ? Error(a(525))
              : ((c = Object.prototype.toString.call(f)),
                Error(
                  a(
                    31,
                    c === "[object Object]"
                      ? "object with keys {" + Object.keys(f).join(", ") + "}"
                      : c
                  )
                ));
          }
          function yi(c) {
            var f = c._init;
            return f(c._payload);
          }
          function si(c) {
            function f(Dt, mt) {
              if (c) {
                var Lt = Dt.deletions;
                Lt === null
                  ? ((Dt.deletions = [mt]), (Dt.flags |= 16))
                  : Lt.push(mt);
              }
            }
            function y(Dt, mt) {
              if (!c) return null;
              for (; mt !== null; ) f(Dt, mt), (mt = mt.sibling);
              return null;
            }
            function A(Dt) {
              for (var mt = new Map(); Dt !== null; )
                Dt.key !== null ? mt.set(Dt.key, Dt) : mt.set(Dt.index, Dt),
                  (Dt = Dt.sibling);
              return mt;
            }
            function w(Dt, mt) {
              return (Dt = Cs(Dt, mt)), (Dt.index = 0), (Dt.sibling = null), Dt;
            }
            function U(Dt, mt, Lt) {
              return (
                (Dt.index = Lt),
                c
                  ? ((Lt = Dt.alternate),
                    Lt !== null
                      ? ((Lt = Lt.index),
                        Lt < mt ? ((Dt.flags |= 33554434), mt) : Lt)
                      : ((Dt.flags |= 33554434), mt))
                  : ((Dt.flags |= 1048576), mt)
              );
            }
            function q(Dt) {
              return c && Dt.alternate === null && (Dt.flags |= 33554434), Dt;
            }
            function lt(Dt, mt, Lt, fe) {
              return mt === null || mt.tag !== 6
                ? ((mt = wh(Lt, Dt.mode, fe)), (mt.return = Dt), mt)
                : ((mt = w(mt, Lt)), (mt.return = Dt), mt);
            }
            function St(Dt, mt, Lt, fe) {
              var Ge = Lt.type;
              return Ge === Fo
                ? he(Dt, mt, Lt.props.children, fe, Lt.key)
                : mt !== null &&
                  (mt.elementType === Ge ||
                    (typeof Ge == "object" &&
                      Ge !== null &&
                      Ge.$$typeof === Bs &&
                      yi(Ge) === mt.type))
                ? ((mt = w(mt, Lt.props)), mn(mt, Lt), (mt.return = Dt), mt)
                : ((mt = pr(Lt.type, Lt.key, Lt.props, null, Dt.mode, fe)),
                  mn(mt, Lt),
                  (mt.return = Dt),
                  mt);
            }
            function Xt(Dt, mt, Lt, fe) {
              return mt === null ||
                mt.tag !== 4 ||
                mt.stateNode.containerInfo !== Lt.containerInfo ||
                mt.stateNode.implementation !== Lt.implementation
                ? ((mt = Hp(Lt, Dt.mode, fe)), (mt.return = Dt), mt)
                : ((mt = w(mt, Lt.children || [])), (mt.return = Dt), mt);
            }
            function he(Dt, mt, Lt, fe, Ge) {
              return mt === null || mt.tag !== 7
                ? ((mt = _i(Lt, Dt.mode, fe, Ge)), (mt.return = Dt), mt)
                : ((mt = w(mt, Lt)), (mt.return = Dt), mt);
            }
            function Me(Dt, mt, Lt) {
              if (
                (typeof mt == "string" && mt !== "") ||
                typeof mt == "number" ||
                typeof mt == "bigint"
              )
                return (mt = wh("" + mt, Dt.mode, Lt)), (mt.return = Dt), mt;
              if (typeof mt == "object" && mt !== null) {
                switch (mt.$$typeof) {
                  case qu:
                    return (
                      (Lt = pr(mt.type, mt.key, mt.props, null, Dt.mode, Lt)),
                      mn(Lt, mt),
                      (Lt.return = Dt),
                      Lt
                    );
                  case Rs:
                    return (mt = Hp(mt, Dt.mode, Lt)), (mt.return = Dt), mt;
                  case Bs:
                    var fe = mt._init;
                    return (mt = fe(mt._payload)), Me(Dt, mt, Lt);
                }
                if (Mc(mt) || r(mt))
                  return (mt = _i(mt, Dt.mode, Lt, null)), (mt.return = Dt), mt;
                if (typeof mt.then == "function") return Me(Dt, Le(mt), Lt);
                if (mt.$$typeof === Ks) return Me(Dt, Ou(Dt, mt), Lt);
                ln(Dt, mt);
              }
              return null;
            }
            function Te(Dt, mt, Lt, fe) {
              var Ge = mt !== null ? mt.key : null;
              if (
                (typeof Lt == "string" && Lt !== "") ||
                typeof Lt == "number" ||
                typeof Lt == "bigint"
              )
                return Ge !== null ? null : lt(Dt, mt, "" + Lt, fe);
              if (typeof Lt == "object" && Lt !== null) {
                switch (Lt.$$typeof) {
                  case qu:
                    return Lt.key === Ge ? St(Dt, mt, Lt, fe) : null;
                  case Rs:
                    return Lt.key === Ge ? Xt(Dt, mt, Lt, fe) : null;
                  case Bs:
                    return (
                      (Ge = Lt._init),
                      (Lt = Ge(Lt._payload)),
                      Te(Dt, mt, Lt, fe)
                    );
                }
                if (Mc(Lt) || r(Lt))
                  return Ge !== null ? null : he(Dt, mt, Lt, fe, null);
                if (typeof Lt.then == "function") return Te(Dt, mt, Le(Lt), fe);
                if (Lt.$$typeof === Ks) return Te(Dt, mt, Ou(Dt, Lt), fe);
                ln(Dt, Lt);
              }
              return null;
            }
            function un(Dt, mt, Lt, fe, Ge) {
              if (
                (typeof fe == "string" && fe !== "") ||
                typeof fe == "number" ||
                typeof fe == "bigint"
              )
                return (Dt = Dt.get(Lt) || null), lt(mt, Dt, "" + fe, Ge);
              if (typeof fe == "object" && fe !== null) {
                switch (fe.$$typeof) {
                  case qu:
                    return (
                      (Dt = Dt.get(fe.key === null ? Lt : fe.key) || null),
                      St(mt, Dt, fe, Ge)
                    );
                  case Rs:
                    return (
                      (Dt = Dt.get(fe.key === null ? Lt : fe.key) || null),
                      Xt(mt, Dt, fe, Ge)
                    );
                  case Bs:
                    var di = fe._init;
                    return (fe = di(fe._payload)), un(Dt, mt, Lt, fe, Ge);
                }
                if (Mc(fe) || r(fe))
                  return (Dt = Dt.get(Lt) || null), he(mt, Dt, fe, Ge, null);
                if (typeof fe.then == "function")
                  return un(Dt, mt, Lt, Le(fe), Ge);
                if (fe.$$typeof === Ks) return un(Dt, mt, Lt, Ou(mt, fe), Ge);
                ln(mt, fe);
              }
              return null;
            }
            function ys(Dt, mt, Lt, fe) {
              for (
                var Ge = null, di = null, an = mt, zn = (mt = 0), Ni = null;
                an !== null && zn < Lt.length;
                zn++
              ) {
                an.index > zn ? ((Ni = an), (an = null)) : (Ni = an.sibling);
                var Tn = Te(Dt, an, Lt[zn], fe);
                if (Tn === null) {
                  an === null && (an = Ni);
                  break;
                }
                c && an && Tn.alternate === null && f(Dt, an),
                  (mt = U(Tn, mt, zn)),
                  di === null ? (Ge = Tn) : (di.sibling = Tn),
                  (di = Tn),
                  (an = Ni);
              }
              if (zn === Lt.length) return y(Dt, an), On && X(Dt, zn), Ge;
              if (an === null) {
                for (; zn < Lt.length; zn++)
                  (an = Me(Dt, Lt[zn], fe)),
                    an !== null &&
                      ((mt = U(an, mt, zn)),
                      di === null ? (Ge = an) : (di.sibling = an),
                      (di = an));
                return On && X(Dt, zn), Ge;
              }
              for (an = A(an); zn < Lt.length; zn++)
                (Ni = un(an, Dt, zn, Lt[zn], fe)),
                  Ni !== null &&
                    (c &&
                      Ni.alternate !== null &&
                      an.delete(Ni.key === null ? zn : Ni.key),
                    (mt = U(Ni, mt, zn)),
                    di === null ? (Ge = Ni) : (di.sibling = Ni),
                    (di = Ni));
              return (
                c &&
                  an.forEach(function (wr) {
                    return f(Dt, wr);
                  }),
                On && X(Dt, zn),
                Ge
              );
            }
            function el(Dt, mt, Lt, fe) {
              if (Lt == null) throw Error(a(151));
              for (
                var Ge = null,
                  di = null,
                  an = mt,
                  zn = (mt = 0),
                  Ni = null,
                  Tn = Lt.next();
                an !== null && !Tn.done;
                zn++, Tn = Lt.next()
              ) {
                an.index > zn ? ((Ni = an), (an = null)) : (Ni = an.sibling);
                var wr = Te(Dt, an, Tn.value, fe);
                if (wr === null) {
                  an === null && (an = Ni);
                  break;
                }
                c && an && wr.alternate === null && f(Dt, an),
                  (mt = U(wr, mt, zn)),
                  di === null ? (Ge = wr) : (di.sibling = wr),
                  (di = wr),
                  (an = Ni);
              }
              if (Tn.done) return y(Dt, an), On && X(Dt, zn), Ge;
              if (an === null) {
                for (; !Tn.done; zn++, Tn = Lt.next())
                  (Tn = Me(Dt, Tn.value, fe)),
                    Tn !== null &&
                      ((mt = U(Tn, mt, zn)),
                      di === null ? (Ge = Tn) : (di.sibling = Tn),
                      (di = Tn));
                return On && X(Dt, zn), Ge;
              }
              for (an = A(an); !Tn.done; zn++, Tn = Lt.next())
                (Tn = un(an, Dt, zn, Tn.value, fe)),
                  Tn !== null &&
                    (c &&
                      Tn.alternate !== null &&
                      an.delete(Tn.key === null ? zn : Tn.key),
                    (mt = U(Tn, mt, zn)),
                    di === null ? (Ge = Tn) : (di.sibling = Tn),
                    (di = Tn));
              return (
                c &&
                  an.forEach(function (id) {
                    return f(Dt, id);
                  }),
                On && X(Dt, zn),
                Ge
              );
            }
            function nl(Dt, mt, Lt, fe) {
              if (
                (typeof Lt == "object" &&
                  Lt !== null &&
                  Lt.type === Fo &&
                  Lt.key === null &&
                  (Lt = Lt.props.children),
                typeof Lt == "object" && Lt !== null)
              ) {
                switch (Lt.$$typeof) {
                  case qu:
                    t: {
                      for (var Ge = Lt.key; mt !== null; ) {
                        if (mt.key === Ge) {
                          if (((Ge = Lt.type), Ge === Fo)) {
                            if (mt.tag === 7) {
                              y(Dt, mt.sibling),
                                (fe = w(mt, Lt.props.children)),
                                (fe.return = Dt),
                                (Dt = fe);
                              break t;
                            }
                          } else if (
                            mt.elementType === Ge ||
                            (typeof Ge == "object" &&
                              Ge !== null &&
                              Ge.$$typeof === Bs &&
                              yi(Ge) === mt.type)
                          ) {
                            y(Dt, mt.sibling),
                              (fe = w(mt, Lt.props)),
                              mn(fe, Lt),
                              (fe.return = Dt),
                              (Dt = fe);
                            break t;
                          }
                          y(Dt, mt);
                          break;
                        } else f(Dt, mt);
                        mt = mt.sibling;
                      }
                      Lt.type === Fo
                        ? ((fe = _i(Lt.props.children, Dt.mode, fe, Lt.key)),
                          (fe.return = Dt),
                          (Dt = fe))
                        : ((fe = pr(
                            Lt.type,
                            Lt.key,
                            Lt.props,
                            null,
                            Dt.mode,
                            fe
                          )),
                          mn(fe, Lt),
                          (fe.return = Dt),
                          (Dt = fe));
                    }
                    return q(Dt);
                  case Rs:
                    t: {
                      for (Ge = Lt.key; mt !== null; ) {
                        if (mt.key === Ge)
                          if (
                            mt.tag === 4 &&
                            mt.stateNode.containerInfo === Lt.containerInfo &&
                            mt.stateNode.implementation === Lt.implementation
                          ) {
                            y(Dt, mt.sibling),
                              (fe = w(mt, Lt.children || [])),
                              (fe.return = Dt),
                              (Dt = fe);
                            break t;
                          } else {
                            y(Dt, mt);
                            break;
                          }
                        else f(Dt, mt);
                        mt = mt.sibling;
                      }
                      (fe = Hp(Lt, Dt.mode, fe)), (fe.return = Dt), (Dt = fe);
                    }
                    return q(Dt);
                  case Bs:
                    return (
                      (Ge = Lt._init),
                      (Lt = Ge(Lt._payload)),
                      nl(Dt, mt, Lt, fe)
                    );
                }
                if (Mc(Lt)) return ys(Dt, mt, Lt, fe);
                if (r(Lt)) {
                  if (((Ge = r(Lt)), typeof Ge != "function"))
                    throw Error(a(150));
                  return (Lt = Ge.call(Lt)), el(Dt, mt, Lt, fe);
                }
                if (typeof Lt.then == "function") return nl(Dt, mt, Le(Lt), fe);
                if (Lt.$$typeof === Ks) return nl(Dt, mt, Ou(Dt, Lt), fe);
                ln(Dt, Lt);
              }
              return (typeof Lt == "string" && Lt !== "") ||
                typeof Lt == "number" ||
                typeof Lt == "bigint"
                ? ((Lt = "" + Lt),
                  mt !== null && mt.tag === 6
                    ? (y(Dt, mt.sibling),
                      (fe = w(mt, Lt)),
                      (fe.return = Dt),
                      (Dt = fe))
                    : (y(Dt, mt),
                      (fe = wh(Lt, Dt.mode, fe)),
                      (fe.return = Dt),
                      (Dt = fe)),
                  q(Dt))
                : y(Dt, mt);
            }
            return function (Dt, mt, Lt, fe) {
              try {
                Ko = 0;
                var Ge = nl(Dt, mt, Lt, fe);
                return (qo = null), Ge;
              } catch (an) {
                if (an === Ic) throw an;
                var di = e(29, an, null, Dt.mode);
                return (di.lanes = fe), (di.return = Dt), di;
              } finally {
              }
            };
          }
          function xi(c, f) {
            (c = Aa), R(Pc, c), R(oi, f), (Aa = c | f.baseLanes);
          }
          function Ci() {
            R(Pc, Aa), R(oi, oi.current);
          }
          function Ri() {
            (Aa = Pc.current), S(oi), S(Pc);
          }
          function ya(c) {
            var f = c.alternate;
            R(Xi, Xi.current & 1),
              R(fs, c),
              ei === null &&
                (f === null ||
                  oi.current !== null ||
                  f.memoizedState !== null) &&
                (ei = c);
          }
          function Ws(c) {
            if (c.tag === 22) {
              if ((R(Xi, Xi.current), R(fs, c), ei === null)) {
                var f = c.alternate;
                f !== null && f.memoizedState !== null && (ei = c);
              }
            } else sa();
          }
          function sa() {
            R(Xi, Xi.current), R(fs, fs.current);
          }
          function Ke(c) {
            S(fs), ei === c && (ei = null), S(Xi);
          }
          function ka(c) {
            for (var f = c; f !== null; ) {
              if (f.tag === 13) {
                var y = f.memoizedState;
                if (
                  y !== null &&
                  ((y = y.dehydrated), y === null || zh(y) || Fh(y))
                )
                  return f;
              } else if (
                f.tag === 19 &&
                f.memoizedProps.revealOrder !== void 0
              ) {
                if ((f.flags & 128) !== 0) return f;
              } else if (f.child !== null) {
                (f.child.return = f), (f = f.child);
                continue;
              }
              if (f === c) break;
              for (; f.sibling === null; ) {
                if (f.return === null || f.return === c) return null;
                f = f.return;
              }
              (f.sibling.return = f.return), (f = f.sibling);
            }
            return null;
          }
          function Vn() {
            throw Error(a(321));
          }
          function G(c, f) {
            if (f === null) return !1;
            for (var y = 0; y < f.length && y < c.length; y++)
              if (!Za(c[y], f[y])) return !1;
            return !0;
          }
          function K(c, f, y, A, w, U) {
            return (
              (oo = U),
              (_n = f),
              (f.memoizedState = null),
              (f.updateQueue = null),
              (f.lanes = 0),
              (nn.H = c === null || c.memoizedState === null ? Qo : La),
              (Zo = !1),
              (U = y(A, w)),
              (Zo = !1),
              Ol && (U = Bt(f, y, A, w)),
              ut(c),
              U
            );
          }
          function ut(c) {
            nn.H = bi;
            var f = Je !== null && Je.next !== null;
            if (
              ((oo = 0),
              (Nn = Je = _n = null),
              (Ls = !1),
              (Nl = 0),
              (na = null),
              f)
            )
              throw Error(a(300));
            c === null ||
              ni ||
              ((c = c.dependencies), c !== null && Uu(c) && (ni = !0));
          }
          function Bt(c, f, y, A) {
            _n = c;
            var w = 0;
            do {
              if ((Ol && (na = null), (Nl = 0), (Ol = !1), 25 <= w))
                throw Error(a(301));
              if (((w += 1), (Nn = Je = null), c.updateQueue != null)) {
                var U = c.updateQueue;
                (U.lastEffect = null),
                  (U.events = null),
                  (U.stores = null),
                  U.memoCache != null && (U.memoCache.index = 0);
              }
              (nn.H = hs), (U = f(y, A));
            } while (Ol);
            return U;
          }
          function Ut() {
            var c = nn.H,
              f = c.useState()[0];
            return (
              (f = typeof f.then == "function" ? rt(f) : f),
              (c = c.useState()[0]),
              (Je !== null ? Je.memoizedState : null) !== c &&
                (_n.flags |= 1024),
              f
            );
          }
          function Ht() {
            var c = Kh !== 0;
            return (Kh = 0), c;
          }
          function ue(c, f, y) {
            (f.updateQueue = c.updateQueue),
              (f.flags &= -2053),
              (c.lanes &= ~y);
          }
          function ae(c) {
            if (Ls) {
              for (c = c.memoizedState; c !== null; ) {
                var f = c.queue;
                f !== null && (f.pending = null), (c = c.next);
              }
              Ls = !1;
            }
            (oo = 0),
              (Nn = Je = _n = null),
              (Ol = !1),
              (Nl = Kh = 0),
              (na = null);
          }
          function H() {
            var c = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null,
            };
            return (
              Nn === null ? (_n.memoizedState = Nn = c) : (Nn = Nn.next = c), Nn
            );
          }
          function tt() {
            if (Je === null) {
              var c = _n.alternate;
              c = c !== null ? c.memoizedState : null;
            } else c = Je.next;
            var f = Nn === null ? _n.memoizedState : Nn.next;
            if (f !== null) (Nn = f), (Je = c);
            else {
              if (c === null)
                throw _n.alternate === null ? Error(a(467)) : Error(a(310));
              (Je = c),
                (c = {
                  memoizedState: Je.memoizedState,
                  baseState: Je.baseState,
                  baseQueue: Je.baseQueue,
                  queue: Je.queue,
                  next: null,
                }),
                Nn === null ? (_n.memoizedState = Nn = c) : (Nn = Nn.next = c);
            }
            return Nn;
          }
          function rt(c) {
            var f = Nl;
            return (
              (Nl += 1),
              na === null && (na = []),
              (c = Kt(na, c, f)),
              (f = _n),
              (Nn === null ? f.memoizedState : Nn.next) === null &&
                ((f = f.alternate),
                (nn.H = f === null || f.memoizedState === null ? Qo : La)),
              c
            );
          }
          function ot(c) {
            if (c !== null && typeof c == "object") {
              if (typeof c.then == "function") return rt(c);
              if (c.$$typeof === Ks) return oa(c);
            }
            throw Error(a(438, String(c)));
          }
          function gt(c) {
            var f = null,
              y = _n.updateQueue;
            if ((y !== null && (f = y.memoCache), f == null)) {
              var A = _n.alternate;
              A !== null &&
                ((A = A.updateQueue),
                A !== null &&
                  ((A = A.memoCache),
                  A != null &&
                    (f = {
                      data: A.data.map(function (w) {
                        return w.slice();
                      }),
                      index: 0,
                    })));
            }
            if (
              (f == null && (f = { data: [], index: 0 }),
              y === null && ((y = Jh()), (_n.updateQueue = y)),
              (y.memoCache = f),
              (y = f.data[f.index]),
              y === void 0)
            )
              for (y = f.data[f.index] = Array(c), A = 0; A < c; A++) y[A] = xg;
            return f.index++, y;
          }
          function wt(c, f) {
            return typeof f == "function" ? f(c) : f;
          }
          function Vt(c) {
            var f = tt();
            return Jt(f, Je, c);
          }
          function Jt(c, f, y) {
            var A = c.queue;
            if (A === null) throw Error(a(311));
            A.lastRenderedReducer = y;
            var w = c.baseQueue,
              U = A.pending;
            if (U !== null) {
              if (w !== null) {
                var q = w.next;
                (w.next = U.next), (U.next = q);
              }
              (f.baseQueue = w = U), (A.pending = null);
            }
            if (((U = c.baseState), w === null)) c.memoizedState = U;
            else {
              f = w.next;
              var lt = (q = null),
                St = null,
                Xt = f,
                he = !1;
              do {
                var Me = Xt.lane & -536870913;
                if (Me !== Xt.lane ? (wn & Me) === Me : (oo & Me) === Me) {
                  var Te = Xt.revertLane;
                  if (Te === 0)
                    St !== null &&
                      (St = St.next =
                        {
                          lane: 0,
                          revertLane: 0,
                          action: Xt.action,
                          hasEagerState: Xt.hasEagerState,
                          eagerState: Xt.eagerState,
                          next: null,
                        }),
                      Me === us && (he = !0);
                  else if ((oo & Te) === Te) {
                    (Xt = Xt.next), Te === us && (he = !0);
                    continue;
                  } else
                    (Me = {
                      lane: 0,
                      revertLane: Xt.revertLane,
                      action: Xt.action,
                      hasEagerState: Xt.hasEagerState,
                      eagerState: Xt.eagerState,
                      next: null,
                    }),
                      St === null
                        ? ((lt = St = Me), (q = U))
                        : (St = St.next = Me),
                      (_n.lanes |= Te),
                      (gs |= Te);
                  (Me = Xt.action),
                    Zo && y(U, Me),
                    (U = Xt.hasEagerState ? Xt.eagerState : y(U, Me));
                } else
                  (Te = {
                    lane: Me,
                    revertLane: Xt.revertLane,
                    action: Xt.action,
                    hasEagerState: Xt.hasEagerState,
                    eagerState: Xt.eagerState,
                    next: null,
                  }),
                    St === null
                      ? ((lt = St = Te), (q = U))
                      : (St = St.next = Te),
                    (_n.lanes |= Me),
                    (gs |= Me);
                Xt = Xt.next;
              } while (Xt !== null && Xt !== f);
              if (
                (St === null ? (q = U) : (St.next = lt),
                !Za(U, c.memoizedState) &&
                  ((ni = !0), he && ((y = Dl), y !== null)))
              )
                throw y;
              (c.memoizedState = U),
                (c.baseState = q),
                (c.baseQueue = St),
                (A.lastRenderedState = U);
            }
            return w === null && (A.lanes = 0), [c.memoizedState, A.dispatch];
          }
          function ee(c) {
            var f = tt(),
              y = f.queue;
            if (y === null) throw Error(a(311));
            y.lastRenderedReducer = c;
            var A = y.dispatch,
              w = y.pending,
              U = f.memoizedState;
            if (w !== null) {
              y.pending = null;
              var q = (w = w.next);
              do (U = c(U, q.action)), (q = q.next);
              while (q !== w);
              Za(U, f.memoizedState) || (ni = !0),
                (f.memoizedState = U),
                f.baseQueue === null && (f.baseState = U),
                (y.lastRenderedState = U);
            }
            return [U, A];
          }
          function xe(c, f, y) {
            var A = _n,
              w = tt(),
              U = On;
            if (U) {
              if (y === void 0) throw Error(a(407));
              y = y();
            } else y = f();
            var q = !Za((Je || w).memoizedState, y);
            if (
              (q && ((w.memoizedState = y), (ni = !0)),
              (w = w.queue),
              fp(He.bind(null, A, w, c), [c]),
              w.getSnapshot !== f ||
                q ||
                (Nn !== null && Nn.memoizedState.tag & 1))
            ) {
              if (
                ((A.flags |= 2048),
                Ca(9, _e.bind(null, A, w, y, f), { destroy: void 0 }, null),
                Xn === null)
              )
                throw Error(a(349));
              U || (oo & 60) !== 0 || ve(A, f, y);
            }
            return y;
          }
          function ve(c, f, y) {
            (c.flags |= 16384),
              (c = { getSnapshot: f, value: y }),
              (f = _n.updateQueue),
              f === null
                ? ((f = Jh()), (_n.updateQueue = f), (f.stores = [c]))
                : ((y = f.stores), y === null ? (f.stores = [c]) : y.push(c));
          }
          function _e(c, f, y, A) {
            (f.value = y), (f.getSnapshot = A), ze(f) && Mn(c);
          }
          function He(c, f, y) {
            return y(function () {
              ze(f) && Mn(c);
            });
          }
          function ze(c) {
            var f = c.getSnapshot;
            c = c.value;
            try {
              var y = f();
              return !Za(c, y);
            } catch {
              return !0;
            }
          }
          function Mn(c) {
            var f = $t(c, 2);
            f !== null && $i(f, c, 2);
          }
          function Oe(c) {
            var f = H();
            if (typeof c == "function") {
              var y = c;
              if (((c = y()), Zo)) {
                Q(!0);
                try {
                  y();
                } finally {
                  Q(!1);
                }
              }
            }
            return (
              (f.memoizedState = f.baseState = c),
              (f.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: wt,
                lastRenderedState: c,
              }),
              f
            );
          }
          function Ve(c, f, y, A) {
            return (
              (c.baseState = y), Jt(c, Je, typeof A == "function" ? A : wt)
            );
          }
          function Ne(c, f, y, A, w) {
            if (wu(c)) throw Error(a(485));
            if (((c = f.action), c !== null)) {
              var U = {
                payload: w,
                action: c,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function (q) {
                  U.listeners.push(q);
                },
              };
              nn.T !== null ? y(!0) : (U.isTransition = !1),
                A(U),
                (y = f.pending),
                y === null
                  ? ((U.next = f.pending = U), Yn(f, U))
                  : ((U.next = y.next), (f.pending = y.next = U));
            }
          }
          function Yn(c, f) {
            var y = f.action,
              A = f.payload,
              w = c.state;
            if (f.isTransition) {
              var U = nn.T,
                q = {};
              nn.T = q;
              try {
                var lt = y(w, A),
                  St = nn.S;
                St !== null && St(q, lt), en(c, f, lt);
              } catch (Xt) {
                Qn(c, f, Xt);
              } finally {
                nn.T = U;
              }
            } else
              try {
                (U = y(w, A)), en(c, f, U);
              } catch (Xt) {
                Qn(c, f, Xt);
              }
          }
          function en(c, f, y) {
            y !== null && typeof y == "object" && typeof y.then == "function"
              ? y.then(
                  function (A) {
                    on(c, f, A);
                  },
                  function (A) {
                    return Qn(c, f, A);
                  }
                )
              : on(c, f, y);
          }
          function on(c, f, y) {
            (f.status = "fulfilled"),
              (f.value = y),
              qe(f),
              (c.state = y),
              (f = c.pending),
              f !== null &&
                ((y = f.next),
                y === f
                  ? (c.pending = null)
                  : ((y = y.next), (f.next = y), Yn(c, y)));
          }
          function Qn(c, f, y) {
            var A = c.pending;
            if (((c.pending = null), A !== null)) {
              A = A.next;
              do (f.status = "rejected"), (f.reason = y), qe(f), (f = f.next);
              while (f !== A);
            }
            c.action = null;
          }
          function qe(c) {
            c = c.listeners;
            for (var f = 0; f < c.length; f++) (0, c[f])();
          }
          function xn(c, f) {
            return f;
          }
          function gn(c, f) {
            if (On) {
              var y = Xn.formState;
              if (y !== null) {
                t: {
                  var A = _n;
                  if (On) {
                    if (da) {
                      var w = im(da, ea);
                      if (w) {
                        (da = am(w)), (A = Gg(w));
                        break t;
                      }
                    }
                    ie(A);
                  }
                  A = !1;
                }
                A && (f = y[0]);
              }
            }
            (y = H()),
              (y.memoizedState = y.baseState = f),
              (A = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: xn,
                lastRenderedState: f,
              }),
              (y.queue = A),
              (y = mp.bind(null, _n, A)),
              (A.dispatch = y),
              (A = Oe(!1));
            var U = rc.bind(null, _n, !1, A.queue);
            return (
              (A = H()),
              (w = { state: f, dispatch: null, action: c, pending: null }),
              (A.queue = w),
              (y = Ne.bind(null, _n, w, U, y)),
              (w.dispatch = y),
              (A.memoizedState = c),
              [f, y, !1]
            );
          }
          function fi(c) {
            var f = tt();
            return Un(f, Je, c);
          }
          function Un(c, f, y) {
            (f = Jt(c, f, xn)[0]),
              (c = Vt(wt)[0]),
              (f =
                typeof f == "object" &&
                f !== null &&
                typeof f.then == "function"
                  ? rt(f)
                  : f);
            var A = tt(),
              w = A.queue,
              U = w.dispatch;
            return (
              y !== A.memoizedState &&
                ((_n.flags |= 2048),
                Ca(9, $n.bind(null, w, y), { destroy: void 0 }, null)),
              [f, U, c]
            );
          }
          function $n(c, f) {
            c.action = f;
          }
          function Zi(c) {
            var f = tt(),
              y = Je;
            if (y !== null) return Un(f, y, c);
            tt(), (f = f.memoizedState), (y = tt());
            var A = y.queue.dispatch;
            return (y.memoizedState = c), [f, A, !1];
          }
          function Ca(c, f, y, A) {
            return (
              (c = { tag: c, create: f, inst: y, deps: A, next: null }),
              (f = _n.updateQueue),
              f === null && ((f = Jh()), (_n.updateQueue = f)),
              (y = f.lastEffect),
              y === null
                ? (f.lastEffect = c.next = c)
                : ((A = y.next),
                  (y.next = c),
                  (c.next = A),
                  (f.lastEffect = c)),
              c
            );
          }
          function ur() {
            return tt().memoizedState;
          }
          function Au(c, f, y, A) {
            var w = H();
            (_n.flags |= c),
              (w.memoizedState = Ca(
                1 | f,
                y,
                { destroy: void 0 },
                A === void 0 ? null : A
              ));
          }
          function Su(c, f, y, A) {
            var w = tt();
            A = A === void 0 ? null : A;
            var U = w.memoizedState.inst;
            Je !== null && A !== null && G(A, Je.memoizedState.deps)
              ? (w.memoizedState = Ca(f, y, U, A))
              : ((_n.flags |= c), (w.memoizedState = Ca(1 | f, y, U, A)));
          }
          function oh(c, f) {
            Au(8390656, 8, c, f);
          }
          function fp(c, f) {
            Su(2048, 8, c, f);
          }
          function Z0(c, f) {
            return Su(4, 2, c, f);
          }
          function Mu(c, f) {
            return Su(4, 4, c, f);
          }
          function lh(c, f) {
            if (typeof f == "function") {
              c = c();
              var y = f(c);
              return function () {
                typeof y == "function" ? y() : f(null);
              };
            }
            if (f != null)
              return (
                (c = c()),
                (f.current = c),
                function () {
                  f.current = null;
                }
              );
          }
          function ch(c, f, y) {
            (y = y != null ? y.concat([c]) : null),
              Su(4, 4, lh.bind(null, f, c), y);
          }
          function Mo() {}
          function gl(c, f) {
            var y = tt();
            f = f === void 0 ? null : f;
            var A = y.memoizedState;
            return f !== null && G(f, A[1])
              ? A[0]
              : ((y.memoizedState = [c, f]), c);
          }
          function hp(c, f) {
            var y = tt();
            f = f === void 0 ? null : f;
            var A = y.memoizedState;
            if (f !== null && G(f, A[1])) return A[0];
            if (((A = c()), Zo)) {
              Q(!0);
              try {
                c();
              } finally {
                Q(!1);
              }
            }
            return (y.memoizedState = [A, f]), A;
          }
          function Eu(c, f, y) {
            return y === void 0 || (oo & 1073741824) !== 0
              ? (c.memoizedState = f)
              : ((c.memoizedState = y),
                (c = Np()),
                (_n.lanes |= c),
                (gs |= c),
                y);
          }
          function dp(c, f, y, A) {
            return Za(y, f)
              ? y
              : oi.current !== null
              ? ((c = Eu(c, y, A)), Za(c, f) || (ni = !0), c)
              : (oo & 42) === 0
              ? ((ni = !0), (c.memoizedState = y))
              : ((c = Np()), (_n.lanes |= c), (gs |= c), f);
          }
          function ac(c, f, y, A, w) {
            var U = no();
            _a(U !== 0 && 8 > U ? U : 8);
            var q = nn.T,
              lt = {};
            (nn.T = lt), rc(c, !1, f, y);
            try {
              var St = w(),
                Xt = nn.S;
              if (
                (Xt !== null && Xt(lt, St),
                St !== null &&
                  typeof St == "object" &&
                  typeof St.then == "function")
              ) {
                var he = de(St, A);
                Eo(c, f, he, Bi(c));
              } else Eo(c, f, A, Bi(c));
            } catch (Me) {
              Eo(
                c,
                f,
                { then: function () {}, status: "rejected", reason: Me },
                Bi()
              );
            } finally {
              _a(U), (nn.T = q);
            }
          }
          function fr(c) {
            var f = c.memoizedState;
            if (f !== null) return f;
            f = {
              memoizedState: Go,
              baseState: Go,
              baseQueue: null,
              queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: wt,
                lastRenderedState: Go,
              },
              next: null,
            };
            var y = {};
            return (
              (f.next = {
                memoizedState: y,
                baseState: y,
                baseQueue: null,
                queue: {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: wt,
                  lastRenderedState: y,
                },
                next: null,
              }),
              (c.memoizedState = f),
              (c = c.alternate),
              c !== null && (c.memoizedState = f),
              f
            );
          }
          function Tu() {
            return oa(Js);
          }
          function sc() {
            return tt().memoizedState;
          }
          function Gr() {
            return tt().memoizedState;
          }
          function pp(c) {
            for (var f = c.return; f !== null; ) {
              switch (f.tag) {
                case 24:
                case 3:
                  var y = Bi();
                  c = jt(y);
                  var A = ce(f, c, y);
                  A !== null && ($i(A, f, y), Re(A, f, y)),
                    (f = { cache: Ro() }),
                    (c.payload = f);
                  return;
              }
              f = f.return;
            }
          }
          function uh(c, f, y) {
            var A = Bi();
            (y = {
              lane: A,
              revertLane: 0,
              action: y,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            }),
              wu(c)
                ? Ra(f, y)
                : ((y = se(c, f, y, A)),
                  y !== null && ($i(y, c, A), To(y, f, A)));
          }
          function mp(c, f, y) {
            var A = Bi();
            Eo(c, f, y, A);
          }
          function Eo(c, f, y, A) {
            var w = {
              lane: A,
              revertLane: 0,
              action: y,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
            if (wu(c)) Ra(f, w);
            else {
              var U = c.alternate;
              if (
                c.lanes === 0 &&
                (U === null || U.lanes === 0) &&
                ((U = f.lastRenderedReducer), U !== null)
              )
                try {
                  var q = f.lastRenderedState,
                    lt = U(q, y);
                  if (((w.hasEagerState = !0), (w.eagerState = lt), Za(lt, q)))
                    return le(c, f, w, 0), Xn === null && J(), !1;
                } catch {
                } finally {
                }
              if (((y = se(c, f, w, A)), y !== null))
                return $i(y, c, A), To(y, f, A), !0;
            }
            return !1;
          }
          function rc(c, f, y, A) {
            if (
              ((A = {
                lane: 2,
                revertLane: Gt(),
                action: A,
                hasEagerState: !1,
                eagerState: null,
                next: null,
              }),
              wu(c))
            ) {
              if (f) throw Error(a(479));
            } else (f = se(c, y, A, 2)), f !== null && $i(f, c, 2);
          }
          function wu(c) {
            var f = c.alternate;
            return c === _n || (f !== null && f === _n);
          }
          function Ra(c, f) {
            Ol = Ls = !0;
            var y = c.pending;
            y === null ? (f.next = f) : ((f.next = y.next), (y.next = f)),
              (c.pending = f);
          }
          function To(c, f, y) {
            if ((y & 4194176) !== 0) {
              var A = f.lanes;
              (A &= c.pendingLanes), (y |= A), (f.lanes = y), dt(c, y);
            }
          }
          function oc(c, f, y, A) {
            (f = c.memoizedState),
              (y = y(A, f)),
              (y = y == null ? f : Rh({}, f, y)),
              (c.memoizedState = y),
              c.lanes === 0 && (c.updateQueue.baseState = y);
          }
          function lc(c, f, y, A, w, U, q) {
            return (
              (c = c.stateNode),
              typeof c.shouldComponentUpdate == "function"
                ? c.shouldComponentUpdate(A, U, q)
                : f.prototype && f.prototype.isPureReactComponent
                ? !qt(y, A) || !qt(w, U)
                : !0
            );
          }
          function Q0(c, f, y, A) {
            (c = f.state),
              typeof f.componentWillReceiveProps == "function" &&
                f.componentWillReceiveProps(y, A),
              typeof f.UNSAFE_componentWillReceiveProps == "function" &&
                f.UNSAFE_componentWillReceiveProps(y, A),
              f.state !== c && br.enqueueReplaceState(f, f.state, null);
          }
          function Vr(c, f) {
            var y = f;
            if ("ref" in f) {
              y = {};
              for (var A in f) A !== "ref" && (y[A] = f[A]);
            }
            if ((c = c.defaultProps)) {
              y === f && (y = Rh({}, y));
              for (var w in c) y[w] === void 0 && (y[w] = c[w]);
            }
            return y;
          }
          function cc(c, f) {
            try {
              var y = c.onUncaughtError;
              y(f.value, { componentStack: f.stack });
            } catch (A) {
              setTimeout(function () {
                throw A;
              });
            }
          }
          function uc(c, f, y) {
            try {
              var A = c.onCaughtError;
              A(y.value, {
                componentStack: y.stack,
                errorBoundary: f.tag === 1 ? f.stateNode : null,
              });
            } catch (w) {
              setTimeout(function () {
                throw w;
              });
            }
          }
          function fc(c, f, y) {
            return (
              (y = jt(y)),
              (y.tag = 3),
              (y.payload = { element: null }),
              (y.callback = function () {
                cc(c, f);
              }),
              y
            );
          }
          function gp(c) {
            return (c = jt(c)), (c.tag = 3), c;
          }
          function $0(c, f, y, A) {
            var w = y.type.getDerivedStateFromError;
            if (typeof w == "function") {
              var U = A.value;
              (c.payload = function () {
                return w(U);
              }),
                (c.callback = function () {
                  uc(f, y, A);
                });
            }
            var q = y.stateNode;
            q !== null &&
              typeof q.componentDidCatch == "function" &&
              (c.callback = function () {
                uc(f, y, A),
                  typeof w != "function" &&
                    ($o === null ? ($o = new Set([this])) : $o.add(this));
                var lt = A.stack;
                this.componentDidCatch(A.value, {
                  componentStack: lt !== null ? lt : "",
                });
              });
          }
          function v1(c, f, y, A, w) {
            if (
              ((y.flags |= 32768),
              A !== null && typeof A == "object" && typeof A.then == "function")
            ) {
              if (
                ((f = y.alternate),
                f !== null && Du(f, y, w, !0),
                (y = fs.current),
                y !== null)
              ) {
                switch (y.tag) {
                  case 13:
                    return (
                      ei === null
                        ? Jr()
                        : y.alternate === null && ii === 0 && (ii = 3),
                      (y.flags &= -257),
                      (y.flags |= 65536),
                      (y.lanes = w),
                      A === uf
                        ? (y.flags |= 16384)
                        : ((f = y.updateQueue),
                          f === null
                            ? (y.updateQueue = new Set([A]))
                            : f.add(A),
                          xl(c, A, w)),
                      !1
                    );
                  case 22:
                    return (
                      (y.flags |= 65536),
                      A === uf
                        ? (y.flags |= 16384)
                        : ((f = y.updateQueue),
                          f === null
                            ? ((f = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([A]),
                              }),
                              (y.updateQueue = f))
                            : ((y = f.retryQueue),
                              y === null
                                ? (f.retryQueue = new Set([A]))
                                : y.add(A)),
                          xl(c, A, w)),
                      !1
                    );
                }
                throw Error(a(435, y.tag));
              }
              return xl(c, A, w), Jr(), !1;
            }
            if (On)
              return (
                (f = fs.current),
                f !== null
                  ? ((f.flags & 65536) === 0 && (f.flags |= 256),
                    (f.flags |= 65536),
                    (f.lanes = w),
                    A !== of &&
                      ((c = Error(a(422), { cause: A })), Ue(xt(c, y))))
                  : (A !== of &&
                      ((f = Error(a(423), { cause: A })), Ue(xt(f, y))),
                    (c = c.current.alternate),
                    (c.flags |= 65536),
                    (w &= -w),
                    (c.lanes |= w),
                    (A = xt(A, y)),
                    (w = fc(c.stateNode, A, w)),
                    it(c, w),
                    ii !== 4 && (ii = 2)),
                !1
              );
            var U = Error(a(520), { cause: A });
            if (
              ((U = xt(U, y)),
              Il === null ? (Il = [U]) : Il.push(U),
              ii !== 4 && (ii = 2),
              f === null)
            )
              return !0;
            (A = xt(A, y)), (y = f);
            do {
              switch (y.tag) {
                case 3:
                  return (
                    (y.flags |= 65536),
                    (c = w & -w),
                    (y.lanes |= c),
                    (c = fc(y.stateNode, A, c)),
                    it(y, c),
                    !1
                  );
                case 1:
                  if (
                    ((f = y.type),
                    (U = y.stateNode),
                    (y.flags & 128) === 0 &&
                      (typeof f.getDerivedStateFromError == "function" ||
                        (U !== null &&
                          typeof U.componentDidCatch == "function" &&
                          ($o === null || !$o.has(U)))))
                  )
                    return (
                      (y.flags |= 65536),
                      (w &= -w),
                      (y.lanes |= w),
                      (w = gp(w)),
                      $0(w, c, y, A),
                      it(y, w),
                      !1
                    );
              }
              y = y.return;
            } while (y !== null);
            return !1;
          }
          function ra(c, f, y, A) {
            f.child = c === null ? _r(f, null, y, A) : Jo(f, c.child, y, A);
          }
          function fh(c, f, y, A, w) {
            y = y.render;
            var U = f.ref;
            if ("ref" in A) {
              var q = {};
              for (var lt in A) lt !== "ref" && (q[lt] = A[lt]);
            } else q = A;
            return (
              Co(f),
              (A = K(c, f, y, q, U, w)),
              (lt = Ht()),
              c !== null && !ni
                ? (ue(c, f, w), kr(c, f, w))
                : (On && lt && At(f), (f.flags |= 1), ra(c, f, A, w), f.child)
            );
          }
          function tg(c, f, y, A, w) {
            if (c === null) {
              var U = y.type;
              return typeof U == "function" &&
                !ju(U) &&
                U.defaultProps === void 0 &&
                y.compare === null
                ? ((f.tag = 15), (f.type = U), eg(c, f, U, A, w))
                : ((c = pr(y.type, null, A, f, f.mode, w)),
                  (c.ref = f.ref),
                  (c.return = f),
                  (f.child = c));
            }
            if (((U = c.child), !bp(c, w))) {
              var q = U.memoizedProps;
              if (
                ((y = y.compare),
                (y = y !== null ? y : qt),
                y(q, A) && c.ref === f.ref)
              )
                return kr(c, f, w);
            }
            return (
              (f.flags |= 1),
              (c = Cs(U, A)),
              (c.ref = f.ref),
              (c.return = f),
              (f.child = c)
            );
          }
          function eg(c, f, y, A, w) {
            if (c !== null) {
              var U = c.memoizedProps;
              if (qt(U, A) && c.ref === f.ref)
                if (((ni = !1), (f.pendingProps = A = U), bp(c, w)))
                  (c.flags & 131072) !== 0 && (ni = !0);
                else return (f.lanes = c.lanes), kr(c, f, w);
            }
            return hh(c, f, y, A, w);
          }
          function ng(c, f, y) {
            var A = f.pendingProps,
              w = A.children,
              U = (f.stateNode._pendingVisibility & 2) !== 0,
              q = c !== null ? c.memoizedState : null;
            if ((Cu(c, f), A.mode === "hidden" || U)) {
              if ((f.flags & 128) !== 0) {
                if (((A = q !== null ? q.baseLanes | y : y), c !== null)) {
                  for (w = f.child = c.child, U = 0; w !== null; )
                    (U = U | w.lanes | w.childLanes), (w = w.sibling);
                  f.childLanes = U & ~A;
                } else (f.childLanes = 0), (f.child = null);
                return ig(c, f, A, y);
              }
              if ((y & 536870912) !== 0)
                (f.memoizedState = { baseLanes: 0, cachePool: null }),
                  c !== null && ph(f, q !== null ? q.cachePool : null),
                  q !== null ? xi(f, q) : Ci(),
                  Ws(f);
              else
                return (
                  (f.lanes = f.childLanes = 536870912),
                  ig(c, f, q !== null ? q.baseLanes | y : y, y)
                );
            } else
              q !== null
                ? (ph(f, q.cachePool), xi(f, q), sa(), (f.memoizedState = null))
                : (c !== null && ph(f, null), Ci(), sa());
            return ra(c, f, w, y), f.child;
          }
          function ig(c, f, y, A) {
            var w = Sp();
            return (
              (w =
                w === null
                  ? null
                  : {
                      parent: Ua ? li._currentValue : li._currentValue2,
                      pool: w,
                    }),
              (f.memoizedState = { baseLanes: y, cachePool: w }),
              c !== null && ph(f, null),
              Ci(),
              Ws(f),
              c !== null && Du(c, f, A, !0),
              null
            );
          }
          function Cu(c, f) {
            var y = f.ref;
            if (y === null)
              c !== null && c.ref !== null && (f.flags |= 2097664);
            else {
              if (typeof y != "function" && typeof y != "object")
                throw Error(a(284));
              (c === null || c.ref !== y) && (f.flags |= 2097664);
            }
          }
          function hh(c, f, y, A, w) {
            return (
              Co(f),
              (y = K(c, f, y, A, void 0, w)),
              (A = Ht()),
              c !== null && !ni
                ? (ue(c, f, w), kr(c, f, w))
                : (On && A && At(f), (f.flags |= 1), ra(c, f, y, w), f.child)
            );
          }
          function ag(c, f, y, A, w, U) {
            return (
              Co(f),
              (f.updateQueue = null),
              (y = Bt(f, A, y, w)),
              ut(c),
              (A = Ht()),
              c !== null && !ni
                ? (ue(c, f, U), kr(c, f, U))
                : (On && A && At(f), (f.flags |= 1), ra(c, f, y, U), f.child)
            );
          }
          function sg(c, f, y, A, w) {
            if ((Co(f), f.stateNode === null)) {
              var U = Xo,
                q = y.contextType;
              typeof q == "object" && q !== null && (U = oa(q)),
                (U = new y(A, U)),
                (f.memoizedState =
                  U.state !== null && U.state !== void 0 ? U.state : null),
                (U.updater = br),
                (f.stateNode = U),
                (U._reactInternals = f),
                (U = f.stateNode),
                (U.props = A),
                (U.state = f.memoizedState),
                (U.refs = {}),
                we(f),
                (q = y.contextType),
                (U.context = typeof q == "object" && q !== null ? oa(q) : Xo),
                (U.state = f.memoizedState),
                (q = y.getDerivedStateFromProps),
                typeof q == "function" &&
                  (oc(f, y, q, A), (U.state = f.memoizedState)),
                typeof y.getDerivedStateFromProps == "function" ||
                  typeof U.getSnapshotBeforeUpdate == "function" ||
                  (typeof U.UNSAFE_componentWillMount != "function" &&
                    typeof U.componentWillMount != "function") ||
                  ((q = U.state),
                  typeof U.componentWillMount == "function" &&
                    U.componentWillMount(),
                  typeof U.UNSAFE_componentWillMount == "function" &&
                    U.UNSAFE_componentWillMount(),
                  q !== U.state && br.enqueueReplaceState(U, U.state, null),
                  Qt(f, A, U, w),
                  yt(),
                  (U.state = f.memoizedState)),
                typeof U.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (A = !0);
            } else if (c === null) {
              U = f.stateNode;
              var lt = f.memoizedProps,
                St = Vr(y, lt);
              U.props = St;
              var Xt = U.context,
                he = y.contextType;
              (q = Xo), typeof he == "object" && he !== null && (q = oa(he));
              var Me = y.getDerivedStateFromProps;
              (he =
                typeof Me == "function" ||
                typeof U.getSnapshotBeforeUpdate == "function"),
                (lt = f.pendingProps !== lt),
                he ||
                  (typeof U.UNSAFE_componentWillReceiveProps != "function" &&
                    typeof U.componentWillReceiveProps != "function") ||
                  ((lt || Xt !== q) && Q0(f, U, A, q)),
                (ro = !1);
              var Te = f.memoizedState;
              (U.state = Te),
                Qt(f, A, U, w),
                yt(),
                (Xt = f.memoizedState),
                lt || Te !== Xt || ro
                  ? (typeof Me == "function" &&
                      (oc(f, y, Me, A), (Xt = f.memoizedState)),
                    (St = ro || lc(f, y, St, A, Te, Xt, q))
                      ? (he ||
                          (typeof U.UNSAFE_componentWillMount != "function" &&
                            typeof U.componentWillMount != "function") ||
                          (typeof U.componentWillMount == "function" &&
                            U.componentWillMount(),
                          typeof U.UNSAFE_componentWillMount == "function" &&
                            U.UNSAFE_componentWillMount()),
                        typeof U.componentDidMount == "function" &&
                          (f.flags |= 4194308))
                      : (typeof U.componentDidMount == "function" &&
                          (f.flags |= 4194308),
                        (f.memoizedProps = A),
                        (f.memoizedState = Xt)),
                    (U.props = A),
                    (U.state = Xt),
                    (U.context = q),
                    (A = St))
                  : (typeof U.componentDidMount == "function" &&
                      (f.flags |= 4194308),
                    (A = !1));
            } else {
              (U = f.stateNode),
                Ce(c, f),
                (q = f.memoizedProps),
                (he = Vr(y, q)),
                (U.props = he),
                (Me = f.pendingProps),
                (Te = U.context),
                (Xt = y.contextType),
                (St = Xo),
                typeof Xt == "object" && Xt !== null && (St = oa(Xt)),
                (lt = y.getDerivedStateFromProps),
                (Xt =
                  typeof lt == "function" ||
                  typeof U.getSnapshotBeforeUpdate == "function") ||
                  (typeof U.UNSAFE_componentWillReceiveProps != "function" &&
                    typeof U.componentWillReceiveProps != "function") ||
                  ((q !== Me || Te !== St) && Q0(f, U, A, St)),
                (ro = !1),
                (Te = f.memoizedState),
                (U.state = Te),
                Qt(f, A, U, w),
                yt();
              var un = f.memoizedState;
              q !== Me ||
              Te !== un ||
              ro ||
              (c !== null && c.dependencies !== null && Uu(c.dependencies))
                ? (typeof lt == "function" &&
                    (oc(f, y, lt, A), (un = f.memoizedState)),
                  (he =
                    ro ||
                    lc(f, y, he, A, Te, un, St) ||
                    (c !== null &&
                      c.dependencies !== null &&
                      Uu(c.dependencies)))
                    ? (Xt ||
                        (typeof U.UNSAFE_componentWillUpdate != "function" &&
                          typeof U.componentWillUpdate != "function") ||
                        (typeof U.componentWillUpdate == "function" &&
                          U.componentWillUpdate(A, un, St),
                        typeof U.UNSAFE_componentWillUpdate == "function" &&
                          U.UNSAFE_componentWillUpdate(A, un, St)),
                      typeof U.componentDidUpdate == "function" &&
                        (f.flags |= 4),
                      typeof U.getSnapshotBeforeUpdate == "function" &&
                        (f.flags |= 1024))
                    : (typeof U.componentDidUpdate != "function" ||
                        (q === c.memoizedProps && Te === c.memoizedState) ||
                        (f.flags |= 4),
                      typeof U.getSnapshotBeforeUpdate != "function" ||
                        (q === c.memoizedProps && Te === c.memoizedState) ||
                        (f.flags |= 1024),
                      (f.memoizedProps = A),
                      (f.memoizedState = un)),
                  (U.props = A),
                  (U.state = un),
                  (U.context = St),
                  (A = he))
                : (typeof U.componentDidUpdate != "function" ||
                    (q === c.memoizedProps && Te === c.memoizedState) ||
                    (f.flags |= 4),
                  typeof U.getSnapshotBeforeUpdate != "function" ||
                    (q === c.memoizedProps && Te === c.memoizedState) ||
                    (f.flags |= 1024),
                  (A = !1));
            }
            return (
              (U = A),
              Cu(c, f),
              (A = (f.flags & 128) !== 0),
              U || A
                ? ((U = f.stateNode),
                  (y =
                    A && typeof y.getDerivedStateFromError != "function"
                      ? null
                      : U.render()),
                  (f.flags |= 1),
                  c !== null && A
                    ? ((f.child = Jo(f, c.child, null, w)),
                      (f.child = Jo(f, null, y, w)))
                    : ra(c, f, y, w),
                  (f.memoizedState = U.state),
                  (c = f.child))
                : (c = kr(c, f, w)),
              c
            );
          }
          function rg(c, f, y, A) {
            return je(), (f.flags |= 256), ra(c, f, y, A), f.child;
          }
          function vp(c) {
            return { baseLanes: c, cachePool: Mp() };
          }
          function Ru(c, f, y) {
            return (c = c !== null ? c.childLanes & ~y : 0), f && (c |= vs), c;
          }
          function og(c, f, y) {
            var A = f.pendingProps,
              w = !1,
              U = (f.flags & 128) !== 0,
              q;
            if (
              ((q = U) ||
                (q =
                  c !== null && c.memoizedState === null
                    ? !1
                    : (Xi.current & 2) !== 0),
              q && ((w = !0), (f.flags &= -129)),
              (q = (f.flags & 32) !== 0),
              (f.flags &= -33),
              c === null)
            ) {
              if (On) {
                if ((w ? ya(f) : sa(), On)) {
                  var lt = da,
                    St;
                  (St = lt) &&
                    ((lt = jg(lt, ea)),
                    lt !== null
                      ? ((f.memoizedState = {
                          dehydrated: lt,
                          treeContext:
                            Wo !== null ? { id: Qs, overflow: $s } : null,
                          retryLane: 536870912,
                        }),
                        (St = e(18, null, null, 0)),
                        (St.stateNode = lt),
                        (St.return = f),
                        (f.child = St),
                        (ha = f),
                        (da = null),
                        (St = !0))
                      : (St = !1)),
                    St || ie(f);
                }
                if (
                  ((lt = f.memoizedState),
                  lt !== null && ((lt = lt.dehydrated), lt !== null))
                )
                  return Fh(lt) ? (f.lanes = 16) : (f.lanes = 536870912), null;
                Ke(f);
              }
              return (
                (lt = A.children),
                (A = A.fallback),
                w
                  ? (sa(),
                    (w = f.mode),
                    (lt = xp({ mode: "hidden", children: lt }, w)),
                    (A = _i(A, w, y, null)),
                    (lt.return = f),
                    (A.return = f),
                    (lt.sibling = A),
                    (f.child = lt),
                    (w = f.child),
                    (w.memoizedState = vp(y)),
                    (w.childLanes = Ru(c, q, y)),
                    (f.memoizedState = $h),
                    A)
                  : (ya(f), yp(f, lt))
              );
            }
            if (
              ((St = c.memoizedState),
              St !== null && ((lt = St.dehydrated), lt !== null))
            ) {
              if (U)
                f.flags & 256
                  ? (ya(f), (f.flags &= -257), (f = dh(c, f, y)))
                  : f.memoizedState !== null
                  ? (sa(), (f.child = c.child), (f.flags |= 128), (f = null))
                  : (sa(),
                    (w = A.fallback),
                    (lt = f.mode),
                    (A = xp({ mode: "visible", children: A.children }, lt)),
                    (w = _i(w, lt, y, null)),
                    (w.flags |= 2),
                    (A.return = f),
                    (w.return = f),
                    (A.sibling = w),
                    (f.child = A),
                    Jo(f, c.child, null, y),
                    (A = f.child),
                    (A.memoizedState = vp(y)),
                    (A.childLanes = Ru(c, q, y)),
                    (f.memoizedState = $h),
                    (f = w));
              else if ((ya(f), Fh(lt)))
                (q = Fg(lt).digest),
                  (A = Error(a(419))),
                  (A.stack = ""),
                  (A.digest = q),
                  Ue({ value: A, source: null, stack: null }),
                  (f = dh(c, f, y));
              else if (
                (ni || Du(c, f, y, !1), (q = (y & c.childLanes) !== 0), ni || q)
              ) {
                if (((q = Xn), q !== null)) {
                  if (((A = y & -y), (A & 42) !== 0)) A = 1;
                  else
                    switch (A) {
                      case 2:
                        A = 1;
                        break;
                      case 8:
                        A = 4;
                        break;
                      case 32:
                        A = 16;
                        break;
                      case 128:
                      case 256:
                      case 512:
                      case 1024:
                      case 2048:
                      case 4096:
                      case 8192:
                      case 16384:
                      case 32768:
                      case 65536:
                      case 131072:
                      case 262144:
                      case 524288:
                      case 1048576:
                      case 2097152:
                      case 4194304:
                      case 8388608:
                      case 16777216:
                      case 33554432:
                        A = 64;
                        break;
                      case 268435456:
                        A = 134217728;
                        break;
                      default:
                        A = 0;
                    }
                  if (
                    ((A = (A & (q.suspendedLanes | y)) !== 0 ? 0 : A),
                    A !== 0 && A !== St.retryLane)
                  )
                    throw ((St.retryLane = A), $t(c, A), $i(q, c, A), Qh);
                }
                zh(lt) || Jr(), (f = dh(c, f, y));
              } else
                zh(lt)
                  ? ((f.flags |= 128),
                    (f.child = c.child),
                    (f = Zr.bind(null, c)),
                    Hg(lt, f),
                    (f = null))
                  : ((c = St.treeContext),
                    fa &&
                      ((da = kg(lt)),
                      (ha = f),
                      (On = !0),
                      (Os = null),
                      (ea = !1),
                      c !== null &&
                        ((ls[cs++] = Qs),
                        (ls[cs++] = $s),
                        (ls[cs++] = Wo),
                        (Qs = c.id),
                        ($s = c.overflow),
                        (Wo = f))),
                    (f = yp(f, A.children)),
                    (f.flags |= 4096));
              return f;
            }
            return w
              ? (sa(),
                (w = A.fallback),
                (lt = f.mode),
                (St = c.child),
                (U = St.sibling),
                (A = Cs(St, { mode: "hidden", children: A.children })),
                (A.subtreeFlags = St.subtreeFlags & 31457280),
                U !== null
                  ? (w = Cs(U, w))
                  : ((w = _i(w, lt, y, null)), (w.flags |= 2)),
                (w.return = f),
                (A.return = f),
                (A.sibling = w),
                (f.child = A),
                (A = w),
                (w = f.child),
                (lt = c.child.memoizedState),
                lt === null
                  ? (lt = vp(y))
                  : ((St = lt.cachePool),
                    St !== null
                      ? ((U = Ua ? li._currentValue : li._currentValue2),
                        (St = St.parent !== U ? { parent: U, pool: U } : St))
                      : (St = Mp()),
                    (lt = { baseLanes: lt.baseLanes | y, cachePool: St })),
                (w.memoizedState = lt),
                (w.childLanes = Ru(c, q, y)),
                (f.memoizedState = $h),
                A)
              : (ya(f),
                (y = c.child),
                (c = y.sibling),
                (y = Cs(y, { mode: "visible", children: A.children })),
                (y.return = f),
                (y.sibling = null),
                c !== null &&
                  ((q = f.deletions),
                  q === null
                    ? ((f.deletions = [c]), (f.flags |= 16))
                    : q.push(c)),
                (f.child = y),
                (f.memoizedState = null),
                y);
          }
          function yp(c, f) {
            return (
              (f = xp({ mode: "visible", children: f }, c.mode)),
              (f.return = c),
              (c.child = f)
            );
          }
          function xp(c, f) {
            return Wu(c, f, 0, null);
          }
          function dh(c, f, y) {
            return (
              Jo(f, c.child, null, y),
              (c = yp(f, f.pendingProps.children)),
              (c.flags |= 2),
              (f.memoizedState = null),
              c
            );
          }
          function lg(c, f, y) {
            c.lanes |= f;
            var A = c.alternate;
            A !== null && (A.lanes |= f), Bu(c.return, f, y);
          }
          function _p(c, f, y, A, w) {
            var U = c.memoizedState;
            U === null
              ? (c.memoizedState = {
                  isBackwards: f,
                  rendering: null,
                  renderingStartTime: 0,
                  last: A,
                  tail: y,
                  tailMode: w,
                })
              : ((U.isBackwards = f),
                (U.rendering = null),
                (U.renderingStartTime = 0),
                (U.last = A),
                (U.tail = y),
                (U.tailMode = w));
          }
          function cg(c, f, y) {
            var A = f.pendingProps,
              w = A.revealOrder,
              U = A.tail;
            if ((ra(c, f, A.children, y), (A = Xi.current), (A & 2) !== 0))
              (A = (A & 1) | 2), (f.flags |= 128);
            else {
              if (c !== null && (c.flags & 128) !== 0)
                t: for (c = f.child; c !== null; ) {
                  if (c.tag === 13) c.memoizedState !== null && lg(c, y, f);
                  else if (c.tag === 19) lg(c, y, f);
                  else if (c.child !== null) {
                    (c.child.return = c), (c = c.child);
                    continue;
                  }
                  if (c === f) break t;
                  for (; c.sibling === null; ) {
                    if (c.return === null || c.return === f) break t;
                    c = c.return;
                  }
                  (c.sibling.return = c.return), (c = c.sibling);
                }
              A &= 1;
            }
            switch ((R(Xi, A), w)) {
              case "forwards":
                for (y = f.child, w = null; y !== null; )
                  (c = y.alternate),
                    c !== null && ka(c) === null && (w = y),
                    (y = y.sibling);
                (y = w),
                  y === null
                    ? ((w = f.child), (f.child = null))
                    : ((w = y.sibling), (y.sibling = null)),
                  _p(f, !1, w, y, U);
                break;
              case "backwards":
                for (y = null, w = f.child, f.child = null; w !== null; ) {
                  if (((c = w.alternate), c !== null && ka(c) === null)) {
                    f.child = w;
                    break;
                  }
                  (c = w.sibling), (w.sibling = y), (y = w), (w = c);
                }
                _p(f, !0, y, null, U);
                break;
              case "together":
                _p(f, !1, null, null, void 0);
                break;
              default:
                f.memoizedState = null;
            }
            return f.child;
          }
          function kr(c, f, y) {
            if (
              (c !== null && (f.dependencies = c.dependencies),
              (gs |= f.lanes),
              (y & f.childLanes) === 0)
            )
              if (c !== null) {
                if ((Du(c, f, y, !1), (y & f.childLanes) === 0)) return null;
              } else return null;
            if (c !== null && f.child !== c.child) throw Error(a(153));
            if (f.child !== null) {
              for (
                c = f.child,
                  y = Cs(c, c.pendingProps),
                  f.child = y,
                  y.return = f;
                c.sibling !== null;

              )
                (c = c.sibling),
                  (y = y.sibling = Cs(c, c.pendingProps)),
                  (y.return = f);
              y.sibling = null;
            }
            return f.child;
          }
          function bp(c, f) {
            return (c.lanes & f) !== 0
              ? !0
              : ((c = c.dependencies), !!(c !== null && Uu(c)));
          }
          function y1(c, f, y) {
            switch (f.tag) {
              case 3:
                ht(f, f.stateNode.containerInfo),
                  wo(f, li, c.memoizedState.cache),
                  je();
                break;
              case 27:
              case 5:
                Pt(f);
                break;
              case 4:
                ht(f, f.stateNode.containerInfo);
                break;
              case 10:
                wo(f, f.type, f.memoizedProps.value);
                break;
              case 13:
                var A = f.memoizedState;
                if (A !== null)
                  return A.dehydrated !== null
                    ? (ya(f), (f.flags |= 128), null)
                    : (y & f.child.childLanes) !== 0
                    ? og(c, f, y)
                    : (ya(f), (c = kr(c, f, y)), c !== null ? c.sibling : null);
                ya(f);
                break;
              case 19:
                var w = (c.flags & 128) !== 0;
                if (
                  ((A = (y & f.childLanes) !== 0),
                  A || (Du(c, f, y, !1), (A = (y & f.childLanes) !== 0)),
                  w)
                ) {
                  if (A) return cg(c, f, y);
                  f.flags |= 128;
                }
                if (
                  ((w = f.memoizedState),
                  w !== null &&
                    ((w.rendering = null),
                    (w.tail = null),
                    (w.lastEffect = null)),
                  R(Xi, Xi.current),
                  A)
                )
                  break;
                return null;
              case 22:
              case 23:
                return (f.lanes = 0), ng(c, f, y);
              case 24:
                wo(f, li, c.memoizedState.cache);
            }
            return kr(c, f, y);
          }
          function ug(c, f, y) {
            if (c !== null)
              if (c.memoizedProps !== f.pendingProps) ni = !0;
              else {
                if (!bp(c, y) && (f.flags & 128) === 0)
                  return (ni = !1), y1(c, f, y);
                ni = (c.flags & 131072) !== 0;
              }
            else
              (ni = !1), On && (f.flags & 1048576) !== 0 && ft(f, Uc, f.index);
            switch (((f.lanes = 0), f.tag)) {
              case 16:
                t: {
                  c = f.pendingProps;
                  var A = f.elementType,
                    w = A._init;
                  if (
                    ((A = w(A._payload)), (f.type = A), typeof A == "function")
                  )
                    ju(A)
                      ? ((c = Vr(A, c)),
                        (f.tag = 1),
                        (f = sg(null, f, A, c, y)))
                      : ((f.tag = 0), (f = hh(null, f, A, c, y)));
                  else {
                    if (A != null) {
                      if (((w = A.$$typeof), w === Zu)) {
                        (f.tag = 11), (f = fh(null, f, A, c, y));
                        break t;
                      } else if (w === Uh) {
                        (f.tag = 14), (f = tg(null, f, A, c, y));
                        break t;
                      }
                    }
                    throw ((f = l(A) || A), Error(a(306, f, "")));
                  }
                }
                return f;
              case 0:
                return hh(c, f, f.type, f.pendingProps, y);
              case 1:
                return (
                  (A = f.type), (w = Vr(A, f.pendingProps)), sg(c, f, A, w, y)
                );
              case 3:
                t: {
                  if ((ht(f, f.stateNode.containerInfo), c === null))
                    throw Error(a(387));
                  var U = f.pendingProps;
                  (w = f.memoizedState),
                    (A = w.element),
                    Ce(c, f),
                    Qt(f, U, null, y);
                  var q = f.memoizedState;
                  if (
                    ((U = q.cache),
                    wo(f, li, U),
                    U !== w.cache && vl(f, [li], y, !0),
                    yt(),
                    (U = q.element),
                    fa && w.isDehydrated)
                  )
                    if (
                      ((w = { element: U, isDehydrated: !1, cache: q.cache }),
                      (f.updateQueue.baseState = w),
                      (f.memoizedState = w),
                      f.flags & 256)
                    ) {
                      f = rg(c, f, U, y);
                      break t;
                    } else if (U !== A) {
                      (A = xt(Error(a(424)), f)), Ue(A), (f = rg(c, f, U, y));
                      break t;
                    } else
                      for (
                        fa &&
                          ((da = Vg(f.stateNode.containerInfo)),
                          (ha = f),
                          (On = !0),
                          (Os = null),
                          (ea = !0)),
                          y = _r(f, null, U, y),
                          f.child = y;
                        y;

                      )
                        (y.flags = (y.flags & -3) | 4096), (y = y.sibling);
                  else {
                    if ((je(), U === A)) {
                      f = kr(c, f, y);
                      break t;
                    }
                    ra(c, f, U, y);
                  }
                  f = f.child;
                }
                return f;
              case 26:
                if (os)
                  return (
                    Cu(c, f),
                    c === null
                      ? (y = om(f.type, null, f.pendingProps, null))
                        ? (f.memoizedState = y)
                        : On ||
                          (f.stateNode = jh(
                            f.type,
                            f.pendingProps,
                            yr.current,
                            f
                          ))
                      : (f.memoizedState = om(
                          f.type,
                          c.memoizedProps,
                          f.pendingProps,
                          c.memoizedState
                        )),
                    null
                  );
              case 27:
                if (ti)
                  return (
                    Pt(f),
                    c === null &&
                      ti &&
                      On &&
                      ((A = f.stateNode =
                        Zs(f.type, f.pendingProps, yr.current, ji.current, !1)),
                      (ha = f),
                      (ea = !0),
                      (da = Hh(A))),
                    (A = f.pendingProps.children),
                    c !== null || On
                      ? ra(c, f, A, y)
                      : (f.child = Jo(f, null, A, y)),
                    Cu(c, f),
                    f.child
                  );
              case 5:
                return (
                  c === null &&
                    On &&
                    (Vh(f.type, f.pendingProps, ji.current),
                    (w = A = da) &&
                      ((A = E1(A, f.type, f.pendingProps, ea)),
                      A !== null
                        ? ((f.stateNode = A),
                          (ha = f),
                          (da = Hh(A)),
                          (ea = !1),
                          (w = !0))
                        : (w = !1)),
                    w || ie(f)),
                  Pt(f),
                  (w = f.type),
                  (U = f.pendingProps),
                  (q = c !== null ? c.memoizedProps : null),
                  (A = U.children),
                  hn(w, U)
                    ? (A = null)
                    : q !== null && hn(w, q) && (f.flags |= 32),
                  f.memoizedState !== null &&
                    ((w = K(c, f, Ut, null, null, y)),
                    Ua ? (Js._currentValue = w) : (Js._currentValue2 = w)),
                  Cu(c, f),
                  ra(c, f, A, y),
                  f.child
                );
              case 6:
                return (
                  c === null &&
                    On &&
                    (Kg(f.pendingProps, ji.current),
                    (c = y = da) &&
                      ((y = sm(y, f.pendingProps, ea)),
                      y !== null
                        ? ((f.stateNode = y), (ha = f), (da = null), (c = !0))
                        : (c = !1)),
                    c || ie(f)),
                  null
                );
              case 13:
                return og(c, f, y);
              case 4:
                return (
                  ht(f, f.stateNode.containerInfo),
                  (A = f.pendingProps),
                  c === null ? (f.child = Jo(f, null, A, y)) : ra(c, f, A, y),
                  f.child
                );
              case 11:
                return fh(c, f, f.type, f.pendingProps, y);
              case 7:
                return ra(c, f, f.pendingProps, y), f.child;
              case 8:
                return ra(c, f, f.pendingProps.children, y), f.child;
              case 12:
                return ra(c, f, f.pendingProps.children, y), f.child;
              case 10:
                return (
                  (A = f.pendingProps),
                  wo(f, f.type, A.value),
                  ra(c, f, A.children, y),
                  f.child
                );
              case 9:
                return (
                  (w = f.type._context),
                  (A = f.pendingProps.children),
                  Co(f),
                  (w = oa(w)),
                  (A = A(w)),
                  (f.flags |= 1),
                  ra(c, f, A, y),
                  f.child
                );
              case 14:
                return tg(c, f, f.type, f.pendingProps, y);
              case 15:
                return eg(c, f, f.type, f.pendingProps, y);
              case 19:
                return cg(c, f, y);
              case 22:
                return ng(c, f, y);
              case 24:
                return (
                  Co(f),
                  (A = oa(li)),
                  c === null
                    ? ((w = Sp()),
                      w === null &&
                        ((w = Xn),
                        (U = Ro()),
                        (w.pooledCache = U),
                        U.refCount++,
                        U !== null && (w.pooledCacheLanes |= y),
                        (w = U)),
                      (f.memoizedState = { parent: A, cache: w }),
                      we(f),
                      wo(f, li, w))
                    : ((c.lanes & y) !== 0 &&
                        (Ce(c, f), Qt(f, null, null, y), yt()),
                      (w = c.memoizedState),
                      (U = f.memoizedState),
                      w.parent !== A
                        ? ((w = { parent: A, cache: A }),
                          (f.memoizedState = w),
                          f.lanes === 0 &&
                            (f.memoizedState = f.updateQueue.baseState = w),
                          wo(f, li, A))
                        : ((A = U.cache),
                          wo(f, li, A),
                          A !== w.cache && vl(f, [li], y, !0))),
                  ra(c, f, f.pendingProps.children, y),
                  f.child
                );
              case 29:
                throw f.pendingProps;
            }
            throw Error(a(156, f.tag));
          }
          function wo(c, f, y) {
            Ua
              ? (R(lo, f._currentValue), (f._currentValue = y))
              : (R(lo, f._currentValue2), (f._currentValue2 = y));
          }
          function jr(c) {
            var f = lo.current;
            Ua ? (c._currentValue = f) : (c._currentValue2 = f), S(lo);
          }
          function Bu(c, f, y) {
            for (; c !== null; ) {
              var A = c.alternate;
              if (
                ((c.childLanes & f) !== f
                  ? ((c.childLanes |= f), A !== null && (A.childLanes |= f))
                  : A !== null &&
                    (A.childLanes & f) !== f &&
                    (A.childLanes |= f),
                c === y)
              )
                break;
              c = c.return;
            }
          }
          function vl(c, f, y, A) {
            var w = c.child;
            for (w !== null && (w.return = c); w !== null; ) {
              var U = w.dependencies;
              if (U !== null) {
                var q = w.child;
                U = U.firstContext;
                t: for (; U !== null; ) {
                  var lt = U;
                  U = w;
                  for (var St = 0; St < f.length; St++)
                    if (lt.context === f[St]) {
                      (U.lanes |= y),
                        (lt = U.alternate),
                        lt !== null && (lt.lanes |= y),
                        Bu(U.return, y, c),
                        A || (q = null);
                      break t;
                    }
                  U = lt.next;
                }
              } else if (w.tag === 18) {
                if (((q = w.return), q === null)) throw Error(a(341));
                (q.lanes |= y),
                  (U = q.alternate),
                  U !== null && (U.lanes |= y),
                  Bu(q, y, c),
                  (q = null);
              } else q = w.child;
              if (q !== null) q.return = w;
              else
                for (q = w; q !== null; ) {
                  if (q === c) {
                    q = null;
                    break;
                  }
                  if (((w = q.sibling), w !== null)) {
                    (w.return = q.return), (q = w);
                    break;
                  }
                  q = q.return;
                }
              w = q;
            }
          }
          function Du(c, f, y, A) {
            c = null;
            for (var w = f, U = !1; w !== null; ) {
              if (!U) {
                if ((w.flags & 524288) !== 0) U = !0;
                else if ((w.flags & 262144) !== 0) break;
              }
              if (w.tag === 10) {
                var q = w.alternate;
                if (q === null) throw Error(a(387));
                if (((q = q.memoizedProps), q !== null)) {
                  var lt = w.type;
                  Za(w.pendingProps.value, q.value) ||
                    (c !== null ? c.push(lt) : (c = [lt]));
                }
              } else if (w === wl.current) {
                if (((q = w.alternate), q === null)) throw Error(a(387));
                q.memoizedState.memoizedState !==
                  w.memoizedState.memoizedState &&
                  (c !== null ? c.push(Js) : (c = [Js]));
              }
              w = w.return;
            }
            c !== null && vl(f, c, y, A), (f.flags |= 262144);
          }
          function Uu(c) {
            for (c = c.firstContext; c !== null; ) {
              var f = c.context;
              if (!Za(Ua ? f._currentValue : f._currentValue2, c.memoizedValue))
                return !0;
              c = c.next;
            }
            return !1;
          }
          function Co(c) {
            (nr = c),
              (ds = null),
              (c = c.dependencies),
              c !== null && (c.firstContext = null);
          }
          function oa(c) {
            return Ap(nr, c);
          }
          function Ou(c, f) {
            return nr === null && Co(c), Ap(c, f);
          }
          function Ap(c, f) {
            var y = Ua ? f._currentValue : f._currentValue2;
            if (
              ((f = { context: f, memoizedValue: y, next: null }), ds === null)
            ) {
              if (c === null) throw Error(a(308));
              (ds = f),
                (c.dependencies = { lanes: 0, firstContext: f }),
                (c.flags |= 524288);
            } else ds = ds.next = f;
            return y;
          }
          function Ro() {
            return { controller: new zc(), data: new Map(), refCount: 0 };
          }
          function Nu(c) {
            c.refCount--,
              c.refCount === 0 &&
                rv(ov, function () {
                  c.controller.abort();
                });
          }
          function Sp() {
            var c = Ar.current;
            return c !== null ? c : Xn.pooledCache;
          }
          function ph(c, f) {
            f === null ? R(Ar, Ar.current) : R(Ar, f.pool);
          }
          function Mp() {
            var c = Sp();
            return c === null
              ? null
              : { parent: Ua ? li._currentValue : li._currentValue2, pool: c };
          }
          function ja(c) {
            c.flags |= 4;
          }
          function hc(c, f) {
            if (c !== null && c.child === f.child) return !1;
            if ((f.flags & 16) !== 0) return !0;
            for (c = f.child; c !== null; ) {
              if ((c.flags & 13878) !== 0 || (c.subtreeFlags & 13878) !== 0)
                return !0;
              c = c.sibling;
            }
            return !1;
          }
          function yl(c, f, y, A) {
            if (ki)
              for (y = f.child; y !== null; ) {
                if (y.tag === 5 || y.tag === 6) $u(c, y.stateNode);
                else if (
                  !(y.tag === 4 || (ti && y.tag === 27)) &&
                  y.child !== null
                ) {
                  (y.child.return = y), (y = y.child);
                  continue;
                }
                if (y === f) break;
                for (; y.sibling === null; ) {
                  if (y.return === null || y.return === f) return;
                  y = y.return;
                }
                (y.sibling.return = y.return), (y = y.sibling);
              }
            else if (Ds)
              for (var w = f.child; w !== null; ) {
                if (w.tag === 5) {
                  var U = w.stateNode;
                  y && A && (U = em(U, w.type, w.memoizedProps)), $u(c, U);
                } else if (w.tag === 6)
                  (U = w.stateNode),
                    y && A && (U = nm(U, w.memoizedProps)),
                    $u(c, U);
                else if (w.tag !== 4) {
                  if (w.tag === 22 && w.memoizedState !== null)
                    (U = w.child),
                      U !== null && (U.return = w),
                      yl(c, w, !0, !0);
                  else if (w.child !== null) {
                    (w.child.return = w), (w = w.child);
                    continue;
                  }
                }
                if (w === f) break;
                for (; w.sibling === null; ) {
                  if (w.return === null || w.return === f) return;
                  w = w.return;
                }
                (w.sibling.return = w.return), (w = w.sibling);
              }
          }
          function fg(c, f, y, A) {
            if (Ds)
              for (var w = f.child; w !== null; ) {
                if (w.tag === 5) {
                  var U = w.stateNode;
                  y && A && (U = em(U, w.type, w.memoizedProps)), tm(c, U);
                } else if (w.tag === 6)
                  (U = w.stateNode),
                    y && A && (U = nm(U, w.memoizedProps)),
                    tm(c, U);
                else if (w.tag !== 4) {
                  if (w.tag === 22 && w.memoizedState !== null)
                    (U = w.child),
                      U !== null && (U.return = w),
                      fg(
                        c,
                        w,
                        !(
                          w.memoizedProps !== null &&
                          w.memoizedProps.mode === "manual"
                        ),
                        !0
                      );
                  else if (w.child !== null) {
                    (w.child.return = w), (w = w.child);
                    continue;
                  }
                }
                if (w === f) break;
                for (; w.sibling === null; ) {
                  if (w.return === null || w.return === f) return;
                  w = w.return;
                }
                (w.sibling.return = w.return), (w = w.sibling);
              }
          }
          function Lu(c, f) {
            if (Ds && hc(c, f)) {
              c = f.stateNode;
              var y = c.containerInfo,
                A = tf();
              fg(A, f, !1, !1), (c.pendingChildren = A), ja(f), Ph(y, A);
            }
          }
          function mh(c, f, y, A) {
            if (ki) c.memoizedProps !== A && ja(f);
            else if (Ds) {
              var w = c.stateNode,
                U = c.memoizedProps;
              if ((c = hc(c, f)) || U !== A) {
                var q = ji.current;
                (U = Rc(w, y, U, A, !c, null)),
                  U === w
                    ? (f.stateNode = w)
                    : (eo(U, y, A, q) && ja(f),
                      (f.stateNode = U),
                      c ? yl(U, f, !1, !1) : ja(f));
              } else f.stateNode = w;
            }
          }
          function gh(c, f, y) {
            if (Wp(f, y)) {
              if (((c.flags |= 16777216), !Lh(f, y)))
                if (Lo()) c.flags |= 8192;
                else throw ((Yo = uf), cf);
            } else c.flags &= -16777217;
          }
          function vh(c, f) {
            if (Qg(f)) {
              if (((c.flags |= 16777216), !Al(f)))
                if (Lo()) c.flags |= 8192;
                else throw ((Yo = uf), cf);
            } else c.flags &= -16777217;
          }
          function dc(c, f) {
            f !== null && (c.flags |= 4),
              c.flags & 16384 &&
                ((f = c.tag !== 22 ? N() : 536870912),
                (c.lanes |= f),
                (Er |= f));
          }
          function pc(c, f) {
            if (!On)
              switch (c.tailMode) {
                case "hidden":
                  f = c.tail;
                  for (var y = null; f !== null; )
                    f.alternate !== null && (y = f), (f = f.sibling);
                  y === null ? (c.tail = null) : (y.sibling = null);
                  break;
                case "collapsed":
                  y = c.tail;
                  for (var A = null; y !== null; )
                    y.alternate !== null && (A = y), (y = y.sibling);
                  A === null
                    ? f || c.tail === null
                      ? (c.tail = null)
                      : (c.tail.sibling = null)
                    : (A.sibling = null);
              }
          }
          function pi(c) {
            var f = c.alternate !== null && c.alternate.child === c.child,
              y = 0,
              A = 0;
            if (f)
              for (var w = c.child; w !== null; )
                (y |= w.lanes | w.childLanes),
                  (A |= w.subtreeFlags & 31457280),
                  (A |= w.flags & 31457280),
                  (w.return = c),
                  (w = w.sibling);
            else
              for (w = c.child; w !== null; )
                (y |= w.lanes | w.childLanes),
                  (A |= w.subtreeFlags),
                  (A |= w.flags),
                  (w.return = c),
                  (w = w.sibling);
            return (c.subtreeFlags |= A), (c.childLanes = y), f;
          }
          function hg(c, f, y) {
            var A = f.pendingProps;
            switch ((Rt(f), f.tag)) {
              case 16:
              case 15:
              case 0:
              case 11:
              case 7:
              case 8:
              case 12:
              case 9:
              case 14:
                return pi(f), null;
              case 1:
                return pi(f), null;
              case 3:
                return (
                  (y = f.stateNode),
                  (A = null),
                  c !== null && (A = c.memoizedState.cache),
                  f.memoizedState.cache !== A && (f.flags |= 2048),
                  jr(li),
                  It(),
                  y.pendingContext &&
                    ((y.context = y.pendingContext), (y.pendingContext = null)),
                  (c === null || c.child === null) &&
                    (De(f)
                      ? ja(f)
                      : c === null ||
                        (c.memoizedState.isDehydrated &&
                          (f.flags & 256) === 0) ||
                        ((f.flags |= 1024),
                        Os !== null && (Vu(Os), (Os = null)))),
                  Lu(c, f),
                  pi(f),
                  null
                );
              case 26:
                if (os) {
                  y = f.type;
                  var w = f.memoizedState;
                  return (
                    c === null
                      ? (ja(f),
                        w !== null ? (pi(f), vh(f, w)) : (pi(f), gh(f, y, A)))
                      : w
                      ? w !== c.memoizedState
                        ? (ja(f), pi(f), vh(f, w))
                        : (pi(f), (f.flags &= -16777217))
                      : (ki ? c.memoizedProps !== A && ja(f) : mh(c, f, y, A),
                        pi(f),
                        gh(f, y, A)),
                    null
                  );
                }
              case 27:
                if (ti) {
                  if (
                    (re(f),
                    (y = yr.current),
                    (w = f.type),
                    c !== null && f.stateNode != null)
                  )
                    ki ? c.memoizedProps !== A && ja(f) : mh(c, f, w, A);
                  else {
                    if (!A) {
                      if (f.stateNode === null) throw Error(a(166));
                      return pi(f), null;
                    }
                    (c = ji.current),
                      De(f)
                        ? Fe(f, c)
                        : ((c = Zs(w, A, y, c, !0)), (f.stateNode = c), ja(f));
                  }
                  return pi(f), null;
                }
              case 5:
                if ((re(f), (y = f.type), c !== null && f.stateNode != null))
                  mh(c, f, y, A);
                else {
                  if (!A) {
                    if (f.stateNode === null) throw Error(a(166));
                    return pi(f), null;
                  }
                  (c = ji.current),
                    De(f)
                      ? Fe(f, c)
                      : ((w = Xp(y, A, yr.current, c, f)),
                        yl(w, f, !1, !1),
                        (f.stateNode = w),
                        eo(w, y, A, c) && ja(f));
                }
                return pi(f), gh(f, f.type, f.pendingProps), null;
              case 6:
                if (c && f.stateNode != null)
                  (y = c.memoizedProps),
                    ki
                      ? y !== A && ja(f)
                      : Ds &&
                        (y !== A
                          ? ((f.stateNode = qn(A, yr.current, ji.current, f)),
                            ja(f))
                          : (f.stateNode = c.stateNode));
                else {
                  if (typeof A != "string" && f.stateNode === null)
                    throw Error(a(166));
                  if (((c = yr.current), (y = ji.current), De(f))) {
                    if (!fa) throw Error(a(176));
                    if (
                      ((c = f.stateNode),
                      (y = f.memoizedProps),
                      (A = null),
                      (w = ha),
                      w !== null)
                    )
                      switch (w.tag) {
                        case 27:
                        case 5:
                          A = w.memoizedProps;
                      }
                    rm(c, y, f, A) || ie(f);
                  } else f.stateNode = qn(A, c, y, f);
                }
                return pi(f), null;
              case 13:
                if (
                  ((A = f.memoizedState),
                  c === null ||
                    (c.memoizedState !== null &&
                      c.memoizedState.dehydrated !== null))
                ) {
                  if (((w = De(f)), A !== null && A.dehydrated !== null)) {
                    if (c === null) {
                      if (!w) throw Error(a(318));
                      if (!fa) throw Error(a(344));
                      if (
                        ((w = f.memoizedState),
                        (w = w !== null ? w.dehydrated : null),
                        !w)
                      )
                        throw Error(a(317));
                      Wg(w, f);
                    } else
                      je(),
                        (f.flags & 128) === 0 && (f.memoizedState = null),
                        (f.flags |= 4);
                    pi(f), (w = !1);
                  } else Os !== null && (Vu(Os), (Os = null)), (w = !0);
                  if (!w) return f.flags & 256 ? (Ke(f), f) : (Ke(f), null);
                }
                if ((Ke(f), (f.flags & 128) !== 0)) return (f.lanes = y), f;
                if (
                  ((y = A !== null),
                  (c = c !== null && c.memoizedState !== null),
                  y)
                ) {
                  (A = f.child),
                    (w = null),
                    A.alternate !== null &&
                      A.alternate.memoizedState !== null &&
                      A.alternate.memoizedState.cachePool !== null &&
                      (w = A.alternate.memoizedState.cachePool.pool);
                  var U = null;
                  A.memoizedState !== null &&
                    A.memoizedState.cachePool !== null &&
                    (U = A.memoizedState.cachePool.pool),
                    U !== w && (A.flags |= 2048);
                }
                return (
                  y !== c && y && (f.child.flags |= 8192),
                  dc(f, f.updateQueue),
                  pi(f),
                  null
                );
              case 4:
                return (
                  It(),
                  Lu(c, f),
                  c === null && Di(f.stateNode.containerInfo),
                  pi(f),
                  null
                );
              case 10:
                return jr(f.type), pi(f), null;
              case 19:
                if ((S(Xi), (w = f.memoizedState), w === null))
                  return pi(f), null;
                if (
                  ((A = (f.flags & 128) !== 0), (U = w.rendering), U === null)
                )
                  if (A) pc(w, !1);
                  else {
                    if (ii !== 0 || (c !== null && (c.flags & 128) !== 0))
                      for (c = f.child; c !== null; ) {
                        if (((U = ka(c)), U !== null)) {
                          for (
                            f.flags |= 128,
                              pc(w, !1),
                              c = U.updateQueue,
                              f.updateQueue = c,
                              dc(f, c),
                              f.subtreeFlags = 0,
                              c = y,
                              y = f.child;
                            y !== null;

                          )
                            Xu(y, c), (y = y.sibling);
                          return R(Xi, (Xi.current & 1) | 2), f.child;
                        }
                        c = c.sibling;
                      }
                    w.tail !== null &&
                      Us() > Gc &&
                      ((f.flags |= 128),
                      (A = !0),
                      pc(w, !1),
                      (f.lanes = 4194304));
                  }
                else {
                  if (!A)
                    if (((c = ka(U)), c !== null)) {
                      if (
                        ((f.flags |= 128),
                        (A = !0),
                        (c = c.updateQueue),
                        (f.updateQueue = c),
                        dc(f, c),
                        pc(w, !0),
                        w.tail === null &&
                          w.tailMode === "hidden" &&
                          !U.alternate &&
                          !On)
                      )
                        return pi(f), null;
                    } else
                      2 * Us() - w.renderingStartTime > Gc &&
                        y !== 536870912 &&
                        ((f.flags |= 128),
                        (A = !0),
                        pc(w, !1),
                        (f.lanes = 4194304));
                  w.isBackwards
                    ? ((U.sibling = f.child), (f.child = U))
                    : ((c = w.last),
                      c !== null ? (c.sibling = U) : (f.child = U),
                      (w.last = U));
                }
                return w.tail !== null
                  ? ((f = w.tail),
                    (w.rendering = f),
                    (w.tail = f.sibling),
                    (w.renderingStartTime = Us()),
                    (f.sibling = null),
                    (c = Xi.current),
                    R(Xi, A ? (c & 1) | 2 : c & 1),
                    f)
                  : (pi(f), null);
              case 22:
              case 23:
                return (
                  Ke(f),
                  Ri(),
                  (A = f.memoizedState !== null),
                  c !== null
                    ? (c.memoizedState !== null) !== A && (f.flags |= 8192)
                    : A && (f.flags |= 8192),
                  A
                    ? (y & 536870912) !== 0 &&
                      (f.flags & 128) === 0 &&
                      (pi(f), f.subtreeFlags & 6 && (f.flags |= 8192))
                    : pi(f),
                  (y = f.updateQueue),
                  y !== null && dc(f, y.retryQueue),
                  (y = null),
                  c !== null &&
                    c.memoizedState !== null &&
                    c.memoizedState.cachePool !== null &&
                    (y = c.memoizedState.cachePool.pool),
                  (A = null),
                  f.memoizedState !== null &&
                    f.memoizedState.cachePool !== null &&
                    (A = f.memoizedState.cachePool.pool),
                  A !== y && (f.flags |= 2048),
                  c !== null && S(Ar),
                  null
                );
              case 24:
                return (
                  (y = null),
                  c !== null && (y = c.memoizedState.cache),
                  f.memoizedState.cache !== y && (f.flags |= 2048),
                  jr(li),
                  pi(f),
                  null
                );
              case 25:
                return null;
            }
            throw Error(a(156, f.tag));
          }
          function x1(c, f) {
            switch ((Rt(f), f.tag)) {
              case 1:
                return (
                  (c = f.flags),
                  c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
                );
              case 3:
                return (
                  jr(li),
                  It(),
                  (c = f.flags),
                  (c & 65536) !== 0 && (c & 128) === 0
                    ? ((f.flags = (c & -65537) | 128), f)
                    : null
                );
              case 26:
              case 27:
              case 5:
                return re(f), null;
              case 13:
                if (
                  (Ke(f),
                  (c = f.memoizedState),
                  c !== null && c.dehydrated !== null)
                ) {
                  if (f.alternate === null) throw Error(a(340));
                  je();
                }
                return (
                  (c = f.flags),
                  c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
                );
              case 19:
                return S(Xi), null;
              case 4:
                return It(), null;
              case 10:
                return jr(f.type), null;
              case 22:
              case 23:
                return (
                  Ke(f),
                  Ri(),
                  c !== null && S(Ar),
                  (c = f.flags),
                  c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
                );
              case 24:
                return jr(li), null;
              case 25:
                return null;
              default:
                return null;
            }
          }
          function dg(c, f) {
            switch ((Rt(f), f.tag)) {
              case 3:
                jr(li), It();
                break;
              case 26:
              case 27:
              case 5:
                re(f);
                break;
              case 4:
                It();
                break;
              case 13:
                Ke(f);
                break;
              case 19:
                S(Xi);
                break;
              case 10:
                jr(f.type);
                break;
              case 22:
              case 23:
                Ke(f), Ri(), c !== null && S(Ar);
                break;
              case 24:
                jr(li);
            }
          }
          function Iu(c, f) {
            try {
              var y = f.updateQueue,
                A = y !== null ? y.lastEffect : null;
              if (A !== null) {
                var w = A.next;
                y = w;
                do {
                  if ((y.tag & c) === c) {
                    A = void 0;
                    var U = y.create,
                      q = y.inst;
                    (A = U()), (q.destroy = A);
                  }
                  y = y.next;
                } while (y !== w);
              }
            } catch (lt) {
              kn(f, f.return, lt);
            }
          }
          function Bo(c, f, y) {
            try {
              var A = f.updateQueue,
                w = A !== null ? A.lastEffect : null;
              if (w !== null) {
                var U = w.next;
                A = U;
                do {
                  if ((A.tag & c) === c) {
                    var q = A.inst,
                      lt = q.destroy;
                    if (lt !== void 0) {
                      (q.destroy = void 0), (w = f);
                      var St = y;
                      try {
                        lt();
                      } catch (Xt) {
                        kn(w, St, Xt);
                      }
                    }
                  }
                  A = A.next;
                } while (A !== U);
              }
            } catch (Xt) {
              kn(f, f.return, Xt);
            }
          }
          function pg(c) {
            var f = c.updateQueue;
            if (f !== null) {
              var y = c.stateNode;
              try {
                Et(f, y);
              } catch (A) {
                kn(c, c.return, A);
              }
            }
          }
          function Xa(c, f, y) {
            (y.props = Vr(c.type, c.memoizedProps)),
              (y.state = c.memoizedState);
            try {
              y.componentWillUnmount();
            } catch (A) {
              kn(c, f, A);
            }
          }
          function Ys(c, f) {
            try {
              var y = c.ref;
              if (y !== null) {
                var A = c.stateNode;
                switch (c.tag) {
                  case 26:
                  case 27:
                  case 5:
                    var w = Tc(A);
                    break;
                  default:
                    w = A;
                }
                typeof y == "function"
                  ? (c.refCleanup = y(w))
                  : (y.current = w);
              }
            } catch (U) {
              kn(c, f, U);
            }
          }
          function Wa(c, f) {
            var y = c.ref,
              A = c.refCleanup;
            if (y !== null)
              if (typeof A == "function")
                try {
                  A();
                } catch (w) {
                  kn(c, f, w);
                } finally {
                  (c.refCleanup = null),
                    (c = c.alternate),
                    c != null && (c.refCleanup = null);
                }
              else if (typeof y == "function")
                try {
                  y(null);
                } catch (w) {
                  kn(c, f, w);
                }
              else y.current = null;
          }
          function Ep(c) {
            var f = c.type,
              y = c.memoizedProps,
              A = c.stateNode;
            try {
              S1(A, f, y, c);
            } catch (w) {
              kn(c, c.return, w);
            }
          }
          function Tp(c, f, y) {
            try {
              Dg(c.stateNode, c.type, y, f, c);
            } catch (A) {
              kn(c, c.return, A);
            }
          }
          function wp(c) {
            return (
              c.tag === 5 ||
              c.tag === 3 ||
              (os ? c.tag === 26 : !1) ||
              (ti ? c.tag === 27 : !1) ||
              c.tag === 4
            );
          }
          function Pu(c) {
            t: for (;;) {
              for (; c.sibling === null; ) {
                if (c.return === null || wp(c.return)) return null;
                c = c.return;
              }
              for (
                c.sibling.return = c.return, c = c.sibling;
                c.tag !== 5 &&
                c.tag !== 6 &&
                (!ti || c.tag !== 27) &&
                c.tag !== 18;

              ) {
                if (c.flags & 2 || c.child === null || c.tag === 4) continue t;
                (c.child.return = c), (c = c.child);
              }
              if (!(c.flags & 2)) return c.stateNode;
            }
          }
          function Cp(c, f, y) {
            var A = c.tag;
            if (A === 5 || A === 6)
              (c = c.stateNode), f ? Og(y, c, f) : Zp(y, c);
            else if (
              !(A === 4 || (ti && A === 27)) &&
              ((c = c.child), c !== null)
            )
              for (Cp(c, f, y), c = c.sibling; c !== null; )
                Cp(c, f, y), (c = c.sibling);
          }
          function Xr(c, f, y) {
            var A = c.tag;
            if (A === 5 || A === 6)
              (c = c.stateNode), f ? Ug(y, c, f) : Rg(y, c);
            else if (
              !(A === 4 || (ti && A === 27)) &&
              ((c = c.child), c !== null)
            )
              for (Xr(c, f, y), c = c.sibling; c !== null; )
                Xr(c, f, y), (c = c.sibling);
          }
          function yh(c, f, y) {
            c = c.containerInfo;
            try {
              Bc(c, y);
            } catch (A) {
              kn(f, f.return, A);
            }
          }
          function zu(c, f) {
            for (Oh(c.containerInfo), cn = f; cn !== null; )
              if (
                ((c = cn),
                (f = c.child),
                (c.subtreeFlags & 1028) !== 0 && f !== null)
              )
                (f.return = c), (cn = f);
              else
                for (; cn !== null; ) {
                  c = cn;
                  var y = c.alternate;
                  switch (((f = c.flags), c.tag)) {
                    case 0:
                      break;
                    case 11:
                    case 15:
                      break;
                    case 1:
                      if ((f & 1024) !== 0 && y !== null) {
                        f = void 0;
                        var A = c,
                          w = y.memoizedProps;
                        y = y.memoizedState;
                        var U = A.stateNode;
                        try {
                          var q = Vr(A.type, w, A.elementType === A.type);
                          (f = U.getSnapshotBeforeUpdate(q, y)),
                            (U.__reactInternalSnapshotBeforeUpdate = f);
                        } catch (lt) {
                          kn(A, A.return, lt);
                        }
                      }
                      break;
                    case 3:
                      (f & 1024) !== 0 && ki && zg(c.stateNode.containerInfo);
                      break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                      break;
                    default:
                      if ((f & 1024) !== 0) throw Error(a(163));
                  }
                  if (((f = c.sibling), f !== null)) {
                    (f.return = c.return), (cn = f);
                    break;
                  }
                  cn = c.return;
                }
            return (q = En), (En = !1), q;
          }
          function xh(c, f, y) {
            var A = y.flags;
            switch (y.tag) {
              case 0:
              case 11:
              case 15:
                Yr(c, y), A & 4 && Iu(5, y);
                break;
              case 1:
                if ((Yr(c, y), A & 4))
                  if (((c = y.stateNode), f === null))
                    try {
                      c.componentDidMount();
                    } catch (lt) {
                      kn(y, y.return, lt);
                    }
                  else {
                    var w = Vr(y.type, f.memoizedProps);
                    f = f.memoizedState;
                    try {
                      c.componentDidUpdate(
                        w,
                        f,
                        c.__reactInternalSnapshotBeforeUpdate
                      );
                    } catch (lt) {
                      kn(y, y.return, lt);
                    }
                  }
                A & 64 && pg(y), A & 512 && Ys(y, y.return);
                break;
              case 3:
                if ((Yr(c, y), A & 64 && ((A = y.updateQueue), A !== null))) {
                  if (((c = null), y.child !== null))
                    switch (y.child.tag) {
                      case 27:
                      case 5:
                        c = Tc(y.child.stateNode);
                        break;
                      case 1:
                        c = y.child.stateNode;
                    }
                  try {
                    Et(A, c);
                  } catch (lt) {
                    kn(y, y.return, lt);
                  }
                }
                break;
              case 26:
                if (os) {
                  Yr(c, y), A & 512 && Ys(y, y.return);
                  break;
                }
              case 27:
              case 5:
                Yr(c, y),
                  f === null && A & 4 && Ep(y),
                  A & 512 && Ys(y, y.return);
                break;
              case 12:
                Yr(c, y);
                break;
              case 13:
                Yr(c, y), A & 4 && _h(c, y);
                break;
              case 22:
                if (((w = y.memoizedState !== null || Sr), !w)) {
                  f = (f !== null && f.memoizedState !== null) || Ai;
                  var U = Sr,
                    q = Ai;
                  (Sr = w),
                    (Ai = f) && !q
                      ? qr(c, y, (y.subtreeFlags & 8772) !== 0)
                      : Yr(c, y),
                    (Sr = U),
                    (Ai = q);
                }
                A & 512 &&
                  (y.memoizedProps.mode === "manual"
                    ? Ys(y, y.return)
                    : Wa(y, y.return));
                break;
              default:
                Yr(c, y);
            }
          }
          function Rp(c) {
            var f = c.alternate;
            f !== null && ((c.alternate = null), Rp(f)),
              (c.child = null),
              (c.deletions = null),
              (c.sibling = null),
              c.tag === 5 && ((f = c.stateNode), f !== null && A1(f)),
              (c.stateNode = null),
              (c.return = null),
              (c.dependencies = null),
              (c.memoizedProps = null),
              (c.memoizedState = null),
              (c.pendingProps = null),
              (c.stateNode = null),
              (c.updateQueue = null);
          }
          function la(c, f, y) {
            for (y = y.child; y !== null; ) Do(c, f, y), (y = y.sibling);
          }
          function Do(c, f, y) {
            if (Ja && typeof Ja.onCommitFiberUnmount == "function")
              try {
                Ja.onCommitFiberUnmount(Oi, y);
              } catch {}
            switch (y.tag) {
              case 26:
                if (os) {
                  Ai || Wa(y, f),
                    la(c, f, y),
                    y.memoizedState
                      ? bl(y.memoizedState)
                      : y.stateNode && Dc(y.stateNode);
                  break;
                }
              case 27:
                if (ti) {
                  Ai || Wa(y, f);
                  var A = We,
                    w = vn;
                  (We = y.stateNode),
                    la(c, f, y),
                    jo(y.stateNode),
                    (We = A),
                    (vn = w);
                  break;
                }
              case 5:
                Ai || Wa(y, f);
              case 6:
                if (ki) {
                  if (
                    ((A = We),
                    (w = vn),
                    (We = null),
                    la(c, f, y),
                    (We = A),
                    (vn = w),
                    We !== null)
                  )
                    if (vn)
                      try {
                        Ng(We, y.stateNode);
                      } catch (U) {
                        kn(y, f, U);
                      }
                    else
                      try {
                        Qp(We, y.stateNode);
                      } catch (U) {
                        kn(y, f, U);
                      }
                } else la(c, f, y);
                break;
              case 18:
                ki &&
                  We !== null &&
                  (vn ? ef(We, y.stateNode) : qg(We, y.stateNode));
                break;
              case 4:
                ki
                  ? ((A = We),
                    (w = vn),
                    (We = y.stateNode.containerInfo),
                    (vn = !0),
                    la(c, f, y),
                    (We = A),
                    (vn = w))
                  : (Ds && yh(y.stateNode, y, tf()), la(c, f, y));
                break;
              case 0:
              case 11:
              case 14:
              case 15:
                Ai || Bo(2, y, f), Ai || Bo(4, y, f), la(c, f, y);
                break;
              case 1:
                Ai ||
                  (Wa(y, f),
                  (A = y.stateNode),
                  typeof A.componentWillUnmount == "function" && Xa(y, f, A)),
                  la(c, f, y);
                break;
              case 21:
                la(c, f, y);
                break;
              case 22:
                Ai || Wa(y, f),
                  (Ai = (A = Ai) || y.memoizedState !== null),
                  la(c, f, y),
                  (Ai = A);
                break;
              default:
                la(c, f, y);
            }
          }
          function _h(c, f) {
            if (
              fa &&
              f.memoizedState === null &&
              ((c = f.alternate),
              c !== null &&
                ((c = c.memoizedState),
                c !== null && ((c = c.dehydrated), c !== null)))
            )
              try {
                w1(c);
              } catch (y) {
                kn(f, f.return, y);
              }
          }
          function mg(c) {
            switch (c.tag) {
              case 13:
              case 19:
                var f = c.stateNode;
                return f === null && (f = c.stateNode = new jn()), f;
              case 22:
                return (
                  (c = c.stateNode),
                  (f = c._retryCache),
                  f === null && (f = c._retryCache = new jn()),
                  f
                );
              default:
                throw Error(a(435, c.tag));
            }
          }
          function Wr(c, f) {
            var y = mg(c);
            f.forEach(function (A) {
              var w = zo.bind(null, c, A);
              y.has(A) || (y.add(A), A.then(w, w));
            });
          }
          function Ba(c, f) {
            var y = f.deletions;
            if (y !== null)
              for (var A = 0; A < y.length; A++) {
                var w = y[A],
                  U = c,
                  q = f;
                if (ki) {
                  var lt = q;
                  t: for (; lt !== null; ) {
                    switch (lt.tag) {
                      case 27:
                      case 5:
                        (We = lt.stateNode), (vn = !1);
                        break t;
                      case 3:
                        (We = lt.stateNode.containerInfo), (vn = !0);
                        break t;
                      case 4:
                        (We = lt.stateNode.containerInfo), (vn = !0);
                        break t;
                    }
                    lt = lt.return;
                  }
                  if (We === null) throw Error(a(160));
                  Do(U, q, w), (We = null), (vn = !1);
                } else Do(U, q, w);
                (U = w.alternate),
                  U !== null && (U.return = null),
                  (w.return = null);
              }
            if (f.subtreeFlags & 13878)
              for (f = f.child; f !== null; ) Bp(f, c), (f = f.sibling);
          }
          function Bp(c, f) {
            var y = c.alternate,
              A = c.flags;
            switch (c.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Ba(f, c),
                  Ya(c),
                  A & 4 && (Bo(3, c, c.return), Iu(3, c), Bo(5, c, c.return));
                break;
              case 1:
                Ba(f, c),
                  Ya(c),
                  A & 512 && (Ai || y === null || Wa(y, y.return)),
                  A & 64 &&
                    Sr &&
                    ((c = c.updateQueue),
                    c !== null &&
                      ((A = c.callbacks),
                      A !== null &&
                        ((y = c.shared.hiddenCallbacks),
                        (c.shared.hiddenCallbacks =
                          y === null ? A : y.concat(A)))));
                break;
              case 26:
                if (os) {
                  var w = gi;
                  Ba(f, c),
                    Ya(c),
                    A & 512 && (Ai || y === null || Wa(y, y.return)),
                    A & 4 &&
                      ((A = y !== null ? y.memoizedState : null),
                      (f = c.memoizedState),
                      y === null
                        ? f === null
                          ? c.stateNode === null
                            ? (c.stateNode = af(w, c.type, c.memoizedProps, c))
                            : sf(w, c.type, c.stateNode)
                          : (c.stateNode = Jg(w, f, c.memoizedProps))
                        : A !== f
                        ? (A === null
                            ? y.stateNode !== null && Dc(y.stateNode)
                            : bl(A),
                          f === null
                            ? sf(w, c.type, c.stateNode)
                            : Jg(w, f, c.memoizedProps))
                        : f === null &&
                          c.stateNode !== null &&
                          Tp(c, c.memoizedProps, y.memoizedProps));
                  break;
                }
              case 27:
                if (ti && A & 4 && c.alternate === null) {
                  w = c.stateNode;
                  var U = c.memoizedProps;
                  try {
                    ko(w), tv(c.type, U, w, c);
                  } catch (he) {
                    kn(c, c.return, he);
                  }
                }
              case 5:
                if (
                  (Ba(f, c),
                  Ya(c),
                  A & 512 && (Ai || y === null || Wa(y, y.return)),
                  ki)
                ) {
                  if (c.flags & 32) {
                    f = c.stateNode;
                    try {
                      $p(f);
                    } catch (he) {
                      kn(c, c.return, he);
                    }
                  }
                  A & 4 &&
                    c.stateNode != null &&
                    ((f = c.memoizedProps),
                    Tp(c, f, y !== null ? y.memoizedProps : f)),
                    A & 1024 && (fm = !0);
                }
                break;
              case 6:
                if ((Ba(f, c), Ya(c), A & 4 && ki)) {
                  if (c.stateNode === null) throw Error(a(162));
                  (A = c.memoizedProps),
                    (y = y !== null ? y.memoizedProps : A),
                    (f = c.stateNode);
                  try {
                    Bg(f, y, A);
                  } catch (he) {
                    kn(c, c.return, he);
                  }
                }
                break;
              case 3:
                if (
                  (os
                    ? (Zg(),
                      (w = gi),
                      (gi = kh(f.containerInfo)),
                      Ba(f, c),
                      (gi = w))
                    : Ba(f, c),
                  Ya(c),
                  A & 4)
                ) {
                  if (ki && fa && y !== null && y.memoizedState.isDehydrated)
                    try {
                      T1(f.containerInfo);
                    } catch (he) {
                      kn(c, c.return, he);
                    }
                  if (Ds) {
                    (A = f.containerInfo), (y = f.pendingChildren);
                    try {
                      Bc(A, y);
                    } catch (he) {
                      kn(c, c.return, he);
                    }
                  }
                }
                fm && ((fm = !1), gg(c));
                break;
              case 4:
                os
                  ? ((y = gi),
                    (gi = kh(c.stateNode.containerInfo)),
                    Ba(f, c),
                    Ya(c),
                    (gi = y))
                  : (Ba(f, c), Ya(c)),
                  A & 4 &&
                    Ds &&
                    yh(c.stateNode, c, c.stateNode.pendingChildren);
                break;
              case 12:
                Ba(f, c), Ya(c);
                break;
              case 13:
                Ba(f, c),
                  Ya(c),
                  c.child.flags & 8192 &&
                    (c.memoizedState !== null) !=
                      (y !== null && y.memoizedState !== null) &&
                    (Ia = Us()),
                  A & 4 &&
                    ((A = c.updateQueue),
                    A !== null && ((c.updateQueue = null), Wr(c, A)));
                break;
              case 22:
                A & 512 && (Ai || y === null || Wa(y, y.return)),
                  (w = c.memoizedState !== null);
                var q = y !== null && y.memoizedState !== null,
                  lt = Sr,
                  St = Ai;
                if (
                  ((Sr = lt || w),
                  (Ai = St || q),
                  Ba(f, c),
                  (Ai = St),
                  (Sr = lt),
                  Ya(c),
                  (f = c.stateNode),
                  (f._current = c),
                  (f._visibility &= -3),
                  (f._visibility |= f._pendingVisibility & 2),
                  A & 8192 &&
                    ((f._visibility = w
                      ? f._visibility & -2
                      : f._visibility | 1),
                    w && ((f = Sr || Ai), y === null || q || f || mc(c)),
                    ki &&
                      (c.memoizedProps === null ||
                        c.memoizedProps.mode !== "manual")))
                ) {
                  t: if (((y = null), ki))
                    for (f = c; ; ) {
                      if (
                        f.tag === 5 ||
                        (os && f.tag === 26) ||
                        (ti && f.tag === 27)
                      ) {
                        if (y === null) {
                          q = y = f;
                          try {
                            (U = q.stateNode),
                              w ? Lg(U) : Pg(q.stateNode, q.memoizedProps);
                          } catch (he) {
                            kn(q, q.return, he);
                          }
                        }
                      } else if (f.tag === 6) {
                        if (y === null) {
                          q = f;
                          try {
                            var Xt = q.stateNode;
                            w ? Ig(Xt) : M1(Xt, q.memoizedProps);
                          } catch (he) {
                            kn(q, q.return, he);
                          }
                        }
                      } else if (
                        ((f.tag !== 22 && f.tag !== 23) ||
                          f.memoizedState === null ||
                          f === c) &&
                        f.child !== null
                      ) {
                        (f.child.return = f), (f = f.child);
                        continue;
                      }
                      if (f === c) break t;
                      for (; f.sibling === null; ) {
                        if (f.return === null || f.return === c) break t;
                        y === f && (y = null), (f = f.return);
                      }
                      y === f && (y = null),
                        (f.sibling.return = f.return),
                        (f = f.sibling);
                    }
                }
                A & 4 &&
                  ((A = c.updateQueue),
                  A !== null &&
                    ((y = A.retryQueue),
                    y !== null && ((A.retryQueue = null), Wr(c, y))));
                break;
              case 19:
                Ba(f, c),
                  Ya(c),
                  A & 4 &&
                    ((A = c.updateQueue),
                    A !== null && ((c.updateQueue = null), Wr(c, A)));
                break;
              case 21:
                break;
              default:
                Ba(f, c), Ya(c);
            }
          }
          function Ya(c) {
            var f = c.flags;
            if (f & 2) {
              try {
                if (ki && (!ti || c.tag !== 27)) {
                  t: {
                    for (var y = c.return; y !== null; ) {
                      if (wp(y)) {
                        var A = y;
                        break t;
                      }
                      y = y.return;
                    }
                    throw Error(a(160));
                  }
                  switch (A.tag) {
                    case 27:
                      if (ti) {
                        var w = A.stateNode,
                          U = Pu(c);
                        Xr(c, U, w);
                        break;
                      }
                    case 5:
                      var q = A.stateNode;
                      A.flags & 32 && ($p(q), (A.flags &= -33));
                      var lt = Pu(c);
                      Xr(c, lt, q);
                      break;
                    case 3:
                    case 4:
                      var St = A.stateNode.containerInfo,
                        Xt = Pu(c);
                      Cp(c, Xt, St);
                      break;
                    default:
                      throw Error(a(161));
                  }
                }
              } catch (he) {
                kn(c, c.return, he);
              }
              c.flags &= -3;
            }
            f & 4096 && (c.flags &= -4097);
          }
          function gg(c) {
            if (c.subtreeFlags & 1024)
              for (c = c.child; c !== null; ) {
                var f = c;
                gg(f),
                  f.tag === 5 && f.flags & 1024 && Ih(f.stateNode),
                  (c = c.sibling);
              }
          }
          function Yr(c, f) {
            if (f.subtreeFlags & 8772)
              for (f = f.child; f !== null; )
                xh(c, f.alternate, f), (f = f.sibling);
          }
          function mc(c) {
            for (c = c.child; c !== null; ) {
              var f = c;
              switch (f.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Bo(4, f, f.return), mc(f);
                  break;
                case 1:
                  Wa(f, f.return);
                  var y = f.stateNode;
                  typeof y.componentWillUnmount == "function" &&
                    Xa(f, f.return, y),
                    mc(f);
                  break;
                case 26:
                case 27:
                case 5:
                  Wa(f, f.return), mc(f);
                  break;
                case 22:
                  Wa(f, f.return), f.memoizedState === null && mc(f);
                  break;
                default:
                  mc(f);
              }
              c = c.sibling;
            }
          }
          function qr(c, f, y) {
            for (
              y = y && (f.subtreeFlags & 8772) !== 0, f = f.child;
              f !== null;

            ) {
              var A = f.alternate,
                w = c,
                U = f,
                q = U.flags;
              switch (U.tag) {
                case 0:
                case 11:
                case 15:
                  qr(w, U, y), Iu(4, U);
                  break;
                case 1:
                  if (
                    (qr(w, U, y),
                    (A = U),
                    (w = A.stateNode),
                    typeof w.componentDidMount == "function")
                  )
                    try {
                      w.componentDidMount();
                    } catch (Xt) {
                      kn(A, A.return, Xt);
                    }
                  if (((A = U), (w = A.updateQueue), w !== null)) {
                    var lt = A.stateNode;
                    try {
                      var St = w.shared.hiddenCallbacks;
                      if (St !== null)
                        for (
                          w.shared.hiddenCallbacks = null, w = 0;
                          w < St.length;
                          w++
                        )
                          st(St[w], lt);
                    } catch (Xt) {
                      kn(A, A.return, Xt);
                    }
                  }
                  y && q & 64 && pg(U), Ys(U, U.return);
                  break;
                case 26:
                case 27:
                case 5:
                  qr(w, U, y),
                    y && A === null && q & 4 && Ep(U),
                    Ys(U, U.return);
                  break;
                case 12:
                  qr(w, U, y);
                  break;
                case 13:
                  qr(w, U, y), y && q & 4 && _h(w, U);
                  break;
                case 22:
                  U.memoizedState === null && qr(w, U, y), Ys(U, U.return);
                  break;
                default:
                  qr(w, U, y);
              }
              f = f.sibling;
            }
          }
          function bh(c, f) {
            var y = null;
            c !== null &&
              c.memoizedState !== null &&
              c.memoizedState.cachePool !== null &&
              (y = c.memoizedState.cachePool.pool),
              (c = null),
              f.memoizedState !== null &&
                f.memoizedState.cachePool !== null &&
                (c = f.memoizedState.cachePool.pool),
              c !== y && (c != null && c.refCount++, y != null && Nu(y));
          }
          function Fu(c, f) {
            (c = null),
              f.alternate !== null && (c = f.alternate.memoizedState.cache),
              (f = f.memoizedState.cache),
              f !== c && (f.refCount++, c != null && Nu(c));
          }
          function Qi(c, f, y, A) {
            if (f.subtreeFlags & 10256)
              for (f = f.child; f !== null; ) Dp(c, f, y, A), (f = f.sibling);
          }
          function Dp(c, f, y, A) {
            var w = f.flags;
            switch (f.tag) {
              case 0:
              case 11:
              case 15:
                Qi(c, f, y, A), w & 2048 && Iu(9, f);
                break;
              case 3:
                Qi(c, f, y, A),
                  w & 2048 &&
                    ((c = null),
                    f.alternate !== null &&
                      (c = f.alternate.memoizedState.cache),
                    (f = f.memoizedState.cache),
                    f !== c && (f.refCount++, c != null && Nu(c)));
                break;
              case 12:
                if (w & 2048) {
                  Qi(c, f, y, A), (c = f.stateNode);
                  try {
                    var U = f.memoizedProps,
                      q = U.id,
                      lt = U.onPostCommit;
                    typeof lt == "function" &&
                      lt(
                        q,
                        f.alternate === null ? "mount" : "update",
                        c.passiveEffectDuration,
                        -0
                      );
                  } catch (St) {
                    kn(f, f.return, St);
                  }
                } else Qi(c, f, y, A);
                break;
              case 23:
                break;
              case 22:
                (U = f.stateNode),
                  f.memoizedState !== null
                    ? U._visibility & 4
                      ? Qi(c, f, y, A)
                      : xa(c, f)
                    : U._visibility & 4
                    ? Qi(c, f, y, A)
                    : ((U._visibility |= 4),
                      ca(c, f, y, A, (f.subtreeFlags & 10256) !== 0)),
                  w & 2048 && bh(f.alternate, f);
                break;
              case 24:
                Qi(c, f, y, A), w & 2048 && Fu(f.alternate, f);
                break;
              default:
                Qi(c, f, y, A);
            }
          }
          function ca(c, f, y, A, w) {
            for (
              w = w && (f.subtreeFlags & 10256) !== 0, f = f.child;
              f !== null;

            ) {
              var U = c,
                q = f,
                lt = y,
                St = A,
                Xt = q.flags;
              switch (q.tag) {
                case 0:
                case 11:
                case 15:
                  ca(U, q, lt, St, w), Iu(8, q);
                  break;
                case 23:
                  break;
                case 22:
                  var he = q.stateNode;
                  q.memoizedState !== null
                    ? he._visibility & 4
                      ? ca(U, q, lt, St, w)
                      : xa(U, q)
                    : ((he._visibility |= 4), ca(U, q, lt, St, w)),
                    w && Xt & 2048 && bh(q.alternate, q);
                  break;
                case 24:
                  ca(U, q, lt, St, w), w && Xt & 2048 && Fu(q.alternate, q);
                  break;
                default:
                  ca(U, q, lt, St, w);
              }
              f = f.sibling;
            }
          }
          function xa(c, f) {
            if (f.subtreeFlags & 10256)
              for (f = f.child; f !== null; ) {
                var y = c,
                  A = f,
                  w = A.flags;
                switch (A.tag) {
                  case 22:
                    xa(y, A), w & 2048 && bh(A.alternate, A);
                    break;
                  case 24:
                    xa(y, A), w & 2048 && Fu(A.alternate, A);
                    break;
                  default:
                    xa(y, A);
                }
                f = f.sibling;
              }
          }
          function Ts(c) {
            if (c.subtreeFlags & ps)
              for (c = c.child; c !== null; ) Ah(c), (c = c.sibling);
          }
          function Ah(c) {
            switch (c.tag) {
              case 26:
                Ts(c),
                  c.flags & ps &&
                    (c.memoizedState !== null
                      ? $g(gi, c.memoizedState, c.memoizedProps)
                      : Oa(c.type, c.memoizedProps));
                break;
              case 5:
                Ts(c), c.flags & ps && Oa(c.type, c.memoizedProps);
                break;
              case 3:
              case 4:
                if (os) {
                  var f = gi;
                  (gi = kh(c.stateNode.containerInfo)), Ts(c), (gi = f);
                } else Ts(c);
                break;
              case 22:
                c.memoizedState === null &&
                  ((f = c.alternate),
                  f !== null && f.memoizedState !== null
                    ? ((f = ps), (ps = 16777216), Ts(c), (ps = f))
                    : Ts(c));
                break;
              default:
                Ts(c);
            }
          }
          function Hu(c) {
            var f = c.alternate;
            if (f !== null && ((c = f.child), c !== null)) {
              f.child = null;
              do (f = c.sibling), (c.sibling = null), (c = f);
              while (c !== null);
            }
          }
          function Uo(c) {
            var f = c.deletions;
            if ((c.flags & 16) !== 0) {
              if (f !== null)
                for (var y = 0; y < f.length; y++) {
                  var A = f[y];
                  (cn = A), Up(A, c);
                }
              Hu(c);
            }
            if (c.subtreeFlags & 10256)
              for (c = c.child; c !== null; ) Sh(c), (c = c.sibling);
          }
          function Sh(c) {
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                Uo(c), c.flags & 2048 && Bo(9, c, c.return);
                break;
              case 3:
                Uo(c);
                break;
              case 12:
                Uo(c);
                break;
              case 22:
                var f = c.stateNode;
                c.memoizedState !== null &&
                f._visibility & 4 &&
                (c.return === null || c.return.tag !== 13)
                  ? ((f._visibility &= -5), Kr(c))
                  : Uo(c);
                break;
              default:
                Uo(c);
            }
          }
          function Kr(c) {
            var f = c.deletions;
            if ((c.flags & 16) !== 0) {
              if (f !== null)
                for (var y = 0; y < f.length; y++) {
                  var A = f[y];
                  (cn = A), Up(A, c);
                }
              Hu(c);
            }
            for (c = c.child; c !== null; ) {
              switch (((f = c), f.tag)) {
                case 0:
                case 11:
                case 15:
                  Bo(8, f, f.return), Kr(f);
                  break;
                case 22:
                  (y = f.stateNode),
                    y._visibility & 4 && ((y._visibility &= -5), Kr(f));
                  break;
                default:
                  Kr(f);
              }
              c = c.sibling;
            }
          }
          function Up(c, f) {
            for (; cn !== null; ) {
              var y = cn;
              switch (y.tag) {
                case 0:
                case 11:
                case 15:
                  Bo(8, y, f);
                  break;
                case 23:
                case 22:
                  if (
                    y.memoizedState !== null &&
                    y.memoizedState.cachePool !== null
                  ) {
                    var A = y.memoizedState.cachePool.pool;
                    A != null && A.refCount++;
                  }
                  break;
                case 24:
                  Nu(y.memoizedState.cache);
              }
              if (((A = y.child), A !== null)) (A.return = y), (cn = A);
              else
                t: for (y = c; cn !== null; ) {
                  A = cn;
                  var w = A.sibling,
                    U = A.return;
                  if ((Rp(A), A === y)) {
                    cn = null;
                    break t;
                  }
                  if (w !== null) {
                    (w.return = U), (cn = w);
                    break t;
                  }
                  cn = U;
                }
            }
          }
          function gc(c) {
            var f = Ag(c);
            if (f != null) {
              if (typeof f.memoizedProps["data-testname"] != "string")
                throw Error(a(364));
              return f;
            }
            if (((c = Kp(c)), c === null)) throw Error(a(362));
            return c.stateNode.current;
          }
          function Oo(c, f) {
            var y = c.tag;
            switch (f.$$typeof) {
              case Hc:
                if (c.type === f.value) return !0;
                break;
              case Is:
                t: {
                  for (f = f.value, c = [c, 0], y = 0; y < c.length; ) {
                    var A = c[y++],
                      w = A.tag,
                      U = c[y++],
                      q = f[U];
                    if ((w !== 5 && w !== 26 && w !== 27) || !Cc(A)) {
                      for (; q != null && Oo(A, q); ) U++, (q = f[U]);
                      if (U === f.length) {
                        f = !0;
                        break t;
                      } else
                        for (A = A.child; A !== null; )
                          c.push(A, U), (A = A.sibling);
                    }
                  }
                  f = !1;
                }
                return f;
              case hi:
                if (
                  (y === 5 || y === 26 || y === 27) &&
                  Tg(c.stateNode, f.value)
                )
                  return !0;
                break;
              case Mr:
                if (
                  (y === 5 || y === 6 || y === 26 || y === 27) &&
                  ((c = Eg(c)), c !== null && 0 <= c.indexOf(f.value))
                )
                  return !0;
                break;
              case ir:
                if (
                  (y === 5 || y === 26 || y === 27) &&
                  ((c = c.memoizedProps["data-testname"]),
                  typeof c == "string" &&
                    c.toLowerCase() === f.value.toLowerCase())
                )
                  return !0;
                break;
              default:
                throw Error(a(365));
            }
            return !1;
          }
          function Op(c) {
            switch (c.$$typeof) {
              case Hc:
                return "<" + (l(c.value) || "Unknown") + ">";
              case Is:
                return ":has(" + (Op(c) || "") + ")";
              case hi:
                return '[role="' + c.value + '"]';
              case Mr:
                return '"' + c.value + '"';
              case ir:
                return '[data-testname="' + c.value + '"]';
              default:
                throw Error(a(365));
            }
          }
          function qa(c, f) {
            var y = [];
            c = [c, 0];
            for (var A = 0; A < c.length; ) {
              var w = c[A++],
                U = w.tag,
                q = c[A++],
                lt = f[q];
              if ((U !== 5 && U !== 26 && U !== 27) || !Cc(w)) {
                for (; lt != null && Oo(w, lt); ) q++, (lt = f[q]);
                if (q === f.length) y.push(w);
                else
                  for (w = w.child; w !== null; ) c.push(w, q), (w = w.sibling);
              }
            }
            return y;
          }
          function Gu(c, f) {
            if (!Vo) throw Error(a(363));
            (c = gc(c)), (c = qa(c, f)), (f = []), (c = Array.from(c));
            for (var y = 0; y < c.length; ) {
              var A = c[y++],
                w = A.tag;
              if (w === 5 || w === 26 || w === 27) Cc(A) || f.push(A.stateNode);
              else for (A = A.child; A !== null; ) c.push(A), (A = A.sibling);
            }
            return f;
          }
          function Bi() {
            if ((Ln & 2) !== 0 && wn !== 0) return wn & -wn;
            if (nn.T !== null) {
              var c = us;
              return c !== 0 ? c : Gt();
            }
            return Sg();
          }
          function Np() {
            vs === 0 && (vs = (wn & 536870912) === 0 || On ? F() : 536870912);
            var c = fs.current;
            return c !== null && (c.flags |= 32), vs;
          }
          function $i(c, f, y) {
            ((c === Xn && Jn === 2) || c.cancelPendingCommit !== null) &&
              (ua(c, 0), Ka(c, wn, vs, !1)),
              Y(c, y),
              ((Ln & 2) === 0 || c !== Xn) &&
                (c === Xn &&
                  ((Ln & 2) === 0 && (co |= y), ii === 4 && Ka(c, wn, vs, !1)),
                te(c));
          }
          function No(c, f, y) {
            if ((Ln & 6) !== 0) throw Error(a(327));
            var A =
                (!y && (f & 60) === 0 && (f & c.expiredLanes) === 0) || P(c, f),
              w = A ? Ip(c, f) : Eh(c, f, !0),
              U = A;
            do {
              if (w === 0) {
                ms && !A && Ka(c, f, 0, !1);
                break;
              } else if (w === 6) Ka(c, f, 0, !zs);
              else {
                if (((y = c.current.alternate), U && !vc(y))) {
                  (w = Eh(c, f, !1)), (U = !1);
                  continue;
                }
                if (w === 2) {
                  if (((U = f), c.errorRecoveryDisabledLanes & U)) var q = 0;
                  else
                    (q = c.pendingLanes & -536870913),
                      (q = q !== 0 ? q : q & 536870912 ? 536870912 : 0);
                  if (q !== 0) {
                    f = q;
                    t: {
                      var lt = c;
                      w = Il;
                      var St = fa && lt.current.memoizedState.isDehydrated;
                      if (
                        (St && (ua(lt, q).flags |= 256),
                        (q = Eh(lt, q, !1)),
                        q !== 2)
                      ) {
                        if (Wi && !St) {
                          (lt.errorRecoveryDisabledLanes |= U),
                            (co |= U),
                            (w = 4);
                          break t;
                        }
                        (U = Si), (Si = w), U !== null && Vu(U);
                      }
                      w = q;
                    }
                    if (((U = !1), w !== 2)) continue;
                  }
                }
                if (w === 1) {
                  ua(c, 0), Ka(c, f, 0, !0);
                  break;
                }
                t: {
                  switch (((A = c), w)) {
                    case 0:
                    case 1:
                      throw Error(a(345));
                    case 4:
                      if ((f & 4194176) === f) {
                        Ka(A, f, vs, !zs);
                        break t;
                      }
                      break;
                    case 2:
                      Si = null;
                      break;
                    case 3:
                    case 5:
                      break;
                    default:
                      throw Error(a(329));
                  }
                  if (
                    ((A.finishedWork = y),
                    (A.finishedLanes = f),
                    (f & 62914560) === f && ((U = Ia + 300 - Us()), 10 < U))
                  ) {
                    if ((Ka(A, f, vs, !zs), I(A, 0) !== 0)) break t;
                    A.timeoutHandle = Fi(
                      Mh.bind(
                        null,
                        A,
                        y,
                        Si,
                        hf,
                        td,
                        f,
                        vs,
                        co,
                        Er,
                        zs,
                        2,
                        -0,
                        0
                      ),
                      U
                    );
                    break t;
                  }
                  Mh(A, y, Si, hf, td, f, vs, co, Er, zs, 0, -0, 0);
                }
              }
              break;
            } while (!0);
            te(c);
          }
          function Vu(c) {
            Si === null ? (Si = c) : Si.push.apply(Si, c);
          }
          function Mh(c, f, y, A, w, U, q, lt, St, Xt, he, Me, Te) {
            var un = f.subtreeFlags;
            if (
              (un & 8192 || (un & 16785408) === 16785408) &&
              (Yp(), Ah(f), (f = Hi()), f !== null)
            ) {
              (c.cancelPendingCommit = f(
                Io.bind(null, c, y, A, w, q, lt, St, 1, Me, Te)
              )),
                Ka(c, U, q, !Xt);
              return;
            }
            Io(c, y, A, w, q, lt, St, he, Me, Te);
          }
          function vc(c) {
            for (var f = c; ; ) {
              var y = f.tag;
              if (
                (y === 0 || y === 11 || y === 15) &&
                f.flags & 16384 &&
                ((y = f.updateQueue),
                y !== null && ((y = y.stores), y !== null))
              )
                for (var A = 0; A < y.length; A++) {
                  var w = y[A],
                    U = w.getSnapshot;
                  w = w.value;
                  try {
                    if (!Za(U(), w)) return !1;
                  } catch {
                    return !1;
                  }
                }
              if (((y = f.child), f.subtreeFlags & 16384 && y !== null))
                (y.return = f), (f = y);
              else {
                if (f === c) break;
                for (; f.sibling === null; ) {
                  if (f.return === null || f.return === c) return !0;
                  f = f.return;
                }
                (f.sibling.return = f.return), (f = f.sibling);
              }
            }
            return !0;
          }
          function Ka(c, f, y, A) {
            (f &= ~ff),
              (f &= ~co),
              (c.suspendedLanes |= f),
              (c.pingedLanes &= ~f),
              A && (c.warmLanes |= f),
              (A = c.expirationTimes);
            for (var w = f; 0 < w; ) {
              var U = 31 - Na(w),
                q = 1 << U;
              (A[U] = -1), (w &= ~q);
            }
            y !== 0 && nt(c, y, f);
          }
          function ku() {
            return (Ln & 6) === 0 ? (pe(0), !1) : !0;
          }
          function yc() {
            if (Ze !== null) {
              if (Jn === 0) var c = Ze.return;
              else
                (c = Ze),
                  (ds = nr = null),
                  ae(c),
                  (qo = null),
                  (Ko = 0),
                  (c = Ze);
              for (; c !== null; ) dg(c.alternate, c), (c = c.return);
              Ze = null;
            }
          }
          function ua(c, f) {
            (c.finishedWork = null), (c.finishedLanes = 0);
            var y = c.timeoutHandle;
            y !== Ho && ((c.timeoutHandle = Ho), Nh(y)),
              (y = c.cancelPendingCommit),
              y !== null && ((c.cancelPendingCommit = null), y()),
              yc(),
              (Xn = c),
              (Ze = y = Cs(c.current, null)),
              (wn = f),
              (Jn = 0),
              (ba = null),
              (zs = !1),
              (ms = P(c, f)),
              (Wi = !1),
              (Er = vs = ff = co = gs = ii = 0),
              (Si = Il = null),
              (td = !1),
              (f & 8) !== 0 && (f |= f & 32);
            var A = c.entangledLanes;
            if (A !== 0)
              for (c = c.entanglements, A &= f; 0 < A; ) {
                var w = 31 - Na(A),
                  U = 1 << w;
                (f |= c[w]), (A &= ~U);
              }
            return (Aa = f), J(), y;
          }
          function as(c, f) {
            (_n = null),
              (nn.H = bi),
              f === Ic
                ? ((f = be()), (Jn = 3))
                : f === cf
                ? ((f = be()), (Jn = 4))
                : (Jn =
                    f === Qh
                      ? 8
                      : f !== null &&
                        typeof f == "object" &&
                        typeof f.then == "function"
                      ? 6
                      : 1),
              (ba = f),
              Ze === null && ((ii = 1), cc(c, xt(f, c.current)));
          }
          function Lo() {
            var c = fs.current;
            return c === null
              ? !0
              : (wn & 4194176) === wn
              ? ei === null
              : (wn & 62914560) === wn || (wn & 536870912) !== 0
              ? c === ei
              : !1;
          }
          function hr() {
            var c = nn.H;
            return (nn.H = bi), c === null ? bi : c;
          }
          function dr() {
            var c = nn.A;
            return (nn.A = Fc), c;
          }
          function Jr() {
            (ii = 4),
              zs || ((wn & 4194176) !== wn && fs.current !== null) || (ms = !0),
              ((gs & 134217727) === 0 && (co & 134217727) === 0) ||
                Xn === null ||
                Ka(Xn, wn, vs, !1);
          }
          function Eh(c, f, y) {
            var A = Ln;
            Ln |= 2;
            var w = hr(),
              U = dr();
            (Xn !== c || wn !== f) && ((hf = null), ua(c, f)), (f = !1);
            var q = ii;
            t: do
              try {
                if (Jn !== 0 && Ze !== null) {
                  var lt = Ze,
                    St = ba;
                  switch (Jn) {
                    case 8:
                      yc(), (q = 6);
                      break t;
                    case 3:
                    case 2:
                    case 6:
                      fs.current === null && (f = !0);
                      var Xt = Jn;
                      if (((Jn = 0), (ba = null), ws(c, lt, St, Xt), y && ms)) {
                        q = 0;
                        break t;
                      }
                      break;
                    default:
                      (Xt = Jn), (Jn = 0), (ba = null), ws(c, lt, St, Xt);
                  }
                }
                Lp(), (q = ii);
                break;
              } catch (he) {
                as(c, he);
              }
            while (!0);
            return (
              f && c.shellSuspendCounter++,
              (ds = nr = null),
              (Ln = A),
              (nn.H = w),
              (nn.A = U),
              Ze === null && ((Xn = null), (wn = 0), J()),
              q
            );
          }
          function Lp() {
            for (; Ze !== null; ) mi(Ze);
          }
          function Ip(c, f) {
            var y = Ln;
            Ln |= 2;
            var A = hr(),
              w = dr();
            Xn !== c || wn !== f
              ? ((hf = null), (Gc = Us() + 500), ua(c, f))
              : (ms = P(c, f));
            t: do
              try {
                if (Jn !== 0 && Ze !== null) {
                  f = Ze;
                  var U = ba;
                  e: switch (Jn) {
                    case 1:
                      (Jn = 0), (ba = null), ws(c, f, U, 1);
                      break;
                    case 2:
                      if (ge(U)) {
                        (Jn = 0), (ba = null), Pn(f);
                        break;
                      }
                      (f = function () {
                        Jn === 2 && Xn === c && (Jn = 7), te(c);
                      }),
                        U.then(f, f);
                      break t;
                    case 3:
                      Jn = 7;
                      break t;
                    case 4:
                      Jn = 5;
                      break t;
                    case 7:
                      ge(U)
                        ? ((Jn = 0), (ba = null), Pn(f))
                        : ((Jn = 0), (ba = null), ws(c, f, U, 7));
                      break;
                    case 5:
                      var q = null;
                      switch (Ze.tag) {
                        case 26:
                          q = Ze.memoizedState;
                        case 5:
                        case 27:
                          var lt = Ze,
                            St = lt.type,
                            Xt = lt.pendingProps;
                          if (q ? Al(q) : Lh(St, Xt)) {
                            (Jn = 0), (ba = null);
                            var he = lt.sibling;
                            if (he !== null) Ze = he;
                            else {
                              var Me = lt.return;
                              Me !== null ? ((Ze = Me), ss(Me)) : (Ze = null);
                            }
                            break e;
                          }
                      }
                      (Jn = 0), (ba = null), ws(c, f, U, 5);
                      break;
                    case 6:
                      (Jn = 0), (ba = null), ws(c, f, U, 6);
                      break;
                    case 8:
                      yc(), (ii = 6);
                      break t;
                    default:
                      throw Error(a(462));
                  }
                }
                Da();
                break;
              } catch (Te) {
                as(c, Te);
              }
            while (!0);
            return (
              (ds = nr = null),
              (nn.H = A),
              (nn.A = w),
              (Ln = y),
              Ze !== null ? 0 : ((Xn = null), (wn = 0), J(), ii)
            );
          }
          function Da() {
            for (; Ze !== null && !iv(); ) mi(Ze);
          }
          function mi(c) {
            var f = ug(c.alternate, c, Aa);
            (c.memoizedProps = c.pendingProps), f === null ? ss(c) : (Ze = f);
          }
          function Pn(c) {
            var f = c,
              y = f.alternate;
            switch (f.tag) {
              case 15:
              case 0:
                f = ag(y, f, f.pendingProps, f.type, void 0, wn);
                break;
              case 11:
                f = ag(y, f, f.pendingProps, f.type.render, f.ref, wn);
                break;
              case 5:
                ae(f);
              default:
                dg(y, f), (f = Ze = Xu(f, Aa)), (f = ug(y, f, Aa));
            }
            (c.memoizedProps = c.pendingProps), f === null ? ss(c) : (Ze = f);
          }
          function ws(c, f, y, A) {
            (ds = nr = null), ae(f), (qo = null), (Ko = 0);
            var w = f.return;
            try {
              if (v1(c, w, f, y, wn)) {
                (ii = 1), cc(c, xt(y, c.current)), (Ze = null);
                return;
              }
            } catch (U) {
              if (w !== null) throw ((Ze = w), U);
              (ii = 1), cc(c, xt(y, c.current)), (Ze = null);
              return;
            }
            f.flags & 32768
              ? (On || A === 1
                  ? (c = !0)
                  : ms || (wn & 536870912) !== 0
                  ? (c = !1)
                  : ((zs = c = !0),
                    (A === 2 || A === 3 || A === 6) &&
                      ((A = fs.current),
                      A !== null && A.tag === 13 && (A.flags |= 16384))),
                Th(f, c))
              : ss(f);
          }
          function ss(c) {
            var f = c;
            do {
              if ((f.flags & 32768) !== 0) {
                Th(f, zs);
                return;
              }
              c = f.return;
              var y = hg(f.alternate, f, Aa);
              if (y !== null) {
                Ze = y;
                return;
              }
              if (((f = f.sibling), f !== null)) {
                Ze = f;
                return;
              }
              Ze = f = c;
            } while (f !== null);
            ii === 0 && (ii = 5);
          }
          function Th(c, f) {
            do {
              var y = x1(c.alternate, c);
              if (y !== null) {
                (y.flags &= 32767), (Ze = y);
                return;
              }
              if (
                ((y = c.return),
                y !== null &&
                  ((y.flags |= 32768),
                  (y.subtreeFlags = 0),
                  (y.deletions = null)),
                !f && ((c = c.sibling), c !== null))
              ) {
                Ze = c;
                return;
              }
              Ze = c = y;
            } while (c !== null);
            (ii = 6), (Ze = null);
          }
          function Io(c, f, y, A, w, U, q, lt, St, Xt) {
            var he = nn.T,
              Me = no();
            try {
              _a(2), (nn.T = null), vg(c, f, y, A, Me, w, U, q, lt, St, Xt);
            } finally {
              (nn.T = he), _a(Me);
            }
          }
          function vg(c, f, y, A, w, U, q, lt) {
            do qs();
            while (Tr !== null);
            if ((Ln & 6) !== 0) throw Error(a(327));
            var St = c.finishedWork;
            if (((A = c.finishedLanes), St === null)) return null;
            if (
              ((c.finishedWork = null), (c.finishedLanes = 0), St === c.current)
            )
              throw Error(a(177));
            (c.callbackNode = null),
              (c.callbackPriority = 0),
              (c.cancelPendingCommit = null);
            var Xt = St.lanes | St.childLanes;
            if (
              ((Xt |= tr),
              ct(c, A, Xt, U, q, lt),
              c === Xn && ((Ze = Xn = null), (wn = 0)),
              ((St.subtreeFlags & 10256) === 0 && (St.flags & 10256) === 0) ||
                ar ||
                ((ar = !0),
                (tl = Xt),
                (ed = y),
                Qr(qh, function () {
                  return qs(), null;
                })),
              (y = (St.flags & 15990) !== 0),
              (St.subtreeFlags & 15990) !== 0 || y
                ? ((y = nn.T),
                  (nn.T = null),
                  (U = no()),
                  _a(2),
                  (q = Ln),
                  (Ln |= 4),
                  zu(c, St),
                  Bp(St, c),
                  bg(c.containerInfo),
                  (c.current = St),
                  xh(c, St.alternate, St),
                  Wh(),
                  (Ln = q),
                  _a(U),
                  (nn.T = y))
                : (c.current = St),
              ar ? ((ar = !1), (Tr = c), (Pl = A)) : Pp(c, Xt),
              (Xt = c.pendingLanes),
              Xt === 0 && ($o = null),
              j(St.stateNode),
              te(c),
              f !== null)
            )
              for (w = c.onRecoverableError, St = 0; St < f.length; St++)
                (Xt = f[St]), w(Xt.value, { componentStack: Xt.stack });
            return (
              (Pl & 3) !== 0 && qs(),
              (Xt = c.pendingLanes),
              (A & 4194218) !== 0 && (Xt & 42) !== 0
                ? c === nd
                  ? Vc++
                  : ((Vc = 0), (nd = c))
                : (Vc = 0),
              pe(0),
              null
            );
          }
          function Pp(c, f) {
            (c.pooledCacheLanes &= f) === 0 &&
              ((f = c.pooledCache),
              f != null && ((c.pooledCache = null), Nu(f)));
          }
          function qs() {
            if (Tr !== null) {
              var c = Tr,
                f = tl;
              tl = 0;
              var y = pt(Pl),
                A = 32 > y ? 32 : y;
              y = nn.T;
              var w = no();
              try {
                if ((_a(A), (nn.T = null), Tr === null)) var U = !1;
                else {
                  (A = ed), (ed = null);
                  var q = Tr,
                    lt = Pl;
                  if (((Tr = null), (Pl = 0), (Ln & 6) !== 0))
                    throw Error(a(331));
                  var St = Ln;
                  if (
                    ((Ln |= 4),
                    Sh(q.current),
                    Dp(q, q.current, lt, A),
                    (Ln = St),
                    pe(0, !1),
                    Ja && typeof Ja.onPostCommitFiberRoot == "function")
                  )
                    try {
                      Ja.onPostCommitFiberRoot(Oi, q);
                    } catch {}
                  U = !0;
                }
                return U;
              } finally {
                _a(w), (nn.T = y), Pp(c, f);
              }
            }
            return !1;
          }
          function xc(c, f, y) {
            (f = xt(y, f)),
              (f = fc(c.stateNode, f, 2)),
              (c = ce(c, f, 2)),
              c !== null && (Y(c, 2), te(c));
          }
          function kn(c, f, y) {
            if (c.tag === 3) xc(c, c, y);
            else
              for (; f !== null; ) {
                if (f.tag === 3) {
                  xc(f, c, y);
                  break;
                } else if (f.tag === 1) {
                  var A = f.stateNode;
                  if (
                    typeof f.type.getDerivedStateFromError == "function" ||
                    (typeof A.componentDidCatch == "function" &&
                      ($o === null || !$o.has(A)))
                  ) {
                    (c = xt(y, c)),
                      (y = gp(2)),
                      (A = ce(f, y, 2)),
                      A !== null && ($0(y, A, f, c), Y(A, 2), te(A));
                    break;
                  }
                }
                f = f.return;
              }
          }
          function xl(c, f, y) {
            var A = c.pingCache;
            if (A === null) {
              A = c.pingCache = new Ps();
              var w = new Set();
              A.set(f, w);
            } else
              (w = A.get(f)), w === void 0 && ((w = new Set()), A.set(f, w));
            w.has(y) ||
              ((Wi = !0), w.add(y), (c = zp.bind(null, c, f, y)), f.then(c, c));
          }
          function zp(c, f, y) {
            var A = c.pingCache;
            A !== null && A.delete(f),
              (c.pingedLanes |= c.suspendedLanes & y),
              (c.warmLanes &= ~y),
              Xn === c &&
                (wn & y) === y &&
                (ii === 4 ||
                (ii === 3 && (wn & 62914560) === wn && 300 > Us() - Ia)
                  ? (Ln & 2) === 0 && ua(c, 0)
                  : (ff |= y),
                Er === wn && (Er = 0)),
              te(c);
          }
          function Po(c, f) {
            f === 0 && (f = N()),
              (c = $t(c, f)),
              c !== null && (Y(c, f), te(c));
          }
          function Zr(c) {
            var f = c.memoizedState,
              y = 0;
            f !== null && (y = f.retryLane), Po(c, y);
          }
          function zo(c, f) {
            var y = 0;
            switch (c.tag) {
              case 13:
                var A = c.stateNode,
                  w = c.memoizedState;
                w !== null && (y = w.retryLane);
                break;
              case 19:
                A = c.stateNode;
                break;
              case 22:
                A = c.stateNode._retryCache;
                break;
              default:
                throw Error(a(314));
            }
            A !== null && A.delete(f), Po(c, y);
          }
          function Qr(c, f) {
            return rf(c, f);
          }
          function Fp(c, f, y, A) {
            (this.tag = c),
              (this.key = y),
              (this.sibling =
                this.child =
                this.return =
                this.stateNode =
                this.type =
                this.elementType =
                  null),
              (this.index = 0),
              (this.refCleanup = this.ref = null),
              (this.pendingProps = f),
              (this.dependencies =
                this.memoizedState =
                this.updateQueue =
                this.memoizedProps =
                  null),
              (this.mode = A),
              (this.subtreeFlags = this.flags = 0),
              (this.deletions = null),
              (this.childLanes = this.lanes = 0),
              (this.alternate = null);
          }
          function ju(c) {
            return (c = c.prototype), !(!c || !c.isReactComponent);
          }
          function Cs(c, f) {
            var y = c.alternate;
            return (
              y === null
                ? ((y = e(c.tag, f, c.key, c.mode)),
                  (y.elementType = c.elementType),
                  (y.type = c.type),
                  (y.stateNode = c.stateNode),
                  (y.alternate = c),
                  (c.alternate = y))
                : ((y.pendingProps = f),
                  (y.type = c.type),
                  (y.flags = 0),
                  (y.subtreeFlags = 0),
                  (y.deletions = null)),
              (y.flags = c.flags & 31457280),
              (y.childLanes = c.childLanes),
              (y.lanes = c.lanes),
              (y.child = c.child),
              (y.memoizedProps = c.memoizedProps),
              (y.memoizedState = c.memoizedState),
              (y.updateQueue = c.updateQueue),
              (f = c.dependencies),
              (y.dependencies =
                f === null
                  ? null
                  : { lanes: f.lanes, firstContext: f.firstContext }),
              (y.sibling = c.sibling),
              (y.index = c.index),
              (y.ref = c.ref),
              (y.refCleanup = c.refCleanup),
              y
            );
          }
          function Xu(c, f) {
            c.flags &= 31457282;
            var y = c.alternate;
            return (
              y === null
                ? ((c.childLanes = 0),
                  (c.lanes = f),
                  (c.child = null),
                  (c.subtreeFlags = 0),
                  (c.memoizedProps = null),
                  (c.memoizedState = null),
                  (c.updateQueue = null),
                  (c.dependencies = null),
                  (c.stateNode = null))
                : ((c.childLanes = y.childLanes),
                  (c.lanes = y.lanes),
                  (c.child = y.child),
                  (c.subtreeFlags = 0),
                  (c.deletions = null),
                  (c.memoizedProps = y.memoizedProps),
                  (c.memoizedState = y.memoizedState),
                  (c.updateQueue = y.updateQueue),
                  (c.type = y.type),
                  (f = y.dependencies),
                  (c.dependencies =
                    f === null
                      ? null
                      : { lanes: f.lanes, firstContext: f.firstContext })),
              c
            );
          }
          function pr(c, f, y, A, w, U) {
            var q = 0;
            if (((A = c), typeof c == "function")) ju(c) && (q = 1);
            else if (typeof c == "string")
              q =
                os && ti
                  ? nf(c, y, ji.current)
                    ? 26
                    : gr(c)
                    ? 27
                    : 5
                  : os
                  ? nf(c, y, ji.current)
                    ? 26
                    : 5
                  : ti && gr(c)
                  ? 27
                  : 5;
            else
              t: switch (c) {
                case Fo:
                  return _i(y.children, w, U, f);
                case Ku:
                  (q = 8), (w |= 24);
                  break;
                case Bh:
                  return (
                    (c = e(12, y, f, w | 2)),
                    (c.elementType = Bh),
                    (c.lanes = U),
                    c
                  );
                case Dh:
                  return (
                    (c = e(13, y, f, w)), (c.elementType = Dh), (c.lanes = U), c
                  );
                case Sc:
                  return (
                    (c = e(19, y, f, w)), (c.elementType = Sc), (c.lanes = U), c
                  );
                case Vp:
                  return Wu(y, w, U, f);
                default:
                  if (typeof c == "object" && c !== null)
                    switch (c.$$typeof) {
                      case Ju:
                      case Ks:
                        q = 10;
                        break t;
                      case Gp:
                        q = 9;
                        break t;
                      case Zu:
                        q = 11;
                        break t;
                      case Uh:
                        q = 14;
                        break t;
                      case Bs:
                        (q = 16), (A = null);
                        break t;
                    }
                  (q = 29),
                    (y = Error(a(130, c === null ? "null" : typeof c, ""))),
                    (A = null);
              }
            return (
              (f = e(q, y, f, w)),
              (f.elementType = c),
              (f.type = A),
              (f.lanes = U),
              f
            );
          }
          function _i(c, f, y, A) {
            return (c = e(7, c, A, f)), (c.lanes = y), c;
          }
          function Wu(c, f, y, A) {
            (c = e(22, c, A, f)), (c.elementType = Vp), (c.lanes = y);
            var w = {
              _visibility: 1,
              _pendingVisibility: 1,
              _pendingMarkers: null,
              _retryCache: null,
              _transitions: null,
              _current: null,
              detach: function () {
                var U = w._current;
                if (U === null) throw Error(a(456));
                if ((w._pendingVisibility & 2) === 0) {
                  var q = $t(U, 2);
                  q !== null && ((w._pendingVisibility |= 2), $i(q, U, 2));
                }
              },
              attach: function () {
                var U = w._current;
                if (U === null) throw Error(a(456));
                if ((w._pendingVisibility & 2) !== 0) {
                  var q = $t(U, 2);
                  q !== null && ((w._pendingVisibility &= -3), $i(q, U, 2));
                }
              },
            };
            return (c.stateNode = w), c;
          }
          function wh(c, f, y) {
            return (c = e(6, c, null, f)), (c.lanes = y), c;
          }
          function Hp(c, f, y) {
            return (
              (f = e(4, c.children !== null ? c.children : [], c.key, f)),
              (f.lanes = y),
              (f.stateNode = {
                containerInfo: c.containerInfo,
                pendingChildren: null,
                implementation: c.implementation,
              }),
              f
            );
          }
          function _1(c, f, y, A, w, U, q, lt) {
            (this.tag = 1),
              (this.containerInfo = c),
              (this.finishedWork =
                this.pingCache =
                this.current =
                this.pendingChildren =
                  null),
              (this.timeoutHandle = Ho),
              (this.callbackNode =
                this.next =
                this.pendingContext =
                this.context =
                this.cancelPendingCommit =
                  null),
              (this.callbackPriority = 0),
              (this.expirationTimes = L(-1)),
              (this.entangledLanes =
                this.shellSuspendCounter =
                this.errorRecoveryDisabledLanes =
                this.finishedLanes =
                this.expiredLanes =
                this.warmLanes =
                this.pingedLanes =
                this.suspendedLanes =
                this.pendingLanes =
                  0),
              (this.entanglements = L(0)),
              (this.hiddenUpdates = L(null)),
              (this.identifierPrefix = A),
              (this.onUncaughtError = w),
              (this.onCaughtError = U),
              (this.onRecoverableError = q),
              (this.pooledCache = null),
              (this.pooledCacheLanes = 0),
              (this.formState = lt),
              (this.incompleteTransitions = new Map());
          }
          function yg(c, f, y, A, w, U, q, lt, St, Xt, he, Me) {
            return (
              (c = new _1(c, f, y, q, lt, St, Xt, Me)),
              (f = 1),
              U === !0 && (f |= 24),
              (U = e(3, null, null, f)),
              (c.current = U),
              (U.stateNode = c),
              (f = Ro()),
              f.refCount++,
              (c.pooledCache = f),
              f.refCount++,
              (U.memoizedState = { element: A, isDehydrated: y, cache: f }),
              we(U),
              c
            );
          }
          function zi(c) {
            return c ? ((c = Xo), c) : Xo;
          }
          function Ch(c) {
            var f = c._reactInternals;
            if (f === void 0)
              throw typeof c.render == "function"
                ? Error(a(188))
                : ((c = Object.keys(c).join(",")), Error(a(268, c)));
            return (
              (c = _(f)),
              (c = c !== null ? M(c) : null),
              c === null ? null : Tc(c.stateNode)
            );
          }
          function _c(c, f, y, A, w, U) {
            (w = zi(w)),
              A.context === null ? (A.context = w) : (A.pendingContext = w),
              (A = jt(f)),
              (A.payload = { element: y }),
              (U = U === void 0 ? null : U),
              U !== null && (A.callback = U),
              (y = ce(c, A, f)),
              y !== null && ($i(y, c, f), Re(y, c, f));
          }
          function bc(c, f) {
            if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
              var y = c.retryLane;
              c.retryLane = y !== 0 && y < f ? y : f;
            }
          }
          function Yu(c, f) {
            bc(c, f), (c = c.alternate) && bc(c, f);
          }
          var fn = {},
            Ac = nh(),
            rs = GR(),
            Rh = Object.assign,
            b1 = Symbol.for("react.element"),
            qu = Symbol.for("react.transitional.element"),
            Rs = Symbol.for("react.portal"),
            Fo = Symbol.for("react.fragment"),
            Ku = Symbol.for("react.strict_mode"),
            Bh = Symbol.for("react.profiler"),
            Ju = Symbol.for("react.provider"),
            Gp = Symbol.for("react.consumer"),
            Ks = Symbol.for("react.context"),
            Zu = Symbol.for("react.forward_ref"),
            Dh = Symbol.for("react.suspense"),
            Sc = Symbol.for("react.suspense_list"),
            Uh = Symbol.for("react.memo"),
            Bs = Symbol.for("react.lazy"),
            Vp = Symbol.for("react.offscreen"),
            xg = Symbol.for("react.memo_cache_sentinel"),
            $r = Symbol.iterator,
            kp = Symbol.for("react.client.reference"),
            nn =
              Ac.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
            mr,
            to,
            _l = !1,
            Mc = Array.isArray,
            jp = t.rendererVersion,
            Qu = t.rendererPackageName,
            Ec = t.extraDevToolsConfig,
            Tc = t.getPublicInstance,
            _g = t.getRootHostContext,
            wc = t.getChildHostContext,
            Oh = t.prepareForCommit,
            bg = t.resetAfterCommit,
            Xp = t.createInstance,
            $u = t.appendInitialChild,
            eo = t.finalizeInitialChildren,
            hn = t.shouldSetTextContent,
            qn = t.createTextInstance,
            Fi = t.scheduleTimeout,
            Nh = t.cancelTimeout,
            Ho = t.noTimeout,
            Ua = t.isPrimaryRenderer;
          t.warnsIfNotActing;
          var ki = t.supportsMutation,
            Ds = t.supportsPersistence,
            fa = t.supportsHydration,
            Ag = t.getInstanceFromNode;
          t.beforeActiveInstanceBlur, t.afterActiveInstanceBlur;
          var Di = t.preparePortalMount;
          t.prepareScopeUpdate, t.getInstanceFromScope;
          var _a = t.setCurrentUpdatePriority,
            no = t.getCurrentUpdatePriority,
            Sg = t.resolveUpdatePriority;
          t.resolveEventType, t.resolveEventTimeStamp;
          var Mg = t.shouldAttemptEagerTransition,
            A1 = t.detachDeletedInstance;
          t.requestPostPaintCallback;
          var Wp = t.maySuspendCommit,
            Lh = t.preloadInstance,
            Yp = t.startSuspendingCommit,
            Oa = t.suspendInstance,
            Hi = t.waitForCommitToBeReady,
            Go = t.NotPendingTransition,
            Js = t.HostTransitionContext,
            Ih = t.resetFormInstance;
          t.bindToConsole;
          var qp = t.supportsMicrotasks,
            io = t.scheduleMicrotask,
            Vo = t.supportsTestSelectors,
            Kp = t.findFiberRoot,
            Jp = t.getBoundingRect,
            Eg = t.getTextContent,
            Cc = t.isHiddenSubtree,
            Tg = t.matchAccessibilityRole,
            wg = t.setFocusIfFocusable,
            Cg = t.setupIntersectionObserver,
            Rg = t.appendChild,
            Zp = t.appendChildToContainer,
            Bg = t.commitTextUpdate,
            S1 = t.commitMount,
            Dg = t.commitUpdate,
            Ug = t.insertBefore,
            Og = t.insertInContainerBefore,
            Qp = t.removeChild,
            Ng = t.removeChildFromContainer,
            $p = t.resetTextContent,
            Lg = t.hideInstance,
            Ig = t.hideTextInstance,
            Pg = t.unhideInstance,
            M1 = t.unhideTextInstance,
            zg = t.clearContainer,
            Rc = t.cloneInstance,
            tf = t.createContainerChildSet,
            tm = t.appendChildToContainerChildSet,
            Ph = t.finalizeContainerChildren,
            Bc = t.replaceContainerChildren,
            em = t.cloneHiddenInstance,
            nm = t.cloneHiddenTextInstance,
            zh = t.isSuspenseInstancePending,
            Fh = t.isSuspenseInstanceFallback,
            Fg = t.getSuspenseInstanceFallbackErrorDetails,
            Hg = t.registerSuspenseInstanceRetry,
            im = t.canHydrateFormStateMarker,
            Gg = t.isFormStateMarkerMatching,
            am = t.getNextHydratableSibling,
            Hh = t.getFirstHydratableChild,
            Vg = t.getFirstHydratableChildWithinContainer,
            kg = t.getFirstHydratableChildWithinSuspenseInstance,
            E1 = t.canHydrateInstance,
            sm = t.canHydrateTextInstance,
            jg = t.canHydrateSuspenseInstance,
            Xg = t.hydrateInstance,
            rm = t.hydrateTextInstance,
            Wg = t.hydrateSuspenseInstance,
            Yg = t.getNextHydratableInstanceAfterSuspenseInstance,
            T1 = t.commitHydratedContainer,
            w1 = t.commitHydratedSuspenseInstance,
            qg = t.clearSuspenseBoundary,
            ef = t.clearSuspenseBoundaryFromContainer,
            Gh = t.shouldDeleteUnhydratedTailInstances;
          t.diffHydratedPropsForDevWarnings,
            t.diffHydratedTextForDevWarnings,
            t.describeHydratableInstanceForDevWarnings;
          var Vh = t.validateHydratableInstance,
            Kg = t.validateHydratableTextInstance,
            os = t.supportsResources,
            nf = t.isHostHoistableType,
            kh = t.getHoistableRoot,
            om = t.getResource,
            Jg = t.acquireResource,
            bl = t.releaseResource,
            af = t.hydrateHoistable,
            sf = t.mountHoistable,
            Dc = t.unmountHoistable,
            jh = t.createHoistableInstance,
            Zg = t.prepareToCommitHoistables,
            Qg = t.mayResourceSuspendCommit,
            Al = t.preloadResource,
            $g = t.suspendResource,
            ti = t.supportsSingletons,
            Zs = t.resolveSingletonInstance,
            ko = t.clearSingleton,
            tv = t.acquireSingletonInstance,
            jo = t.releaseSingletonInstance,
            gr = t.isHostSingletonType,
            Ui = [],
            ao = -1,
            Xo = {},
            Na = Math.clz32 ? Math.clz32 : B,
            ev = Math.log,
            nv = Math.LN2,
            vr = 128,
            Sl = 4194304,
            rf = rs.unstable_scheduleCallback,
            Xh = rs.unstable_cancelCallback,
            iv = rs.unstable_shouldYield,
            Wh = rs.unstable_requestPaint,
            Us = rs.unstable_now,
            Yh = rs.unstable_ImmediatePriority,
            av = rs.unstable_UserBlockingPriority,
            qh = rs.unstable_NormalPriority,
            C1 = rs.unstable_IdlePriority,
            sv = rs.log,
            ta = rs.unstable_setDisableYieldValue,
            Oi = null,
            Ja = null,
            Za = typeof Object.is == "function" ? Object.is : et,
            lm = new WeakMap(),
            Ml = [],
            El = 0,
            Tl = null,
            Uc = 0,
            ls = [],
            cs = 0,
            Wo = null,
            Qs = 1,
            $s = "",
            ji = E(null),
            Oc = E(null),
            yr = E(null),
            wl = E(null),
            ha = null,
            da = null,
            On = !1,
            Os = null,
            ea = !1,
            of = Error(a(519)),
            Ns = [],
            Cl = 0,
            tr = 0,
            lf = null,
            so = null,
            Rl = !1,
            ri = !1,
            cm = !1,
            Nc = 0,
            Lc = null,
            Bl = 0,
            us = 0,
            Dl = null,
            ro = !1,
            Ul = !1,
            xr = Object.prototype.hasOwnProperty,
            Ic = Error(a(460)),
            cf = Error(a(474)),
            uf = { then: function () {} },
            Yo = null,
            qo = null,
            Ko = 0,
            Jo = si(!0),
            _r = si(!1),
            oi = E(null),
            Pc = E(0),
            fs = E(null),
            ei = null,
            Xi = E(0),
            oo = 0,
            _n = null,
            Je = null,
            Nn = null,
            Ls = !1,
            Ol = !1,
            Zo = !1,
            Kh = 0,
            Nl = 0,
            na = null,
            er = 0,
            Jh = function () {
              return {
                lastEffect: null,
                events: null,
                stores: null,
                memoCache: null,
              };
            },
            bi = {
              readContext: oa,
              use: ot,
              useCallback: Vn,
              useContext: Vn,
              useEffect: Vn,
              useImperativeHandle: Vn,
              useLayoutEffect: Vn,
              useInsertionEffect: Vn,
              useMemo: Vn,
              useReducer: Vn,
              useRef: Vn,
              useState: Vn,
              useDebugValue: Vn,
              useDeferredValue: Vn,
              useTransition: Vn,
              useSyncExternalStore: Vn,
              useId: Vn,
            };
          (bi.useCacheRefresh = Vn),
            (bi.useMemoCache = Vn),
            (bi.useHostTransitionStatus = Vn),
            (bi.useFormState = Vn),
            (bi.useActionState = Vn),
            (bi.useOptimistic = Vn);
          var Qo = {
            readContext: oa,
            use: ot,
            useCallback: function (c, f) {
              return (H().memoizedState = [c, f === void 0 ? null : f]), c;
            },
            useContext: oa,
            useEffect: oh,
            useImperativeHandle: function (c, f, y) {
              (y = y != null ? y.concat([c]) : null),
                Au(4194308, 4, lh.bind(null, f, c), y);
            },
            useLayoutEffect: function (c, f) {
              return Au(4194308, 4, c, f);
            },
            useInsertionEffect: function (c, f) {
              Au(4, 2, c, f);
            },
            useMemo: function (c, f) {
              var y = H();
              f = f === void 0 ? null : f;
              var A = c();
              if (Zo) {
                Q(!0);
                try {
                  c();
                } finally {
                  Q(!1);
                }
              }
              return (y.memoizedState = [A, f]), A;
            },
            useReducer: function (c, f, y) {
              var A = H();
              if (y !== void 0) {
                var w = y(f);
                if (Zo) {
                  Q(!0);
                  try {
                    y(f);
                  } finally {
                    Q(!1);
                  }
                }
              } else w = f;
              return (
                (A.memoizedState = A.baseState = w),
                (c = {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: c,
                  lastRenderedState: w,
                }),
                (A.queue = c),
                (c = c.dispatch = uh.bind(null, _n, c)),
                [A.memoizedState, c]
              );
            },
            useRef: function (c) {
              var f = H();
              return (c = { current: c }), (f.memoizedState = c);
            },
            useState: function (c) {
              c = Oe(c);
              var f = c.queue,
                y = mp.bind(null, _n, f);
              return (f.dispatch = y), [c.memoizedState, y];
            },
            useDebugValue: Mo,
            useDeferredValue: function (c, f) {
              var y = H();
              return Eu(y, c, f);
            },
            useTransition: function () {
              var c = Oe(!1);
              return (
                (c = ac.bind(null, _n, c.queue, !0, !1)),
                (H().memoizedState = c),
                [!1, c]
              );
            },
            useSyncExternalStore: function (c, f, y) {
              var A = _n,
                w = H();
              if (On) {
                if (y === void 0) throw Error(a(407));
                y = y();
              } else {
                if (((y = f()), Xn === null)) throw Error(a(349));
                (wn & 60) !== 0 || ve(A, f, y);
              }
              w.memoizedState = y;
              var U = { value: y, getSnapshot: f };
              return (
                (w.queue = U),
                oh(He.bind(null, A, U, c), [c]),
                (A.flags |= 2048),
                Ca(9, _e.bind(null, A, U, y, f), { destroy: void 0 }, null),
                y
              );
            },
            useId: function () {
              var c = H(),
                f = Xn.identifierPrefix;
              if (On) {
                var y = $s,
                  A = Qs;
                (y = (A & ~(1 << (32 - Na(A) - 1))).toString(32) + y),
                  (f = ":" + f + "R" + y),
                  (y = Kh++),
                  0 < y && (f += "H" + y.toString(32)),
                  (f += ":");
              } else (y = er++), (f = ":" + f + "r" + y.toString(32) + ":");
              return (c.memoizedState = f);
            },
            useCacheRefresh: function () {
              return (H().memoizedState = pp.bind(null, _n));
            },
          };
          (Qo.useMemoCache = gt),
            (Qo.useHostTransitionStatus = Tu),
            (Qo.useFormState = gn),
            (Qo.useActionState = gn),
            (Qo.useOptimistic = function (c) {
              var f = H();
              f.memoizedState = f.baseState = c;
              var y = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null,
              };
              return (
                (f.queue = y),
                (f = rc.bind(null, _n, !0, y)),
                (y.dispatch = f),
                [c, f]
              );
            });
          var La = {
            readContext: oa,
            use: ot,
            useCallback: gl,
            useContext: oa,
            useEffect: fp,
            useImperativeHandle: ch,
            useInsertionEffect: Z0,
            useLayoutEffect: Mu,
            useMemo: hp,
            useReducer: Vt,
            useRef: ur,
            useState: function () {
              return Vt(wt);
            },
            useDebugValue: Mo,
            useDeferredValue: function (c, f) {
              var y = tt();
              return dp(y, Je.memoizedState, c, f);
            },
            useTransition: function () {
              var c = Vt(wt)[0],
                f = tt().memoizedState;
              return [typeof c == "boolean" ? c : rt(c), f];
            },
            useSyncExternalStore: xe,
            useId: sc,
          };
          (La.useCacheRefresh = Gr),
            (La.useMemoCache = gt),
            (La.useHostTransitionStatus = Tu),
            (La.useFormState = fi),
            (La.useActionState = fi),
            (La.useOptimistic = function (c, f) {
              var y = tt();
              return Ve(y, Je, c, f);
            });
          var hs = {
            readContext: oa,
            use: ot,
            useCallback: gl,
            useContext: oa,
            useEffect: fp,
            useImperativeHandle: ch,
            useInsertionEffect: Z0,
            useLayoutEffect: Mu,
            useMemo: hp,
            useReducer: ee,
            useRef: ur,
            useState: function () {
              return ee(wt);
            },
            useDebugValue: Mo,
            useDeferredValue: function (c, f) {
              var y = tt();
              return Je === null ? Eu(y, c, f) : dp(y, Je.memoizedState, c, f);
            },
            useTransition: function () {
              var c = ee(wt)[0],
                f = tt().memoizedState;
              return [typeof c == "boolean" ? c : rt(c), f];
            },
            useSyncExternalStore: xe,
            useId: sc,
          };
          (hs.useCacheRefresh = Gr),
            (hs.useMemoCache = gt),
            (hs.useHostTransitionStatus = Tu),
            (hs.useFormState = Zi),
            (hs.useActionState = Zi),
            (hs.useOptimistic = function (c, f) {
              var y = tt();
              return Je !== null
                ? Ve(y, Je, c, f)
                : ((y.baseState = c), [c, y.queue.dispatch]);
            });
          var br = {
              isMounted: function (c) {
                return (c = c._reactInternals) ? v(c) === c : !1;
              },
              enqueueSetState: function (c, f, y) {
                c = c._reactInternals;
                var A = Bi(),
                  w = jt(A);
                (w.payload = f),
                  y != null && (w.callback = y),
                  (f = ce(c, w, A)),
                  f !== null && ($i(f, c, A), Re(f, c, A));
              },
              enqueueReplaceState: function (c, f, y) {
                c = c._reactInternals;
                var A = Bi(),
                  w = jt(A);
                (w.tag = 1),
                  (w.payload = f),
                  y != null && (w.callback = y),
                  (f = ce(c, w, A)),
                  f !== null && ($i(f, c, A), Re(f, c, A));
              },
              enqueueForceUpdate: function (c, f) {
                c = c._reactInternals;
                var y = Bi(),
                  A = jt(y);
                (A.tag = 2),
                  f != null && (A.callback = f),
                  (f = ce(c, A, y)),
                  f !== null && ($i(f, c, y), Re(f, c, y));
              },
            },
            Zh =
              typeof reportError == "function"
                ? reportError
                : function (c) {
                    if (
                      typeof window == "object" &&
                      typeof window.ErrorEvent == "function"
                    ) {
                      var f = new window.ErrorEvent("error", {
                        bubbles: !0,
                        cancelable: !0,
                        message:
                          typeof c == "object" &&
                          c !== null &&
                          typeof c.message == "string"
                            ? String(c.message)
                            : String(c),
                        error: c,
                      });
                      if (!window.dispatchEvent(f)) return;
                    } else if (
                      typeof process == "object" &&
                      typeof process.emit == "function"
                    ) {
                      process.emit("uncaughtException", c);
                      return;
                    }
                    console.error(c);
                  },
            Qh = Error(a(461)),
            ni = !1,
            $h = { dehydrated: null, treeContext: null, retryLane: 0 },
            lo = E(null),
            nr = null,
            ds = null,
            zc =
              typeof AbortController < "u"
                ? AbortController
                : function () {
                    var c = [],
                      f = (this.signal = {
                        aborted: !1,
                        addEventListener: function (y, A) {
                          c.push(A);
                        },
                      });
                    this.abort = function () {
                      (f.aborted = !0),
                        c.forEach(function (y) {
                          return y();
                        });
                    };
                  },
            rv = rs.unstable_scheduleCallback,
            ov = rs.unstable_NormalPriority,
            li = {
              $$typeof: Ks,
              Consumer: null,
              Provider: null,
              _currentValue: null,
              _currentValue2: null,
              _threadCount: 0,
            },
            um = nn.S;
          nn.S = function (c, f) {
            typeof f == "object" &&
              f !== null &&
              typeof f.then == "function" &&
              zt(c, f),
              um !== null && um(c, f);
          };
          var Ar = E(null),
            Sr = !1,
            Ai = !1,
            fm = !1,
            jn = typeof WeakSet == "function" ? WeakSet : Set,
            cn = null,
            En = !1,
            We = null,
            vn = !1,
            gi = null,
            ps = 8192,
            Fc = {
              getCacheForType: function (c) {
                var f = oa(li),
                  y = f.data.get(c);
                return y === void 0 && ((y = c()), f.data.set(c, y)), y;
              },
            },
            Hc = 0,
            Is = 1,
            hi = 2,
            ir = 3,
            Mr = 4;
          if (typeof Symbol == "function" && Symbol.for) {
            var Ll = Symbol.for;
            (Hc = Ll("selector.component")),
              (Is = Ll("selector.has_pseudo_class")),
              (hi = Ll("selector.role")),
              (ir = Ll("selector.test_id")),
              (Mr = Ll("selector.text"));
          }
          var Ps = typeof WeakMap == "function" ? WeakMap : Map,
            Ln = 0,
            Xn = null,
            Ze = null,
            wn = 0,
            Jn = 0,
            ba = null,
            zs = !1,
            ms = !1,
            Wi = !1,
            Aa = 0,
            ii = 0,
            gs = 0,
            co = 0,
            ff = 0,
            vs = 0,
            Er = 0,
            Il = null,
            Si = null,
            td = !1,
            Ia = 0,
            Gc = 1 / 0,
            hf = null,
            $o = null,
            ar = !1,
            Tr = null,
            Pl = 0,
            tl = 0,
            ed = null,
            Vc = 0,
            nd = null;
          return (
            (fn.attemptContinuousHydration = function (c) {
              if (c.tag === 13) {
                var f = $t(c, 67108864);
                f !== null && $i(f, c, 67108864), Yu(c, 67108864);
              }
            }),
            (fn.attemptHydrationAtCurrentPriority = function (c) {
              if (c.tag === 13) {
                var f = Bi(),
                  y = $t(c, f);
                y !== null && $i(y, c, f), Yu(c, f);
              }
            }),
            (fn.attemptSynchronousHydration = function (c) {
              switch (c.tag) {
                case 3:
                  if (
                    ((c = c.stateNode), c.current.memoizedState.isDehydrated)
                  ) {
                    var f = D(c.pendingLanes);
                    if (f !== 0) {
                      for (c.pendingLanes |= 2, c.entangledLanes |= 2; f; ) {
                        var y = 1 << (31 - Na(f));
                        (c.entanglements[1] |= y), (f &= ~y);
                      }
                      te(c), (Ln & 6) === 0 && ((Gc = Us() + 500), pe(0));
                    }
                  }
                  break;
                case 13:
                  (f = $t(c, 2)), f !== null && $i(f, c, 2), ku(), Yu(c, 2);
              }
            }),
            (fn.batchedUpdates = function (c, f) {
              return c(f);
            }),
            (fn.createComponentSelector = function (c) {
              return { $$typeof: Hc, value: c };
            }),
            (fn.createContainer = function (c, f, y, A, w, U, q, lt, St, Xt) {
              return yg(c, f, !1, null, y, A, U, q, lt, St, Xt, null);
            }),
            (fn.createHasPseudoClassSelector = function (c) {
              return { $$typeof: Is, value: c };
            }),
            (fn.createHydrationContainer = function (
              c,
              f,
              y,
              A,
              w,
              U,
              q,
              lt,
              St,
              Xt,
              he,
              Me,
              Te
            ) {
              return (
                (c = yg(y, A, !0, c, w, U, lt, St, Xt, he, Me, Te)),
                (c.context = zi(null)),
                (y = c.current),
                (A = Bi()),
                (w = jt(A)),
                (w.callback = f ?? null),
                ce(y, w, A),
                (c.current.lanes = A),
                Y(c, A),
                te(c),
                c
              );
            }),
            (fn.createPortal = function (c, f, y) {
              var A =
                3 < arguments.length && arguments[3] !== void 0
                  ? arguments[3]
                  : null;
              return {
                $$typeof: Rs,
                key: A == null ? null : "" + A,
                children: c,
                containerInfo: f,
                implementation: y,
              };
            }),
            (fn.createRoleSelector = function (c) {
              return { $$typeof: hi, value: c };
            }),
            (fn.createTestNameSelector = function (c) {
              return { $$typeof: ir, value: c };
            }),
            (fn.createTextSelector = function (c) {
              return { $$typeof: Mr, value: c };
            }),
            (fn.defaultOnCaughtError = function (c) {
              console.error(c);
            }),
            (fn.defaultOnRecoverableError = function (c) {
              Zh(c);
            }),
            (fn.defaultOnUncaughtError = function (c) {
              Zh(c);
            }),
            (fn.deferredUpdates = function (c) {
              var f = nn.T,
                y = no();
              try {
                return _a(32), (nn.T = null), c();
              } finally {
                _a(y), (nn.T = f);
              }
            }),
            (fn.discreteUpdates = function (c, f, y, A, w) {
              var U = nn.T,
                q = no();
              try {
                return _a(2), (nn.T = null), c(f, y, A, w);
              } finally {
                _a(q), (nn.T = U), Ln === 0 && (Gc = Us() + 500);
              }
            }),
            (fn.findAllNodes = Gu),
            (fn.findBoundingRects = function (c, f) {
              if (!Vo) throw Error(a(363));
              (f = Gu(c, f)), (c = []);
              for (var y = 0; y < f.length; y++) c.push(Jp(f[y]));
              for (f = c.length - 1; 0 < f; f--) {
                y = c[f];
                for (
                  var A = y.x,
                    w = A + y.width,
                    U = y.y,
                    q = U + y.height,
                    lt = f - 1;
                  0 <= lt;
                  lt--
                )
                  if (f !== lt) {
                    var St = c[lt],
                      Xt = St.x,
                      he = Xt + St.width,
                      Me = St.y,
                      Te = Me + St.height;
                    if (A >= Xt && U >= Me && w <= he && q <= Te) {
                      c.splice(f, 1);
                      break;
                    } else if (
                      A !== Xt ||
                      y.width !== St.width ||
                      Te < U ||
                      Me > q
                    ) {
                      if (
                        !(
                          U !== Me ||
                          y.height !== St.height ||
                          he < A ||
                          Xt > w
                        )
                      ) {
                        Xt > A && ((St.width += Xt - A), (St.x = A)),
                          he < w && (St.width = w - Xt),
                          c.splice(f, 1);
                        break;
                      }
                    } else {
                      Me > U && ((St.height += Me - U), (St.y = U)),
                        Te < q && (St.height = q - Me),
                        c.splice(f, 1);
                      break;
                    }
                  }
              }
              return c;
            }),
            (fn.findHostInstance = Ch),
            (fn.findHostInstanceWithNoPortals = function (c) {
              return (
                (c = _(c)),
                (c = c !== null ? C(c) : null),
                c === null ? null : Tc(c.stateNode)
              );
            }),
            (fn.findHostInstanceWithWarning = function (c) {
              return Ch(c);
            }),
            (fn.flushPassiveEffects = qs),
            (fn.flushSyncFromReconciler = function (c) {
              var f = Ln;
              Ln |= 1;
              var y = nn.T,
                A = no();
              try {
                if ((_a(2), (nn.T = null), c)) return c();
              } finally {
                _a(A), (nn.T = y), (Ln = f), (Ln & 6) === 0 && pe(0);
              }
            }),
            (fn.flushSyncWork = ku),
            (fn.focusWithin = function (c, f) {
              if (!Vo) throw Error(a(363));
              for (
                c = gc(c), f = qa(c, f), f = Array.from(f), c = 0;
                c < f.length;

              ) {
                var y = f[c++],
                  A = y.tag;
                if (!Cc(y)) {
                  if ((A === 5 || A === 26 || A === 27) && wg(y.stateNode))
                    return !0;
                  for (y = y.child; y !== null; ) f.push(y), (y = y.sibling);
                }
              }
              return !1;
            }),
            (fn.getFindAllNodesFailureDescription = function (c, f) {
              if (!Vo) throw Error(a(363));
              var y = 0,
                A = [];
              c = [gc(c), 0];
              for (var w = 0; w < c.length; ) {
                var U = c[w++],
                  q = U.tag,
                  lt = c[w++],
                  St = f[lt];
                if (
                  ((q !== 5 && q !== 26 && q !== 27) || !Cc(U)) &&
                  (Oo(U, St) && (A.push(Op(St)), lt++, lt > y && (y = lt)),
                  lt < f.length)
                )
                  for (U = U.child; U !== null; )
                    c.push(U, lt), (U = U.sibling);
              }
              if (y < f.length) {
                for (c = []; y < f.length; y++) c.push(Op(f[y]));
                return (
                  `findAllNodes was able to match part of the selector:
  ` +
                  (A.join(" > ") +
                    `

No matching component was found for:
  `) +
                  c.join(" > ")
                );
              }
              return null;
            }),
            (fn.getPublicRootInstance = function (c) {
              if (((c = c.current), !c.child)) return null;
              switch (c.child.tag) {
                case 27:
                case 5:
                  return Tc(c.child.stateNode);
                default:
                  return c.child.stateNode;
              }
            }),
            (fn.injectIntoDevTools = function () {
              var c = {
                bundleType: 0,
                version: jp,
                rendererPackageName: Qu,
                currentDispatcherRef: nn,
                findFiberByHostInstance: Ag,
                reconcilerVersion: "19.0.0",
              };
              if (
                (Ec !== null && (c.rendererConfig = Ec),
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
              )
                c = !1;
              else {
                var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (f.isDisabled || !f.supportsFiber) c = !0;
                else {
                  try {
                    (Oi = f.inject(c)), (Ja = f);
                  } catch {}
                  c = !!f.checkDCE;
                }
              }
              return c;
            }),
            (fn.isAlreadyRendering = function () {
              return !1;
            }),
            (fn.observeVisibleRects = function (c, f, y, A) {
              if (!Vo) throw Error(a(363));
              c = Gu(c, f);
              var w = Cg(c, y, A).disconnect;
              return {
                disconnect: function () {
                  w();
                },
              };
            }),
            (fn.shouldError = function () {
              return null;
            }),
            (fn.shouldSuspend = function () {
              return !1;
            }),
            (fn.startHostTransition = function (c, f, y, A) {
              if (c.tag !== 5) throw Error(a(476));
              var w = fr(c).queue;
              ac(
                c,
                w,
                f,
                Go,
                y === null
                  ? n
                  : function () {
                      var U = fr(c).next.queue;
                      return Eo(c, U, {}, Bi()), y(A);
                    }
              );
            }),
            (fn.updateContainer = function (c, f, y, A) {
              var w = f.current,
                U = Bi();
              return _c(w, U, c, f, y, A), U;
            }),
            (fn.updateContainerSync = function (c, f, y, A) {
              return f.tag === 0 && qs(), _c(f.current, 2, c, f, y, A), 2;
            }),
            fn
          );
        }),
          (i.exports.default = i.exports),
          Object.defineProperty(i.exports, "__esModule", { value: !0 });
      })(tb)),
    tb.exports
  );
}
var $T;
function vz() {
  return $T || (($T = 1), ($_.exports = gz())), $_.exports;
}
var yz = vz();
const xz = CA(yz);
var tw = GR();
const _z = (i) => typeof i == "object" && typeof i.then == "function",
  Gf = [];
function VR(i, t, e = (n, a) => n === a) {
  if (i === t) return !0;
  if (!i || !t) return !1;
  const n = i.length;
  if (t.length !== n) return !1;
  for (let a = 0; a < n; a++) if (!e(i[a], t[a])) return !1;
  return !0;
}
function kR(i, t = null, e = !1, n = {}) {
  t === null && (t = [i]);
  for (const r of Gf)
    if (VR(t, r.keys, r.equal)) {
      if (e) return;
      if (Object.prototype.hasOwnProperty.call(r, "error")) throw r.error;
      if (Object.prototype.hasOwnProperty.call(r, "response"))
        return (
          n.lifespan &&
            n.lifespan > 0 &&
            (r.timeout && clearTimeout(r.timeout),
            (r.timeout = setTimeout(r.remove, n.lifespan))),
          r.response
        );
      if (!e) throw r.promise;
    }
  const a = {
    keys: t,
    equal: n.equal,
    remove: () => {
      const r = Gf.indexOf(a);
      r !== -1 && Gf.splice(r, 1);
    },
    promise: (_z(i) ? i : i(...t))
      .then((r) => {
        (a.response = r),
          n.lifespan &&
            n.lifespan > 0 &&
            (a.timeout = setTimeout(a.remove, n.lifespan));
      })
      .catch((r) => (a.error = r)),
  };
  if ((Gf.push(a), !e)) throw a.promise;
}
const bz = (i, t, e) => kR(i, t, !1, e),
  Az = (i, t, e) => void kR(i, t, !0, e),
  Sz = (i) => {
    if (i === void 0 || i.length === 0) Gf.splice(0, Gf.length);
    else {
      const t = Gf.find((e) => VR(i, e.keys, e.equal));
      t && t.remove();
    }
  };
function SS(i, t, e) {
  if (!i) return;
  if (e(i) === !0) return i;
  let n = t ? i.return : i.child;
  for (; n; ) {
    const a = SS(n, t, e);
    if (a) return a;
    n = t ? null : n.sibling;
  }
}
function jR(i) {
  try {
    return Object.defineProperties(i, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return i;
  }
}
const MS = jR(bt.createContext(null));
class XR extends bt.Component {
  render() {
    return bt.createElement(
      MS.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function WR() {
  const i = bt.useContext(MS);
  if (i === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const t = bt.useId();
  return bt.useMemo(() => {
    for (const e of [i, i?.alternate]) {
      if (!e) continue;
      const n = SS(e, !1, (a) => {
        let r = a.memoizedState;
        for (; r; ) {
          if (r.memoizedState === t) return !0;
          r = r.next;
        }
      });
      if (n) return n;
    }
  }, [i, t]);
}
const Mz = Symbol.for("react.context"),
  Ez = (i) =>
    i !== null && typeof i == "object" && "$$typeof" in i && i.$$typeof === Mz;
function Tz() {
  const i = WR(),
    [t] = bt.useState(() => new Map());
  t.clear();
  let e = i;
  for (; e; ) {
    const n = e.type;
    Ez(n) && n !== MS && !t.has(n) && t.set(n, bt.use(jR(n))), (e = e.return);
  }
  return t;
}
function wz() {
  const i = Tz();
  return bt.useMemo(
    () =>
      Array.from(i.keys()).reduce(
        (t, e) => (n) =>
          bt.createElement(
            t,
            null,
            bt.createElement(e.Provider, { ...n, value: i.get(e) })
          ),
        (t) => bt.createElement(XR, { ...t })
      ),
    [i]
  );
}
function YR(i) {
  let t = i.root;
  for (; t.getState().previousRoot; ) t = t.getState().previousRoot;
  return t;
}
const qR = (i) => i && i.isOrthographicCamera,
  Cz = (i) => i && i.hasOwnProperty("current"),
  Rz = (i) =>
    i != null && (typeof i == "string" || typeof i == "number" || i.isColor),
  k0 = ((i, t) =>
    typeof window < "u" &&
    (((i = window.document) == null ? void 0 : i.createElement) ||
      ((t = window.navigator) == null ? void 0 : t.product) ===
        "ReactNative"))()
    ? bt.useLayoutEffect
    : bt.useEffect;
function ES(i) {
  const t = bt.useRef(i);
  return k0(() => void (t.current = i), [i]), t;
}
function Bz() {
  const i = WR(),
    t = wz();
  return bt.useMemo(
    () =>
      ({ children: e }) => {
        const a = !!SS(i, !0, (r) => r.type === bt.StrictMode)
          ? bt.StrictMode
          : bt.Fragment;
        return O.jsx(a, { children: O.jsx(t, { children: e }) });
      },
    [i, t]
  );
}
function Dz({ set: i }) {
  return k0(() => (i(new Promise(() => null)), () => i(!1)), [i]), null;
}
const Uz = ((i) => (
  (i = class extends bt.Component {
    constructor(...e) {
      super(...e), (this.state = { error: !1 });
    }
    componentDidCatch(e) {
      this.props.set(e);
    }
    render() {
      return this.state.error ? null : this.props.children;
    }
  }),
  (i.getDerivedStateFromError = () => ({ error: !0 })),
  i
))();
function KR(i) {
  var t;
  const e =
    typeof window < "u" ? ((t = window.devicePixelRatio) != null ? t : 2) : 1;
  return Array.isArray(i) ? Math.min(Math.max(i[0], e), i[1]) : i;
}
function Td(i) {
  var t;
  return (t = i.__r3f) == null ? void 0 : t.root.getState();
}
const Mi = {
  obj: (i) => i === Object(i) && !Mi.arr(i) && typeof i != "function",
  fun: (i) => typeof i == "function",
  str: (i) => typeof i == "string",
  num: (i) => typeof i == "number",
  boo: (i) => typeof i == "boolean",
  und: (i) => i === void 0,
  nul: (i) => i === null,
  arr: (i) => Array.isArray(i),
  equ(
    i,
    t,
    { arrays: e = "shallow", objects: n = "reference", strict: a = !0 } = {}
  ) {
    if (typeof i != typeof t || !!i != !!t) return !1;
    if (Mi.str(i) || Mi.num(i) || Mi.boo(i)) return i === t;
    const r = Mi.obj(i);
    if (r && n === "reference") return i === t;
    const l = Mi.arr(i);
    if (l && e === "reference") return i === t;
    if ((l || r) && i === t) return !0;
    let u;
    for (u in i) if (!(u in t)) return !1;
    if (r && e === "shallow" && n === "shallow") {
      for (u in a ? t : i)
        if (!Mi.equ(i[u], t[u], { strict: a, objects: "reference" })) return !1;
    } else for (u in a ? t : i) if (i[u] !== t[u]) return !1;
    if (Mi.und(u)) {
      if (
        (l && i.length === 0 && t.length === 0) ||
        (r && Object.keys(i).length === 0 && Object.keys(t).length === 0)
      )
        return !0;
      if (i !== t) return !1;
    }
    return !0;
  },
};
function Oz(i) {
  const t = { nodes: {}, materials: {}, meshes: {} };
  return (
    i &&
      i.traverse((e) => {
        e.name && (t.nodes[e.name] = e),
          e.material &&
            !t.materials[e.material.name] &&
            (t.materials[e.material.name] = e.material),
          e.isMesh && !t.meshes[e.name] && (t.meshes[e.name] = e);
      }),
    t
  );
}
function Nz(i) {
  i.type !== "Scene" && (i.dispose == null || i.dispose());
  for (const t in i) {
    const e = i[t];
    e?.type !== "Scene" && (e == null || e.dispose == null || e.dispose());
  }
}
const JR = ["children", "key", "ref"];
function Lz(i) {
  const t = {};
  for (const e in i) JR.includes(e) || (t[e] = i[e]);
  return t;
}
function _x(i, t, e, n) {
  const a = i;
  let r = a?.__r3f;
  return (
    r ||
      ((r = {
        root: t,
        type: e,
        parent: null,
        children: [],
        props: Lz(n),
        object: a,
        eventCount: 0,
        handlers: {},
        isHidden: !1,
      }),
      a && (a.__r3f = r)),
    r
  );
}
function y0(i, t) {
  let e = i[t];
  if (!t.includes("-")) return { root: i, key: t, target: e };
  e = i;
  for (const a of t.split("-")) {
    var n;
    (t = a), (i = e), (e = (n = e) == null ? void 0 : n[t]);
  }
  return { root: i, key: t, target: e };
}
const ew = /-\d+$/;
function bx(i, t) {
  if (Mi.str(t.props.attach)) {
    if (ew.test(t.props.attach)) {
      const a = t.props.attach.replace(ew, ""),
        { root: r, key: l } = y0(i.object, a);
      Array.isArray(r[l]) || (r[l] = []);
    }
    const { root: e, key: n } = y0(i.object, t.props.attach);
    (t.previousAttach = e[n]), (e[n] = t.object);
  } else
    Mi.fun(t.props.attach) &&
      (t.previousAttach = t.props.attach(i.object, t.object));
}
function Ax(i, t) {
  if (Mi.str(t.props.attach)) {
    const { root: e, key: n } = y0(i.object, t.props.attach),
      a = t.previousAttach;
    a === void 0 ? delete e[n] : (e[n] = a);
  } else t.previousAttach == null || t.previousAttach(i.object, t.object);
  delete t.previousAttach;
}
const Zb = [
    ...JR,
    "args",
    "dispose",
    "attach",
    "object",
    "onUpdate",
    "dispose",
  ],
  nw = new Map();
function Iz(i) {
  let t = nw.get(i.constructor);
  try {
    t || ((t = new i.constructor()), nw.set(i.constructor, t));
  } catch {}
  return t;
}
function Pz(i, t) {
  const e = {};
  for (const n in t)
    if (!Zb.includes(n) && !Mi.equ(t[n], i.props[n])) {
      e[n] = t[n];
      for (const a in t) a.startsWith(`${n}-`) && (e[a] = t[a]);
    }
  for (const n in i.props) {
    if (Zb.includes(n) || t.hasOwnProperty(n)) continue;
    const { root: a, key: r } = y0(i.object, n);
    if (a.constructor && a.constructor.length === 0) {
      const l = Iz(a);
      Mi.und(l) || (e[r] = l[r]);
    } else e[r] = 0;
  }
  return e;
}
const zz = [
    "map",
    "emissiveMap",
    "sheenColorMap",
    "specularColorMap",
    "envMap",
  ],
  Fz = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
function rl(i, t) {
  var e;
  const n = i.__r3f,
    a = n && YR(n).getState(),
    r = n?.eventCount;
  for (const u in t) {
    let h = t[u];
    if (Zb.includes(u)) continue;
    if (n && Fz.test(u)) {
      typeof h == "function" ? (n.handlers[u] = h) : delete n.handlers[u],
        (n.eventCount = Object.keys(n.handlers).length);
      continue;
    }
    if (h === void 0) continue;
    let { root: p, key: m, target: v } = y0(i, u);
    if (v instanceof Zd && h instanceof Zd) v.mask = h.mask;
    else if (v instanceof Se && Rz(h)) v.set(h);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      typeof v.copy == "function" &&
      h != null &&
      h.constructor &&
      v.constructor === h.constructor
    )
      v.copy(h);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      Array.isArray(h)
    )
      typeof v.fromArray == "function" ? v.fromArray(h) : v.set(...h);
    else if (
      v !== null &&
      typeof v == "object" &&
      typeof v.set == "function" &&
      typeof h == "number"
    )
      typeof v.setScalar == "function" ? v.setScalar(h) : v.set(h);
    else {
      var l;
      (p[m] = h),
        a &&
          !a.linear &&
          zz.includes(m) &&
          (l = p[m]) != null &&
          l.isTexture &&
          p[m].format === Ji &&
          p[m].type === Es &&
          (p[m].colorSpace = Fa);
    }
  }
  if (
    n != null &&
    n.parent &&
    a != null &&
    a.internal &&
    (e = n.object) != null &&
    e.isObject3D &&
    r !== n.eventCount
  ) {
    const u = n.object,
      h = a.internal.interaction.indexOf(u);
    h > -1 && a.internal.interaction.splice(h, 1),
      n.eventCount && u.raycast !== null && a.internal.interaction.push(u);
  }
  return (
    n &&
      n.props.attach === void 0 &&
      (n.object.isBufferGeometry
        ? (n.props.attach = "geometry")
        : n.object.isMaterial && (n.props.attach = "material")),
    n && op(n),
    i
  );
}
function op(i) {
  var t;
  if (!i.parent) return;
  i.props.onUpdate == null || i.props.onUpdate(i.object);
  const e = (t = i.root) == null || t.getState == null ? void 0 : t.getState();
  e && e.internal.frames === 0 && e.invalidate();
}
function ZR(i, t) {
  i.manual ||
    (qR(i)
      ? ((i.left = t.width / -2),
        (i.right = t.width / 2),
        (i.top = t.height / 2),
        (i.bottom = t.height / -2))
      : (i.aspect = t.width / t.height),
    i.updateProjectionMatrix());
}
const bs = (i) => i?.isObject3D;
function my(i) {
  return (i.eventObject || i.object).uuid + "/" + i.index + i.instanceId;
}
function QR(i, t, e, n) {
  const a = e.get(t);
  a &&
    (e.delete(t),
    e.size === 0 && (i.delete(n), a.target.releasePointerCapture(n)));
}
function Hz(i, t) {
  const { internal: e } = i.getState();
  (e.interaction = e.interaction.filter((n) => n !== t)),
    (e.initialHits = e.initialHits.filter((n) => n !== t)),
    e.hovered.forEach((n, a) => {
      (n.eventObject === t || n.object === t) && e.hovered.delete(a);
    }),
    e.capturedMap.forEach((n, a) => {
      QR(e.capturedMap, t, n, a);
    });
}
function Gz(i) {
  function t(h) {
    const { internal: p } = i.getState(),
      m = h.offsetX - p.initialClick[0],
      v = h.offsetY - p.initialClick[1];
    return Math.round(Math.sqrt(m * m + v * v));
  }
  function e(h) {
    return h.filter((p) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((m) => {
        var v;
        return (v = p.__r3f) == null ? void 0 : v.handlers["onPointer" + m];
      })
    );
  }
  function n(h, p) {
    const m = i.getState(),
      v = new Set(),
      x = [],
      _ = p ? p(m.internal.interaction) : m.internal.interaction;
    for (let S = 0; S < _.length; S++) {
      const R = Td(_[S]);
      R && (R.raycaster.camera = void 0);
    }
    m.previousRoot || m.events.compute == null || m.events.compute(h, m);
    function M(S) {
      const R = Td(S);
      if (!R || !R.events.enabled || R.raycaster.camera === null) return [];
      if (R.raycaster.camera === void 0) {
        var B;
        R.events.compute == null ||
          R.events.compute(
            h,
            R,
            (B = R.previousRoot) == null ? void 0 : B.getState()
          ),
          R.raycaster.camera === void 0 && (R.raycaster.camera = null);
      }
      return R.raycaster.camera ? R.raycaster.intersectObject(S, !0) : [];
    }
    let C = _.flatMap(M)
      .sort((S, R) => {
        const B = Td(S.object),
          D = Td(R.object);
        return !B || !D
          ? S.distance - R.distance
          : D.events.priority - B.events.priority || S.distance - R.distance;
      })
      .filter((S) => {
        const R = my(S);
        return v.has(R) ? !1 : (v.add(R), !0);
      });
    m.events.filter && (C = m.events.filter(C, m));
    for (const S of C) {
      let R = S.object;
      for (; R; ) {
        var E;
        (E = R.__r3f) != null &&
          E.eventCount &&
          x.push({ ...S, eventObject: R }),
          (R = R.parent);
      }
    }
    if ("pointerId" in h && m.internal.capturedMap.has(h.pointerId))
      for (let S of m.internal.capturedMap.get(h.pointerId).values())
        v.has(my(S.intersection)) || x.push(S.intersection);
    return x;
  }
  function a(h, p, m, v) {
    if (h.length) {
      const x = { stopped: !1 };
      for (const _ of h) {
        let M = Td(_.object);
        if (
          (M ||
            _.object.traverseAncestors((C) => {
              const E = Td(C);
              if (E) return (M = E), !1;
            }),
          M)
        ) {
          const { raycaster: C, pointer: E, camera: S, internal: R } = M,
            B = new Z(E.x, E.y, 0).unproject(S),
            D = (N) => {
              var L, Y;
              return (L =
                (Y = R.capturedMap.get(N)) == null
                  ? void 0
                  : Y.has(_.eventObject)) != null
                ? L
                : !1;
            },
            I = (N) => {
              const L = { intersection: _, target: p.target };
              R.capturedMap.has(N)
                ? R.capturedMap.get(N).set(_.eventObject, L)
                : R.capturedMap.set(N, new Map([[_.eventObject, L]])),
                p.target.setPointerCapture(N);
            },
            P = (N) => {
              const L = R.capturedMap.get(N);
              L && QR(R.capturedMap, _.eventObject, L, N);
            };
          let V = {};
          for (let N in p) {
            let L = p[N];
            typeof L != "function" && (V[N] = L);
          }
          let F = {
            ..._,
            ...V,
            pointer: E,
            intersections: h,
            stopped: x.stopped,
            delta: m,
            unprojectedPoint: B,
            ray: C.ray,
            camera: S,
            stopPropagation() {
              const N = "pointerId" in p && R.capturedMap.get(p.pointerId);
              if (
                (!N || N.has(_.eventObject)) &&
                ((F.stopped = x.stopped = !0),
                R.hovered.size &&
                  Array.from(R.hovered.values()).find(
                    (L) => L.eventObject === _.eventObject
                  ))
              ) {
                const L = h.slice(0, h.indexOf(_));
                r([...L, _]);
              }
            },
            target: {
              hasPointerCapture: D,
              setPointerCapture: I,
              releasePointerCapture: P,
            },
            currentTarget: {
              hasPointerCapture: D,
              setPointerCapture: I,
              releasePointerCapture: P,
            },
            nativeEvent: p,
          };
          if ((v(F), x.stopped === !0)) break;
        }
      }
    }
    return h;
  }
  function r(h) {
    const { internal: p } = i.getState();
    for (const m of p.hovered.values())
      if (
        !h.length ||
        !h.find(
          (v) =>
            v.object === m.object &&
            v.index === m.index &&
            v.instanceId === m.instanceId
        )
      ) {
        const x = m.eventObject.__r3f;
        if ((p.hovered.delete(my(m)), x != null && x.eventCount)) {
          const _ = x.handlers,
            M = { ...m, intersections: h };
          _.onPointerOut == null || _.onPointerOut(M),
            _.onPointerLeave == null || _.onPointerLeave(M);
        }
      }
  }
  function l(h, p) {
    for (let m = 0; m < p.length; m++) {
      const v = p[m].__r3f;
      v == null ||
        v.handlers.onPointerMissed == null ||
        v.handlers.onPointerMissed(h);
    }
  }
  function u(h) {
    switch (h) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => r([]);
      case "onLostPointerCapture":
        return (p) => {
          const { internal: m } = i.getState();
          "pointerId" in p &&
            m.capturedMap.has(p.pointerId) &&
            requestAnimationFrame(() => {
              m.capturedMap.has(p.pointerId) &&
                (m.capturedMap.delete(p.pointerId), r([]));
            });
        };
    }
    return function (m) {
      const { onPointerMissed: v, internal: x } = i.getState();
      x.lastEvent.current = m;
      const _ = h === "onPointerMove",
        M = h === "onClick" || h === "onContextMenu" || h === "onDoubleClick",
        E = n(m, _ ? e : void 0),
        S = M ? t(m) : 0;
      h === "onPointerDown" &&
        ((x.initialClick = [m.offsetX, m.offsetY]),
        (x.initialHits = E.map((B) => B.eventObject))),
        M && !E.length && S <= 2 && (l(m, x.interaction), v && v(m)),
        _ && r(E);
      function R(B) {
        const D = B.eventObject,
          I = D.__r3f;
        if (!(I != null && I.eventCount)) return;
        const P = I.handlers;
        if (_) {
          if (
            P.onPointerOver ||
            P.onPointerEnter ||
            P.onPointerOut ||
            P.onPointerLeave
          ) {
            const V = my(B),
              F = x.hovered.get(V);
            F
              ? F.stopped && B.stopPropagation()
              : (x.hovered.set(V, B),
                P.onPointerOver == null || P.onPointerOver(B),
                P.onPointerEnter == null || P.onPointerEnter(B));
          }
          P.onPointerMove == null || P.onPointerMove(B);
        } else {
          const V = P[h];
          V
            ? (!M || x.initialHits.includes(D)) &&
              (l(
                m,
                x.interaction.filter((F) => !x.initialHits.includes(F))
              ),
              V(B))
            : M &&
              x.initialHits.includes(D) &&
              l(
                m,
                x.interaction.filter((F) => !x.initialHits.includes(F))
              );
        }
      }
      a(E, m, S, R);
    };
  }
  return { handlePointer: u };
}
const iw = (i) => !!(i != null && i.render),
  TS = bt.createContext(null),
  Vz = (i, t) => {
    const e = HR((u, h) => {
        const p = new Z(),
          m = new Z(),
          v = new Z();
        function x(S = h().camera, R = m, B = h().size) {
          const { width: D, height: I, top: P, left: V } = B,
            F = D / I;
          R.isVector3 ? v.copy(R) : v.set(...R);
          const N = S.getWorldPosition(p).distanceTo(v);
          if (qR(S))
            return {
              width: D / S.zoom,
              height: I / S.zoom,
              top: P,
              left: V,
              factor: 1,
              distance: N,
              aspect: F,
            };
          {
            const L = (S.fov * Math.PI) / 180,
              Y = 2 * Math.tan(L / 2) * N,
              ct = Y * (D / I);
            return {
              width: ct,
              height: Y,
              top: P,
              left: V,
              factor: D / ct,
              distance: N,
              aspect: F,
            };
          }
        }
        let _;
        const M = (S) =>
            u((R) => ({ performance: { ...R.performance, current: S } })),
          C = new Yt();
        return {
          set: u,
          get: h,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          scene: null,
          xr: null,
          invalidate: (S = 1) => i(h(), S),
          advance: (S, R) => t(S, R, h()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new pS(),
          pointer: C,
          mouse: C,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const S = h();
              _ && clearTimeout(_),
                S.performance.current !== S.performance.min &&
                  M(S.performance.min),
                (_ = setTimeout(
                  () => M(h().performance.max),
                  S.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: x,
          },
          setEvents: (S) => u((R) => ({ ...R, events: { ...R.events, ...S } })),
          setSize: (S, R, B = 0, D = 0) => {
            const I = h().camera,
              P = { width: S, height: R, top: B, left: D };
            u((V) => ({ size: P, viewport: { ...V.viewport, ...x(I, m, P) } }));
          },
          setDpr: (S) =>
            u((R) => {
              const B = KR(S);
              return {
                viewport: {
                  ...R.viewport,
                  dpr: B,
                  initialDpr: R.viewport.initialDpr || B,
                },
              };
            }),
          setFrameloop: (S = "always") => {
            const R = h().clock;
            R.stop(),
              (R.elapsedTime = 0),
              S !== "never" && (R.start(), (R.elapsedTime = 0)),
              u(() => ({ frameloop: S }));
          },
          previousRoot: void 0,
          internal: {
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            lastEvent: bt.createRef(),
            active: !1,
            frames: 0,
            priority: 0,
            subscribe: (S, R, B) => {
              const D = h().internal;
              return (
                (D.priority = D.priority + (R > 0 ? 1 : 0)),
                D.subscribers.push({ ref: S, priority: R, store: B }),
                (D.subscribers = D.subscribers.sort(
                  (I, P) => I.priority - P.priority
                )),
                () => {
                  const I = h().internal;
                  I != null &&
                    I.subscribers &&
                    ((I.priority = I.priority - (R > 0 ? 1 : 0)),
                    (I.subscribers = I.subscribers.filter((P) => P.ref !== S)));
                }
              );
            },
          },
        };
      }),
      n = e.getState();
    let a = n.size,
      r = n.viewport.dpr,
      l = n.camera;
    return (
      e.subscribe(() => {
        const { camera: u, size: h, viewport: p, gl: m, set: v } = e.getState();
        if (h.width !== a.width || h.height !== a.height || p.dpr !== r) {
          (a = h), (r = p.dpr), ZR(u, h), p.dpr > 0 && m.setPixelRatio(p.dpr);
          const x =
            typeof HTMLCanvasElement < "u" &&
            m.domElement instanceof HTMLCanvasElement;
          m.setSize(h.width, h.height, x);
        }
        u !== l &&
          ((l = u),
          v((x) => ({
            viewport: { ...x.viewport, ...x.viewport.getCurrentViewport(u) },
          })));
      }),
      e.subscribe((u) => i(u)),
      e
    );
  };
function wS() {
  const i = bt.useContext(TS);
  if (!i)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return i;
}
function Gs(i = (e) => e, t) {
  return wS()(i, t);
}
function f1(i, t = 0) {
  const e = wS(),
    n = e.getState().internal.subscribe,
    a = ES(i);
  return k0(() => n(a, t, e), [t, n, e]), null;
}
const aw = new WeakMap(),
  kz = (i) => {
    var t;
    return (
      typeof i == "function" &&
      (i == null || (t = i.prototype) == null ? void 0 : t.constructor) === i
    );
  };
function $R(i, t) {
  return function (e, ...n) {
    let a;
    return (
      kz(e) ? ((a = aw.get(e)), a || ((a = new e()), aw.set(e, a))) : (a = e),
      i && i(a),
      Promise.all(
        n.map(
          (r) =>
            new Promise((l, u) =>
              a.load(
                r,
                (h) => {
                  bs(h?.scene) && Object.assign(h, Oz(h.scene)), l(h);
                },
                t,
                (h) => u(new Error(`Could not load ${r}: ${h?.message}`))
              )
            )
        )
      )
    );
  };
}
function ec(i, t, e, n) {
  const a = Array.isArray(t) ? t : [t],
    r = bz($R(e, n), [i, ...a], { equal: Mi.equ });
  return Array.isArray(t) ? r : r[0];
}
ec.preload = function (i, t, e) {
  const n = Array.isArray(t) ? t : [t];
  return Az($R(e), [i, ...n]);
};
ec.clear = function (i, t) {
  const e = Array.isArray(t) ? t : [t];
  return Sz([i, ...e]);
};
function jz(i) {
  const t = xz(i);
  return (
    t.injectIntoDevTools({
      bundleType: 0,
      rendererPackageName: "@react-three/fiber",
      version: bt.version,
    }),
    t
  );
}
const tB = 0,
  tp = {},
  Xz = /^three(?=[A-Z])/,
  h1 = (i) => `${i[0].toUpperCase()}${i.slice(1)}`;
let Wz = 0;
const Yz = (i) => typeof i == "function";
function eB(i) {
  if (Yz(i)) {
    const t = `${Wz++}`;
    return (tp[t] = i), t;
  } else Object.assign(tp, i);
}
function nB(i, t) {
  const e = h1(i),
    n = tp[e];
  if (i !== "primitive" && !n)
    throw new Error(
      `R3F: ${e} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
    );
  if (i === "primitive" && !t.object)
    throw new Error("R3F: Primitives without 'object' are invalid!");
  if (t.args !== void 0 && !Array.isArray(t.args))
    throw new Error("R3F: The args prop must be an array!");
}
function qz(i, t, e) {
  var n;
  return (
    (i = h1(i) in tp ? i : i.replace(Xz, "")),
    nB(i, t),
    i === "primitive" &&
      (n = t.object) != null &&
      n.__r3f &&
      delete t.object.__r3f,
    _x(t.object, e, i, t)
  );
}
function Kz(i) {
  if (!i.isHidden) {
    var t;
    i.props.attach && (t = i.parent) != null && t.object
      ? Ax(i.parent, i)
      : bs(i.object) && (i.object.visible = !1),
      (i.isHidden = !0),
      op(i);
  }
}
function iB(i) {
  if (i.isHidden) {
    var t;
    i.props.attach && (t = i.parent) != null && t.object
      ? bx(i.parent, i)
      : bs(i.object) && i.props.visible !== !1 && (i.object.visible = !0),
      (i.isHidden = !1),
      op(i);
  }
}
function CS(i, t, e) {
  const n = t.root.getState();
  if (!(!i.parent && i.object !== n.scene)) {
    if (!t.object) {
      var a, r;
      const l = tp[h1(t.type)];
      (t.object =
        (a = t.props.object) != null
          ? a
          : new l(...((r = t.props.args) != null ? r : []))),
        (t.object.__r3f = t);
    }
    if ((rl(t.object, t.props), t.props.attach)) bx(i, t);
    else if (bs(t.object) && bs(i.object)) {
      const l = i.object.children.indexOf(e?.object);
      if (e && l !== -1) {
        const u = i.object.children.indexOf(t.object);
        if (u !== -1) {
          i.object.children.splice(u, 1);
          const h = u < l ? l - 1 : l;
          i.object.children.splice(h, 0, t.object);
        } else
          (t.object.parent = i.object),
            i.object.children.splice(l, 0, t.object),
            t.object.dispatchEvent({ type: "added" }),
            i.object.dispatchEvent({ type: "childadded", child: t.object });
      } else i.object.add(t.object);
    }
    for (const l of t.children) CS(t, l);
    op(t);
  }
}
function ib(i, t) {
  t && ((t.parent = i), i.children.push(t), CS(i, t));
}
function sw(i, t, e) {
  if (!t || !e) return;
  t.parent = i;
  const n = i.children.indexOf(e);
  n !== -1 ? i.children.splice(n, 0, t) : i.children.push(t), CS(i, t, e);
}
function aB(i) {
  if (typeof i.dispose == "function") {
    const t = () => {
      try {
        i.dispose();
      } catch {}
    };
    typeof IS_REACT_ACT_ENVIRONMENT < "u"
      ? t()
      : tw.unstable_scheduleCallback(tw.unstable_IdlePriority, t);
  }
}
function Qb(i, t, e) {
  if (!t) return;
  t.parent = null;
  const n = i.children.indexOf(t);
  n !== -1 && i.children.splice(n, 1),
    t.props.attach
      ? Ax(i, t)
      : bs(t.object) &&
        bs(i.object) &&
        (i.object.remove(t.object), Hz(YR(t), t.object));
  const a = t.props.dispose !== null && e !== !1;
  for (let r = t.children.length - 1; r >= 0; r--) {
    const l = t.children[r];
    Qb(t, l, a);
  }
  (t.children.length = 0),
    delete t.object.__r3f,
    a && t.type !== "primitive" && t.object.type !== "Scene" && aB(t.object),
    e === void 0 && op(t);
}
function Jz(i, t) {
  for (const e of [i, i.alternate])
    if (e !== null)
      if (typeof e.ref == "function") {
        e.refCleanup == null || e.refCleanup();
        const n = e.ref(t);
        typeof n == "function" && (e.refCleanup = n);
      } else e.ref && (e.ref.current = t);
}
const Ry = [];
function Zz() {
  for (const [e] of Ry) {
    const n = e.parent;
    if (n) {
      e.props.attach
        ? Ax(n, e)
        : bs(e.object) && bs(n.object) && n.object.remove(e.object);
      for (const a of e.children)
        a.props.attach
          ? Ax(e, a)
          : bs(a.object) && bs(e.object) && e.object.remove(a.object);
    }
    e.isHidden && iB(e),
      e.object.__r3f && delete e.object.__r3f,
      e.type !== "primitive" && aB(e.object);
  }
  for (const [e, n, a] of Ry) {
    e.props = n;
    const r = e.parent;
    if (r) {
      var i, t;
      const l = tp[h1(e.type)];
      (e.object =
        (i = e.props.object) != null
          ? i
          : new l(...((t = e.props.args) != null ? t : []))),
        (e.object.__r3f = e),
        Jz(a, e.object),
        rl(e.object, e.props),
        e.props.attach
          ? bx(r, e)
          : bs(e.object) && bs(r.object) && r.object.add(e.object);
      for (const u of e.children)
        u.props.attach
          ? bx(e, u)
          : bs(u.object) && bs(e.object) && e.object.add(u.object);
      op(e);
    }
  }
  Ry.length = 0;
}
const ab = () => {},
  rw = {};
let gy = tB;
const Qz = 0,
  $z = 4,
  Sx = jz({
    isPrimaryRenderer: !1,
    warnsIfNotActing: !1,
    supportsMutation: !0,
    supportsPersistence: !1,
    supportsHydration: !1,
    createInstance: qz,
    removeChild: Qb,
    appendChild: ib,
    appendInitialChild: ib,
    insertBefore: sw,
    appendChildToContainer(i, t) {
      const e = i.getState().scene.__r3f;
      !t || !e || ib(e, t);
    },
    removeChildFromContainer(i, t) {
      const e = i.getState().scene.__r3f;
      !t || !e || Qb(e, t);
    },
    insertInContainerBefore(i, t, e) {
      const n = i.getState().scene.__r3f;
      !t || !e || !n || sw(n, t, e);
    },
    getRootHostContext: () => rw,
    getChildHostContext: () => rw,
    commitUpdate(i, t, e, n, a) {
      var r, l, u;
      nB(t, n);
      let h = !1;
      if (
        (((i.type === "primitive" && e.object !== n.object) ||
          ((r = n.args) == null ? void 0 : r.length) !==
            ((l = e.args) == null ? void 0 : l.length) ||
          ((u = n.args) != null &&
            u.some((m, v) => {
              var x;
              return m !== ((x = e.args) == null ? void 0 : x[v]);
            }))) &&
          (h = !0),
        h)
      )
        Ry.push([i, { ...n }, a]);
      else {
        const m = Pz(i, n);
        Object.keys(m).length && (Object.assign(i.props, m), rl(i.object, m));
      }
      (a.sibling === null || (a.flags & $z) === Qz) && Zz();
    },
    finalizeInitialChildren: () => !1,
    commitMount() {},
    getPublicInstance: (i) => i?.object,
    prepareForCommit: () => null,
    preparePortalMount: (i) => _x(i.getState().scene, i, "", {}),
    resetAfterCommit: () => {},
    shouldSetTextContent: () => !1,
    clearContainer: () => !1,
    hideInstance: Kz,
    unhideInstance: iB,
    createTextInstance: ab,
    hideTextInstance: ab,
    unhideTextInstance: ab,
    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
    noTimeout: -1,
    getInstanceFromNode: () => null,
    beforeActiveInstanceBlur() {},
    afterActiveInstanceBlur() {},
    detachDeletedInstance() {},
    prepareScopeUpdate() {},
    getInstanceFromScope: () => null,
    shouldAttemptEagerTransition: () => !1,
    trackSchedulerEvent: () => {},
    resolveEventType: () => null,
    resolveEventTimeStamp: () => -1.1,
    requestPostPaintCallback() {},
    maySuspendCommit: () => !1,
    preloadInstance: () => !0,
    startSuspendingCommit() {},
    suspendInstance() {},
    waitForCommitToBeReady: () => null,
    NotPendingTransition: null,
    HostTransitionContext: bt.createContext(null),
    setCurrentUpdatePriority(i) {
      gy = i;
    },
    getCurrentUpdatePriority() {
      return gy;
    },
    resolveUpdatePriority() {
      var i;
      if (gy !== tB) return gy;
      switch (
        typeof window < "u" &&
        ((i = window.event) == null ? void 0 : i.type)
      ) {
        case "click":
        case "contextmenu":
        case "dblclick":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
          return Cy.DiscreteEventPriority;
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerenter":
        case "pointerleave":
        case "wheel":
          return Cy.ContinuousEventPriority;
        default:
          return Cy.DefaultEventPriority;
      }
    },
    resetFormInstance() {},
  }),
  eh = new Map(),
  wd = { objects: "shallow", strict: !1 };
function tF(i, t) {
  if (
    !t &&
    typeof HTMLCanvasElement < "u" &&
    i instanceof HTMLCanvasElement &&
    i.parentElement
  ) {
    const {
      width: e,
      height: n,
      top: a,
      left: r,
    } = i.parentElement.getBoundingClientRect();
    return { width: e, height: n, top: a, left: r };
  } else if (!t && typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas)
    return { width: i.width, height: i.height, top: 0, left: 0 };
  return { width: 0, height: 0, top: 0, left: 0, ...t };
}
function eF(i) {
  const t = eh.get(i),
    e = t?.fiber,
    n = t?.store;
  t && console.warn("R3F.createRoot should only be called once!");
  const a = typeof reportError == "function" ? reportError : console.error,
    r = n || Vz(eA, lw),
    l =
      e ||
      Sx.createContainer(
        r,
        Cy.ConcurrentRoot,
        null,
        !1,
        null,
        "",
        a,
        a,
        a,
        null
      );
  t || eh.set(i, { fiber: l, store: r });
  let u,
    h,
    p = !1,
    m = null;
  return {
    async configure(v = {}) {
      let x;
      m = new Promise((ft) => (x = ft));
      let {
          gl: _,
          size: M,
          scene: C,
          events: E,
          onCreated: S,
          shadows: R = !1,
          linear: B = !1,
          flat: D = !1,
          legacy: I = !1,
          orthographic: P = !1,
          frameloop: V = "always",
          dpr: F = [1, 2],
          performance: N,
          raycaster: L,
          camera: Y,
          onPointerMissed: ct,
        } = v,
        nt = r.getState(),
        dt = nt.gl;
      if (!nt.gl) {
        const ft = {
            canvas: i,
            powerPreference: "high-performance",
            antialias: !0,
            alpha: !0,
          },
          At = typeof _ == "function" ? await _(ft) : _;
        iw(At) ? (dt = At) : (dt = new AS({ ...ft, ..._ })), nt.set({ gl: dt });
      }
      let pt = nt.raycaster;
      pt || nt.set({ raycaster: (pt = new xS()) });
      const { params: j, ...Q } = L || {};
      if (
        (Mi.equ(Q, pt, wd) || rl(pt, { ...Q }),
        Mi.equ(j, pt.params, wd) || rl(pt, { params: { ...pt.params, ...j } }),
        !nt.camera || (nt.camera === h && !Mi.equ(h, Y, wd)))
      ) {
        h = Y;
        const ft = Y?.isCamera,
          At = ft
            ? Y
            : P
            ? new Ir(0, 0, 0, 0, 0.1, 1e3)
            : new Ei(75, 0, 0.1, 1e3);
        ft ||
          ((At.position.z = 5),
          Y &&
            (rl(At, Y),
            At.manual ||
              (("aspect" in Y ||
                "left" in Y ||
                "right" in Y ||
                "bottom" in Y ||
                "top" in Y) &&
                ((At.manual = !0), At.updateProjectionMatrix()))),
          !nt.camera && !(Y != null && Y.rotation) && At.lookAt(0, 0, 0)),
          nt.set({ camera: At }),
          (pt.camera = At);
      }
      if (!nt.scene) {
        let ft;
        C != null && C.isScene
          ? ((ft = C), _x(ft, r, "", {}))
          : ((ft = new N0()), _x(ft, r, "", {}), C && rl(ft, C)),
          nt.set({ scene: ft });
      }
      E && !nt.events.handlers && nt.set({ events: E(r) });
      const et = tF(i, M);
      if (
        (Mi.equ(et, nt.size, wd) ||
          nt.setSize(et.width, et.height, et.top, et.left),
        F && nt.viewport.dpr !== KR(F) && nt.setDpr(F),
        nt.frameloop !== V && nt.setFrameloop(V),
        nt.onPointerMissed || nt.set({ onPointerMissed: ct }),
        N &&
          !Mi.equ(N, nt.performance, wd) &&
          nt.set((ft) => ({ performance: { ...ft.performance, ...N } })),
        !nt.xr)
      ) {
        var xt;
        const ft = (ht, It) => {
            const Pt = r.getState();
            Pt.frameloop !== "never" && lw(ht, !0, Pt, It);
          },
          At = () => {
            const ht = r.getState();
            (ht.gl.xr.enabled = ht.gl.xr.isPresenting),
              ht.gl.xr.setAnimationLoop(ht.gl.xr.isPresenting ? ft : null),
              ht.gl.xr.isPresenting || eA(ht);
          },
          Rt = {
            connect() {
              const ht = r.getState().gl;
              ht.xr.addEventListener("sessionstart", At),
                ht.xr.addEventListener("sessionend", At);
            },
            disconnect() {
              const ht = r.getState().gl;
              ht.xr.removeEventListener("sessionstart", At),
                ht.xr.removeEventListener("sessionend", At);
            },
          };
        typeof ((xt = dt.xr) == null ? void 0 : xt.addEventListener) ==
          "function" && Rt.connect(),
          nt.set({ xr: Rt });
      }
      if (dt.shadowMap) {
        const ft = dt.shadowMap.enabled,
          At = dt.shadowMap.type;
        if (((dt.shadowMap.enabled = !!R), Mi.boo(R))) dt.shadowMap.type = Wm;
        else if (Mi.str(R)) {
          var X;
          const Rt = { basic: Y2, percentage: Ux, soft: Wm, variance: vo };
          dt.shadowMap.type = (X = Rt[R]) != null ? X : Wm;
        } else Mi.obj(R) && Object.assign(dt.shadowMap, R);
        (ft !== dt.shadowMap.enabled || At !== dt.shadowMap.type) &&
          (dt.shadowMap.needsUpdate = !0);
      }
      return (
        (In.enabled = !I),
        p ||
          ((dt.outputColorSpace = B ? bo : Fa), (dt.toneMapping = D ? ll : BA)),
        nt.legacy !== I && nt.set(() => ({ legacy: I })),
        nt.linear !== B && nt.set(() => ({ linear: B })),
        nt.flat !== D && nt.set(() => ({ flat: D })),
        _ && !Mi.fun(_) && !iw(_) && !Mi.equ(_, dt, wd) && rl(dt, _),
        (u = S),
        (p = !0),
        x(),
        this
      );
    },
    render(v) {
      return (
        !p && !m && this.configure(),
        m.then(() => {
          Sx.updateContainer(
            O.jsx(nF, { store: r, children: v, onCreated: u, rootElement: i }),
            l,
            null,
            () => {}
          );
        }),
        r
      );
    },
    unmount() {
      sB(i);
    },
  };
}
function nF({ store: i, children: t, onCreated: e, rootElement: n }) {
  return (
    k0(() => {
      const a = i.getState();
      a.set((r) => ({ internal: { ...r.internal, active: !0 } })),
        e && e(a),
        i.getState().events.connected ||
          a.events.connect == null ||
          a.events.connect(n);
    }, []),
    O.jsx(TS.Provider, { value: i, children: t })
  );
}
function sB(i, t) {
  const e = eh.get(i),
    n = e?.fiber;
  if (n) {
    const a = e?.store.getState();
    a && (a.internal.active = !1),
      Sx.updateContainer(null, n, null, () => {
        a &&
          setTimeout(() => {
            try {
              var r, l, u, h;
              a.events.disconnect == null || a.events.disconnect(),
                (r = a.gl) == null ||
                  (l = r.renderLists) == null ||
                  l.dispose == null ||
                  l.dispose(),
                (u = a.gl) == null ||
                  u.forceContextLoss == null ||
                  u.forceContextLoss(),
                (h = a.gl) != null && h.xr && a.xr.disconnect(),
                Nz(a.scene),
                eh.delete(i);
            } catch {}
          }, 500);
      });
  }
}
function iF(i, t, e) {
  return O.jsx(aF, { children: i, container: t, state: e });
}
function aF({ state: i = {}, children: t, container: e }) {
  const { events: n, size: a, ...r } = i,
    l = wS(),
    [u] = bt.useState(() => new xS()),
    [h] = bt.useState(() => new Yt()),
    p = ES((v, x) => {
      let _;
      if (x.camera && a) {
        const M = x.camera;
        (_ = v.viewport.getCurrentViewport(M, new Z(), a)),
          M !== v.camera && ZR(M, a);
      }
      return {
        ...v,
        ...x,
        scene: e,
        raycaster: u,
        pointer: h,
        mouse: h,
        previousRoot: l,
        events: { ...v.events, ...x.events, ...n },
        size: { ...v.size, ...a },
        viewport: { ...v.viewport, ..._ },
        setEvents: (M) =>
          x.set((C) => ({ ...C, events: { ...C.events, ...M } })),
      };
    }),
    m = bt.useMemo(() => {
      const v = HR((_, M) => ({ ...r, set: _, get: M })),
        x = (_) => v.setState((M) => p.current(_, M));
      return x(l.getState()), l.subscribe(x), v;
    }, [l, e]);
  return O.jsx(O.Fragment, {
    children: Sx.createPortal(
      O.jsx(TS.Provider, { value: m, children: t }),
      m,
      null
    ),
  });
}
const sF = new Set(),
  rF = new Set(),
  oF = new Set();
function sb(i, t) {
  if (i.size) for (const { callback: e } of i.values()) e(t);
}
function e0(i, t) {
  switch (i) {
    case "before":
      return sb(sF, t);
    case "after":
      return sb(rF, t);
    case "tail":
      return sb(oF, t);
  }
}
let rb, ob;
function $b(i, t, e) {
  let n = t.clock.getDelta();
  t.frameloop === "never" &&
    typeof i == "number" &&
    ((n = i - t.clock.elapsedTime),
    (t.clock.oldTime = t.clock.elapsedTime),
    (t.clock.elapsedTime = i)),
    (rb = t.internal.subscribers);
  for (let a = 0; a < rb.length; a++)
    (ob = rb[a]), ob.ref.current(ob.store.getState(), n, e);
  return (
    !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera),
    (t.internal.frames = Math.max(0, t.internal.frames - 1)),
    t.frameloop === "always" ? 1 : t.internal.frames
  );
}
let Mx = !1,
  tA = !1,
  lb,
  ow,
  Cd;
function rB(i) {
  (ow = requestAnimationFrame(rB)),
    (Mx = !0),
    (lb = 0),
    e0("before", i),
    (tA = !0);
  for (const e of eh.values()) {
    var t;
    (Cd = e.store.getState()),
      Cd.internal.active &&
        (Cd.frameloop === "always" || Cd.internal.frames > 0) &&
        !((t = Cd.gl.xr) != null && t.isPresenting) &&
        (lb += $b(i, Cd));
  }
  if (((tA = !1), e0("after", i), lb === 0))
    return e0("tail", i), (Mx = !1), cancelAnimationFrame(ow);
}
function eA(i, t = 1) {
  var e;
  if (!i) return eh.forEach((n) => eA(n.store.getState(), t));
  ((e = i.gl.xr) != null && e.isPresenting) ||
    !i.internal.active ||
    i.frameloop === "never" ||
    (t > 1
      ? (i.internal.frames = Math.min(60, i.internal.frames + t))
      : tA
      ? (i.internal.frames = 2)
      : (i.internal.frames = 1),
    Mx || ((Mx = !0), requestAnimationFrame(rB)));
}
function lw(i, t = !0, e, n) {
  if ((t && e0("before", i), e)) $b(i, e, n);
  else for (const a of eh.values()) $b(i, a.store.getState());
  t && e0("after", i);
}
const cb = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function lF(i) {
  const { handlePointer: t } = Gz(i);
  return {
    priority: 1,
    enabled: !0,
    compute(e, n, a) {
      n.pointer.set(
        (e.offsetX / n.size.width) * 2 - 1,
        -(e.offsetY / n.size.height) * 2 + 1
      ),
        n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(cb).reduce((e, n) => ({ ...e, [n]: t(n) }), {}),
    update: () => {
      var e;
      const { events: n, internal: a } = i.getState();
      (e = a.lastEvent) != null &&
        e.current &&
        n.handlers &&
        n.handlers.onPointerMove(a.lastEvent.current);
    },
    connect: (e) => {
      const { set: n, events: a } = i.getState();
      if (
        (a.disconnect == null || a.disconnect(),
        n((r) => ({ events: { ...r.events, connected: e } })),
        a.handlers)
      )
        for (const r in a.handlers) {
          const l = a.handlers[r],
            [u, h] = cb[r];
          e.addEventListener(u, l, { passive: h });
        }
    },
    disconnect: () => {
      const { set: e, events: n } = i.getState();
      if (n.connected) {
        if (n.handlers)
          for (const a in n.handlers) {
            const r = n.handlers[a],
              [l] = cb[a];
            n.connected.removeEventListener(l, r);
          }
        e((a) => ({ events: { ...a.events, connected: void 0 } }));
      }
    },
  };
}
function cw(i, t) {
  let e;
  return (...n) => {
    window.clearTimeout(e), (e = window.setTimeout(() => i(...n), t));
  };
}
function cF(
  { debounce: i, scroll: t, polyfill: e, offsetSize: n } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const a = e || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!a)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [r, l] = bt.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    u = bt.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: r,
      orientationHandler: null,
    }),
    h = i ? (typeof i == "number" ? i : i.scroll) : null,
    p = i ? (typeof i == "number" ? i : i.resize) : null,
    m = bt.useRef(!1);
  bt.useEffect(() => ((m.current = !0), () => void (m.current = !1)));
  const [v, x, _] = bt.useMemo(() => {
    const S = () => {
      if (!u.current.element) return;
      const {
          left: R,
          top: B,
          width: D,
          height: I,
          bottom: P,
          right: V,
          x: F,
          y: N,
        } = u.current.element.getBoundingClientRect(),
        L = {
          left: R,
          top: B,
          width: D,
          height: I,
          bottom: P,
          right: V,
          x: F,
          y: N,
        };
      u.current.element instanceof HTMLElement &&
        n &&
        ((L.height = u.current.element.offsetHeight),
        (L.width = u.current.element.offsetWidth)),
        Object.freeze(L),
        m.current &&
          !dF(u.current.lastBounds, L) &&
          l((u.current.lastBounds = L));
    };
    return [S, p ? cw(S, p) : S, h ? cw(S, h) : S];
  }, [l, n, h, p]);
  function M() {
    u.current.scrollContainers &&
      (u.current.scrollContainers.forEach((S) =>
        S.removeEventListener("scroll", _, !0)
      ),
      (u.current.scrollContainers = null)),
      u.current.resizeObserver &&
        (u.current.resizeObserver.disconnect(),
        (u.current.resizeObserver = null)),
      u.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              u.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              u.current.orientationHandler
            ));
  }
  function C() {
    u.current.element &&
      ((u.current.resizeObserver = new a(_)),
      u.current.resizeObserver.observe(u.current.element),
      t &&
        u.current.scrollContainers &&
        u.current.scrollContainers.forEach((S) =>
          S.addEventListener("scroll", _, { capture: !0, passive: !0 })
        ),
      (u.current.orientationHandler = () => {
        _();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            u.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            u.current.orientationHandler
          ));
  }
  const E = (S) => {
    !S ||
      S === u.current.element ||
      (M(), (u.current.element = S), (u.current.scrollContainers = oB(S)), C());
  };
  return (
    fF(_, !!t),
    uF(x),
    bt.useEffect(() => {
      M(), C();
    }, [t, _, x]),
    bt.useEffect(() => M, []),
    [E, r, v]
  );
}
function uF(i) {
  bt.useEffect(() => {
    const t = i;
    return (
      window.addEventListener("resize", t),
      () => void window.removeEventListener("resize", t)
    );
  }, [i]);
}
function fF(i, t) {
  bt.useEffect(() => {
    if (t) {
      const e = i;
      return (
        window.addEventListener("scroll", e, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", e, !0)
      );
    }
  }, [i, t]);
}
function oB(i) {
  const t = [];
  if (!i || i === document.body) return t;
  const {
    overflow: e,
    overflowX: n,
    overflowY: a,
  } = window.getComputedStyle(i);
  return (
    [e, n, a].some((r) => r === "auto" || r === "scroll") && t.push(i),
    [...t, ...oB(i.parentElement)]
  );
}
const hF = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  dF = (i, t) => hF.every((e) => i[e] === t[e]);
function pF({
  ref: i,
  children: t,
  fallback: e,
  resize: n,
  style: a,
  gl: r,
  events: l = lF,
  eventSource: u,
  eventPrefix: h,
  shadows: p,
  linear: m,
  flat: v,
  legacy: x,
  orthographic: _,
  frameloop: M,
  dpr: C,
  performance: E,
  raycaster: S,
  camera: R,
  scene: B,
  onPointerMissed: D,
  onCreated: I,
  ...P
}) {
  bt.useMemo(() => eB(nz), []);
  const V = Bz(),
    [F, N] = cF({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...n }),
    L = bt.useRef(null),
    Y = bt.useRef(null);
  bt.useImperativeHandle(i, () => L.current);
  const ct = ES(D),
    [nt, dt] = bt.useState(!1),
    [pt, j] = bt.useState(!1);
  if (nt) throw nt;
  if (pt) throw pt;
  const Q = bt.useRef(null);
  k0(() => {
    const xt = L.current;
    if (N.width > 0 && N.height > 0 && xt) {
      Q.current || (Q.current = eF(xt));
      async function X() {
        await Q.current.configure({
          gl: r,
          scene: B,
          events: l,
          shadows: p,
          linear: m,
          flat: v,
          legacy: x,
          orthographic: _,
          frameloop: M,
          dpr: C,
          performance: E,
          raycaster: S,
          camera: R,
          size: N,
          onPointerMissed: (...ft) =>
            ct.current == null ? void 0 : ct.current(...ft),
          onCreated: (ft) => {
            ft.events.connect == null ||
              ft.events.connect(u ? (Cz(u) ? u.current : u) : Y.current),
              h &&
                ft.setEvents({
                  compute: (At, Rt) => {
                    const ht = At[h + "X"],
                      It = At[h + "Y"];
                    Rt.pointer.set(
                      (ht / Rt.size.width) * 2 - 1,
                      -(It / Rt.size.height) * 2 + 1
                    ),
                      Rt.raycaster.setFromCamera(Rt.pointer, Rt.camera);
                  },
                }),
              I?.(ft);
          },
        }),
          Q.current.render(
            O.jsx(V, {
              children: O.jsx(Uz, {
                set: j,
                children: O.jsx(bt.Suspense, {
                  fallback: O.jsx(Dz, { set: dt }),
                  children: t ?? null,
                }),
              }),
            })
          );
      }
      X();
    }
  }),
    bt.useEffect(() => {
      const xt = L.current;
      if (xt) return () => sB(xt);
    }, []);
  const et = u ? "none" : "auto";
  return O.jsx("div", {
    ref: Y,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: et,
      ...a,
    },
    ...P,
    children: O.jsx("div", {
      ref: F,
      style: { width: "100%", height: "100%" },
      children: O.jsx("canvas", {
        ref: L,
        style: { display: "block" },
        children: e,
      }),
    }),
  });
}
function uw(i) {
  return O.jsx(XR, { children: O.jsx(pF, { ...i }) });
}
function x0() {
  return (
    (x0 = Object.assign
      ? Object.assign.bind()
      : function (i) {
          for (var t = 1; t < arguments.length; t++) {
            var e = arguments[t];
            for (var n in e) ({}.hasOwnProperty.call(e, n) && (i[n] = e[n]));
          }
          return i;
        }),
    x0.apply(null, arguments)
  );
}
const j0 = new Z(),
  RS = new Z(),
  mF = new Z(),
  fw = new Yt();
function gF(i, t, e) {
  const n = j0.setFromMatrixPosition(i.matrixWorld);
  n.project(t);
  const a = e.width / 2,
    r = e.height / 2;
  return [n.x * a + a, -(n.y * r) + r];
}
function vF(i, t) {
  const e = j0.setFromMatrixPosition(i.matrixWorld),
    n = RS.setFromMatrixPosition(t.matrixWorld),
    a = e.sub(n),
    r = t.getWorldDirection(mF);
  return a.angleTo(r) > Math.PI / 2;
}
function yF(i, t, e, n) {
  const a = j0.setFromMatrixPosition(i.matrixWorld),
    r = a.clone();
  r.project(t), fw.set(r.x, r.y), e.setFromCamera(fw, t);
  const l = e.intersectObjects(n, !0);
  if (l.length) {
    const u = l[0].distance;
    return a.distanceTo(e.ray.origin) < u;
  }
  return !0;
}
function xF(i, t) {
  if (t instanceof Ir) return t.zoom;
  if (t instanceof Ei) {
    const e = j0.setFromMatrixPosition(i.matrixWorld),
      n = RS.setFromMatrixPosition(t.matrixWorld),
      a = (t.fov * Math.PI) / 180,
      r = e.distanceTo(n);
    return 1 / (2 * Math.tan(a / 2) * r);
  } else return 1;
}
function _F(i, t, e) {
  if (t instanceof Ei || t instanceof Ir) {
    const n = j0.setFromMatrixPosition(i.matrixWorld),
      a = RS.setFromMatrixPosition(t.matrixWorld),
      r = n.distanceTo(a),
      l = (e[1] - e[0]) / (t.far - t.near),
      u = e[1] - l * t.far;
    return Math.round(l * r + u);
  }
}
const nA = (i) => (Math.abs(i) < 1e-10 ? 0 : i);
function lB(i, t, e = "") {
  let n = "matrix3d(";
  for (let a = 0; a !== 16; a++)
    n += nA(t[a] * i.elements[a]) + (a !== 15 ? "," : ")");
  return e + n;
}
const bF = (
    (i) => (t) =>
      lB(t, i)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  AF = (
    (i) => (t, e) =>
      lB(t, i(e), "translate(-50%,-50%)")
  )((i) => [
    1 / i,
    1 / i,
    1 / i,
    1,
    -1 / i,
    -1 / i,
    -1 / i,
    -1,
    1 / i,
    1 / i,
    1 / i,
    1,
    1,
    1,
    1,
    1,
  ]);
function SF(i) {
  return i && typeof i == "object" && "current" in i;
}
const hw = bt.forwardRef(
    (
      {
        children: i,
        eps: t = 0.001,
        style: e,
        className: n,
        prepend: a,
        center: r,
        fullscreen: l,
        portal: u,
        distanceFactor: h,
        sprite: p = !1,
        transform: m = !1,
        occlude: v,
        onOcclude: x,
        castShadow: _,
        receiveShadow: M,
        material: C,
        geometry: E,
        zIndexRange: S = [16777271, 0],
        calculatePosition: R = gF,
        as: B = "div",
        wrapperClass: D,
        pointerEvents: I = "auto",
        ...P
      },
      V
    ) => {
      const {
          gl: F,
          camera: N,
          scene: L,
          size: Y,
          raycaster: ct,
          events: nt,
          viewport: dt,
        } = Gs(),
        [pt] = bt.useState(() => document.createElement(B)),
        j = bt.useRef(null),
        Q = bt.useRef(null),
        et = bt.useRef(0),
        xt = bt.useRef([0, 0]),
        X = bt.useRef(null),
        ft = bt.useRef(null),
        At = u?.current || nt.connected || F.domElement.parentNode,
        Rt = bt.useRef(null),
        ht = bt.useRef(!1),
        It = bt.useMemo(
          () =>
            (v && v !== "blending") ||
            (Array.isArray(v) && v.length && SF(v[0])),
          [v]
        );
      bt.useLayoutEffect(() => {
        const Ae = F.domElement;
        v && v === "blending"
          ? ((Ae.style.zIndex = `${Math.floor(S[0] / 2)}`),
            (Ae.style.position = "absolute"),
            (Ae.style.pointerEvents = "none"))
          : ((Ae.style.zIndex = null),
            (Ae.style.position = null),
            (Ae.style.pointerEvents = null));
      }, [v]),
        bt.useLayoutEffect(() => {
          if (Q.current) {
            const Ae = (j.current = j2.createRoot(pt));
            if ((L.updateMatrixWorld(), m))
              pt.style.cssText =
                "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
              const De = R(Q.current, N, Y);
              pt.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${De[0]}px,${De[1]}px,0);transform-origin:0 0;`;
            }
            return (
              At && (a ? At.prepend(pt) : At.appendChild(pt)),
              () => {
                At && At.removeChild(pt), Ae.unmount();
              }
            );
          }
        }, [At, m]),
        bt.useLayoutEffect(() => {
          D && (pt.className = D);
        }, [D]);
      const Pt = bt.useMemo(
          () =>
            m
              ? {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: Y.width,
                  height: Y.height,
                  transformStyle: "preserve-3d",
                  pointerEvents: "none",
                }
              : {
                  position: "absolute",
                  transform: r ? "translate3d(-50%,-50%,0)" : "none",
                  ...(l && {
                    top: -Y.height / 2,
                    left: -Y.width / 2,
                    width: Y.width,
                    height: Y.height,
                  }),
                  ...e,
                },
          [e, r, l, Y, m]
        ),
        re = bt.useMemo(
          () => ({ position: "absolute", pointerEvents: I }),
          [I]
        );
      bt.useLayoutEffect(() => {
        if (((ht.current = !1), m)) {
          var Ae;
          (Ae = j.current) == null ||
            Ae.render(
              bt.createElement(
                "div",
                { ref: X, style: Pt },
                bt.createElement(
                  "div",
                  { ref: ft, style: re },
                  bt.createElement("div", {
                    ref: V,
                    className: n,
                    style: e,
                    children: i,
                  })
                )
              )
            );
        } else {
          var De;
          (De = j.current) == null ||
            De.render(
              bt.createElement("div", {
                ref: V,
                style: Pt,
                className: n,
                children: i,
              })
            );
        }
      });
      const ie = bt.useRef(!0);
      f1((Ae) => {
        if (Q.current) {
          N.updateMatrixWorld(), Q.current.updateWorldMatrix(!0, !1);
          const De = m ? xt.current : R(Q.current, N, Y);
          if (
            m ||
            Math.abs(et.current - N.zoom) > t ||
            Math.abs(xt.current[0] - De[0]) > t ||
            Math.abs(xt.current[1] - De[1]) > t
          ) {
            const je = vF(Q.current, N);
            let Ue = !1;
            It &&
              (Array.isArray(v)
                ? (Ue = v.map(($t) => $t.current))
                : v !== "blending" && (Ue = [L]));
            const J = ie.current;
            if (Ue) {
              const $t = yF(Q.current, N, ct, Ue);
              ie.current = $t && !je;
            } else ie.current = !je;
            J !== ie.current &&
              (x
                ? x(!ie.current)
                : (pt.style.display = ie.current ? "block" : "none"));
            const le = Math.floor(S[0] / 2),
              se = v ? (It ? [S[0], le] : [le - 1, 0]) : S;
            if (((pt.style.zIndex = `${_F(Q.current, N, se)}`), m)) {
              const [$t, kt] = [Y.width / 2, Y.height / 2],
                ye = N.projectionMatrix.elements[5] * kt,
                {
                  isOrthographicCamera: te,
                  top: pe,
                  left: Ye,
                  bottom: $,
                  right: k,
                } = N,
                Mt = bF(N.matrixWorldInverse),
                Ft = te
                  ? `scale(${ye})translate(${nA(-(k + Ye) / 2)}px,${nA(
                      (pe + $) / 2
                    )}px)`
                  : `translateZ(${ye}px)`;
              let Gt = Q.current.matrixWorld;
              p &&
                ((Gt = N.matrixWorldInverse
                  .clone()
                  .transpose()
                  .copyPosition(Gt)
                  .scale(Q.current.scale)),
                (Gt.elements[3] = Gt.elements[7] = Gt.elements[11] = 0),
                (Gt.elements[15] = 1)),
                (pt.style.width = Y.width + "px"),
                (pt.style.height = Y.height + "px"),
                (pt.style.perspective = te ? "" : `${ye}px`),
                X.current &&
                  ft.current &&
                  ((X.current.style.transform = `${Ft}${Mt}translate(${$t}px,${kt}px)`),
                  (ft.current.style.transform = AF(Gt, 1 / ((h || 10) / 400))));
            } else {
              const $t = h === void 0 ? 1 : xF(Q.current, N) * h;
              pt.style.transform = `translate3d(${De[0]}px,${De[1]}px,0) scale(${$t})`;
            }
            (xt.current = De), (et.current = N.zoom);
          }
        }
        if (!It && Rt.current && !ht.current)
          if (m) {
            if (X.current) {
              const De = X.current.children[0];
              if (
                De != null &&
                De.clientWidth &&
                De != null &&
                De.clientHeight
              ) {
                const { isOrthographicCamera: je } = N;
                if (je || E)
                  P.scale &&
                    (Array.isArray(P.scale)
                      ? P.scale instanceof Z
                        ? Rt.current.scale.copy(P.scale.clone().divideScalar(1))
                        : Rt.current.scale.set(
                            1 / P.scale[0],
                            1 / P.scale[1],
                            1 / P.scale[2]
                          )
                      : Rt.current.scale.setScalar(1 / P.scale));
                else {
                  const Ue = (h || 10) / 400,
                    J = De.clientWidth * Ue,
                    le = De.clientHeight * Ue;
                  Rt.current.scale.set(J, le, 1);
                }
                ht.current = !0;
              }
            }
          } else {
            const De = pt.children[0];
            if (De != null && De.clientWidth && De != null && De.clientHeight) {
              const je = 1 / dt.factor,
                Ue = De.clientWidth * je,
                J = De.clientHeight * je;
              Rt.current.scale.set(Ue, J, 1), (ht.current = !0);
            }
            Rt.current.lookAt(Ae.camera.position);
          }
      });
      const Fe = bt.useMemo(
        () => ({
          vertexShader: m
            ? void 0
            : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
          fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
        }),
        [m]
      );
      return bt.createElement(
        "group",
        x0({}, P, { ref: Q }),
        v &&
          !It &&
          bt.createElement(
            "mesh",
            { castShadow: _, receiveShadow: M, ref: Rt },
            E || bt.createElement("planeGeometry", null),
            C ||
              bt.createElement("shaderMaterial", {
                side: or,
                vertexShader: Fe.vertexShader,
                fragmentShader: Fe.fragmentShader,
              })
          )
      );
    }
  ),
  BS = parseInt(C0.replace(/\D+/g, ""));
function dw(i, t) {
  if (t === SC)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      i
    );
  if (t === mx || t === zA) {
    let e = i.getIndex();
    if (e === null) {
      const l = [],
        u = i.getAttribute("position");
      if (u !== void 0) {
        for (let h = 0; h < u.count; h++) l.push(h);
        i.setIndex(l), (e = i.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          i
        );
    }
    const n = e.count - 2,
      a = [];
    if (e)
      if (t === mx)
        for (let l = 1; l <= n; l++)
          a.push(e.getX(0)), a.push(e.getX(l)), a.push(e.getX(l + 1));
      else
        for (let l = 0; l < n; l++)
          l % 2 === 0
            ? (a.push(e.getX(l)), a.push(e.getX(l + 1)), a.push(e.getX(l + 2)))
            : (a.push(e.getX(l + 2)), a.push(e.getX(l + 1)), a.push(e.getX(l)));
    a.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const r = i.clone();
    return r.setIndex(a), r.clearGroups(), r;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        t
      ),
      i
    );
}
var Or = Uint8Array,
  ou = Uint16Array,
  iA = Uint32Array,
  cB = new Or([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  uB = new Or([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  MF = new Or([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  fB = function (i, t) {
    for (var e = new ou(31), n = 0; n < 31; ++n) e[n] = t += 1 << i[n - 1];
    for (var a = new iA(e[30]), n = 1; n < 30; ++n)
      for (var r = e[n]; r < e[n + 1]; ++r) a[r] = ((r - e[n]) << 5) | n;
    return [e, a];
  },
  hB = fB(cB, 2),
  dB = hB[0],
  EF = hB[1];
(dB[28] = 258), (EF[258] = 28);
var TF = fB(uB, 0),
  wF = TF[0],
  aA = new ou(32768);
for (var vi = 0; vi < 32768; ++vi) {
  var nu = ((vi & 43690) >>> 1) | ((vi & 21845) << 1);
  (nu = ((nu & 52428) >>> 2) | ((nu & 13107) << 2)),
    (nu = ((nu & 61680) >>> 4) | ((nu & 3855) << 4)),
    (aA[vi] = (((nu & 65280) >>> 8) | ((nu & 255) << 8)) >>> 1);
}
var n0 = function (i, t, e) {
    for (var n = i.length, a = 0, r = new ou(t); a < n; ++a) ++r[i[a] - 1];
    var l = new ou(t);
    for (a = 0; a < t; ++a) l[a] = (l[a - 1] + r[a - 1]) << 1;
    var u;
    if (e) {
      u = new ou(1 << t);
      var h = 15 - t;
      for (a = 0; a < n; ++a)
        if (i[a])
          for (
            var p = (a << 4) | i[a],
              m = t - i[a],
              v = l[i[a] - 1]++ << m,
              x = v | ((1 << m) - 1);
            v <= x;
            ++v
          )
            u[aA[v] >>> h] = p;
    } else
      for (u = new ou(n), a = 0; a < n; ++a)
        i[a] && (u[a] = aA[l[i[a] - 1]++] >>> (15 - i[a]));
    return u;
  },
  X0 = new Or(288);
for (var vi = 0; vi < 144; ++vi) X0[vi] = 8;
for (var vi = 144; vi < 256; ++vi) X0[vi] = 9;
for (var vi = 256; vi < 280; ++vi) X0[vi] = 7;
for (var vi = 280; vi < 288; ++vi) X0[vi] = 8;
var pB = new Or(32);
for (var vi = 0; vi < 32; ++vi) pB[vi] = 5;
var CF = n0(X0, 9, 1),
  RF = n0(pB, 5, 1),
  ub = function (i) {
    for (var t = i[0], e = 1; e < i.length; ++e) i[e] > t && (t = i[e]);
    return t;
  },
  mo = function (i, t, e) {
    var n = (t / 8) | 0;
    return ((i[n] | (i[n + 1] << 8)) >> (t & 7)) & e;
  },
  fb = function (i, t) {
    var e = (t / 8) | 0;
    return (i[e] | (i[e + 1] << 8) | (i[e + 2] << 16)) >> (t & 7);
  },
  BF = function (i) {
    return ((i / 8) | 0) + (i & 7 && 1);
  },
  DF = function (i, t, e) {
    (e == null || e > i.length) && (e = i.length);
    var n = new (i instanceof ou ? ou : i instanceof iA ? iA : Or)(e - t);
    return n.set(i.subarray(t, e)), n;
  },
  UF = function (i, t, e) {
    var n = i.length;
    if (!n || (e && !e.l && n < 5)) return t || new Or(0);
    var a = !t || e,
      r = !e || e.i;
    e || (e = {}), t || (t = new Or(n * 3));
    var l = function (Pt) {
        var re = t.length;
        if (Pt > re) {
          var ie = new Or(Math.max(re * 2, Pt));
          ie.set(t), (t = ie);
        }
      },
      u = e.f || 0,
      h = e.p || 0,
      p = e.b || 0,
      m = e.l,
      v = e.d,
      x = e.m,
      _ = e.n,
      M = n * 8;
    do {
      if (!m) {
        e.f = u = mo(i, h, 1);
        var C = mo(i, h + 1, 3);
        if (((h += 3), C))
          if (C == 1) (m = CF), (v = RF), (x = 9), (_ = 5);
          else if (C == 2) {
            var B = mo(i, h, 31) + 257,
              D = mo(i, h + 10, 15) + 4,
              I = B + mo(i, h + 5, 31) + 1;
            h += 14;
            for (var P = new Or(I), V = new Or(19), F = 0; F < D; ++F)
              V[MF[F]] = mo(i, h + F * 3, 7);
            h += D * 3;
            for (
              var N = ub(V), L = (1 << N) - 1, Y = n0(V, N, 1), F = 0;
              F < I;

            ) {
              var ct = Y[mo(i, h, L)];
              h += ct & 15;
              var E = ct >>> 4;
              if (E < 16) P[F++] = E;
              else {
                var nt = 0,
                  dt = 0;
                for (
                  E == 16
                    ? ((dt = 3 + mo(i, h, 3)), (h += 2), (nt = P[F - 1]))
                    : E == 17
                    ? ((dt = 3 + mo(i, h, 7)), (h += 3))
                    : E == 18 && ((dt = 11 + mo(i, h, 127)), (h += 7));
                  dt--;

                )
                  P[F++] = nt;
              }
            }
            var pt = P.subarray(0, B),
              j = P.subarray(B);
            (x = ub(pt)), (_ = ub(j)), (m = n0(pt, x, 1)), (v = n0(j, _, 1));
          } else throw "invalid block type";
        else {
          var E = BF(h) + 4,
            S = i[E - 4] | (i[E - 3] << 8),
            R = E + S;
          if (R > n) {
            if (r) throw "unexpected EOF";
            break;
          }
          a && l(p + S),
            t.set(i.subarray(E, R), p),
            (e.b = p += S),
            (e.p = h = R * 8);
          continue;
        }
        if (h > M) {
          if (r) throw "unexpected EOF";
          break;
        }
      }
      a && l(p + 131072);
      for (var Q = (1 << x) - 1, et = (1 << _) - 1, xt = h; ; xt = h) {
        var nt = m[fb(i, h) & Q],
          X = nt >>> 4;
        if (((h += nt & 15), h > M)) {
          if (r) throw "unexpected EOF";
          break;
        }
        if (!nt) throw "invalid length/literal";
        if (X < 256) t[p++] = X;
        else if (X == 256) {
          (xt = h), (m = null);
          break;
        } else {
          var ft = X - 254;
          if (X > 264) {
            var F = X - 257,
              At = cB[F];
            (ft = mo(i, h, (1 << At) - 1) + dB[F]), (h += At);
          }
          var Rt = v[fb(i, h) & et],
            ht = Rt >>> 4;
          if (!Rt) throw "invalid distance";
          h += Rt & 15;
          var j = wF[ht];
          if (ht > 3) {
            var At = uB[ht];
            (j += fb(i, h) & ((1 << At) - 1)), (h += At);
          }
          if (h > M) {
            if (r) throw "unexpected EOF";
            break;
          }
          a && l(p + 131072);
          for (var It = p + ft; p < It; p += 4)
            (t[p] = t[p - j]),
              (t[p + 1] = t[p + 1 - j]),
              (t[p + 2] = t[p + 2 - j]),
              (t[p + 3] = t[p + 3 - j]);
          p = It;
        }
      }
      (e.l = m),
        (e.p = xt),
        (e.b = p),
        m && ((u = 1), (e.m = x), (e.d = v), (e.n = _));
    } while (!u);
    return p == t.length ? t : DF(t, 0, p);
  },
  OF = new Or(0),
  NF = function (i) {
    if ((i[0] & 15) != 8 || i[0] >>> 4 > 7 || ((i[0] << 8) | i[1]) % 31)
      throw "invalid zlib data";
    if (i[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
  };
function vy(i, t) {
  return UF((NF(i), i.subarray(2, -4)), t);
}
var LF = typeof TextDecoder < "u" && new TextDecoder(),
  IF = 0;
try {
  LF.decode(OF, { stream: !0 }), (IF = 1);
} catch {}
const PF = (i) => i && i.isCubeTexture;
class zF extends Ti {
  constructor(t, e) {
    var n, a;
    const r = PF(t),
      u =
        ((a = r
          ? (n = t.image[0]) == null
            ? void 0
            : n.width
          : t.image.width) != null
          ? a
          : 1024) / 4,
      h = Math.floor(Math.log2(u)),
      p = Math.pow(2, h),
      m = 3 * Math.max(p, 16 * 7),
      v = 4 * p,
      x = [
        r ? "#define ENVMAP_TYPE_CUBE" : "",
        `#define CUBEUV_TEXEL_WIDTH ${1 / m}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / v}`,
        `#define CUBEUV_MAX_MIP ${h}.0`,
      ],
      _ = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      M =
        x.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${
              BS >= 154 ? "colorspace_fragment" : "encodings_fragment"
            }>
        }
        `,
      C = {
        map: { value: t },
        height: { value: e?.height || 15 },
        radius: { value: e?.radius || 100 },
      },
      E = new F0(1, 16),
      S = new Xs({ uniforms: C, fragmentShader: M, vertexShader: _, side: or });
    super(E, S);
  }
  set radius(t) {
    this.material.uniforms.radius.value = t;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(t) {
    this.material.uniforms.height.value = t;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
function mB(i, t, e = {}) {
  const n = new Z(),
    a = new pa(),
    r = new Z(),
    l = new Xe(),
    u = new Xe(),
    h = new Xe();
  (e.preserveMatrix = e.preserveMatrix !== void 0 ? e.preserveMatrix : !0),
    (e.preservePosition =
      e.preservePosition !== void 0 ? e.preservePosition : !0),
    (e.preserveHipPosition =
      e.preserveHipPosition !== void 0 ? e.preserveHipPosition : !1),
    (e.useTargetMatrix = e.useTargetMatrix !== void 0 ? e.useTargetMatrix : !1),
    (e.hip = e.hip !== void 0 ? e.hip : "hip"),
    (e.names = e.names || {});
  const p = t.isObject3D ? t.skeleton.bones : Ex(t),
    m = i.isObject3D ? i.skeleton.bones : Ex(i);
  let v, x, _, M, C;
  if (
    (i.isObject3D
      ? i.skeleton.pose()
      : ((e.useTargetMatrix = !0), (e.preserveMatrix = !1)),
    e.preservePosition)
  ) {
    C = [];
    for (let E = 0; E < m.length; E++) C.push(m[E].position.clone());
  }
  if (e.preserveMatrix) {
    i.updateMatrixWorld(), i.matrixWorld.identity();
    for (let E = 0; E < i.children.length; ++E)
      i.children[E].updateMatrixWorld(!0);
  }
  if (e.offsets) {
    v = [];
    for (let E = 0; E < m.length; ++E)
      (x = m[E]),
        (_ = e.names[x.name] || x.name),
        e.offsets[_] &&
          (x.matrix.multiply(e.offsets[_]),
          x.matrix.decompose(x.position, x.quaternion, x.scale),
          x.updateMatrixWorld()),
        v.push(x.matrixWorld.clone());
  }
  for (let E = 0; E < m.length; ++E) {
    if (
      ((x = m[E]),
      (_ = e.names[x.name] || x.name),
      (M = gB(_, p)),
      h.copy(x.matrixWorld),
      M)
    ) {
      if (
        (M.updateMatrixWorld(),
        e.useTargetMatrix
          ? u.copy(M.matrixWorld)
          : (u.copy(i.matrixWorld).invert(), u.multiply(M.matrixWorld)),
        r.setFromMatrixScale(u),
        u.scale(r.set(1 / r.x, 1 / r.y, 1 / r.z)),
        h.makeRotationFromQuaternion(a.setFromRotationMatrix(u)),
        i.isObject3D)
      ) {
        const S = m.indexOf(x),
          R = v ? v[S] : l.copy(i.skeleton.boneInverses[S]).invert();
        h.multiply(R);
      }
      h.copyPosition(u);
    }
    x.parent && x.parent.isBone
      ? (x.matrix.copy(x.parent.matrixWorld).invert(), x.matrix.multiply(h))
      : x.matrix.copy(h),
      e.preserveHipPosition &&
        _ === e.hip &&
        x.matrix.setPosition(n.set(0, x.position.y, 0)),
      x.matrix.decompose(x.position, x.quaternion, x.scale),
      x.updateMatrixWorld();
  }
  if (e.preservePosition)
    for (let E = 0; E < m.length; ++E)
      (x = m[E]),
        (_ = e.names[x.name] || x.name),
        _ !== e.hip && x.position.copy(C[E]);
  e.preserveMatrix && i.updateMatrixWorld(!0);
}
function FF(i, t, e, n = {}) {
  (n.useFirstFramePosition =
    n.useFirstFramePosition !== void 0 ? n.useFirstFramePosition : !1),
    (n.fps = n.fps !== void 0 ? n.fps : 30),
    (n.names = n.names || []),
    t.isObject3D || (t = GF(t));
  const a = Math.round(e.duration * (n.fps / 1e3) * 1e3),
    r = 1 / n.fps,
    l = [],
    u = new vS(t),
    h = Ex(i.skeleton),
    p = [];
  let m, v, x, _, M;
  u.clipAction(e).play(), u.update(0), t.updateMatrixWorld();
  for (let C = 0; C < a; ++C) {
    const E = C * r;
    mB(i, t, n);
    for (let S = 0; S < h.length; ++S)
      (M = n.names[h[S].name] || h[S].name),
        (x = gB(M, t.skeleton)),
        x &&
          ((v = h[S]),
          (_ = p[S] = p[S] || { bone: v }),
          n.hip === M &&
            (_.pos ||
              (_.pos = {
                times: new Float32Array(a),
                values: new Float32Array(a * 3),
              }),
            n.useFirstFramePosition &&
              (C === 0 && (m = v.position.clone()), v.position.sub(m)),
            (_.pos.times[C] = E),
            v.position.toArray(_.pos.values, C * 3)),
          _.quat ||
            (_.quat = {
              times: new Float32Array(a),
              values: new Float32Array(a * 4),
            }),
          (_.quat.times[C] = E),
          v.quaternion.toArray(_.quat.values, C * 4));
    u.update(r), t.updateMatrixWorld();
  }
  for (let C = 0; C < p.length; ++C)
    (_ = p[C]),
      _ &&
        (_.pos &&
          l.push(
            new pu(
              ".bones[" + _.bone.name + "].position",
              _.pos.times,
              _.pos.values
            )
          ),
        l.push(
          new du(
            ".bones[" + _.bone.name + "].quaternion",
            _.quat.times,
            _.quat.values
          )
        ));
  return u.uncacheAction(e), new th(e.name, -1, l);
}
function HF(i) {
  const t = new Map(),
    e = new Map(),
    n = i.clone();
  return (
    vB(i, n, function (a, r) {
      t.set(r, a), e.set(a, r);
    }),
    n.traverse(function (a) {
      if (!a.isSkinnedMesh) return;
      const r = a,
        l = t.get(a),
        u = l.skeleton.bones;
      (r.skeleton = l.skeleton.clone()),
        r.bindMatrix.copy(l.bindMatrix),
        (r.skeleton.bones = u.map(function (h) {
          return e.get(h);
        })),
        r.bind(r.skeleton, r.bindMatrix);
    }),
    n
  );
}
function gB(i, t) {
  for (let e = 0, n = Ex(t); e < n.length; e++)
    if (i === n[e].name) return n[e];
}
function Ex(i) {
  return Array.isArray(i) ? i : i.bones;
}
function GF(i) {
  const t = new UR(i.bones[0]);
  return (t.skeleton = i), t;
}
function vB(i, t, e) {
  e(i, t);
  for (let n = 0; n < i.children.length; n++)
    vB(i.children[n], t.children[n], e);
}
const VF = { retarget: mB, retargetClip: FF, clone: HF };
var kF = Object.defineProperty,
  jF = (i, t, e) =>
    t in i
      ? kF(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e })
      : (i[t] = e),
  XF = (i, t, e) => (jF(i, t + "", e), e);
class WF {
  constructor() {
    XF(this, "_listeners");
  }
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }
  hasEventListener(t, e) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    if (this._listeners === void 0) return;
    const a = this._listeners[t];
    if (a !== void 0) {
      const r = a.indexOf(e);
      r !== -1 && a.splice(r, 1);
    }
  }
  dispatchEvent(t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const a = n.slice(0);
      for (let r = 0, l = a.length; r < l; r++) a[r].call(this, t);
      t.target = null;
    }
  }
}
var YF = Object.defineProperty,
  qF = (i, t, e) =>
    t in i
      ? YF(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e })
      : (i[t] = e),
  Qe = (i, t, e) => (qF(i, typeof t != "symbol" ? t + "" : t, e), e);
const yy = new ih(),
  pw = new Yl(),
  KF = Math.cos(70 * (Math.PI / 180)),
  mw = (i, t) => ((i % t) + t) % t;
let JF = class extends WF {
  constructor(t, e) {
    super(),
      Qe(this, "object"),
      Qe(this, "domElement"),
      Qe(this, "enabled", !0),
      Qe(this, "target", new Z()),
      Qe(this, "minDistance", 0),
      Qe(this, "maxDistance", 1 / 0),
      Qe(this, "minZoom", 0),
      Qe(this, "maxZoom", 1 / 0),
      Qe(this, "minPolarAngle", 0),
      Qe(this, "maxPolarAngle", Math.PI),
      Qe(this, "minAzimuthAngle", -1 / 0),
      Qe(this, "maxAzimuthAngle", 1 / 0),
      Qe(this, "enableDamping", !1),
      Qe(this, "dampingFactor", 0.05),
      Qe(this, "enableZoom", !0),
      Qe(this, "zoomSpeed", 1),
      Qe(this, "enableRotate", !0),
      Qe(this, "rotateSpeed", 1),
      Qe(this, "enablePan", !0),
      Qe(this, "panSpeed", 1),
      Qe(this, "screenSpacePanning", !0),
      Qe(this, "keyPanSpeed", 7),
      Qe(this, "zoomToCursor", !1),
      Qe(this, "autoRotate", !1),
      Qe(this, "autoRotateSpeed", 2),
      Qe(this, "reverseOrbit", !1),
      Qe(this, "reverseHorizontalOrbit", !1),
      Qe(this, "reverseVerticalOrbit", !1),
      Qe(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      Qe(this, "mouseButtons", {
        LEFT: Bf.ROTATE,
        MIDDLE: Bf.DOLLY,
        RIGHT: Bf.PAN,
      }),
      Qe(this, "touches", { ONE: Df.ROTATE, TWO: Df.DOLLY_PAN }),
      Qe(this, "target0"),
      Qe(this, "position0"),
      Qe(this, "zoom0"),
      Qe(this, "_domElementKeyEvents", null),
      Qe(this, "getPolarAngle"),
      Qe(this, "getAzimuthalAngle"),
      Qe(this, "setPolarAngle"),
      Qe(this, "setAzimuthalAngle"),
      Qe(this, "getDistance"),
      Qe(this, "getZoomScale"),
      Qe(this, "listenToKeyEvents"),
      Qe(this, "stopListenToKeyEvents"),
      Qe(this, "saveState"),
      Qe(this, "reset"),
      Qe(this, "update"),
      Qe(this, "connect"),
      Qe(this, "dispose"),
      Qe(this, "dollyIn"),
      Qe(this, "dollyOut"),
      Qe(this, "getScale"),
      Qe(this, "setScale"),
      (this.object = t),
      (this.domElement = e),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => m.phi),
      (this.getAzimuthalAngle = () => m.theta),
      (this.setPolarAngle = (it) => {
        let yt = mw(it, 2 * Math.PI),
          Qt = m.phi;
        Qt < 0 && (Qt += 2 * Math.PI), yt < 0 && (yt += 2 * Math.PI);
        let st = Math.abs(yt - Qt);
        2 * Math.PI - st < st &&
          (yt < Qt ? (yt += 2 * Math.PI) : (Qt += 2 * Math.PI)),
          (v.phi = yt - Qt),
          n.update();
      }),
      (this.setAzimuthalAngle = (it) => {
        let yt = mw(it, 2 * Math.PI),
          Qt = m.theta;
        Qt < 0 && (Qt += 2 * Math.PI), yt < 0 && (yt += 2 * Math.PI);
        let st = Math.abs(yt - Qt);
        2 * Math.PI - st < st &&
          (yt < Qt ? (yt += 2 * Math.PI) : (Qt += 2 * Math.PI)),
          (v.theta = yt - Qt),
          n.update();
      }),
      (this.getDistance = () => n.object.position.distanceTo(n.target)),
      (this.listenToKeyEvents = (it) => {
        it.addEventListener("keydown", zt), (this._domElementKeyEvents = it);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", zt),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom);
      }),
      (this.reset = () => {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(a),
          n.update(),
          (h = u.NONE);
      }),
      (this.update = (() => {
        const it = new Z(),
          yt = new Z(0, 1, 0),
          Qt = new pa().setFromUnitVectors(t.up, yt),
          st = Qt.clone().invert(),
          Et = new Z(),
          qt = new pa(),
          ge = 2 * Math.PI;
        return function () {
          const Kt = n.object.position;
          Qt.setFromUnitVectors(t.up, yt),
            st.copy(Qt).invert(),
            it.copy(Kt).sub(n.target),
            it.applyQuaternion(Qt),
            m.setFromVector3(it),
            n.autoRotate && h === u.NONE && dt(ct()),
            n.enableDamping
              ? ((m.theta += v.theta * n.dampingFactor),
                (m.phi += v.phi * n.dampingFactor))
              : ((m.theta += v.theta), (m.phi += v.phi));
          let be = n.minAzimuthAngle,
            Le = n.maxAzimuthAngle;
          isFinite(be) &&
            isFinite(Le) &&
            (be < -Math.PI ? (be += ge) : be > Math.PI && (be -= ge),
            Le < -Math.PI ? (Le += ge) : Le > Math.PI && (Le -= ge),
            be <= Le
              ? (m.theta = Math.max(be, Math.min(Le, m.theta)))
              : (m.theta =
                  m.theta > (be + Le) / 2
                    ? Math.max(be, m.theta)
                    : Math.min(Le, m.theta))),
            (m.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, m.phi)
            )),
            m.makeSafe(),
            n.enableDamping === !0
              ? n.target.addScaledVector(_, n.dampingFactor)
              : n.target.add(_),
            (n.zoomToCursor && N) || n.object.isOrthographicCamera
              ? (m.radius = Rt(m.radius))
              : (m.radius = Rt(m.radius * x)),
            it.setFromSpherical(m),
            it.applyQuaternion(st),
            Kt.copy(n.target).add(it),
            n.object.matrixAutoUpdate || n.object.updateMatrix(),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((v.theta *= 1 - n.dampingFactor),
                (v.phi *= 1 - n.dampingFactor),
                _.multiplyScalar(1 - n.dampingFactor))
              : (v.set(0, 0, 0), _.set(0, 0, 0));
          let mn = !1;
          if (n.zoomToCursor && N) {
            let ln = null;
            if (n.object instanceof Ei && n.object.isPerspectiveCamera) {
              const yi = it.length();
              ln = Rt(yi * x);
              const si = yi - ln;
              n.object.position.addScaledVector(V, si),
                n.object.updateMatrixWorld();
            } else if (n.object.isOrthographicCamera) {
              const yi = new Z(F.x, F.y, 0);
              yi.unproject(n.object),
                (n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / x)
                )),
                n.object.updateProjectionMatrix(),
                (mn = !0);
              const si = new Z(F.x, F.y, 0);
              si.unproject(n.object),
                n.object.position.sub(si).add(yi),
                n.object.updateMatrixWorld(),
                (ln = it.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (n.zoomToCursor = !1);
            ln !== null &&
              (n.screenSpacePanning
                ? n.target
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix)
                    .multiplyScalar(ln)
                    .add(n.object.position)
                : (yy.origin.copy(n.object.position),
                  yy.direction
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix),
                  Math.abs(n.object.up.dot(yy.direction)) < KF
                    ? t.lookAt(n.target)
                    : (pw.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                      yy.intersectPlane(pw, n.target))));
          } else
            n.object instanceof Ir &&
              n.object.isOrthographicCamera &&
              ((mn = x !== 1),
              mn &&
                ((n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / x)
                )),
                n.object.updateProjectionMatrix()));
          return (
            (x = 1),
            (N = !1),
            mn ||
            Et.distanceToSquared(n.object.position) > p ||
            8 * (1 - qt.dot(n.object.quaternion)) > p
              ? (n.dispatchEvent(a),
                Et.copy(n.object.position),
                qt.copy(n.object.quaternion),
                (mn = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (it) => {
        (n.domElement = it),
          (n.domElement.style.touchAction = "none"),
          n.domElement.addEventListener("contextmenu", we),
          n.domElement.addEventListener("pointerdown", Ye),
          n.domElement.addEventListener("pointercancel", k),
          n.domElement.addEventListener("wheel", Gt);
      }),
      (this.dispose = () => {
        var it, yt, Qt, st, Et, qt;
        n.domElement && (n.domElement.style.touchAction = "auto"),
          (it = n.domElement) == null ||
            it.removeEventListener("contextmenu", we),
          (yt = n.domElement) == null ||
            yt.removeEventListener("pointerdown", Ye),
          (Qt = n.domElement) == null ||
            Qt.removeEventListener("pointercancel", k),
          (st = n.domElement) == null || st.removeEventListener("wheel", Gt),
          (Et = n.domElement) == null ||
            Et.ownerDocument.removeEventListener("pointermove", $),
          (qt = n.domElement) == null ||
            qt.ownerDocument.removeEventListener("pointerup", k),
          n._domElementKeyEvents !== null &&
            n._domElementKeyEvents.removeEventListener("keydown", zt);
      });
    const n = this,
      a = { type: "change" },
      r = { type: "start" },
      l = { type: "end" },
      u = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let h = u.NONE;
    const p = 1e-6,
      m = new Yb(),
      v = new Yb();
    let x = 1;
    const _ = new Z(),
      M = new Yt(),
      C = new Yt(),
      E = new Yt(),
      S = new Yt(),
      R = new Yt(),
      B = new Yt(),
      D = new Yt(),
      I = new Yt(),
      P = new Yt(),
      V = new Z(),
      F = new Yt();
    let N = !1;
    const L = [],
      Y = {};
    function ct() {
      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function nt() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function dt(it) {
      n.reverseOrbit || n.reverseHorizontalOrbit
        ? (v.theta += it)
        : (v.theta -= it);
    }
    function pt(it) {
      n.reverseOrbit || n.reverseVerticalOrbit ? (v.phi += it) : (v.phi -= it);
    }
    const j = (() => {
        const it = new Z();
        return function (Qt, st) {
          it.setFromMatrixColumn(st, 0), it.multiplyScalar(-Qt), _.add(it);
        };
      })(),
      Q = (() => {
        const it = new Z();
        return function (Qt, st) {
          n.screenSpacePanning === !0
            ? it.setFromMatrixColumn(st, 1)
            : (it.setFromMatrixColumn(st, 0), it.crossVectors(n.object.up, it)),
            it.multiplyScalar(Qt),
            _.add(it);
        };
      })(),
      et = (() => {
        const it = new Z();
        return function (Qt, st) {
          const Et = n.domElement;
          if (Et && n.object instanceof Ei && n.object.isPerspectiveCamera) {
            const qt = n.object.position;
            it.copy(qt).sub(n.target);
            let ge = it.length();
            (ge *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              j((2 * Qt * ge) / Et.clientHeight, n.object.matrix),
              Q((2 * st * ge) / Et.clientHeight, n.object.matrix);
          } else
            Et && n.object instanceof Ir && n.object.isOrthographicCamera
              ? (j(
                  (Qt * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    Et.clientWidth,
                  n.object.matrix
                ),
                Q(
                  (st * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    Et.clientHeight,
                  n.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (n.enablePan = !1));
        };
      })();
    function xt(it) {
      (n.object instanceof Ei && n.object.isPerspectiveCamera) ||
      (n.object instanceof Ir && n.object.isOrthographicCamera)
        ? (x = it)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function X(it) {
      xt(x / it);
    }
    function ft(it) {
      xt(x * it);
    }
    function At(it) {
      if (!n.zoomToCursor || !n.domElement) return;
      N = !0;
      const yt = n.domElement.getBoundingClientRect(),
        Qt = it.clientX - yt.left,
        st = it.clientY - yt.top,
        Et = yt.width,
        qt = yt.height;
      (F.x = (Qt / Et) * 2 - 1),
        (F.y = -(st / qt) * 2 + 1),
        V.set(F.x, F.y, 1)
          .unproject(n.object)
          .sub(n.object.position)
          .normalize();
    }
    function Rt(it) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, it));
    }
    function ht(it) {
      M.set(it.clientX, it.clientY);
    }
    function It(it) {
      At(it), D.set(it.clientX, it.clientY);
    }
    function Pt(it) {
      S.set(it.clientX, it.clientY);
    }
    function re(it) {
      C.set(it.clientX, it.clientY),
        E.subVectors(C, M).multiplyScalar(n.rotateSpeed);
      const yt = n.domElement;
      yt &&
        (dt((2 * Math.PI * E.x) / yt.clientHeight),
        pt((2 * Math.PI * E.y) / yt.clientHeight)),
        M.copy(C),
        n.update();
    }
    function ie(it) {
      I.set(it.clientX, it.clientY),
        P.subVectors(I, D),
        P.y > 0 ? X(nt()) : P.y < 0 && ft(nt()),
        D.copy(I),
        n.update();
    }
    function Fe(it) {
      R.set(it.clientX, it.clientY),
        B.subVectors(R, S).multiplyScalar(n.panSpeed),
        et(B.x, B.y),
        S.copy(R),
        n.update();
    }
    function Ae(it) {
      At(it), it.deltaY < 0 ? ft(nt()) : it.deltaY > 0 && X(nt()), n.update();
    }
    function De(it) {
      let yt = !1;
      switch (it.code) {
        case n.keys.UP:
          et(0, n.keyPanSpeed), (yt = !0);
          break;
        case n.keys.BOTTOM:
          et(0, -n.keyPanSpeed), (yt = !0);
          break;
        case n.keys.LEFT:
          et(n.keyPanSpeed, 0), (yt = !0);
          break;
        case n.keys.RIGHT:
          et(-n.keyPanSpeed, 0), (yt = !0);
          break;
      }
      yt && (it.preventDefault(), n.update());
    }
    function je() {
      if (L.length == 1) M.set(L[0].pageX, L[0].pageY);
      else {
        const it = 0.5 * (L[0].pageX + L[1].pageX),
          yt = 0.5 * (L[0].pageY + L[1].pageY);
        M.set(it, yt);
      }
    }
    function Ue() {
      if (L.length == 1) S.set(L[0].pageX, L[0].pageY);
      else {
        const it = 0.5 * (L[0].pageX + L[1].pageX),
          yt = 0.5 * (L[0].pageY + L[1].pageY);
        S.set(it, yt);
      }
    }
    function J() {
      const it = L[0].pageX - L[1].pageX,
        yt = L[0].pageY - L[1].pageY,
        Qt = Math.sqrt(it * it + yt * yt);
      D.set(0, Qt);
    }
    function le() {
      n.enableZoom && J(), n.enablePan && Ue();
    }
    function se() {
      n.enableZoom && J(), n.enableRotate && je();
    }
    function $t(it) {
      if (L.length == 1) C.set(it.pageX, it.pageY);
      else {
        const Qt = Re(it),
          st = 0.5 * (it.pageX + Qt.x),
          Et = 0.5 * (it.pageY + Qt.y);
        C.set(st, Et);
      }
      E.subVectors(C, M).multiplyScalar(n.rotateSpeed);
      const yt = n.domElement;
      yt &&
        (dt((2 * Math.PI * E.x) / yt.clientHeight),
        pt((2 * Math.PI * E.y) / yt.clientHeight)),
        M.copy(C);
    }
    function kt(it) {
      if (L.length == 1) R.set(it.pageX, it.pageY);
      else {
        const yt = Re(it),
          Qt = 0.5 * (it.pageX + yt.x),
          st = 0.5 * (it.pageY + yt.y);
        R.set(Qt, st);
      }
      B.subVectors(R, S).multiplyScalar(n.panSpeed), et(B.x, B.y), S.copy(R);
    }
    function ye(it) {
      const yt = Re(it),
        Qt = it.pageX - yt.x,
        st = it.pageY - yt.y,
        Et = Math.sqrt(Qt * Qt + st * st);
      I.set(0, Et),
        P.set(0, Math.pow(I.y / D.y, n.zoomSpeed)),
        X(P.y),
        D.copy(I);
    }
    function te(it) {
      n.enableZoom && ye(it), n.enablePan && kt(it);
    }
    function pe(it) {
      n.enableZoom && ye(it), n.enableRotate && $t(it);
    }
    function Ye(it) {
      var yt, Qt;
      n.enabled !== !1 &&
        (L.length === 0 &&
          ((yt = n.domElement) == null ||
            yt.ownerDocument.addEventListener("pointermove", $),
          (Qt = n.domElement) == null ||
            Qt.ownerDocument.addEventListener("pointerup", k)),
        Ce(it),
        it.pointerType === "touch" ? me(it) : Mt(it));
    }
    function $(it) {
      n.enabled !== !1 && (it.pointerType === "touch" ? de(it) : Ft(it));
    }
    function k(it) {
      var yt, Qt, st;
      jt(it),
        L.length === 0 &&
          ((yt = n.domElement) == null ||
            yt.releasePointerCapture(it.pointerId),
          (Qt = n.domElement) == null ||
            Qt.ownerDocument.removeEventListener("pointermove", $),
          (st = n.domElement) == null ||
            st.ownerDocument.removeEventListener("pointerup", k)),
        n.dispatchEvent(l),
        (h = u.NONE);
    }
    function Mt(it) {
      let yt;
      switch (it.button) {
        case 0:
          yt = n.mouseButtons.LEFT;
          break;
        case 1:
          yt = n.mouseButtons.MIDDLE;
          break;
        case 2:
          yt = n.mouseButtons.RIGHT;
          break;
        default:
          yt = -1;
      }
      switch (yt) {
        case Bf.DOLLY:
          if (n.enableZoom === !1) return;
          It(it), (h = u.DOLLY);
          break;
        case Bf.ROTATE:
          if (it.ctrlKey || it.metaKey || it.shiftKey) {
            if (n.enablePan === !1) return;
            Pt(it), (h = u.PAN);
          } else {
            if (n.enableRotate === !1) return;
            ht(it), (h = u.ROTATE);
          }
          break;
        case Bf.PAN:
          if (it.ctrlKey || it.metaKey || it.shiftKey) {
            if (n.enableRotate === !1) return;
            ht(it), (h = u.ROTATE);
          } else {
            if (n.enablePan === !1) return;
            Pt(it), (h = u.PAN);
          }
          break;
        default:
          h = u.NONE;
      }
      h !== u.NONE && n.dispatchEvent(r);
    }
    function Ft(it) {
      if (n.enabled !== !1)
        switch (h) {
          case u.ROTATE:
            if (n.enableRotate === !1) return;
            re(it);
            break;
          case u.DOLLY:
            if (n.enableZoom === !1) return;
            ie(it);
            break;
          case u.PAN:
            if (n.enablePan === !1) return;
            Fe(it);
            break;
        }
    }
    function Gt(it) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        (h !== u.NONE && h !== u.ROTATE) ||
        (it.preventDefault(), n.dispatchEvent(r), Ae(it), n.dispatchEvent(l));
    }
    function zt(it) {
      n.enabled === !1 || n.enablePan === !1 || De(it);
    }
    function me(it) {
      switch ((ce(it), L.length)) {
        case 1:
          switch (n.touches.ONE) {
            case Df.ROTATE:
              if (n.enableRotate === !1) return;
              je(), (h = u.TOUCH_ROTATE);
              break;
            case Df.PAN:
              if (n.enablePan === !1) return;
              Ue(), (h = u.TOUCH_PAN);
              break;
            default:
              h = u.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Df.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              le(), (h = u.TOUCH_DOLLY_PAN);
              break;
            case Df.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              se(), (h = u.TOUCH_DOLLY_ROTATE);
              break;
            default:
              h = u.NONE;
          }
          break;
        default:
          h = u.NONE;
      }
      h !== u.NONE && n.dispatchEvent(r);
    }
    function de(it) {
      switch ((ce(it), h)) {
        case u.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          $t(it), n.update();
          break;
        case u.TOUCH_PAN:
          if (n.enablePan === !1) return;
          kt(it), n.update();
          break;
        case u.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          te(it), n.update();
          break;
        case u.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          pe(it), n.update();
          break;
        default:
          h = u.NONE;
      }
    }
    function we(it) {
      n.enabled !== !1 && it.preventDefault();
    }
    function Ce(it) {
      L.push(it);
    }
    function jt(it) {
      delete Y[it.pointerId];
      for (let yt = 0; yt < L.length; yt++)
        if (L[yt].pointerId == it.pointerId) {
          L.splice(yt, 1);
          return;
        }
    }
    function ce(it) {
      let yt = Y[it.pointerId];
      yt === void 0 && ((yt = new Yt()), (Y[it.pointerId] = yt)),
        yt.set(it.pageX, it.pageY);
    }
    function Re(it) {
      const yt = it.pointerId === L[0].pointerId ? L[1] : L[0];
      return Y[yt.pointerId];
    }
    (this.dollyIn = (it = nt()) => {
      ft(it), n.update();
    }),
      (this.dollyOut = (it = nt()) => {
        X(it), n.update();
      }),
      (this.getScale = () => x),
      (this.setScale = (it) => {
        xt(it), n.update();
      }),
      (this.getZoomScale = () => nt()),
      e !== void 0 && this.connect(e),
      this.update();
  }
};
function Tx(i) {
  if (typeof TextDecoder < "u") return new TextDecoder().decode(i);
  let t = "";
  for (let e = 0, n = i.length; e < n; e++) t += String.fromCharCode(i[e]);
  try {
    return decodeURIComponent(escape(t));
  } catch {
    return t;
  }
}
const Vf = "srgb",
  $l = "srgb-linear",
  gw = 3001,
  ZF = 3e3;
class DS extends Va {
  constructor(t) {
    super(t),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (e) {
        return new n8(e);
      }),
      this.register(function (e) {
        return new i8(e);
      }),
      this.register(function (e) {
        return new h8(e);
      }),
      this.register(function (e) {
        return new d8(e);
      }),
      this.register(function (e) {
        return new p8(e);
      }),
      this.register(function (e) {
        return new s8(e);
      }),
      this.register(function (e) {
        return new r8(e);
      }),
      this.register(function (e) {
        return new o8(e);
      }),
      this.register(function (e) {
        return new l8(e);
      }),
      this.register(function (e) {
        return new e8(e);
      }),
      this.register(function (e) {
        return new c8(e);
      }),
      this.register(function (e) {
        return new a8(e);
      }),
      this.register(function (e) {
        return new f8(e);
      }),
      this.register(function (e) {
        return new u8(e);
      }),
      this.register(function (e) {
        return new $F(e);
      }),
      this.register(function (e) {
        return new m8(e);
      }),
      this.register(function (e) {
        return new g8(e);
      });
  }
  load(t, e, n, a) {
    const r = this;
    let l;
    if (this.resourcePath !== "") l = this.resourcePath;
    else if (this.path !== "") {
      const p = lu.extractUrlBase(t);
      l = lu.resolveURL(p, this.path);
    } else l = lu.extractUrlBase(t);
    this.manager.itemStart(t);
    const u = function (p) {
        a ? a(p) : console.error(p),
          r.manager.itemError(t),
          r.manager.itemEnd(t);
      },
      h = new Ga(this.manager);
    h.setPath(this.path),
      h.setResponseType("arraybuffer"),
      h.setRequestHeader(this.requestHeader),
      h.setWithCredentials(this.withCredentials),
      h.load(
        t,
        function (p) {
          try {
            r.parse(
              p,
              l,
              function (m) {
                e(m), r.manager.itemEnd(t);
              },
              u
            );
          } catch (m) {
            u(m);
          }
        },
        n,
        u
      );
  }
  setDRACOLoader(t) {
    return (this.dracoLoader = t), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(t) {
    return (this.ktx2Loader = t), this;
  }
  setMeshoptDecoder(t) {
    return (this.meshoptDecoder = t), this;
  }
  register(t) {
    return (
      this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t),
      this
    );
  }
  unregister(t) {
    return (
      this.pluginCallbacks.indexOf(t) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
      this
    );
  }
  parse(t, e, n, a) {
    let r;
    const l = {},
      u = {};
    if (typeof t == "string") r = JSON.parse(t);
    else if (t instanceof ArrayBuffer)
      if (Tx(new Uint8Array(t.slice(0, 4))) === yB) {
        try {
          l[Bn.KHR_BINARY_GLTF] = new v8(t);
        } catch (m) {
          a && a(m);
          return;
        }
        r = JSON.parse(l[Bn.KHR_BINARY_GLTF].content);
      } else r = JSON.parse(Tx(new Uint8Array(t)));
    else r = t;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      a &&
        a(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const h = new B8(r, {
      path: e || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    h.fileLoader.setRequestHeader(this.requestHeader);
    for (let p = 0; p < this.pluginCallbacks.length; p++) {
      const m = this.pluginCallbacks[p](h);
      m.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (u[m.name] = m),
        (l[m.name] = !0);
    }
    if (r.extensionsUsed)
      for (let p = 0; p < r.extensionsUsed.length; ++p) {
        const m = r.extensionsUsed[p],
          v = r.extensionsRequired || [];
        switch (m) {
          case Bn.KHR_MATERIALS_UNLIT:
            l[m] = new t8();
            break;
          case Bn.KHR_DRACO_MESH_COMPRESSION:
            l[m] = new y8(r, this.dracoLoader);
            break;
          case Bn.KHR_TEXTURE_TRANSFORM:
            l[m] = new x8();
            break;
          case Bn.KHR_MESH_QUANTIZATION:
            l[m] = new _8();
            break;
          default:
            v.indexOf(m) >= 0 &&
              u[m] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + m + '".');
        }
      }
    h.setExtensions(l), h.setPlugins(u), h.parse(n, a);
  }
  parseAsync(t, e) {
    const n = this;
    return new Promise(function (a, r) {
      n.parse(t, e, a, r);
    });
  }
}
function QF() {
  let i = {};
  return {
    get: function (t) {
      return i[t];
    },
    add: function (t, e) {
      i[t] = e;
    },
    remove: function (t) {
      delete i[t];
    },
    removeAll: function () {
      i = {};
    },
  };
}
const Bn = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class $F {
  constructor(t) {
    (this.parser = t),
      (this.name = Bn.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const t = this.parser,
      e = this.parser.json.nodes || [];
    for (let n = 0, a = e.length; n < a; n++) {
      const r = e[n];
      r.extensions &&
        r.extensions[this.name] &&
        r.extensions[this.name].light !== void 0 &&
        t._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(t) {
    const e = this.parser,
      n = "light:" + t;
    let a = e.cache.get(n);
    if (a) return a;
    const r = e.json,
      h = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[t];
    let p;
    const m = new Se(16777215);
    h.color !== void 0 && m.setRGB(h.color[0], h.color[1], h.color[2], $l);
    const v = h.range !== void 0 ? h.range : 0;
    switch (h.type) {
      case "directional":
        (p = new hS(m)), p.target.position.set(0, 0, -1), p.add(p.target);
        break;
      case "point":
        (p = new fS(m)), (p.distance = v);
        break;
      case "spot":
        (p = new uS(m)),
          (p.distance = v),
          (h.spot = h.spot || {}),
          (h.spot.innerConeAngle =
            h.spot.innerConeAngle !== void 0 ? h.spot.innerConeAngle : 0),
          (h.spot.outerConeAngle =
            h.spot.outerConeAngle !== void 0
              ? h.spot.outerConeAngle
              : Math.PI / 4),
          (p.angle = h.spot.outerConeAngle),
          (p.penumbra = 1 - h.spot.innerConeAngle / h.spot.outerConeAngle),
          p.target.position.set(0, 0, -1),
          p.add(p.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + h.type);
    }
    return (
      p.position.set(0, 0, 0),
      (p.decay = 2),
      Wl(p, h),
      h.intensity !== void 0 && (p.intensity = h.intensity),
      (p.name = e.createUniqueName(h.name || "light_" + t)),
      (a = Promise.resolve(p)),
      e.cache.add(n, a),
      a
    );
  }
  getDependency(t, e) {
    if (t === "light") return this._loadLight(e);
  }
  createNodeAttachment(t) {
    const e = this,
      n = this.parser,
      r = n.json.nodes[t],
      u = ((r.extensions && r.extensions[this.name]) || {}).light;
    return u === void 0
      ? null
      : this._loadLight(u).then(function (h) {
          return n._getNodeRef(e.cache, u, h);
        });
  }
}
class t8 {
  constructor() {
    this.name = Bn.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return ks;
  }
  extendParams(t, e, n) {
    const a = [];
    (t.color = new Se(1, 1, 1)), (t.opacity = 1);
    const r = e.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const l = r.baseColorFactor;
        t.color.setRGB(l[0], l[1], l[2], $l), (t.opacity = l[3]);
      }
      r.baseColorTexture !== void 0 &&
        a.push(n.assignTexture(t, "map", r.baseColorTexture, Vf));
    }
    return Promise.all(a);
  }
}
class e8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(t, e) {
    const a = this.parser.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = a.extensions[this.name].emissiveStrength;
    return r !== void 0 && (e.emissiveIntensity = r), Promise.resolve();
  }
}
class n8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [],
      l = a.extensions[this.name];
    if (
      (l.clearcoatFactor !== void 0 && (e.clearcoat = l.clearcoatFactor),
      l.clearcoatTexture !== void 0 &&
        r.push(n.assignTexture(e, "clearcoatMap", l.clearcoatTexture)),
      l.clearcoatRoughnessFactor !== void 0 &&
        (e.clearcoatRoughness = l.clearcoatRoughnessFactor),
      l.clearcoatRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(
            e,
            "clearcoatRoughnessMap",
            l.clearcoatRoughnessTexture
          )
        ),
      l.clearcoatNormalTexture !== void 0 &&
        (r.push(
          n.assignTexture(e, "clearcoatNormalMap", l.clearcoatNormalTexture)
        ),
        l.clearcoatNormalTexture.scale !== void 0))
    ) {
      const u = l.clearcoatNormalTexture.scale;
      e.clearcoatNormalScale = new Yt(u, u);
    }
    return Promise.all(r);
  }
}
class i8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const a = this.parser.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = a.extensions[this.name];
    return (
      (e.dispersion = r.dispersion !== void 0 ? r.dispersion : 0),
      Promise.resolve()
    );
  }
}
class a8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [],
      l = a.extensions[this.name];
    return (
      l.iridescenceFactor !== void 0 && (e.iridescence = l.iridescenceFactor),
      l.iridescenceTexture !== void 0 &&
        r.push(n.assignTexture(e, "iridescenceMap", l.iridescenceTexture)),
      l.iridescenceIor !== void 0 && (e.iridescenceIOR = l.iridescenceIor),
      e.iridescenceThicknessRange === void 0 &&
        (e.iridescenceThicknessRange = [100, 400]),
      l.iridescenceThicknessMinimum !== void 0 &&
        (e.iridescenceThicknessRange[0] = l.iridescenceThicknessMinimum),
      l.iridescenceThicknessMaximum !== void 0 &&
        (e.iridescenceThicknessRange[1] = l.iridescenceThicknessMaximum),
      l.iridescenceThicknessTexture !== void 0 &&
        r.push(
          n.assignTexture(
            e,
            "iridescenceThicknessMap",
            l.iridescenceThicknessTexture
          )
        ),
      Promise.all(r)
    );
  }
}
class s8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [];
    (e.sheenColor = new Se(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1);
    const l = a.extensions[this.name];
    if (l.sheenColorFactor !== void 0) {
      const u = l.sheenColorFactor;
      e.sheenColor.setRGB(u[0], u[1], u[2], $l);
    }
    return (
      l.sheenRoughnessFactor !== void 0 &&
        (e.sheenRoughness = l.sheenRoughnessFactor),
      l.sheenColorTexture !== void 0 &&
        r.push(n.assignTexture(e, "sheenColorMap", l.sheenColorTexture, Vf)),
      l.sheenRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(e, "sheenRoughnessMap", l.sheenRoughnessTexture)
        ),
      Promise.all(r)
    );
  }
}
class r8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [],
      l = a.extensions[this.name];
    return (
      l.transmissionFactor !== void 0 &&
        (e.transmission = l.transmissionFactor),
      l.transmissionTexture !== void 0 &&
        r.push(n.assignTexture(e, "transmissionMap", l.transmissionTexture)),
      Promise.all(r)
    );
  }
}
class o8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [],
      l = a.extensions[this.name];
    (e.thickness = l.thicknessFactor !== void 0 ? l.thicknessFactor : 0),
      l.thicknessTexture !== void 0 &&
        r.push(n.assignTexture(e, "thicknessMap", l.thicknessTexture)),
      (e.attenuationDistance = l.attenuationDistance || 1 / 0);
    const u = l.attenuationColor || [1, 1, 1];
    return (
      (e.attenuationColor = new Se().setRGB(u[0], u[1], u[2], $l)),
      Promise.all(r)
    );
  }
}
class l8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_IOR);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const a = this.parser.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = a.extensions[this.name];
    return (e.ior = r.ior !== void 0 ? r.ior : 1.5), Promise.resolve();
  }
}
class c8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [],
      l = a.extensions[this.name];
    (e.specularIntensity = l.specularFactor !== void 0 ? l.specularFactor : 1),
      l.specularTexture !== void 0 &&
        r.push(n.assignTexture(e, "specularIntensityMap", l.specularTexture));
    const u = l.specularColorFactor || [1, 1, 1];
    return (
      (e.specularColor = new Se().setRGB(u[0], u[1], u[2], $l)),
      l.specularColorTexture !== void 0 &&
        r.push(
          n.assignTexture(e, "specularColorMap", l.specularColorTexture, Vf)
        ),
      Promise.all(r)
    );
  }
}
class u8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.EXT_MATERIALS_BUMP);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [],
      l = a.extensions[this.name];
    return (
      (e.bumpScale = l.bumpFactor !== void 0 ? l.bumpFactor : 1),
      l.bumpTexture !== void 0 &&
        r.push(n.assignTexture(e, "bumpMap", l.bumpTexture)),
      Promise.all(r)
    );
  }
}
class f8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t];
    return !n.extensions || !n.extensions[this.name] ? null : Fr;
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      a = n.json.materials[t];
    if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
    const r = [],
      l = a.extensions[this.name];
    return (
      l.anisotropyStrength !== void 0 && (e.anisotropy = l.anisotropyStrength),
      l.anisotropyRotation !== void 0 &&
        (e.anisotropyRotation = l.anisotropyRotation),
      l.anisotropyTexture !== void 0 &&
        r.push(n.assignTexture(e, "anisotropyMap", l.anisotropyTexture)),
      Promise.all(r)
    );
  }
}
class h8 {
  constructor(t) {
    (this.parser = t), (this.name = Bn.KHR_TEXTURE_BASISU);
  }
  loadTexture(t) {
    const e = this.parser,
      n = e.json,
      a = n.textures[t];
    if (!a.extensions || !a.extensions[this.name]) return null;
    const r = a.extensions[this.name],
      l = e.options.ktx2Loader;
    if (!l) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return e.loadTextureImage(t, r.source, l);
  }
}
class d8 {
  constructor(t) {
    (this.parser = t),
      (this.name = Bn.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(t) {
    const e = this.name,
      n = this.parser,
      a = n.json,
      r = a.textures[t];
    if (!r.extensions || !r.extensions[e]) return null;
    const l = r.extensions[e],
      u = a.images[l.source];
    let h = n.textureLoader;
    if (u.uri) {
      const p = n.options.manager.getHandler(u.uri);
      p !== null && (h = p);
    }
    return this.detectSupport().then(function (p) {
      if (p) return n.loadTextureImage(t, l.source, h);
      if (a.extensionsRequired && a.extensionsRequired.indexOf(e) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(t);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (t) {
          const e = new Image();
          (e.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (e.onload = e.onerror =
              function () {
                t(e.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class p8 {
  constructor(t) {
    (this.parser = t),
      (this.name = Bn.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(t) {
    const e = this.name,
      n = this.parser,
      a = n.json,
      r = a.textures[t];
    if (!r.extensions || !r.extensions[e]) return null;
    const l = r.extensions[e],
      u = a.images[l.source];
    let h = n.textureLoader;
    if (u.uri) {
      const p = n.options.manager.getHandler(u.uri);
      p !== null && (h = p);
    }
    return this.detectSupport().then(function (p) {
      if (p) return n.loadTextureImage(t, l.source, h);
      if (a.extensionsRequired && a.extensionsRequired.indexOf(e) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return n.loadTexture(t);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (t) {
          const e = new Image();
          (e.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (e.onload = e.onerror =
              function () {
                t(e.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class m8 {
  constructor(t) {
    (this.name = Bn.EXT_MESHOPT_COMPRESSION), (this.parser = t);
  }
  loadBufferView(t) {
    const e = this.parser.json,
      n = e.bufferViews[t];
    if (n.extensions && n.extensions[this.name]) {
      const a = n.extensions[this.name],
        r = this.parser.getDependency("buffer", a.buffer),
        l = this.parser.options.meshoptDecoder;
      if (!l || !l.supported) {
        if (
          e.extensionsRequired &&
          e.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return r.then(function (u) {
        const h = a.byteOffset || 0,
          p = a.byteLength || 0,
          m = a.count,
          v = a.byteStride,
          x = new Uint8Array(u, h, p);
        return l.decodeGltfBufferAsync
          ? l
              .decodeGltfBufferAsync(m, v, x, a.mode, a.filter)
              .then(function (_) {
                return _.buffer;
              })
          : l.ready.then(function () {
              const _ = new ArrayBuffer(m * v);
              return (
                l.decodeGltfBuffer(
                  new Uint8Array(_),
                  m,
                  v,
                  x,
                  a.mode,
                  a.filter
                ),
                _
              );
            });
      });
    } else return null;
  }
}
class g8 {
  constructor(t) {
    (this.name = Bn.EXT_MESH_GPU_INSTANCING), (this.parser = t);
  }
  createNodeMesh(t) {
    const e = this.parser.json,
      n = e.nodes[t];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const a = e.meshes[n.mesh];
    for (const p of a.primitives)
      if (
        p.mode !== Ur.TRIANGLES &&
        p.mode !== Ur.TRIANGLE_STRIP &&
        p.mode !== Ur.TRIANGLE_FAN &&
        p.mode !== void 0
      )
        return null;
    const l = n.extensions[this.name].attributes,
      u = [],
      h = {};
    for (const p in l)
      u.push(
        this.parser
          .getDependency("accessor", l[p])
          .then((m) => ((h[p] = m), h[p]))
      );
    return u.length < 1
      ? null
      : (u.push(this.parser.createNodeMesh(t)),
        Promise.all(u).then((p) => {
          const m = p.pop(),
            v = m.isGroup ? m.children : [m],
            x = p[0].count,
            _ = [];
          for (const M of v) {
            const C = new Xe(),
              E = new Z(),
              S = new pa(),
              R = new Z(1, 1, 1),
              B = new YA(M.geometry, M.material, x);
            for (let D = 0; D < x; D++)
              h.TRANSLATION && E.fromBufferAttribute(h.TRANSLATION, D),
                h.ROTATION && S.fromBufferAttribute(h.ROTATION, D),
                h.SCALE && R.fromBufferAttribute(h.SCALE, D),
                B.setMatrixAt(D, C.compose(E, S, R));
            for (const D in h)
              if (D === "_COLOR_0") {
                const I = h[D];
                B.instanceColor = new Zf(I.array, I.itemSize, I.normalized);
              } else
                D !== "TRANSLATION" &&
                  D !== "ROTATION" &&
                  D !== "SCALE" &&
                  M.geometry.setAttribute(D, h[D]);
            Dn.prototype.copy.call(B, M),
              this.parser.assignFinalMaterial(B),
              _.push(B);
          }
          return m.isGroup ? (m.clear(), m.add(..._), m) : _[0];
        }));
  }
}
const yB = "glTF",
  zm = 12,
  vw = { JSON: 1313821514, BIN: 5130562 };
class v8 {
  constructor(t) {
    (this.name = Bn.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const e = new DataView(t, 0, zm);
    if (
      ((this.header = {
        magic: Tx(new Uint8Array(t.slice(0, 4))),
        version: e.getUint32(4, !0),
        length: e.getUint32(8, !0),
      }),
      this.header.magic !== yB)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - zm,
      a = new DataView(t, zm);
    let r = 0;
    for (; r < n; ) {
      const l = a.getUint32(r, !0);
      r += 4;
      const u = a.getUint32(r, !0);
      if (((r += 4), u === vw.JSON)) {
        const h = new Uint8Array(t, zm + r, l);
        this.content = Tx(h);
      } else if (u === vw.BIN) {
        const h = zm + r;
        this.body = t.slice(h, h + l);
      }
      r += l;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class y8 {
  constructor(t, e) {
    if (!e)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = Bn.KHR_DRACO_MESH_COMPRESSION),
      (this.json = t),
      (this.dracoLoader = e),
      this.dracoLoader.preload();
  }
  decodePrimitive(t, e) {
    const n = this.json,
      a = this.dracoLoader,
      r = t.extensions[this.name].bufferView,
      l = t.extensions[this.name].attributes,
      u = {},
      h = {},
      p = {};
    for (const m in l) {
      const v = sA[m] || m.toLowerCase();
      u[v] = l[m];
    }
    for (const m in t.attributes) {
      const v = sA[m] || m.toLowerCase();
      if (l[m] !== void 0) {
        const x = n.accessors[t.attributes[m]],
          _ = Hd[x.componentType];
        (p[v] = _.name), (h[v] = x.normalized === !0);
      }
    }
    return e.getDependency("bufferView", r).then(function (m) {
      return new Promise(function (v, x) {
        a.decodeDracoFile(
          m,
          function (_) {
            for (const M in _.attributes) {
              const C = _.attributes[M],
                E = h[M];
              E !== void 0 && (C.normalized = E);
            }
            v(_);
          },
          u,
          p,
          $l,
          x
        );
      });
    });
  }
}
class x8 {
  constructor() {
    this.name = Bn.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(t, e) {
    return (
      ((e.texCoord === void 0 || e.texCoord === t.channel) &&
        e.offset === void 0 &&
        e.rotation === void 0 &&
        e.scale === void 0) ||
        ((t = t.clone()),
        e.texCoord !== void 0 && (t.channel = e.texCoord),
        e.offset !== void 0 && t.offset.fromArray(e.offset),
        e.rotation !== void 0 && (t.rotation = e.rotation),
        e.scale !== void 0 && t.repeat.fromArray(e.scale),
        (t.needsUpdate = !0)),
      t
    );
  }
}
class _8 {
  constructor() {
    this.name = Bn.KHR_MESH_QUANTIZATION;
  }
}
class xB extends sp {
  constructor(t, e, n, a) {
    super(t, e, n, a);
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      a = this.valueSize,
      r = t * a * 3 + a;
    for (let l = 0; l !== a; l++) e[l] = n[r + l];
    return e;
  }
  interpolate_(t, e, n, a) {
    const r = this.resultBuffer,
      l = this.sampleValues,
      u = this.valueSize,
      h = u * 2,
      p = u * 3,
      m = a - e,
      v = (n - e) / m,
      x = v * v,
      _ = x * v,
      M = t * p,
      C = M - p,
      E = -2 * _ + 3 * x,
      S = _ - x,
      R = 1 - E,
      B = S - x + v;
    for (let D = 0; D !== u; D++) {
      const I = l[C + D + u],
        P = l[C + D + h] * m,
        V = l[M + D + u],
        F = l[M + D] * m;
      r[D] = R * I + B * P + E * V + S * F;
    }
    return r;
  }
}
const b8 = new pa();
class A8 extends xB {
  interpolate_(t, e, n, a) {
    const r = super.interpolate_(t, e, n, a);
    return b8.fromArray(r).normalize().toArray(r), r;
  }
}
const Ur = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
  },
  Hd = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  yw = { 9728: Ta, 9729: Kn, 9984: Ox, 9985: Pd, 9986: If, 9987: Nr },
  xw = { 33071: Ki, 33648: kd, 10497: fu },
  hb = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  sA = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(BS >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  iu = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  S8 = { CUBICSPLINE: void 0, LINEAR: Kd, STEP: qd },
  db = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function M8(i) {
  return (
    i.DefaultMaterial === void 0 &&
      (i.DefaultMaterial = new V0({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: hl,
      })),
    i.DefaultMaterial
  );
}
function Cf(i, t, e) {
  for (const n in e.extensions)
    i[n] === void 0 &&
      ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
      (t.userData.gltfExtensions[n] = e.extensions[n]));
}
function Wl(i, t) {
  t.extras !== void 0 &&
    (typeof t.extras == "object"
      ? Object.assign(i.userData, t.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
        ));
}
function E8(i, t, e) {
  let n = !1,
    a = !1,
    r = !1;
  for (let p = 0, m = t.length; p < m; p++) {
    const v = t[p];
    if (
      (v.POSITION !== void 0 && (n = !0),
      v.NORMAL !== void 0 && (a = !0),
      v.COLOR_0 !== void 0 && (r = !0),
      n && a && r)
    )
      break;
  }
  if (!n && !a && !r) return Promise.resolve(i);
  const l = [],
    u = [],
    h = [];
  for (let p = 0, m = t.length; p < m; p++) {
    const v = t[p];
    if (n) {
      const x =
        v.POSITION !== void 0
          ? e.getDependency("accessor", v.POSITION)
          : i.attributes.position;
      l.push(x);
    }
    if (a) {
      const x =
        v.NORMAL !== void 0
          ? e.getDependency("accessor", v.NORMAL)
          : i.attributes.normal;
      u.push(x);
    }
    if (r) {
      const x =
        v.COLOR_0 !== void 0
          ? e.getDependency("accessor", v.COLOR_0)
          : i.attributes.color;
      h.push(x);
    }
  }
  return Promise.all([Promise.all(l), Promise.all(u), Promise.all(h)]).then(
    function (p) {
      const m = p[0],
        v = p[1],
        x = p[2];
      return (
        n && (i.morphAttributes.position = m),
        a && (i.morphAttributes.normal = v),
        r && (i.morphAttributes.color = x),
        (i.morphTargetsRelative = !0),
        i
      );
    }
  );
}
function T8(i, t) {
  if ((i.updateMorphTargets(), t.weights !== void 0))
    for (let e = 0, n = t.weights.length; e < n; e++)
      i.morphTargetInfluences[e] = t.weights[e];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const e = t.extras.targetNames;
    if (i.morphTargetInfluences.length === e.length) {
      i.morphTargetDictionary = {};
      for (let n = 0, a = e.length; n < a; n++)
        i.morphTargetDictionary[e[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function w8(i) {
  let t;
  const e = i.extensions && i.extensions[Bn.KHR_DRACO_MESH_COMPRESSION];
  if (
    (e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + pb(e.attributes))
      : (t = i.indices + ":" + pb(i.attributes) + ":" + i.mode),
    i.targets !== void 0)
  )
    for (let n = 0, a = i.targets.length; n < a; n++)
      t += ":" + pb(i.targets[n]);
  return t;
}
function pb(i) {
  let t = "";
  const e = Object.keys(i).sort();
  for (let n = 0, a = e.length; n < a; n++) t += e[n] + ":" + i[e[n]] + ";";
  return t;
}
function rA(i) {
  switch (i) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function C8(i) {
  return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const R8 = new Xe();
class B8 {
  constructor(t = {}, e = {}) {
    (this.json = t),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = e),
      (this.cache = new QF()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      a = !1,
      r = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (a = navigator.userAgent.indexOf("Firefox") > -1),
      (r = a ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || n || (a && r < 98)
        ? (this.textureLoader = new xR(this.options.manager))
        : (this.textureLoader = new wR(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Ga(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(t) {
    this.extensions = t;
  }
  setPlugins(t) {
    this.plugins = t;
  }
  parse(t, e) {
    const n = this,
      a = this.json,
      r = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (l) {
        return l._markDefs && l._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (l) {
          return l.beforeRoot && l.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (l) {
          const u = {
            scene: l[0][a.scene || 0],
            scenes: l[0],
            animations: l[1],
            cameras: l[2],
            asset: a.asset,
            parser: n,
            userData: {},
          };
          return (
            Cf(r, u, a),
            Wl(u, a),
            Promise.all(
              n._invokeAll(function (h) {
                return h.afterRoot && h.afterRoot(u);
              })
            ).then(function () {
              for (const h of u.scenes) h.updateMatrixWorld();
              t(u);
            })
          );
        })
        .catch(e);
  }
  _markDefs() {
    const t = this.json.nodes || [],
      e = this.json.skins || [],
      n = this.json.meshes || [];
    for (let a = 0, r = e.length; a < r; a++) {
      const l = e[a].joints;
      for (let u = 0, h = l.length; u < h; u++) t[l[u]].isBone = !0;
    }
    for (let a = 0, r = t.length; a < r; a++) {
      const l = t[a];
      l.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, l.mesh),
        l.skin !== void 0 && (n[l.mesh].isSkinnedMesh = !0)),
        l.camera !== void 0 && this._addNodeRef(this.cameraCache, l.camera);
    }
  }
  _addNodeRef(t, e) {
    e !== void 0 &&
      (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
  }
  _getNodeRef(t, e, n) {
    if (t.refs[e] <= 1) return n;
    const a = n.clone(),
      r = (l, u) => {
        const h = this.associations.get(l);
        h != null && this.associations.set(u, h);
        for (const [p, m] of l.children.entries()) r(m, u.children[p]);
      };
    return r(n, a), (a.name += "_instance_" + t.uses[e]++), a;
  }
  _invokeOne(t) {
    const e = Object.values(this.plugins);
    e.push(this);
    for (let n = 0; n < e.length; n++) {
      const a = t(e[n]);
      if (a) return a;
    }
    return null;
  }
  _invokeAll(t) {
    const e = Object.values(this.plugins);
    e.unshift(this);
    const n = [];
    for (let a = 0; a < e.length; a++) {
      const r = t(e[a]);
      r && n.push(r);
    }
    return n;
  }
  getDependency(t, e) {
    const n = t + ":" + e;
    let a = this.cache.get(n);
    if (!a) {
      switch (t) {
        case "scene":
          a = this.loadScene(e);
          break;
        case "node":
          a = this._invokeOne(function (r) {
            return r.loadNode && r.loadNode(e);
          });
          break;
        case "mesh":
          a = this._invokeOne(function (r) {
            return r.loadMesh && r.loadMesh(e);
          });
          break;
        case "accessor":
          a = this.loadAccessor(e);
          break;
        case "bufferView":
          a = this._invokeOne(function (r) {
            return r.loadBufferView && r.loadBufferView(e);
          });
          break;
        case "buffer":
          a = this.loadBuffer(e);
          break;
        case "material":
          a = this._invokeOne(function (r) {
            return r.loadMaterial && r.loadMaterial(e);
          });
          break;
        case "texture":
          a = this._invokeOne(function (r) {
            return r.loadTexture && r.loadTexture(e);
          });
          break;
        case "skin":
          a = this.loadSkin(e);
          break;
        case "animation":
          a = this._invokeOne(function (r) {
            return r.loadAnimation && r.loadAnimation(e);
          });
          break;
        case "camera":
          a = this.loadCamera(e);
          break;
        default:
          if (
            ((a = this._invokeOne(function (r) {
              return r != this && r.getDependency && r.getDependency(t, e);
            })),
            !a)
          )
            throw new Error("Unknown type: " + t);
          break;
      }
      this.cache.add(n, a);
    }
    return a;
  }
  getDependencies(t) {
    let e = this.cache.get(t);
    if (!e) {
      const n = this,
        a = this.json[t + (t === "mesh" ? "es" : "s")] || [];
      (e = Promise.all(
        a.map(function (r, l) {
          return n.getDependency(t, l);
        })
      )),
        this.cache.add(t, e);
    }
    return e;
  }
  loadBuffer(t) {
    const e = this.json.buffers[t],
      n = this.fileLoader;
    if (e.type && e.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
      );
    if (e.uri === void 0 && t === 0)
      return Promise.resolve(this.extensions[Bn.KHR_BINARY_GLTF].body);
    const a = this.options;
    return new Promise(function (r, l) {
      n.load(lu.resolveURL(e.uri, a.path), r, void 0, function () {
        l(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".')
        );
      });
    });
  }
  loadBufferView(t) {
    const e = this.json.bufferViews[t];
    return this.getDependency("buffer", e.buffer).then(function (n) {
      const a = e.byteLength || 0,
        r = e.byteOffset || 0;
      return n.slice(r, r + a);
    });
  }
  loadAccessor(t) {
    const e = this,
      n = this.json,
      a = this.json.accessors[t];
    if (a.bufferView === void 0 && a.sparse === void 0) {
      const l = hb[a.type],
        u = Hd[a.componentType],
        h = a.normalized === !0,
        p = new u(a.count * l);
      return Promise.resolve(new Gn(p, l, h));
    }
    const r = [];
    return (
      a.bufferView !== void 0
        ? r.push(this.getDependency("bufferView", a.bufferView))
        : r.push(null),
      a.sparse !== void 0 &&
        (r.push(this.getDependency("bufferView", a.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", a.sparse.values.bufferView))),
      Promise.all(r).then(function (l) {
        const u = l[0],
          h = hb[a.type],
          p = Hd[a.componentType],
          m = p.BYTES_PER_ELEMENT,
          v = m * h,
          x = a.byteOffset || 0,
          _ =
            a.bufferView !== void 0
              ? n.bufferViews[a.bufferView].byteStride
              : void 0,
          M = a.normalized === !0;
        let C, E;
        if (_ && _ !== v) {
          const S = Math.floor(x / _),
            R =
              "InterleavedBuffer:" +
              a.bufferView +
              ":" +
              a.componentType +
              ":" +
              S +
              ":" +
              a.count;
          let B = e.cache.get(R);
          B ||
            ((C = new p(u, S * _, (a.count * _) / m)),
            (B = new L0(C, _ / m)),
            e.cache.add(R, B)),
            (E = new hu(B, h, (x % _) / m, M));
        } else u === null ? (C = new p(a.count * h)) : (C = new p(u, x, a.count * h)), (E = new Gn(C, h, M));
        if (a.sparse !== void 0) {
          const S = hb.SCALAR,
            R = Hd[a.sparse.indices.componentType],
            B = a.sparse.indices.byteOffset || 0,
            D = a.sparse.values.byteOffset || 0,
            I = new R(l[1], B, a.sparse.count * S),
            P = new p(l[2], D, a.sparse.count * h);
          u !== null && (E = new Gn(E.array.slice(), E.itemSize, E.normalized));
          for (let V = 0, F = I.length; V < F; V++) {
            const N = I[V];
            if (
              (E.setX(N, P[V * h]),
              h >= 2 && E.setY(N, P[V * h + 1]),
              h >= 3 && E.setZ(N, P[V * h + 2]),
              h >= 4 && E.setW(N, P[V * h + 3]),
              h >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return E;
      })
    );
  }
  loadTexture(t) {
    const e = this.json,
      n = this.options,
      r = e.textures[t].source,
      l = e.images[r];
    let u = this.textureLoader;
    if (l.uri) {
      const h = n.manager.getHandler(l.uri);
      h !== null && (u = h);
    }
    return this.loadTextureImage(t, r, u);
  }
  loadTextureImage(t, e, n) {
    const a = this,
      r = this.json,
      l = r.textures[t],
      u = r.images[e],
      h = (u.uri || u.bufferView) + ":" + l.sampler;
    if (this.textureCache[h]) return this.textureCache[h];
    const p = this.loadImageSource(e, n)
      .then(function (m) {
        (m.flipY = !1),
          (m.name = l.name || u.name || ""),
          m.name === "" &&
            typeof u.uri == "string" &&
            u.uri.startsWith("data:image/") === !1 &&
            (m.name = u.uri);
        const x = (r.samplers || {})[l.sampler] || {};
        return (
          (m.magFilter = yw[x.magFilter] || Kn),
          (m.minFilter = yw[x.minFilter] || Nr),
          (m.wrapS = xw[x.wrapS] || fu),
          (m.wrapT = xw[x.wrapT] || fu),
          a.associations.set(m, { textures: t }),
          m
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[h] = p), p;
  }
  loadImageSource(t, e) {
    const n = this,
      a = this.json,
      r = this.options;
    if (this.sourceCache[t] !== void 0)
      return this.sourceCache[t].then((v) => v.clone());
    const l = a.images[t],
      u = self.URL || self.webkitURL;
    let h = l.uri || "",
      p = !1;
    if (l.bufferView !== void 0)
      h = n.getDependency("bufferView", l.bufferView).then(function (v) {
        p = !0;
        const x = new Blob([v], { type: l.mimeType });
        return (h = u.createObjectURL(x)), h;
      });
    else if (l.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + t + " is missing URI and bufferView"
      );
    const m = Promise.resolve(h)
      .then(function (v) {
        return new Promise(function (x, _) {
          let M = x;
          e.isImageBitmapLoader === !0 &&
            (M = function (C) {
              const E = new Zn(C);
              (E.needsUpdate = !0), x(E);
            }),
            e.load(lu.resolveURL(v, r.path), M, void 0, _);
        });
      })
      .then(function (v) {
        return (
          p === !0 && u.revokeObjectURL(h),
          Wl(v, l),
          (v.userData.mimeType = l.mimeType || C8(l.uri)),
          v
        );
      })
      .catch(function (v) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", h), v);
      });
    return (this.sourceCache[t] = m), m;
  }
  assignTexture(t, e, n, a) {
    const r = this;
    return this.getDependency("texture", n.index).then(function (l) {
      if (!l) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((l = l.clone()), (l.channel = n.texCoord)),
        r.extensions[Bn.KHR_TEXTURE_TRANSFORM])
      ) {
        const u =
          n.extensions !== void 0
            ? n.extensions[Bn.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (u) {
          const h = r.associations.get(l);
          (l = r.extensions[Bn.KHR_TEXTURE_TRANSFORM].extendTexture(l, u)),
            r.associations.set(l, h);
        }
      }
      return (
        a !== void 0 &&
          (typeof a == "number" && (a = a === gw ? Vf : $l),
          "colorSpace" in l
            ? (l.colorSpace = a)
            : (l.encoding = a === Vf ? gw : ZF)),
        (t[e] = l),
        l
      );
    });
  }
  assignFinalMaterial(t) {
    const e = t.geometry;
    let n = t.material;
    const a = e.attributes.tangent === void 0,
      r = e.attributes.color !== void 0,
      l = e.attributes.normal === void 0;
    if (t.isPoints) {
      const u = "PointsMaterial:" + n.uuid;
      let h = this.cache.get(u);
      h ||
        ((h = new qx()),
        ma.prototype.copy.call(h, n),
        h.color.copy(n.color),
        (h.map = n.map),
        (h.sizeAttenuation = !1),
        this.cache.add(u, h)),
        (n = h);
    } else if (t.isLine) {
      const u = "LineBasicMaterial:" + n.uuid;
      let h = this.cache.get(u);
      h ||
        ((h = new is()),
        ma.prototype.copy.call(h, n),
        h.color.copy(n.color),
        (h.map = n.map),
        this.cache.add(u, h)),
        (n = h);
    }
    if (a || r || l) {
      let u = "ClonedMaterial:" + n.uuid + ":";
      a && (u += "derivative-tangents:"),
        r && (u += "vertex-colors:"),
        l && (u += "flat-shading:");
      let h = this.cache.get(u);
      h ||
        ((h = n.clone()),
        r && (h.vertexColors = !0),
        l && (h.flatShading = !0),
        a &&
          (h.normalScale && (h.normalScale.y *= -1),
          h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)),
        this.cache.add(u, h),
        this.associations.set(h, this.associations.get(n))),
        (n = h);
    }
    t.material = n;
  }
  getMaterialType() {
    return V0;
  }
  loadMaterial(t) {
    const e = this,
      n = this.json,
      a = this.extensions,
      r = n.materials[t];
    let l;
    const u = {},
      h = r.extensions || {},
      p = [];
    if (h[Bn.KHR_MATERIALS_UNLIT]) {
      const v = a[Bn.KHR_MATERIALS_UNLIT];
      (l = v.getMaterialType()), p.push(v.extendParams(u, r, e));
    } else {
      const v = r.pbrMetallicRoughness || {};
      if (
        ((u.color = new Se(1, 1, 1)),
        (u.opacity = 1),
        Array.isArray(v.baseColorFactor))
      ) {
        const x = v.baseColorFactor;
        u.color.setRGB(x[0], x[1], x[2], $l), (u.opacity = x[3]);
      }
      v.baseColorTexture !== void 0 &&
        p.push(e.assignTexture(u, "map", v.baseColorTexture, Vf)),
        (u.metalness = v.metallicFactor !== void 0 ? v.metallicFactor : 1),
        (u.roughness = v.roughnessFactor !== void 0 ? v.roughnessFactor : 1),
        v.metallicRoughnessTexture !== void 0 &&
          (p.push(
            e.assignTexture(u, "metalnessMap", v.metallicRoughnessTexture)
          ),
          p.push(
            e.assignTexture(u, "roughnessMap", v.metallicRoughnessTexture)
          )),
        (l = this._invokeOne(function (x) {
          return x.getMaterialType && x.getMaterialType(t);
        })),
        p.push(
          Promise.all(
            this._invokeAll(function (x) {
              return x.extendMaterialParams && x.extendMaterialParams(t, u);
            })
          )
        );
    }
    r.doubleSided === !0 && (u.side = or);
    const m = r.alphaMode || db.OPAQUE;
    if (
      (m === db.BLEND
        ? ((u.transparent = !0), (u.depthWrite = !1))
        : ((u.transparent = !1),
          m === db.MASK &&
            (u.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
      r.normalTexture !== void 0 &&
        l !== ks &&
        (p.push(e.assignTexture(u, "normalMap", r.normalTexture)),
        (u.normalScale = new Yt(1, 1)),
        r.normalTexture.scale !== void 0))
    ) {
      const v = r.normalTexture.scale;
      u.normalScale.set(v, v);
    }
    if (
      (r.occlusionTexture !== void 0 &&
        l !== ks &&
        (p.push(e.assignTexture(u, "aoMap", r.occlusionTexture)),
        r.occlusionTexture.strength !== void 0 &&
          (u.aoMapIntensity = r.occlusionTexture.strength)),
      r.emissiveFactor !== void 0 && l !== ks)
    ) {
      const v = r.emissiveFactor;
      u.emissive = new Se().setRGB(v[0], v[1], v[2], $l);
    }
    return (
      r.emissiveTexture !== void 0 &&
        l !== ks &&
        p.push(e.assignTexture(u, "emissiveMap", r.emissiveTexture, Vf)),
      Promise.all(p).then(function () {
        const v = new l(u);
        return (
          r.name && (v.name = r.name),
          Wl(v, r),
          e.associations.set(v, { materials: t }),
          r.extensions && Cf(a, v, r),
          v
        );
      })
    );
  }
  createUniqueName(t) {
    const e = Fn.sanitizeNodeName(t || "");
    return e in this.nodeNamesUsed
      ? e + "_" + ++this.nodeNamesUsed[e]
      : ((this.nodeNamesUsed[e] = 0), e);
  }
  loadGeometries(t) {
    const e = this,
      n = this.extensions,
      a = this.primitiveCache;
    function r(u) {
      return n[Bn.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(u, e)
        .then(function (h) {
          return _w(h, u, e);
        });
    }
    const l = [];
    for (let u = 0, h = t.length; u < h; u++) {
      const p = t[u],
        m = w8(p),
        v = a[m];
      if (v) l.push(v.promise);
      else {
        let x;
        p.extensions && p.extensions[Bn.KHR_DRACO_MESH_COMPRESSION]
          ? (x = r(p))
          : (x = _w(new pn(), p, e)),
          (a[m] = { primitive: p, promise: x }),
          l.push(x);
      }
    }
    return Promise.all(l);
  }
  loadMesh(t) {
    const e = this,
      n = this.json,
      a = this.extensions,
      r = n.meshes[t],
      l = r.primitives,
      u = [];
    for (let h = 0, p = l.length; h < p; h++) {
      const m =
        l[h].material === void 0
          ? M8(this.cache)
          : this.getDependency("material", l[h].material);
      u.push(m);
    }
    return (
      u.push(e.loadGeometries(l)),
      Promise.all(u).then(function (h) {
        const p = h.slice(0, h.length - 1),
          m = h[h.length - 1],
          v = [];
        for (let _ = 0, M = m.length; _ < M; _++) {
          const C = m[_],
            E = l[_];
          let S;
          const R = p[_];
          if (
            E.mode === Ur.TRIANGLES ||
            E.mode === Ur.TRIANGLE_STRIP ||
            E.mode === Ur.TRIANGLE_FAN ||
            E.mode === void 0
          )
            (S = r.isSkinnedMesh === !0 ? new WA(C, R) : new Ti(C, R)),
              S.isSkinnedMesh === !0 && S.normalizeSkinWeights(),
              E.mode === Ur.TRIANGLE_STRIP
                ? (S.geometry = dw(S.geometry, zA))
                : E.mode === Ur.TRIANGLE_FAN &&
                  (S.geometry = dw(S.geometry, mx));
          else if (E.mode === Ur.LINES) S = new Ao(C, R);
          else if (E.mode === Ur.LINE_STRIP) S = new tc(C, R);
          else if (E.mode === Ur.LINE_LOOP) S = new qA(C, R);
          else if (E.mode === Ur.POINTS) S = new KA(C, R);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + E.mode
            );
          Object.keys(S.geometry.morphAttributes).length > 0 && T8(S, r),
            (S.name = e.createUniqueName(r.name || "mesh_" + t)),
            Wl(S, r),
            E.extensions && Cf(a, S, E),
            e.assignFinalMaterial(S),
            v.push(S);
        }
        for (let _ = 0, M = v.length; _ < M; _++)
          e.associations.set(v[_], { meshes: t, primitives: _ });
        if (v.length === 1) return r.extensions && Cf(a, v[0], r), v[0];
        const x = new Jl();
        r.extensions && Cf(a, x, r), e.associations.set(x, { meshes: t });
        for (let _ = 0, M = v.length; _ < M; _++) x.add(v[_]);
        return x;
      })
    );
  }
  loadCamera(t) {
    let e;
    const n = this.json.cameras[t],
      a = n[n.type];
    if (!a) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (e = new Ei(
            NC.radToDeg(a.yfov),
            a.aspectRatio || 1,
            a.znear || 1,
            a.zfar || 2e6
          ))
        : n.type === "orthographic" &&
          (e = new Ir(-a.xmag, a.xmag, a.ymag, -a.ymag, a.znear, a.zfar)),
      n.name && (e.name = this.createUniqueName(n.name)),
      Wl(e, n),
      Promise.resolve(e)
    );
  }
  loadSkin(t) {
    const e = this.json.skins[t],
      n = [];
    for (let a = 0, r = e.joints.length; a < r; a++)
      n.push(this._loadNodeShallow(e.joints[a]));
    return (
      e.inverseBindMatrices !== void 0
        ? n.push(this.getDependency("accessor", e.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (a) {
        const r = a.pop(),
          l = a,
          u = [],
          h = [];
        for (let p = 0, m = l.length; p < m; p++) {
          const v = l[p];
          if (v) {
            u.push(v);
            const x = new Xe();
            r !== null && x.fromArray(r.array, p * 16), h.push(x);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              e.joints[p]
            );
        }
        return new I0(u, h);
      })
    );
  }
  loadAnimation(t) {
    const e = this.json,
      n = this,
      a = e.animations[t],
      r = a.name ? a.name : "animation_" + t,
      l = [],
      u = [],
      h = [],
      p = [],
      m = [];
    for (let v = 0, x = a.channels.length; v < x; v++) {
      const _ = a.channels[v],
        M = a.samplers[_.sampler],
        C = _.target,
        E = C.node,
        S = a.parameters !== void 0 ? a.parameters[M.input] : M.input,
        R = a.parameters !== void 0 ? a.parameters[M.output] : M.output;
      C.node !== void 0 &&
        (l.push(this.getDependency("node", E)),
        u.push(this.getDependency("accessor", S)),
        h.push(this.getDependency("accessor", R)),
        p.push(M),
        m.push(C));
    }
    return Promise.all([
      Promise.all(l),
      Promise.all(u),
      Promise.all(h),
      Promise.all(p),
      Promise.all(m),
    ]).then(function (v) {
      const x = v[0],
        _ = v[1],
        M = v[2],
        C = v[3],
        E = v[4],
        S = [];
      for (let R = 0, B = x.length; R < B; R++) {
        const D = x[R],
          I = _[R],
          P = M[R],
          V = C[R],
          F = E[R];
        if (D === void 0) continue;
        D.updateMatrix && D.updateMatrix();
        const N = n._createAnimationTracks(D, I, P, V, F);
        if (N) for (let L = 0; L < N.length; L++) S.push(N[L]);
      }
      return new th(r, void 0, S);
    });
  }
  createNodeMesh(t) {
    const e = this.json,
      n = this,
      a = e.nodes[t];
    return a.mesh === void 0
      ? null
      : n.getDependency("mesh", a.mesh).then(function (r) {
          const l = n._getNodeRef(n.meshCache, a.mesh, r);
          return (
            a.weights !== void 0 &&
              l.traverse(function (u) {
                if (u.isMesh)
                  for (let h = 0, p = a.weights.length; h < p; h++)
                    u.morphTargetInfluences[h] = a.weights[h];
              }),
            l
          );
        });
  }
  loadNode(t) {
    const e = this.json,
      n = this,
      a = e.nodes[t],
      r = n._loadNodeShallow(t),
      l = [],
      u = a.children || [];
    for (let p = 0, m = u.length; p < m; p++)
      l.push(n.getDependency("node", u[p]));
    const h =
      a.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency("skin", a.skin);
    return Promise.all([r, Promise.all(l), h]).then(function (p) {
      const m = p[0],
        v = p[1],
        x = p[2];
      x !== null &&
        m.traverse(function (_) {
          _.isSkinnedMesh && _.bind(x, R8);
        });
      for (let _ = 0, M = v.length; _ < M; _++) m.add(v[_]);
      return m;
    });
  }
  _loadNodeShallow(t) {
    const e = this.json,
      n = this.extensions,
      a = this;
    if (this.nodeCache[t] !== void 0) return this.nodeCache[t];
    const r = e.nodes[t],
      l = r.name ? a.createUniqueName(r.name) : "",
      u = [],
      h = a._invokeOne(function (p) {
        return p.createNodeMesh && p.createNodeMesh(t);
      });
    return (
      h && u.push(h),
      r.camera !== void 0 &&
        u.push(
          a.getDependency("camera", r.camera).then(function (p) {
            return a._getNodeRef(a.cameraCache, r.camera, p);
          })
        ),
      a
        ._invokeAll(function (p) {
          return p.createNodeAttachment && p.createNodeAttachment(t);
        })
        .forEach(function (p) {
          u.push(p);
        }),
      (this.nodeCache[t] = Promise.all(u).then(function (p) {
        let m;
        if (
          (r.isBone === !0
            ? (m = new Wx())
            : p.length > 1
            ? (m = new Jl())
            : p.length === 1
            ? (m = p[0])
            : (m = new Dn()),
          m !== p[0])
        )
          for (let v = 0, x = p.length; v < x; v++) m.add(p[v]);
        if (
          (r.name && ((m.userData.name = r.name), (m.name = l)),
          Wl(m, r),
          r.extensions && Cf(n, m, r),
          r.matrix !== void 0)
        ) {
          const v = new Xe();
          v.fromArray(r.matrix), m.applyMatrix4(v);
        } else r.translation !== void 0 && m.position.fromArray(r.translation), r.rotation !== void 0 && m.quaternion.fromArray(r.rotation), r.scale !== void 0 && m.scale.fromArray(r.scale);
        return (
          a.associations.has(m) || a.associations.set(m, {}),
          (a.associations.get(m).nodes = t),
          m
        );
      })),
      this.nodeCache[t]
    );
  }
  loadScene(t) {
    const e = this.extensions,
      n = this.json.scenes[t],
      a = this,
      r = new Jl();
    n.name && (r.name = a.createUniqueName(n.name)),
      Wl(r, n),
      n.extensions && Cf(e, r, n);
    const l = n.nodes || [],
      u = [];
    for (let h = 0, p = l.length; h < p; h++)
      u.push(a.getDependency("node", l[h]));
    return Promise.all(u).then(function (h) {
      for (let m = 0, v = h.length; m < v; m++) r.add(h[m]);
      const p = (m) => {
        const v = new Map();
        for (const [x, _] of a.associations)
          (x instanceof ma || x instanceof Zn) && v.set(x, _);
        return (
          m.traverse((x) => {
            const _ = a.associations.get(x);
            _ != null && v.set(x, _);
          }),
          v
        );
      };
      return (a.associations = p(r)), r;
    });
  }
  _createAnimationTracks(t, e, n, a, r) {
    const l = [],
      u = t.name ? t.name : t.uuid,
      h = [];
    iu[r.path] === iu.weights
      ? t.traverse(function (x) {
          x.morphTargetInfluences && h.push(x.name ? x.name : x.uuid);
        })
      : h.push(u);
    let p;
    switch (iu[r.path]) {
      case iu.weights:
        p = $f;
        break;
      case iu.rotation:
        p = du;
        break;
      case iu.position:
      case iu.scale:
        p = pu;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            p = $f;
            break;
          case 2:
          case 3:
          default:
            p = pu;
            break;
        }
        break;
    }
    const m = a.interpolation !== void 0 ? S8[a.interpolation] : Kd,
      v = this._getArrayFromAccessor(n);
    for (let x = 0, _ = h.length; x < _; x++) {
      const M = new p(h[x] + "." + iu[r.path], e.array, v, m);
      a.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(M),
        l.push(M);
    }
    return l;
  }
  _getArrayFromAccessor(t) {
    let e = t.array;
    if (t.normalized) {
      const n = rA(e.constructor),
        a = new Float32Array(e.length);
      for (let r = 0, l = e.length; r < l; r++) a[r] = e[r] * n;
      e = a;
    }
    return e;
  }
  _createCubicSplineTrackInterpolant(t) {
    (t.createInterpolant = function (n) {
      const a = this instanceof du ? A8 : xB;
      return new a(this.times, this.values, this.getValueSize() / 3, n);
    }),
      (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function D8(i, t, e) {
  const n = t.attributes,
    a = new Ha();
  if (n.POSITION !== void 0) {
    const u = e.json.accessors[n.POSITION],
      h = u.min,
      p = u.max;
    if (h !== void 0 && p !== void 0) {
      if (
        (a.set(new Z(h[0], h[1], h[2]), new Z(p[0], p[1], p[2])), u.normalized)
      ) {
        const m = rA(Hd[u.componentType]);
        a.min.multiplyScalar(m), a.max.multiplyScalar(m);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const r = t.targets;
  if (r !== void 0) {
    const u = new Z(),
      h = new Z();
    for (let p = 0, m = r.length; p < m; p++) {
      const v = r[p];
      if (v.POSITION !== void 0) {
        const x = e.json.accessors[v.POSITION],
          _ = x.min,
          M = x.max;
        if (_ !== void 0 && M !== void 0) {
          if (
            (h.setX(Math.max(Math.abs(_[0]), Math.abs(M[0]))),
            h.setY(Math.max(Math.abs(_[1]), Math.abs(M[1]))),
            h.setZ(Math.max(Math.abs(_[2]), Math.abs(M[2]))),
            x.normalized)
          ) {
            const C = rA(Hd[x.componentType]);
            h.multiplyScalar(C);
          }
          u.max(h);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    a.expandByVector(u);
  }
  i.boundingBox = a;
  const l = new wa();
  a.getCenter(l.center),
    (l.radius = a.min.distanceTo(a.max) / 2),
    (i.boundingSphere = l);
}
function _w(i, t, e) {
  const n = t.attributes,
    a = [];
  function r(l, u) {
    return e.getDependency("accessor", l).then(function (h) {
      i.setAttribute(u, h);
    });
  }
  for (const l in n) {
    const u = sA[l] || l.toLowerCase();
    u in i.attributes || a.push(r(n[l], u));
  }
  if (t.indices !== void 0 && !i.index) {
    const l = e.getDependency("accessor", t.indices).then(function (u) {
      i.setIndex(u);
    });
    a.push(l);
  }
  return (
    Wl(i, t),
    D8(i, t, e),
    Promise.all(a).then(function () {
      return t.targets !== void 0 ? E8(i, t.targets, e) : i;
    })
  );
}
class U8 extends lS {
  constructor(t) {
    super(t), (this.type = Ea);
  }
  parse(t) {
    const l = function (F, N) {
        switch (F) {
          case 1:
            throw new Error("THREE.RGBELoader: Read Error: " + (N || ""));
          case 2:
            throw new Error("THREE.RGBELoader: Write Error: " + (N || ""));
          case 3:
            throw new Error("THREE.RGBELoader: Bad File Format: " + (N || ""));
          default:
          case 4:
            throw new Error("THREE.RGBELoader: Memory Error: " + (N || ""));
        }
      },
      m = `
`,
      v = function (F, N, L) {
        N = N || 1024;
        let ct = F.pos,
          nt = -1,
          dt = 0,
          pt = "",
          j = String.fromCharCode.apply(
            null,
            new Uint16Array(F.subarray(ct, ct + 128))
          );
        for (; 0 > (nt = j.indexOf(m)) && dt < N && ct < F.byteLength; )
          (pt += j),
            (dt += j.length),
            (ct += 128),
            (j += String.fromCharCode.apply(
              null,
              new Uint16Array(F.subarray(ct, ct + 128))
            ));
        return -1 < nt ? ((F.pos += dt + nt + 1), pt + j.slice(0, nt)) : !1;
      },
      x = function (F) {
        const N = /^#\?(\S+)/,
          L = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          Y = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          ct = /^\s*FORMAT=(\S+)\s*$/,
          nt = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          dt = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let pt, j;
        for (
          (F.pos >= F.byteLength || !(pt = v(F))) && l(1, "no header found"),
            (j = pt.match(N)) || l(3, "bad initial token"),
            dt.valid |= 1,
            dt.programtype = j[1],
            dt.string +=
              pt +
              `
`;
          (pt = v(F)), pt !== !1;

        ) {
          if (
            ((dt.string +=
              pt +
              `
`),
            pt.charAt(0) === "#")
          ) {
            dt.comments +=
              pt +
              `
`;
            continue;
          }
          if (
            ((j = pt.match(L)) && (dt.gamma = parseFloat(j[1])),
            (j = pt.match(Y)) && (dt.exposure = parseFloat(j[1])),
            (j = pt.match(ct)) && ((dt.valid |= 2), (dt.format = j[1])),
            (j = pt.match(nt)) &&
              ((dt.valid |= 4),
              (dt.height = parseInt(j[1], 10)),
              (dt.width = parseInt(j[2], 10))),
            dt.valid & 2 && dt.valid & 4)
          )
            break;
        }
        return (
          dt.valid & 2 || l(3, "missing format specifier"),
          dt.valid & 4 || l(3, "missing image size specifier"),
          dt
        );
      },
      _ = function (F, N, L) {
        const Y = N;
        if (Y < 8 || Y > 32767 || F[0] !== 2 || F[1] !== 2 || F[2] & 128)
          return new Uint8Array(F);
        Y !== ((F[2] << 8) | F[3]) && l(3, "wrong scanline width");
        const ct = new Uint8Array(4 * N * L);
        ct.length || l(4, "unable to allocate buffer space");
        let nt = 0,
          dt = 0;
        const pt = 4 * Y,
          j = new Uint8Array(4),
          Q = new Uint8Array(pt);
        let et = L;
        for (; et > 0 && dt < F.byteLength; ) {
          dt + 4 > F.byteLength && l(1),
            (j[0] = F[dt++]),
            (j[1] = F[dt++]),
            (j[2] = F[dt++]),
            (j[3] = F[dt++]),
            (j[0] != 2 || j[1] != 2 || ((j[2] << 8) | j[3]) != Y) &&
              l(3, "bad rgbe scanline format");
          let xt = 0,
            X;
          for (; xt < pt && dt < F.byteLength; ) {
            X = F[dt++];
            const At = X > 128;
            if (
              (At && (X -= 128),
              (X === 0 || xt + X > pt) && l(3, "bad scanline data"),
              At)
            ) {
              const Rt = F[dt++];
              for (let ht = 0; ht < X; ht++) Q[xt++] = Rt;
            } else Q.set(F.subarray(dt, dt + X), xt), (xt += X), (dt += X);
          }
          const ft = Y;
          for (let At = 0; At < ft; At++) {
            let Rt = 0;
            (ct[nt] = Q[At + Rt]),
              (Rt += Y),
              (ct[nt + 1] = Q[At + Rt]),
              (Rt += Y),
              (ct[nt + 2] = Q[At + Rt]),
              (Rt += Y),
              (ct[nt + 3] = Q[At + Rt]),
              (nt += 4);
          }
          et--;
        }
        return ct;
      },
      M = function (F, N, L, Y) {
        const ct = F[N + 3],
          nt = Math.pow(2, ct - 128) / 255;
        (L[Y + 0] = F[N + 0] * nt),
          (L[Y + 1] = F[N + 1] * nt),
          (L[Y + 2] = F[N + 2] * nt),
          (L[Y + 3] = 1);
      },
      C = function (F, N, L, Y) {
        const ct = F[N + 3],
          nt = Math.pow(2, ct - 128) / 255;
        (L[Y + 0] = Ff.toHalfFloat(Math.min(F[N + 0] * nt, 65504))),
          (L[Y + 1] = Ff.toHalfFloat(Math.min(F[N + 1] * nt, 65504))),
          (L[Y + 2] = Ff.toHalfFloat(Math.min(F[N + 2] * nt, 65504))),
          (L[Y + 3] = Ff.toHalfFloat(1));
      },
      E = new Uint8Array(t);
    E.pos = 0;
    const S = x(E),
      R = S.width,
      B = S.height,
      D = _(E.subarray(E.pos), R, B);
    let I, P, V;
    switch (this.type) {
      case Pi:
        V = D.length / 4;
        const F = new Float32Array(V * 4);
        for (let L = 0; L < V; L++) M(D, L * 4, F, L * 4);
        (I = F), (P = Pi);
        break;
      case Ea:
        V = D.length / 4;
        const N = new Uint16Array(V * 4);
        for (let L = 0; L < V; L++) C(D, L * 4, N, L * 4);
        (I = N), (P = Ea);
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: R,
      height: B,
      data: I,
      header: S.string,
      gamma: S.gamma,
      exposure: S.exposure,
      type: P,
    };
  }
  setDataType(t) {
    return (this.type = t), this;
  }
  load(t, e, n, a) {
    function r(l, u) {
      switch (l.type) {
        case Pi:
        case Ea:
          "colorSpace" in l
            ? (l.colorSpace = "srgb-linear")
            : (l.encoding = 3e3),
            (l.minFilter = Kn),
            (l.magFilter = Kn),
            (l.generateMipmaps = !1),
            (l.flipY = !0);
          break;
      }
      e && e(l, u);
    }
    return super.load(t, r, n, a);
  }
}
const Fm = BS >= 152;
class O8 extends lS {
  constructor(t) {
    super(t), (this.type = Ea);
  }
  parse(t) {
    const N = Math.pow(2.7182818, 2.2);
    function L(G, K) {
      for (var ut = 0, Bt = 0; Bt < 65536; ++Bt)
        (Bt == 0 || G[Bt >> 3] & (1 << (Bt & 7))) && (K[ut++] = Bt);
      for (var Ut = ut - 1; ut < 65536; ) K[ut++] = 0;
      return Ut;
    }
    function Y(G) {
      for (var K = 0; K < 16384; K++)
        (G[K] = {}), (G[K].len = 0), (G[K].lit = 0), (G[K].p = null);
    }
    const ct = { l: 0, c: 0, lc: 0 };
    function nt(G, K, ut, Bt, Ut) {
      for (; ut < G; ) (K = (K << 8) | Re(Bt, Ut)), (ut += 8);
      (ut -= G), (ct.l = (K >> ut) & ((1 << G) - 1)), (ct.c = K), (ct.lc = ut);
    }
    const dt = new Array(59);
    function pt(G) {
      for (var K = 0; K <= 58; ++K) dt[K] = 0;
      for (var K = 0; K < 65537; ++K) dt[G[K]] += 1;
      for (var ut = 0, K = 58; K > 0; --K) {
        var Bt = (ut + dt[K]) >> 1;
        (dt[K] = ut), (ut = Bt);
      }
      for (var K = 0; K < 65537; ++K) {
        var Ut = G[K];
        Ut > 0 && (G[K] = Ut | (dt[Ut]++ << 6));
      }
    }
    function j(G, K, ut, Bt, Ut, Ht, ue) {
      for (var ae = ut, H = 0, tt = 0; Ut <= Ht; Ut++) {
        if (ae.value - ut.value > Bt) return !1;
        nt(6, H, tt, G, ae);
        var rt = ct.l;
        if (((H = ct.c), (tt = ct.lc), (ue[Ut] = rt), rt == 63)) {
          if (ae.value - ut.value > Bt)
            throw "Something wrong with hufUnpackEncTable";
          nt(8, H, tt, G, ae);
          var ot = ct.l + 6;
          if (((H = ct.c), (tt = ct.lc), Ut + ot > Ht + 1))
            throw "Something wrong with hufUnpackEncTable";
          for (; ot--; ) ue[Ut++] = 0;
          Ut--;
        } else if (rt >= 59) {
          var ot = rt - 59 + 2;
          if (Ut + ot > Ht + 1) throw "Something wrong with hufUnpackEncTable";
          for (; ot--; ) ue[Ut++] = 0;
          Ut--;
        }
      }
      pt(ue);
    }
    function Q(G) {
      return G & 63;
    }
    function et(G) {
      return G >> 6;
    }
    function xt(G, K, ut, Bt) {
      for (; K <= ut; K++) {
        var Ut = et(G[K]),
          Ht = Q(G[K]);
        if (Ut >> Ht) throw "Invalid table entry";
        if (Ht > 14) {
          var ue = Bt[Ut >> (Ht - 14)];
          if (ue.len) throw "Invalid table entry";
          if ((ue.lit++, ue.p)) {
            var ae = ue.p;
            ue.p = new Array(ue.lit);
            for (var H = 0; H < ue.lit - 1; ++H) ue.p[H] = ae[H];
          } else ue.p = new Array(1);
          ue.p[ue.lit - 1] = K;
        } else if (Ht)
          for (var tt = 0, H = 1 << (14 - Ht); H > 0; H--) {
            var ue = Bt[(Ut << (14 - Ht)) + tt];
            if (ue.len || ue.p) throw "Invalid table entry";
            (ue.len = Ht), (ue.lit = K), tt++;
          }
      }
      return !0;
    }
    const X = { c: 0, lc: 0 };
    function ft(G, K, ut, Bt) {
      (G = (G << 8) | Re(ut, Bt)), (K += 8), (X.c = G), (X.lc = K);
    }
    const At = { c: 0, lc: 0 };
    function Rt(G, K, ut, Bt, Ut, Ht, ue, ae, H, tt) {
      if (G == K) {
        Bt < 8 && (ft(ut, Bt, Ut, ue), (ut = X.c), (Bt = X.lc)), (Bt -= 8);
        var rt = ut >> Bt,
          rt = new Uint8Array([rt])[0];
        if (H.value + rt > tt) return !1;
        for (var ot = ae[H.value - 1]; rt-- > 0; ) ae[H.value++] = ot;
      } else if (H.value < tt) ae[H.value++] = G;
      else return !1;
      (At.c = ut), (At.lc = Bt);
    }
    function ht(G) {
      return G & 65535;
    }
    function It(G) {
      var K = ht(G);
      return K > 32767 ? K - 65536 : K;
    }
    const Pt = { a: 0, b: 0 };
    function re(G, K) {
      var ut = It(G),
        Bt = It(K),
        Ut = Bt,
        Ht = ut + (Ut & 1) + (Ut >> 1),
        ue = Ht,
        ae = Ht - Ut;
      (Pt.a = ue), (Pt.b = ae);
    }
    function ie(G, K) {
      var ut = ht(G),
        Bt = ht(K),
        Ut = (ut - (Bt >> 1)) & 65535,
        Ht = (Bt + Ut - 32768) & 65535;
      (Pt.a = Ht), (Pt.b = Ut);
    }
    function Fe(G, K, ut, Bt, Ut, Ht, ue) {
      for (var ae = ue < 16384, H = ut > Ut ? Ut : ut, tt = 1, rt; tt <= H; )
        tt <<= 1;
      for (tt >>= 1, rt = tt, tt >>= 1; tt >= 1; ) {
        for (
          var ot = 0,
            gt = ot + Ht * (Ut - rt),
            wt = Ht * tt,
            Vt = Ht * rt,
            Jt = Bt * tt,
            ee = Bt * rt,
            xe,
            ve,
            _e,
            He;
          ot <= gt;
          ot += Vt
        ) {
          for (var ze = ot, Mn = ot + Bt * (ut - rt); ze <= Mn; ze += ee) {
            var Oe = ze + Jt,
              Ve = ze + wt,
              Ne = Ve + Jt;
            ae
              ? (re(G[ze + K], G[Ve + K]),
                (xe = Pt.a),
                (_e = Pt.b),
                re(G[Oe + K], G[Ne + K]),
                (ve = Pt.a),
                (He = Pt.b),
                re(xe, ve),
                (G[ze + K] = Pt.a),
                (G[Oe + K] = Pt.b),
                re(_e, He),
                (G[Ve + K] = Pt.a),
                (G[Ne + K] = Pt.b))
              : (ie(G[ze + K], G[Ve + K]),
                (xe = Pt.a),
                (_e = Pt.b),
                ie(G[Oe + K], G[Ne + K]),
                (ve = Pt.a),
                (He = Pt.b),
                ie(xe, ve),
                (G[ze + K] = Pt.a),
                (G[Oe + K] = Pt.b),
                ie(_e, He),
                (G[Ve + K] = Pt.a),
                (G[Ne + K] = Pt.b));
          }
          if (ut & tt) {
            var Ve = ze + wt;
            ae ? re(G[ze + K], G[Ve + K]) : ie(G[ze + K], G[Ve + K]),
              (xe = Pt.a),
              (G[Ve + K] = Pt.b),
              (G[ze + K] = xe);
          }
        }
        if (Ut & tt)
          for (var ze = ot, Mn = ot + Bt * (ut - rt); ze <= Mn; ze += ee) {
            var Oe = ze + Jt;
            ae ? re(G[ze + K], G[Oe + K]) : ie(G[ze + K], G[Oe + K]),
              (xe = Pt.a),
              (G[Oe + K] = Pt.b),
              (G[ze + K] = xe);
          }
        (rt = tt), (tt >>= 1);
      }
      return ot;
    }
    function Ae(G, K, ut, Bt, Ut, Ht, ue, ae, H, tt) {
      for (
        var rt = 0, ot = 0, gt = ae, wt = Math.trunc(Ut.value + (Ht + 7) / 8);
        Ut.value < wt;

      )
        for (ft(rt, ot, ut, Ut), rt = X.c, ot = X.lc; ot >= 14; ) {
          var Vt = (rt >> (ot - 14)) & 16383,
            Jt = K[Vt];
          if (Jt.len)
            (ot -= Jt.len),
              Rt(Jt.lit, ue, rt, ot, ut, Bt, Ut, H, tt, gt),
              (rt = At.c),
              (ot = At.lc);
          else {
            if (!Jt.p) throw "hufDecode issues";
            var ee;
            for (ee = 0; ee < Jt.lit; ee++) {
              for (var xe = Q(G[Jt.p[ee]]); ot < xe && Ut.value < wt; )
                ft(rt, ot, ut, Ut), (rt = X.c), (ot = X.lc);
              if (
                ot >= xe &&
                et(G[Jt.p[ee]]) == ((rt >> (ot - xe)) & ((1 << xe) - 1))
              ) {
                (ot -= xe),
                  Rt(Jt.p[ee], ue, rt, ot, ut, Bt, Ut, H, tt, gt),
                  (rt = At.c),
                  (ot = At.lc);
                break;
              }
            }
            if (ee == Jt.lit) throw "hufDecode issues";
          }
        }
      var ve = (8 - Ht) & 7;
      for (rt >>= ve, ot -= ve; ot > 0; ) {
        var Jt = K[(rt << (14 - ot)) & 16383];
        if (Jt.len)
          (ot -= Jt.len),
            Rt(Jt.lit, ue, rt, ot, ut, Bt, Ut, H, tt, gt),
            (rt = At.c),
            (ot = At.lc);
        else throw "hufDecode issues";
      }
      return !0;
    }
    function De(G, K, ut, Bt, Ut, Ht) {
      var ue = { value: 0 },
        ae = ut.value,
        H = ce(K, ut),
        tt = ce(K, ut);
      ut.value += 4;
      var rt = ce(K, ut);
      if (((ut.value += 4), H < 0 || H >= 65537 || tt < 0 || tt >= 65537))
        throw "Something wrong with HUF_ENCSIZE";
      var ot = new Array(65537),
        gt = new Array(16384);
      Y(gt);
      var wt = Bt - (ut.value - ae);
      if ((j(G, K, ut, wt, H, tt, ot), rt > 8 * (Bt - (ut.value - ae))))
        throw "Something wrong with hufUncompress";
      xt(ot, H, tt, gt), Ae(ot, gt, G, K, ut, rt, tt, Ht, Ut, ue);
    }
    function je(G, K, ut) {
      for (var Bt = 0; Bt < ut; ++Bt) K[Bt] = G[K[Bt]];
    }
    function Ue(G) {
      for (var K = 1; K < G.length; K++) {
        var ut = G[K - 1] + G[K] - 128;
        G[K] = ut;
      }
    }
    function J(G, K) {
      for (
        var ut = 0,
          Bt = Math.floor((G.length + 1) / 2),
          Ut = 0,
          Ht = G.length - 1;
        !(Ut > Ht || ((K[Ut++] = G[ut++]), Ut > Ht));

      )
        K[Ut++] = G[Bt++];
    }
    function le(G) {
      for (
        var K = G.byteLength, ut = new Array(), Bt = 0, Ut = new DataView(G);
        K > 0;

      ) {
        var Ht = Ut.getInt8(Bt++);
        if (Ht < 0) {
          var ue = -Ht;
          K -= ue + 1;
          for (var ae = 0; ae < ue; ae++) ut.push(Ut.getUint8(Bt++));
        } else {
          var ue = Ht;
          K -= 2;
          for (var H = Ut.getUint8(Bt++), ae = 0; ae < ue + 1; ae++) ut.push(H);
        }
      }
      return ut;
    }
    function se(G, K, ut, Bt, Ut, Ht) {
      var Oe = new DataView(Ht.buffer),
        ue = ut[G.idx[0]].width,
        ae = ut[G.idx[0]].height,
        H = 3,
        tt = Math.floor(ue / 8),
        rt = Math.ceil(ue / 8),
        ot = Math.ceil(ae / 8),
        gt = ue - (rt - 1) * 8,
        wt = ae - (ot - 1) * 8,
        Vt = { value: 0 },
        Jt = new Array(H),
        ee = new Array(H),
        xe = new Array(H),
        ve = new Array(H),
        _e = new Array(H);
      for (let on = 0; on < H; ++on)
        (_e[on] = K[G.idx[on]]),
          (Jt[on] = on < 1 ? 0 : Jt[on - 1] + rt * ot),
          (ee[on] = new Float32Array(64)),
          (xe[on] = new Uint16Array(64)),
          (ve[on] = new Uint16Array(rt * 64));
      for (let on = 0; on < ot; ++on) {
        var He = 8;
        on == ot - 1 && (He = wt);
        var ze = 8;
        for (let qe = 0; qe < rt; ++qe) {
          qe == rt - 1 && (ze = gt);
          for (let xn = 0; xn < H; ++xn)
            xe[xn].fill(0),
              (xe[xn][0] = Ut[Jt[xn]++]),
              $t(Vt, Bt, xe[xn]),
              kt(xe[xn], ee[xn]),
              ye(ee[xn]);
          te(ee);
          for (let xn = 0; xn < H; ++xn) pe(ee[xn], ve[xn], qe * 64);
        }
        let Qn = 0;
        for (let qe = 0; qe < H; ++qe) {
          const xn = ut[G.idx[qe]].type;
          for (let gn = 8 * on; gn < 8 * on + He; ++gn) {
            Qn = _e[qe][gn];
            for (let fi = 0; fi < tt; ++fi) {
              const Un = fi * 64 + (gn & 7) * 8;
              Oe.setUint16(Qn + 0 * 2 * xn, ve[qe][Un + 0], !0),
                Oe.setUint16(Qn + 1 * 2 * xn, ve[qe][Un + 1], !0),
                Oe.setUint16(Qn + 2 * 2 * xn, ve[qe][Un + 2], !0),
                Oe.setUint16(Qn + 3 * 2 * xn, ve[qe][Un + 3], !0),
                Oe.setUint16(Qn + 4 * 2 * xn, ve[qe][Un + 4], !0),
                Oe.setUint16(Qn + 5 * 2 * xn, ve[qe][Un + 5], !0),
                Oe.setUint16(Qn + 6 * 2 * xn, ve[qe][Un + 6], !0),
                Oe.setUint16(Qn + 7 * 2 * xn, ve[qe][Un + 7], !0),
                (Qn += 8 * 2 * xn);
            }
          }
          if (tt != rt)
            for (let gn = 8 * on; gn < 8 * on + He; ++gn) {
              const fi = _e[qe][gn] + 8 * tt * 2 * xn,
                Un = tt * 64 + (gn & 7) * 8;
              for (let $n = 0; $n < ze; ++$n)
                Oe.setUint16(fi + $n * 2 * xn, ve[qe][Un + $n], !0);
            }
        }
      }
      for (
        var Mn = new Uint16Array(ue), Oe = new DataView(Ht.buffer), Ve = 0;
        Ve < H;
        ++Ve
      ) {
        ut[G.idx[Ve]].decoded = !0;
        var Ne = ut[G.idx[Ve]].type;
        if (ut[Ve].type == 2)
          for (var Yn = 0; Yn < ae; ++Yn) {
            const on = _e[Ve][Yn];
            for (var en = 0; en < ue; ++en)
              Mn[en] = Oe.getUint16(on + en * 2 * Ne, !0);
            for (var en = 0; en < ue; ++en)
              Oe.setFloat32(on + en * 2 * Ne, Et(Mn[en]), !0);
          }
      }
    }
    function $t(G, K, ut) {
      for (var Bt, Ut = 1; Ut < 64; )
        (Bt = K[G.value]),
          Bt == 65280
            ? (Ut = 64)
            : Bt >> 8 == 255
            ? (Ut += Bt & 255)
            : ((ut[Ut] = Bt), Ut++),
          G.value++;
    }
    function kt(G, K) {
      (K[0] = Et(G[0])),
        (K[1] = Et(G[1])),
        (K[2] = Et(G[5])),
        (K[3] = Et(G[6])),
        (K[4] = Et(G[14])),
        (K[5] = Et(G[15])),
        (K[6] = Et(G[27])),
        (K[7] = Et(G[28])),
        (K[8] = Et(G[2])),
        (K[9] = Et(G[4])),
        (K[10] = Et(G[7])),
        (K[11] = Et(G[13])),
        (K[12] = Et(G[16])),
        (K[13] = Et(G[26])),
        (K[14] = Et(G[29])),
        (K[15] = Et(G[42])),
        (K[16] = Et(G[3])),
        (K[17] = Et(G[8])),
        (K[18] = Et(G[12])),
        (K[19] = Et(G[17])),
        (K[20] = Et(G[25])),
        (K[21] = Et(G[30])),
        (K[22] = Et(G[41])),
        (K[23] = Et(G[43])),
        (K[24] = Et(G[9])),
        (K[25] = Et(G[11])),
        (K[26] = Et(G[18])),
        (K[27] = Et(G[24])),
        (K[28] = Et(G[31])),
        (K[29] = Et(G[40])),
        (K[30] = Et(G[44])),
        (K[31] = Et(G[53])),
        (K[32] = Et(G[10])),
        (K[33] = Et(G[19])),
        (K[34] = Et(G[23])),
        (K[35] = Et(G[32])),
        (K[36] = Et(G[39])),
        (K[37] = Et(G[45])),
        (K[38] = Et(G[52])),
        (K[39] = Et(G[54])),
        (K[40] = Et(G[20])),
        (K[41] = Et(G[22])),
        (K[42] = Et(G[33])),
        (K[43] = Et(G[38])),
        (K[44] = Et(G[46])),
        (K[45] = Et(G[51])),
        (K[46] = Et(G[55])),
        (K[47] = Et(G[60])),
        (K[48] = Et(G[21])),
        (K[49] = Et(G[34])),
        (K[50] = Et(G[37])),
        (K[51] = Et(G[47])),
        (K[52] = Et(G[50])),
        (K[53] = Et(G[56])),
        (K[54] = Et(G[59])),
        (K[55] = Et(G[61])),
        (K[56] = Et(G[35])),
        (K[57] = Et(G[36])),
        (K[58] = Et(G[48])),
        (K[59] = Et(G[49])),
        (K[60] = Et(G[57])),
        (K[61] = Et(G[58])),
        (K[62] = Et(G[62])),
        (K[63] = Et(G[63]));
    }
    function ye(G) {
      const K = 0.5 * Math.cos(0.7853975),
        ut = 0.5 * Math.cos(3.14159 / 16),
        Bt = 0.5 * Math.cos(3.14159 / 8),
        Ut = 0.5 * Math.cos((3 * 3.14159) / 16),
        Ht = 0.5 * Math.cos((5 * 3.14159) / 16),
        ue = 0.5 * Math.cos((3 * 3.14159) / 8),
        ae = 0.5 * Math.cos((7 * 3.14159) / 16);
      for (
        var H = new Array(4),
          tt = new Array(4),
          rt = new Array(4),
          ot = new Array(4),
          gt = 0;
        gt < 8;
        ++gt
      ) {
        var wt = gt * 8;
        (H[0] = Bt * G[wt + 2]),
          (H[1] = ue * G[wt + 2]),
          (H[2] = Bt * G[wt + 6]),
          (H[3] = ue * G[wt + 6]),
          (tt[0] =
            ut * G[wt + 1] + Ut * G[wt + 3] + Ht * G[wt + 5] + ae * G[wt + 7]),
          (tt[1] =
            Ut * G[wt + 1] - ae * G[wt + 3] - ut * G[wt + 5] - Ht * G[wt + 7]),
          (tt[2] =
            Ht * G[wt + 1] - ut * G[wt + 3] + ae * G[wt + 5] + Ut * G[wt + 7]),
          (tt[3] =
            ae * G[wt + 1] - Ht * G[wt + 3] + Ut * G[wt + 5] - ut * G[wt + 7]),
          (rt[0] = K * (G[wt + 0] + G[wt + 4])),
          (rt[3] = K * (G[wt + 0] - G[wt + 4])),
          (rt[1] = H[0] + H[3]),
          (rt[2] = H[1] - H[2]),
          (ot[0] = rt[0] + rt[1]),
          (ot[1] = rt[3] + rt[2]),
          (ot[2] = rt[3] - rt[2]),
          (ot[3] = rt[0] - rt[1]),
          (G[wt + 0] = ot[0] + tt[0]),
          (G[wt + 1] = ot[1] + tt[1]),
          (G[wt + 2] = ot[2] + tt[2]),
          (G[wt + 3] = ot[3] + tt[3]),
          (G[wt + 4] = ot[3] - tt[3]),
          (G[wt + 5] = ot[2] - tt[2]),
          (G[wt + 6] = ot[1] - tt[1]),
          (G[wt + 7] = ot[0] - tt[0]);
      }
      for (var Vt = 0; Vt < 8; ++Vt)
        (H[0] = Bt * G[16 + Vt]),
          (H[1] = ue * G[16 + Vt]),
          (H[2] = Bt * G[48 + Vt]),
          (H[3] = ue * G[48 + Vt]),
          (tt[0] =
            ut * G[8 + Vt] +
            Ut * G[24 + Vt] +
            Ht * G[40 + Vt] +
            ae * G[56 + Vt]),
          (tt[1] =
            Ut * G[8 + Vt] -
            ae * G[24 + Vt] -
            ut * G[40 + Vt] -
            Ht * G[56 + Vt]),
          (tt[2] =
            Ht * G[8 + Vt] -
            ut * G[24 + Vt] +
            ae * G[40 + Vt] +
            Ut * G[56 + Vt]),
          (tt[3] =
            ae * G[8 + Vt] -
            Ht * G[24 + Vt] +
            Ut * G[40 + Vt] -
            ut * G[56 + Vt]),
          (rt[0] = K * (G[Vt] + G[32 + Vt])),
          (rt[3] = K * (G[Vt] - G[32 + Vt])),
          (rt[1] = H[0] + H[3]),
          (rt[2] = H[1] - H[2]),
          (ot[0] = rt[0] + rt[1]),
          (ot[1] = rt[3] + rt[2]),
          (ot[2] = rt[3] - rt[2]),
          (ot[3] = rt[0] - rt[1]),
          (G[0 + Vt] = ot[0] + tt[0]),
          (G[8 + Vt] = ot[1] + tt[1]),
          (G[16 + Vt] = ot[2] + tt[2]),
          (G[24 + Vt] = ot[3] + tt[3]),
          (G[32 + Vt] = ot[3] - tt[3]),
          (G[40 + Vt] = ot[2] - tt[2]),
          (G[48 + Vt] = ot[1] - tt[1]),
          (G[56 + Vt] = ot[0] - tt[0]);
    }
    function te(G) {
      for (var K = 0; K < 64; ++K) {
        var ut = G[0][K],
          Bt = G[1][K],
          Ut = G[2][K];
        (G[0][K] = ut + 1.5747 * Ut),
          (G[1][K] = ut - 0.1873 * Bt - 0.4682 * Ut),
          (G[2][K] = ut + 1.8556 * Bt);
      }
    }
    function pe(G, K, ut) {
      for (var Bt = 0; Bt < 64; ++Bt) K[ut + Bt] = Ff.toHalfFloat(Ye(G[Bt]));
    }
    function Ye(G) {
      return G <= 1
        ? Math.sign(G) * Math.pow(Math.abs(G), 2.2)
        : Math.sign(G) * Math.pow(N, Math.abs(G) - 1);
    }
    function $(G) {
      return new DataView(G.array.buffer, G.offset.value, G.size);
    }
    function k(G) {
      var K = G.viewer.buffer.slice(G.offset.value, G.offset.value + G.size),
        ut = new Uint8Array(le(K)),
        Bt = new Uint8Array(ut.length);
      return Ue(ut), J(ut, Bt), new DataView(Bt.buffer);
    }
    function Mt(G) {
      var K = G.array.slice(G.offset.value, G.offset.value + G.size),
        ut = vy(K),
        Bt = new Uint8Array(ut.length);
      return Ue(ut), J(ut, Bt), new DataView(Bt.buffer);
    }
    function Ft(G) {
      for (
        var K = G.viewer,
          ut = { value: G.offset.value },
          Bt = new Uint16Array(
            G.width * G.scanlineBlockSize * (G.channels * G.type)
          ),
          Ut = new Uint8Array(8192),
          Ht = 0,
          ue = new Array(G.channels),
          ae = 0;
        ae < G.channels;
        ae++
      )
        (ue[ae] = {}),
          (ue[ae].start = Ht),
          (ue[ae].end = ue[ae].start),
          (ue[ae].nx = G.width),
          (ue[ae].ny = G.lines),
          (ue[ae].size = G.type),
          (Ht += ue[ae].nx * ue[ae].ny * ue[ae].size);
      var H = qt(K, ut),
        tt = qt(K, ut);
      if (tt >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (H <= tt)
        for (var ae = 0; ae < tt - H + 1; ae++) Ut[ae + H] = it(K, ut);
      var rt = new Uint16Array(65536),
        ot = L(Ut, rt),
        gt = ce(K, ut);
      De(G.array, K, ut, gt, Bt, Ht);
      for (var ae = 0; ae < G.channels; ++ae)
        for (var wt = ue[ae], Vt = 0; Vt < ue[ae].size; ++Vt)
          Fe(Bt, wt.start + Vt, wt.nx, wt.size, wt.ny, wt.nx * wt.size, ot);
      je(rt, Bt, Ht);
      for (
        var Jt = 0, ee = new Uint8Array(Bt.buffer.byteLength), xe = 0;
        xe < G.lines;
        xe++
      )
        for (var ve = 0; ve < G.channels; ve++) {
          var wt = ue[ve],
            _e = wt.nx * wt.size,
            He = new Uint8Array(Bt.buffer, wt.end * 2, _e * 2);
          ee.set(He, Jt), (Jt += _e * 2), (wt.end += _e);
        }
      return new DataView(ee.buffer);
    }
    function Gt(G) {
      var K = G.array.slice(G.offset.value, G.offset.value + G.size),
        ut = vy(K);
      const Bt = G.lines * G.channels * G.width,
        Ut = G.type == 1 ? new Uint16Array(Bt) : new Uint32Array(Bt);
      let Ht = 0,
        ue = 0;
      const ae = new Array(4);
      for (let H = 0; H < G.lines; H++)
        for (let tt = 0; tt < G.channels; tt++) {
          let rt = 0;
          switch (G.type) {
            case 1:
              (ae[0] = Ht), (ae[1] = ae[0] + G.width), (Ht = ae[1] + G.width);
              for (let ot = 0; ot < G.width; ++ot) {
                const gt = (ut[ae[0]++] << 8) | ut[ae[1]++];
                (rt += gt), (Ut[ue] = rt), ue++;
              }
              break;
            case 2:
              (ae[0] = Ht),
                (ae[1] = ae[0] + G.width),
                (ae[2] = ae[1] + G.width),
                (Ht = ae[2] + G.width);
              for (let ot = 0; ot < G.width; ++ot) {
                const gt =
                  (ut[ae[0]++] << 24) |
                  (ut[ae[1]++] << 16) |
                  (ut[ae[2]++] << 8);
                (rt += gt), (Ut[ue] = rt), ue++;
              }
              break;
          }
        }
      return new DataView(Ut.buffer);
    }
    function zt(G) {
      var K = G.viewer,
        ut = { value: G.offset.value },
        Bt = new Uint8Array(G.width * G.lines * (G.channels * G.type * 2)),
        Ut = {
          version: yt(K, ut),
          unknownUncompressedSize: yt(K, ut),
          unknownCompressedSize: yt(K, ut),
          acCompressedSize: yt(K, ut),
          dcCompressedSize: yt(K, ut),
          rleCompressedSize: yt(K, ut),
          rleUncompressedSize: yt(K, ut),
          rleRawSize: yt(K, ut),
          totalAcUncompressedCount: yt(K, ut),
          totalDcUncompressedCount: yt(K, ut),
          acCompression: yt(K, ut),
        };
      if (Ut.version < 2)
        throw (
          "EXRLoader.parse: " +
          sa.compression +
          " version " +
          Ut.version +
          " is unsupported"
        );
      for (var Ht = new Array(), ue = qt(K, ut) - 2; ue > 0; ) {
        var ae = me(K.buffer, ut),
          H = it(K, ut),
          tt = (H >> 2) & 3,
          rt = (H >> 4) - 1,
          ot = new Int8Array([rt])[0],
          gt = it(K, ut);
        Ht.push({ name: ae, index: ot, type: gt, compression: tt }),
          (ue -= ae.length + 3);
      }
      for (
        var wt = sa.channels, Vt = new Array(G.channels), Jt = 0;
        Jt < G.channels;
        ++Jt
      ) {
        var ee = (Vt[Jt] = {}),
          xe = wt[Jt];
        (ee.name = xe.name),
          (ee.compression = 0),
          (ee.decoded = !1),
          (ee.type = xe.pixelType),
          (ee.pLinear = xe.pLinear),
          (ee.width = G.width),
          (ee.height = G.lines);
      }
      for (var ve = { idx: new Array(3) }, _e = 0; _e < G.channels; ++_e)
        for (var ee = Vt[_e], Jt = 0; Jt < Ht.length; ++Jt) {
          var He = Ht[Jt];
          ee.name == He.name &&
            ((ee.compression = He.compression),
            He.index >= 0 && (ve.idx[He.index] = _e),
            (ee.offset = _e));
        }
      if (Ut.acCompressedSize > 0)
        switch (Ut.acCompression) {
          case 0:
            var Oe = new Uint16Array(Ut.totalAcUncompressedCount);
            De(
              G.array,
              K,
              ut,
              Ut.acCompressedSize,
              Oe,
              Ut.totalAcUncompressedCount
            );
            break;
          case 1:
            var ze = G.array.slice(
                ut.value,
                ut.value + Ut.totalAcUncompressedCount
              ),
              Mn = vy(ze),
              Oe = new Uint16Array(Mn.buffer);
            ut.value += Ut.totalAcUncompressedCount;
            break;
        }
      if (Ut.dcCompressedSize > 0) {
        var Ve = { array: G.array, offset: ut, size: Ut.dcCompressedSize },
          Ne = new Uint16Array(Mt(Ve).buffer);
        ut.value += Ut.dcCompressedSize;
      }
      if (Ut.rleRawSize > 0) {
        var ze = G.array.slice(ut.value, ut.value + Ut.rleCompressedSize),
          Mn = vy(ze),
          Yn = le(Mn.buffer);
        ut.value += Ut.rleCompressedSize;
      }
      for (var en = 0, on = new Array(Vt.length), Jt = 0; Jt < on.length; ++Jt)
        on[Jt] = new Array();
      for (var Qn = 0; Qn < G.lines; ++Qn)
        for (var qe = 0; qe < Vt.length; ++qe)
          on[qe].push(en), (en += Vt[qe].width * G.type * 2);
      se(ve, on, Vt, Oe, Ne, Bt);
      for (var Jt = 0; Jt < Vt.length; ++Jt) {
        var ee = Vt[Jt];
        if (!ee.decoded)
          switch (ee.compression) {
            case 2:
              for (var xn = 0, gn = 0, Qn = 0; Qn < G.lines; ++Qn) {
                for (var fi = on[Jt][xn], Un = 0; Un < ee.width; ++Un) {
                  for (var $n = 0; $n < 2 * ee.type; ++$n)
                    Bt[fi++] = Yn[gn + $n * ee.width * ee.height];
                  gn++;
                }
                xn++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(Bt.buffer);
    }
    function me(G, K) {
      for (var ut = new Uint8Array(G), Bt = 0; ut[K.value + Bt] != 0; ) Bt += 1;
      var Ut = new TextDecoder().decode(ut.slice(K.value, K.value + Bt));
      return (K.value = K.value + Bt + 1), Ut;
    }
    function de(G, K, ut) {
      var Bt = new TextDecoder().decode(
        new Uint8Array(G).slice(K.value, K.value + ut)
      );
      return (K.value = K.value + ut), Bt;
    }
    function we(G, K) {
      var ut = jt(G, K),
        Bt = ce(G, K);
      return [ut, Bt];
    }
    function Ce(G, K) {
      var ut = ce(G, K),
        Bt = ce(G, K);
      return [ut, Bt];
    }
    function jt(G, K) {
      var ut = G.getInt32(K.value, !0);
      return (K.value = K.value + 4), ut;
    }
    function ce(G, K) {
      var ut = G.getUint32(K.value, !0);
      return (K.value = K.value + 4), ut;
    }
    function Re(G, K) {
      var ut = G[K.value];
      return (K.value = K.value + 1), ut;
    }
    function it(G, K) {
      var ut = G.getUint8(K.value);
      return (K.value = K.value + 1), ut;
    }
    const yt = function (G, K) {
      let ut;
      return (
        "getBigInt64" in DataView.prototype
          ? (ut = Number(G.getBigInt64(K.value, !0)))
          : (ut =
              G.getUint32(K.value + 4, !0) +
              Number(G.getUint32(K.value, !0) << 32)),
        (K.value += 8),
        ut
      );
    };
    function Qt(G, K) {
      var ut = G.getFloat32(K.value, !0);
      return (K.value += 4), ut;
    }
    function st(G, K) {
      return Ff.toHalfFloat(Qt(G, K));
    }
    function Et(G) {
      var K = (G & 31744) >> 10,
        ut = G & 1023;
      return (
        (G >> 15 ? -1 : 1) *
        (K
          ? K === 31
            ? ut
              ? NaN
              : 1 / 0
            : Math.pow(2, K - 15) * (1 + ut / 1024)
          : 6103515625e-14 * (ut / 1024))
      );
    }
    function qt(G, K) {
      var ut = G.getUint16(K.value, !0);
      return (K.value += 2), ut;
    }
    function ge(G, K) {
      return Et(qt(G, K));
    }
    function oe(G, K, ut, Bt) {
      for (var Ut = ut.value, Ht = []; ut.value < Ut + Bt - 1; ) {
        var ue = me(K, ut),
          ae = jt(G, ut),
          H = it(G, ut);
        ut.value += 3;
        var tt = jt(G, ut),
          rt = jt(G, ut);
        Ht.push({
          name: ue,
          pixelType: ae,
          pLinear: H,
          xSampling: tt,
          ySampling: rt,
        });
      }
      return (ut.value += 1), Ht;
    }
    function Kt(G, K) {
      var ut = Qt(G, K),
        Bt = Qt(G, K),
        Ut = Qt(G, K),
        Ht = Qt(G, K),
        ue = Qt(G, K),
        ae = Qt(G, K),
        H = Qt(G, K),
        tt = Qt(G, K);
      return {
        redX: ut,
        redY: Bt,
        greenX: Ut,
        greenY: Ht,
        blueX: ue,
        blueY: ae,
        whiteX: H,
        whiteY: tt,
      };
    }
    function be(G, K) {
      var ut = [
          "NO_COMPRESSION",
          "RLE_COMPRESSION",
          "ZIPS_COMPRESSION",
          "ZIP_COMPRESSION",
          "PIZ_COMPRESSION",
          "PXR24_COMPRESSION",
          "B44_COMPRESSION",
          "B44A_COMPRESSION",
          "DWAA_COMPRESSION",
          "DWAB_COMPRESSION",
        ],
        Bt = it(G, K);
      return ut[Bt];
    }
    function Le(G, K) {
      var ut = ce(G, K),
        Bt = ce(G, K),
        Ut = ce(G, K),
        Ht = ce(G, K);
      return { xMin: ut, yMin: Bt, xMax: Ut, yMax: Ht };
    }
    function mn(G, K) {
      var ut = ["INCREASING_Y"],
        Bt = it(G, K);
      return ut[Bt];
    }
    function ln(G, K) {
      var ut = Qt(G, K),
        Bt = Qt(G, K);
      return [ut, Bt];
    }
    function yi(G, K) {
      var ut = Qt(G, K),
        Bt = Qt(G, K),
        Ut = Qt(G, K);
      return [ut, Bt, Ut];
    }
    function si(G, K, ut, Bt, Ut) {
      if (Bt === "string" || Bt === "stringvector" || Bt === "iccProfile")
        return de(K, ut, Ut);
      if (Bt === "chlist") return oe(G, K, ut, Ut);
      if (Bt === "chromaticities") return Kt(G, ut);
      if (Bt === "compression") return be(G, ut);
      if (Bt === "box2i") return Le(G, ut);
      if (Bt === "lineOrder") return mn(G, ut);
      if (Bt === "float") return Qt(G, ut);
      if (Bt === "v2f") return ln(G, ut);
      if (Bt === "v3f") return yi(G, ut);
      if (Bt === "int") return jt(G, ut);
      if (Bt === "rational") return we(G, ut);
      if (Bt === "timecode") return Ce(G, ut);
      if (Bt === "preview") return (ut.value += Ut), "skipped";
      ut.value += Ut;
    }
    function xi(G, K, ut) {
      const Bt = {};
      if (G.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      Bt.version = G.getUint8(4);
      const Ut = G.getUint8(5);
      (Bt.spec = {
        singleTile: !!(Ut & 2),
        longName: !!(Ut & 4),
        deepFormat: !!(Ut & 8),
        multiPart: !!(Ut & 16),
      }),
        (ut.value = 8);
      for (var Ht = !0; Ht; ) {
        var ue = me(K, ut);
        if (ue == 0) Ht = !1;
        else {
          var ae = me(K, ut),
            H = ce(G, ut),
            tt = si(G, K, ut, ae, H);
          tt === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${ae}'.`
              )
            : (Bt[ue] = tt);
        }
      }
      if ((Ut & -5) != 0)
        throw (
          (console.error("EXRHeader:", Bt),
          "THREE.EXRLoader: provided file is currently unsupported.")
        );
      return Bt;
    }
    function Ci(G, K, ut, Bt, Ut) {
      const Ht = {
        size: 0,
        viewer: K,
        array: ut,
        offset: Bt,
        width: G.dataWindow.xMax - G.dataWindow.xMin + 1,
        height: G.dataWindow.yMax - G.dataWindow.yMin + 1,
        channels: G.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: G.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [Fm ? "colorSpace" : "encoding"]: null,
      };
      switch (G.compression) {
        case "NO_COMPRESSION":
          (Ht.lines = 1), (Ht.uncompress = $);
          break;
        case "RLE_COMPRESSION":
          (Ht.lines = 1), (Ht.uncompress = k);
          break;
        case "ZIPS_COMPRESSION":
          (Ht.lines = 1), (Ht.uncompress = Mt);
          break;
        case "ZIP_COMPRESSION":
          (Ht.lines = 16), (Ht.uncompress = Mt);
          break;
        case "PIZ_COMPRESSION":
          (Ht.lines = 32), (Ht.uncompress = Ft);
          break;
        case "PXR24_COMPRESSION":
          (Ht.lines = 16), (Ht.uncompress = Gt);
          break;
        case "DWAA_COMPRESSION":
          (Ht.lines = 32), (Ht.uncompress = zt);
          break;
        case "DWAB_COMPRESSION":
          (Ht.lines = 256), (Ht.uncompress = zt);
          break;
        default:
          throw "EXRLoader.parse: " + G.compression + " is unsupported";
      }
      if (((Ht.scanlineBlockSize = Ht.lines), Ht.type == 1))
        switch (Ut) {
          case Pi:
            (Ht.getter = ge), (Ht.inputSize = 2);
            break;
          case Ea:
            (Ht.getter = qt), (Ht.inputSize = 2);
            break;
        }
      else if (Ht.type == 2)
        switch (Ut) {
          case Pi:
            (Ht.getter = Qt), (Ht.inputSize = 4);
            break;
          case Ea:
            (Ht.getter = st), (Ht.inputSize = 4);
        }
      else
        throw (
          "EXRLoader.parse: unsupported pixelType " +
          Ht.type +
          " for " +
          G.compression +
          "."
        );
      Ht.blockCount = (G.dataWindow.yMax + 1) / Ht.scanlineBlockSize;
      for (var ue = 0; ue < Ht.blockCount; ue++) yt(K, Bt);
      Ht.outputChannels = Ht.channels == 3 ? 4 : Ht.channels;
      const ae = Ht.width * Ht.height * Ht.outputChannels;
      switch (Ut) {
        case Pi:
          (Ht.byteArray = new Float32Array(ae)),
            Ht.channels < Ht.outputChannels && Ht.byteArray.fill(1, 0, ae);
          break;
        case Ea:
          (Ht.byteArray = new Uint16Array(ae)),
            Ht.channels < Ht.outputChannels && Ht.byteArray.fill(15360, 0, ae);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", Ut);
          break;
      }
      return (
        (Ht.bytesPerLine = Ht.width * Ht.inputSize * Ht.channels),
        Ht.outputChannels == 4 ? (Ht.format = Ji) : (Ht.format = D0),
        Fm ? (Ht.colorSpace = "srgb-linear") : (Ht.encoding = 3e3),
        Ht
      );
    }
    const Ri = new DataView(t),
      ya = new Uint8Array(t),
      Ws = { value: 0 },
      sa = xi(Ri, t, Ws),
      Ke = Ci(sa, Ri, ya, Ws, this.type),
      ka = { value: 0 },
      Vn = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let G = 0; G < Ke.height / Ke.scanlineBlockSize; G++) {
      const K = ce(Ri, Ws);
      (Ke.size = ce(Ri, Ws)),
        (Ke.lines =
          K + Ke.scanlineBlockSize > Ke.height
            ? Ke.height - K
            : Ke.scanlineBlockSize);
      const Bt =
        Ke.size < Ke.lines * Ke.bytesPerLine ? Ke.uncompress(Ke) : $(Ke);
      Ws.value += Ke.size;
      for (let Ut = 0; Ut < Ke.scanlineBlockSize; Ut++) {
        const Ht = Ut + G * Ke.scanlineBlockSize;
        if (Ht >= Ke.height) break;
        for (let ue = 0; ue < Ke.channels; ue++) {
          const ae = Vn[sa.channels[ue].name];
          for (let H = 0; H < Ke.width; H++) {
            ka.value =
              (Ut * (Ke.channels * Ke.width) + ue * Ke.width + H) *
              Ke.inputSize;
            const tt =
              (Ke.height - 1 - Ht) * (Ke.width * Ke.outputChannels) +
              H * Ke.outputChannels +
              ae;
            Ke.byteArray[tt] = Ke.getter(Bt, ka);
          }
        }
      }
    }
    return {
      header: sa,
      width: Ke.width,
      height: Ke.height,
      data: Ke.byteArray,
      format: Ke.format,
      [Fm ? "colorSpace" : "encoding"]: Ke[Fm ? "colorSpace" : "encoding"],
      type: this.type,
    };
  }
  setDataType(t) {
    return (this.type = t), this;
  }
  load(t, e, n, a) {
    function r(l, u) {
      Fm ? (l.colorSpace = u.colorSpace) : (l.encoding = u.encoding),
        (l.minFilter = Kn),
        (l.magFilter = Kn),
        (l.generateMipmaps = !1),
        (l.flipY = !1),
        e && e(l, u);
    }
    return super.load(t, r, n, a);
  }
}
const mb = new WeakMap();
class N8 extends Va {
  constructor(t) {
    super(t),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(t) {
    return (this.decoderPath = t), this;
  }
  setDecoderConfig(t) {
    return (this.decoderConfig = t), this;
  }
  setWorkerLimit(t) {
    return (this.workerLimit = t), this;
  }
  load(t, e, n, a) {
    const r = new Ga(this.manager);
    r.setPath(this.path),
      r.setResponseType("arraybuffer"),
      r.setRequestHeader(this.requestHeader),
      r.setWithCredentials(this.withCredentials),
      r.load(
        t,
        (l) => {
          const u = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(l, u).then(e).catch(a);
        },
        n,
        a
      );
  }
  decodeDracoFile(t, e, n, a) {
    const r = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: a || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
    };
    this.decodeGeometry(t, r).then(e);
  }
  decodeGeometry(t, e) {
    for (const h in e.attributeTypes) {
      const p = e.attributeTypes[h];
      p.BYTES_PER_ELEMENT !== void 0 && (e.attributeTypes[h] = p.name);
    }
    const n = JSON.stringify(e);
    if (mb.has(t)) {
      const h = mb.get(t);
      if (h.key === n) return h.promise;
      if (t.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let a;
    const r = this.workerNextTaskID++,
      l = t.byteLength,
      u = this._getWorker(r, l)
        .then(
          (h) => (
            (a = h),
            new Promise((p, m) => {
              (a._callbacks[r] = { resolve: p, reject: m }),
                a.postMessage(
                  { type: "decode", id: r, taskConfig: e, buffer: t },
                  [t]
                );
            })
          )
        )
        .then((h) => this._createGeometry(h.geometry));
    return (
      u
        .catch(() => !0)
        .then(() => {
          a && r && this._releaseTask(a, r);
        }),
      mb.set(t, { key: n, promise: u }),
      u
    );
  }
  _createGeometry(t) {
    const e = new pn();
    t.index && e.setIndex(new Gn(t.index.array, 1));
    for (let n = 0; n < t.attributes.length; n++) {
      const a = t.attributes[n],
        r = a.name,
        l = a.array,
        u = a.itemSize;
      e.setAttribute(r, new Gn(l, u));
    }
    return e;
  }
  _loadLibrary(t, e) {
    const n = new Ga(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(e),
      n.setWithCredentials(this.withCredentials),
      new Promise((a, r) => {
        n.load(t, a, void 0, r);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const t =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      e = [];
    return (
      t
        ? e.push(this._loadLibrary("draco_decoder.js", "text"))
        : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(e).then((n) => {
        const a = n[0];
        t || (this.decoderConfig.wasmBinary = n[1]);
        const r = L8.toString(),
          l = [
            "/* draco decoder */",
            a,
            "",
            "/* worker */",
            r.substring(r.indexOf("{") + 1, r.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([l]));
      })),
      this.decoderPending
    );
  }
  _getWorker(t, e) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const a = new Worker(this.workerSourceURL);
        (a._callbacks = {}),
          (a._taskCosts = {}),
          (a._taskLoad = 0),
          a.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (a.onmessage = function (r) {
            const l = r.data;
            switch (l.type) {
              case "decode":
                a._callbacks[l.id].resolve(l);
                break;
              case "error":
                a._callbacks[l.id].reject(l);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + l.type + '"'
                );
            }
          }),
          this.workerPool.push(a);
      } else
        this.workerPool.sort(function (a, r) {
          return a._taskLoad > r._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[t] = e), (n._taskLoad += e), n;
    });
  }
  _releaseTask(t, e) {
    (t._taskLoad -= t._taskCosts[e]),
      delete t._callbacks[e],
      delete t._taskCosts[e];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((t) => t._taskLoad)
    );
  }
  dispose() {
    for (let t = 0; t < this.workerPool.length; ++t)
      this.workerPool[t].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function L8() {
  let i, t;
  onmessage = function (l) {
    const u = l.data;
    switch (u.type) {
      case "init":
        (i = u.decoderConfig),
          (t = new Promise(function (m) {
            (i.onModuleLoaded = function (v) {
              m({ draco: v });
            }),
              DracoDecoderModule(i);
          }));
        break;
      case "decode":
        const h = u.buffer,
          p = u.taskConfig;
        t.then((m) => {
          const v = m.draco,
            x = new v.Decoder(),
            _ = new v.DecoderBuffer();
          _.Init(new Int8Array(h), h.byteLength);
          try {
            const M = e(v, x, _, p),
              C = M.attributes.map((E) => E.array.buffer);
            M.index && C.push(M.index.array.buffer),
              self.postMessage({ type: "decode", id: u.id, geometry: M }, C);
          } catch (M) {
            console.error(M),
              self.postMessage({ type: "error", id: u.id, error: M.message });
          } finally {
            v.destroy(_), v.destroy(x);
          }
        });
        break;
    }
  };
  function e(l, u, h, p) {
    const m = p.attributeIDs,
      v = p.attributeTypes;
    let x, _;
    const M = u.GetEncodedGeometryType(h);
    if (M === l.TRIANGULAR_MESH)
      (x = new l.Mesh()), (_ = u.DecodeBufferToMesh(h, x));
    else if (M === l.POINT_CLOUD)
      (x = new l.PointCloud()), (_ = u.DecodeBufferToPointCloud(h, x));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!_.ok() || x.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + _.error_msg());
    const C = { index: null, attributes: [] };
    for (const E in m) {
      const S = self[v[E]];
      let R, B;
      if (p.useUniqueIDs) (B = m[E]), (R = u.GetAttributeByUniqueId(x, B));
      else {
        if (((B = u.GetAttributeId(x, l[m[E]])), B === -1)) continue;
        R = u.GetAttribute(x, B);
      }
      C.attributes.push(a(l, u, x, E, S, R));
    }
    return M === l.TRIANGULAR_MESH && (C.index = n(l, u, x)), l.destroy(x), C;
  }
  function n(l, u, h) {
    const m = h.num_faces() * 3,
      v = m * 4,
      x = l._malloc(v);
    u.GetTrianglesUInt32Array(h, v, x);
    const _ = new Uint32Array(l.HEAPF32.buffer, x, m).slice();
    return l._free(x), { array: _, itemSize: 1 };
  }
  function a(l, u, h, p, m, v) {
    const x = v.num_components(),
      M = h.num_points() * x,
      C = M * m.BYTES_PER_ELEMENT,
      E = r(l, m),
      S = l._malloc(C);
    u.GetAttributeDataArrayForAllPoints(h, v, E, C, S);
    const R = new m(l.HEAPF32.buffer, S, M).slice();
    return l._free(S), { name: p, array: R, itemSize: x };
  }
  function r(l, u) {
    switch (u) {
      case Float32Array:
        return l.DT_FLOAT32;
      case Int8Array:
        return l.DT_INT8;
      case Int16Array:
        return l.DT_INT16;
      case Int32Array:
        return l.DT_INT32;
      case Uint8Array:
        return l.DT_UINT8;
      case Uint16Array:
        return l.DT_UINT16;
      case Uint32Array:
        return l.DT_UINT32;
    }
  }
}
let xy;
const gb = () => {
  if (xy) return xy;
  const i =
      "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
    t =
      "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
    e = new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0,
      1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7,
      0, 65, 0, 253, 15, 26, 11,
    ]),
    n = new Uint8Array([
      32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
      128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
      107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
      44, 45, 74, 156, 154, 70, 167,
    ]);
  if (typeof WebAssembly != "object") return { supported: !1 };
  let a = i;
  WebAssembly.validate(e) && (a = t);
  let r;
  const l = WebAssembly.instantiate(u(a), {}).then((v) => {
    (r = v.instance), r.exports.__wasm_call_ctors();
  });
  function u(v) {
    const x = new Uint8Array(v.length);
    for (let M = 0; M < v.length; ++M) {
      const C = v.charCodeAt(M);
      x[M] =
        C > 96 ? C - 71 : C > 64 ? C - 65 : C > 47 ? C + 4 : C > 46 ? 63 : 62;
    }
    let _ = 0;
    for (let M = 0; M < v.length; ++M)
      x[_++] = x[M] < 60 ? n[x[M]] : (x[M] - 60) * 64 + x[++M];
    return x.buffer.slice(0, _);
  }
  function h(v, x, _, M, C, E) {
    const S = r.exports.sbrk,
      R = (_ + 3) & -4,
      B = S(R * M),
      D = S(C.length),
      I = new Uint8Array(r.exports.memory.buffer);
    I.set(C, D);
    const P = v(B, _, M, D, C.length);
    if (
      (P === 0 && E && E(B, R, M),
      x.set(I.subarray(B, B + _ * M)),
      S(B - S(0)),
      P !== 0)
    )
      throw new Error(`Malformed buffer data: ${P}`);
  }
  const p = {
      0: "",
      1: "meshopt_decodeFilterOct",
      2: "meshopt_decodeFilterQuat",
      3: "meshopt_decodeFilterExp",
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp",
    },
    m = {
      0: "meshopt_decodeVertexBuffer",
      1: "meshopt_decodeIndexBuffer",
      2: "meshopt_decodeIndexSequence",
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence",
    };
  return (
    (xy = {
      ready: l,
      supported: !0,
      decodeVertexBuffer(v, x, _, M, C) {
        h(r.exports.meshopt_decodeVertexBuffer, v, x, _, M, r.exports[p[C]]);
      },
      decodeIndexBuffer(v, x, _, M) {
        h(r.exports.meshopt_decodeIndexBuffer, v, x, _, M);
      },
      decodeIndexSequence(v, x, _, M) {
        h(r.exports.meshopt_decodeIndexSequence, v, x, _, M);
      },
      decodeGltfBuffer(v, x, _, M, C, E) {
        h(r.exports[m[C]], v, x, _, M, r.exports[p[E]]);
      },
    }),
    xy
  );
};
let _y = null,
  _B = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function bB(i = !0, t = !0, e) {
  return (n) => {
    e && e(n),
      i &&
        (_y || (_y = new N8()),
        _y.setDecoderPath(typeof i == "string" ? i : _B),
        n.setDRACOLoader(_y)),
      t && n.setMeshoptDecoder(typeof gb == "function" ? gb() : gb);
  };
}
const W0 = (i, t, e, n) => ec(DS, i, bB(t, e, n));
W0.preload = (i, t, e, n) => ec.preload(DS, i, bB(t, e, n));
W0.clear = (i) => ec.clear(DS, i);
W0.setDecoderPath = (i) => {
  _B = i;
};
const bw = bt.forwardRef(
  (
    {
      makeDefault: i,
      camera: t,
      regress: e,
      domElement: n,
      enableDamping: a = !0,
      keyEvents: r = !1,
      onChange: l,
      onStart: u,
      onEnd: h,
      ...p
    },
    m
  ) => {
    const v = Gs((P) => P.invalidate),
      x = Gs((P) => P.camera),
      _ = Gs((P) => P.gl),
      M = Gs((P) => P.events),
      C = Gs((P) => P.setEvents),
      E = Gs((P) => P.set),
      S = Gs((P) => P.get),
      R = Gs((P) => P.performance),
      B = t || x,
      D = n || M.connected || _.domElement,
      I = bt.useMemo(() => new JF(B), [B]);
    return (
      f1(() => {
        I.enabled && I.update();
      }, -1),
      bt.useEffect(
        () => (
          r && I.connect(r === !0 ? D : r), I.connect(D), () => void I.dispose()
        ),
        [r, D, e, I, v]
      ),
      bt.useEffect(() => {
        const P = (N) => {
            v(), e && R.regress(), l && l(N);
          },
          V = (N) => {
            u && u(N);
          },
          F = (N) => {
            h && h(N);
          };
        return (
          I.addEventListener("change", P),
          I.addEventListener("start", V),
          I.addEventListener("end", F),
          () => {
            I.removeEventListener("start", V),
              I.removeEventListener("end", F),
              I.removeEventListener("change", P);
          }
        );
      }, [l, u, h, I, v, C]),
      bt.useEffect(() => {
        if (i) {
          const P = S().controls;
          return E({ controls: I }), () => E({ controls: P });
        }
      }, [i, I]),
      bt.createElement(
        "primitive",
        x0({ ref: m, object: I, enableDamping: a }, p)
      )
    );
  }
);
function I8(i, t) {
  const e = bt.useRef(null),
    [n] = bt.useState(() => (t ? (t instanceof Dn ? { current: t } : t) : e)),
    [a] = bt.useState(() => new vS(void 0));
  bt.useLayoutEffect(() => {
    t && (n.current = t instanceof Dn ? t : t.current), (a._root = n.current);
  });
  const r = bt.useRef({}),
    l = bt.useMemo(() => {
      const u = {};
      return (
        i.forEach((h) =>
          Object.defineProperty(u, h.name, {
            enumerable: !0,
            get() {
              if (n.current)
                return (
                  r.current[h.name] ||
                  (r.current[h.name] = a.clipAction(h, n.current))
                );
            },
            configurable: !0,
          })
        ),
        { ref: n, clips: i, actions: u, names: i.map((h) => h.name), mixer: a }
      );
    }, [i]);
  return (
    f1((u, h) => a.update(h)),
    bt.useEffect(() => {
      const u = n.current;
      return () => {
        (r.current = {}),
          a.stopAllAction(),
          Object.values(l.actions).forEach((h) => {
            u && a.uncacheAction(h, u);
          });
      };
    }, [i]),
    l
  );
}
const AB = (i, t, e) => {
  let n;
  switch (i) {
    case Es:
      n = new Uint8ClampedArray(t * e * 4);
      break;
    case Ea:
      n = new Uint16Array(t * e * 4);
      break;
    case pl:
      n = new Uint32Array(t * e * 4);
      break;
    case Nx:
      n = new Int8Array(t * e * 4);
      break;
    case Lx:
      n = new Int16Array(t * e * 4);
      break;
    case B0:
      n = new Int32Array(t * e * 4);
      break;
    case Pi:
      n = new Float32Array(t * e * 4);
      break;
    default:
      throw new Error("Unsupported data type");
  }
  return n;
};
let by;
const P8 = (i, t, e, n) => {
  if (by !== void 0) return by;
  const a = new zr(1, 1, n);
  t.setRenderTarget(a);
  const r = new Ti(new xu(), new ks({ color: 16777215 }));
  t.render(r, e), t.setRenderTarget(null);
  const l = AB(i, a.width, a.height);
  return (
    t.readRenderTargetPixels(a, 0, 0, a.width, a.height, l),
    a.dispose(),
    r.geometry.dispose(),
    r.material.dispose(),
    (by = l[0] !== 0),
    by
  );
};
class US {
  constructor(t) {
    var e, n, a, r, l, u, h, p, m, v, x, _, M, C, E, S;
    (this._rendererIsDisposable = !1),
      (this._supportsReadPixels = !0),
      (this.render = () => {
        this._renderer.setRenderTarget(this._renderTarget);
        try {
          this._renderer.render(this._scene, this._camera);
        } catch (B) {
          throw (this._renderer.setRenderTarget(null), B);
        }
        this._renderer.setRenderTarget(null);
      }),
      (this._width = t.width),
      (this._height = t.height),
      (this._type = t.type),
      (this._colorSpace = t.colorSpace);
    const R = {
      format: Ji,
      depthBuffer: !1,
      stencilBuffer: !1,
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy:
        ((e = t.renderTargetOptions) === null || e === void 0
          ? void 0
          : e.anisotropy) !== void 0
          ? (n = t.renderTargetOptions) === null || n === void 0
            ? void 0
            : n.anisotropy
          : 1,
      generateMipmaps:
        ((a = t.renderTargetOptions) === null || a === void 0
          ? void 0
          : a.generateMipmaps) !== void 0
          ? (r = t.renderTargetOptions) === null || r === void 0
            ? void 0
            : r.generateMipmaps
          : !1,
      magFilter:
        ((l = t.renderTargetOptions) === null || l === void 0
          ? void 0
          : l.magFilter) !== void 0
          ? (u = t.renderTargetOptions) === null || u === void 0
            ? void 0
            : u.magFilter
          : Kn,
      minFilter:
        ((h = t.renderTargetOptions) === null || h === void 0
          ? void 0
          : h.minFilter) !== void 0
          ? (p = t.renderTargetOptions) === null || p === void 0
            ? void 0
            : p.minFilter
          : Kn,
      samples:
        ((m = t.renderTargetOptions) === null || m === void 0
          ? void 0
          : m.samples) !== void 0
          ? (v = t.renderTargetOptions) === null || v === void 0
            ? void 0
            : v.samples
          : void 0,
      wrapS:
        ((x = t.renderTargetOptions) === null || x === void 0
          ? void 0
          : x.wrapS) !== void 0
          ? (_ = t.renderTargetOptions) === null || _ === void 0
            ? void 0
            : _.wrapS
          : Ki,
      wrapT:
        ((M = t.renderTargetOptions) === null || M === void 0
          ? void 0
          : M.wrapT) !== void 0
          ? (C = t.renderTargetOptions) === null || C === void 0
            ? void 0
            : C.wrapT
          : Ki,
    };
    if (
      ((this._material = t.material),
      t.renderer
        ? (this._renderer = t.renderer)
        : ((this._renderer = US.instantiateRenderer()),
          (this._rendererIsDisposable = !0)),
      (this._scene = new N0()),
      (this._camera = new Ir()),
      this._camera.position.set(0, 0, 10),
      (this._camera.left = -0.5),
      (this._camera.right = 0.5),
      (this._camera.top = 0.5),
      (this._camera.bottom = -0.5),
      this._camera.updateProjectionMatrix(),
      !P8(this._type, this._renderer, this._camera, R))
    ) {
      let B;
      switch (this._type) {
        case Ea:
          B = this._renderer.extensions.has("EXT_color_buffer_float")
            ? Pi
            : void 0;
          break;
      }
      B !== void 0
        ? (console.warn(
            `This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${Pi}`
          ),
          (this._type = B))
        : ((this._supportsReadPixels = !1),
          console.warn(
            "This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"
          ));
    }
    (this._quad = new Ti(new xu(), this._material)),
      this._quad.geometry.computeBoundingBox(),
      this._scene.add(this._quad),
      (this._renderTarget = new zr(this.width, this.height, R)),
      (this._renderTarget.texture.mapping =
        ((E = t.renderTargetOptions) === null || E === void 0
          ? void 0
          : E.mapping) !== void 0
          ? (S = t.renderTargetOptions) === null || S === void 0
            ? void 0
            : S.mapping
          : cu);
  }
  static instantiateRenderer() {
    const t = new AS();
    return t.setSize(128, 128), t;
  }
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser");
    const t = AB(this._type, this._width, this._height);
    return (
      this._renderer.readRenderTargetPixels(
        this._renderTarget,
        0,
        0,
        this._width,
        this._height,
        t
      ),
      t
    );
  }
  toDataTexture(t) {
    const e = new _o(
      this.toArray(),
      this.width,
      this.height,
      Ji,
      this._type,
      t?.mapping || cu,
      t?.wrapS || Ki,
      t?.wrapT || Ki,
      t?.magFilter || Kn,
      t?.minFilter || Kn,
      t?.anisotropy || 1,
      bo
    );
    return (
      (e.generateMipmaps =
        t?.generateMipmaps !== void 0 ? t?.generateMipmaps : !1),
      e
    );
  }
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null),
      this._rendererIsDisposable &&
        (this._renderer.dispose(), this._renderer.forceContextLoss());
  }
  dispose(t) {
    this.disposeOnDemandRenderer(),
      t && this.renderTarget.dispose(),
      this.material instanceof Xs &&
        Object.values(this.material.uniforms).forEach((e) => {
          e.value instanceof Zn && e.value.dispose();
        }),
      Object.values(this.material).forEach((e) => {
        e instanceof Zn && e.dispose();
      }),
      this.material.dispose(),
      this._quad.geometry.dispose();
  }
  get width() {
    return this._width;
  }
  set width(t) {
    (this._width = t), this._renderTarget.setSize(this._width, this._height);
  }
  get height() {
    return this._height;
  }
  set height(t) {
    (this._height = t), this._renderTarget.setSize(this._width, this._height);
  }
  get renderer() {
    return this._renderer;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(t) {
    (this._renderTarget = t),
      (this._width = t.width),
      (this._height = t.height);
  }
  get material() {
    return this._material;
  }
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
}
const z8 = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  F8 = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class H8 extends Xs {
  constructor({
    gamma: t,
    offsetHdr: e,
    offsetSdr: n,
    gainMapMin: a,
    gainMapMax: r,
    maxDisplayBoost: l,
    hdrCapacityMin: u,
    hdrCapacityMax: h,
    sdr: p,
    gainMap: m,
  }) {
    super({
      name: "GainMapDecoderMaterial",
      vertexShader: z8,
      fragmentShader: F8,
      uniforms: {
        sdr: { value: p },
        gainMap: { value: m },
        gamma: { value: new Z(1 / t[0], 1 / t[1], 1 / t[2]) },
        offsetHdr: { value: new Z().fromArray(e) },
        offsetSdr: { value: new Z().fromArray(n) },
        gainMapMin: { value: new Z().fromArray(a) },
        gainMapMax: { value: new Z().fromArray(r) },
        weightFactor: { value: (Math.log2(l) - u) / (h - u) },
      },
      blending: ol,
      depthTest: !1,
      depthWrite: !1,
    }),
      (this._maxDisplayBoost = l),
      (this._hdrCapacityMin = u),
      (this._hdrCapacityMax = h),
      (this.needsUpdate = !0),
      (this.uniformsNeedUpdate = !0);
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(t) {
    this.uniforms.sdr.value = t;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(t) {
    this.uniforms.gainMap.value = t;
  }
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(t) {
    this.uniforms.offsetHdr.value.fromArray(t);
  }
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(t) {
    this.uniforms.offsetSdr.value.fromArray(t);
  }
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(t) {
    this.uniforms.gainMapMin.value.fromArray(t);
  }
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(t) {
    this.uniforms.gainMapMax.value.fromArray(t);
  }
  get gamma() {
    const t = this.uniforms.gamma.value;
    return [1 / t.x, 1 / t.y, 1 / t.z];
  }
  set gamma(t) {
    const e = this.uniforms.gamma.value;
    (e.x = 1 / t[0]), (e.y = 1 / t[1]), (e.z = 1 / t[2]);
  }
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(t) {
    (this._hdrCapacityMin = t), this.calculateWeight();
  }
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(t) {
    (this._hdrCapacityMax = t), this.calculateWeight();
  }
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(t) {
    (this._maxDisplayBoost = Math.max(1, Math.min(65504, t))),
      this.calculateWeight();
  }
  calculateWeight() {
    const t =
      (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) /
      (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, t));
  }
}
class SB extends Error {}
class MB extends Error {}
const Hm = (i, t, e) => {
    const n = new RegExp(`${t}="([^"]*)"`, "i").exec(i);
    if (n) return n[1];
    const a = new RegExp(`<${t}[^>]*>([\\s\\S]*?)</${t}>`, "i").exec(i);
    if (a) {
      const r = a[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
      return r && r.length === 3
        ? r.map((l) => l.replace(/<\/?rdf:li>/g, ""))
        : a[1].trim();
    }
    if (e !== void 0) return e;
    throw new Error(`Can't find ${t} in gainmap metadata`);
  },
  G8 = (i) => {
    let t;
    typeof TextDecoder < "u"
      ? (t = new TextDecoder().decode(i))
      : (t = i.toString());
    let e = t.indexOf("<x:xmpmeta");
    for (; e !== -1; ) {
      const n = t.indexOf("x:xmpmeta>", e),
        a = t.slice(e, n + 10);
      try {
        const r = Hm(a, "hdrgm:GainMapMin", "0"),
          l = Hm(a, "hdrgm:GainMapMax"),
          u = Hm(a, "hdrgm:Gamma", "1"),
          h = Hm(a, "hdrgm:OffsetSDR", "0.015625"),
          p = Hm(a, "hdrgm:OffsetHDR", "0.015625"),
          m = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(a),
          v = m ? m[1] : "0",
          x = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(a);
        if (!x) throw new Error("Incomplete gainmap metadata");
        const _ = x[1];
        return {
          gainMapMin: Array.isArray(r)
            ? r.map((M) => parseFloat(M))
            : [parseFloat(r), parseFloat(r), parseFloat(r)],
          gainMapMax: Array.isArray(l)
            ? l.map((M) => parseFloat(M))
            : [parseFloat(l), parseFloat(l), parseFloat(l)],
          gamma: Array.isArray(u)
            ? u.map((M) => parseFloat(M))
            : [parseFloat(u), parseFloat(u), parseFloat(u)],
          offsetSdr: Array.isArray(h)
            ? h.map((M) => parseFloat(M))
            : [parseFloat(h), parseFloat(h), parseFloat(h)],
          offsetHdr: Array.isArray(p)
            ? p.map((M) => parseFloat(M))
            : [parseFloat(p), parseFloat(p), parseFloat(p)],
          hdrCapacityMin: parseFloat(v),
          hdrCapacityMax: parseFloat(_),
        };
      } catch {}
      e = t.indexOf("<x:xmpmeta", n);
    }
  };
class V8 {
  constructor(t) {
    this.options = {
      debug: t && t.debug !== void 0 ? t.debug : !1,
      extractFII: t && t.extractFII !== void 0 ? t.extractFII : !0,
      extractNonFII: t && t.extractNonFII !== void 0 ? t.extractNonFII : !0,
    };
  }
  extract(t) {
    return new Promise((e, n) => {
      const a = this.options.debug,
        r = new DataView(t.buffer);
      if (r.getUint16(0) !== 65496) {
        n(new Error("Not a valid jpeg"));
        return;
      }
      const l = r.byteLength;
      let u = 2,
        h = 0,
        p;
      for (; u < l; ) {
        if (++h > 250) {
          n(new Error(`Found no marker after ${h} loops `));
          return;
        }
        if (r.getUint8(u) !== 255) {
          n(
            new Error(
              `Not a valid marker at offset 0x${u.toString(16)}, found: 0x${r
                .getUint8(u)
                .toString(16)}`
            )
          );
          return;
        }
        if (
          ((p = r.getUint8(u + 1)),
          a && console.log(`Marker: ${p.toString(16)}`),
          p === 226)
        ) {
          a && console.log("Found APP2 marker (0xffe2)");
          const m = u + 4;
          if (r.getUint32(m) === 1297106432) {
            const v = m + 4;
            let x;
            if (r.getUint16(v) === 18761) x = !1;
            else if (r.getUint16(v) === 19789) x = !0;
            else {
              n(new Error("No valid endianness marker found in TIFF header"));
              return;
            }
            if (r.getUint16(v + 2, !x) !== 42) {
              n(new Error("Not valid TIFF data! (no 0x002A marker)"));
              return;
            }
            const _ = r.getUint32(v + 4, !x);
            if (_ < 8) {
              n(new Error("Not valid TIFF data! (First offset less than 8)"));
              return;
            }
            const M = v + _,
              C = r.getUint16(M, !x),
              E = M + 2;
            let S = 0;
            for (let I = E; I < E + 12 * C; I += 12)
              r.getUint16(I, !x) === 45057 && (S = r.getUint32(I + 8, !x));
            const B = M + 2 + C * 12 + 4,
              D = [];
            for (let I = B; I < B + S * 16; I += 16) {
              const P = {
                MPType: r.getUint32(I, !x),
                size: r.getUint32(I + 4, !x),
                dataOffset: r.getUint32(I + 8, !x),
                dependantImages: r.getUint32(I + 12, !x),
                start: -1,
                end: -1,
                isFII: !1,
              };
              P.dataOffset
                ? ((P.start = v + P.dataOffset), (P.isFII = !1))
                : ((P.start = 0), (P.isFII = !0)),
                (P.end = P.start + P.size),
                D.push(P);
            }
            if (this.options.extractNonFII && D.length) {
              const I = new Blob([r]),
                P = [];
              for (const V of D) {
                if (V.isFII && !this.options.extractFII) continue;
                const F = I.slice(V.start, V.end + 1, "image/jpeg");
                P.push(F);
              }
              e(P);
            }
          }
        }
        u += 2 + r.getUint16(u + 2);
      }
    });
  }
}
const k8 = async (i) => {
    const t = G8(i);
    if (!t) throw new MB("Gain map XMP metadata not found");
    const n = await new V8({ extractFII: !0, extractNonFII: !0 }).extract(i);
    if (n.length !== 2) throw new SB("Gain map recovery image not found");
    return {
      sdr: new Uint8Array(await n[0].arrayBuffer()),
      gainMap: new Uint8Array(await n[1].arrayBuffer()),
      metadata: t,
    };
  },
  Aw = (i) =>
    new Promise((t, e) => {
      const n = document.createElement("img");
      (n.onload = () => {
        t(n);
      }),
        (n.onerror = (a) => {
          e(a);
        }),
        (n.src = URL.createObjectURL(i));
    });
class EB extends Va {
  constructor(t, e) {
    super(e),
      t && (this._renderer = t),
      (this._internalLoadingManager = new l1());
  }
  setRenderer(t) {
    return (this._renderer = t), this;
  }
  setRenderTargetOptions(t) {
    return (this._renderTargetOptions = t), this;
  }
  prepareQuadRenderer() {
    this._renderer ||
      console.warn(
        "WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer."
      );
    const t = new H8({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Zn(),
      sdr: new Zn(),
    });
    return new US({
      width: 16,
      height: 16,
      type: Ea,
      colorSpace: bo,
      material: t,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions,
    });
  }
  async render(t, e, n, a) {
    const r = a ? new Blob([a], { type: "image/jpeg" }) : void 0,
      l = new Blob([n], { type: "image/jpeg" });
    let u,
      h,
      p = !1;
    if (typeof createImageBitmap > "u") {
      const x = await Promise.all([r ? Aw(r) : Promise.resolve(void 0), Aw(l)]);
      (h = x[0]), (u = x[1]), (p = !0);
    } else {
      const x = await Promise.all([
        r
          ? createImageBitmap(r, { imageOrientation: "flipY" })
          : Promise.resolve(void 0),
        createImageBitmap(l, { imageOrientation: "flipY" }),
      ]);
      (h = x[0]), (u = x[1]);
    }
    const m = new Zn(
      h || new ImageData(2, 2),
      cu,
      Ki,
      Ki,
      Kn,
      Fb,
      Ji,
      Es,
      1,
      bo
    );
    (m.flipY = p), (m.needsUpdate = !0);
    const v = new Zn(u, cu, Ki, Ki, Kn, Fb, Ji, Es, 1, Fa);
    (v.flipY = p),
      (v.needsUpdate = !0),
      (t.width = u.width),
      (t.height = u.height),
      (t.material.gainMap = m),
      (t.material.sdr = v),
      (t.material.gainMapMin = e.gainMapMin),
      (t.material.gainMapMax = e.gainMapMax),
      (t.material.offsetHdr = e.offsetHdr),
      (t.material.offsetSdr = e.offsetSdr),
      (t.material.gamma = e.gamma),
      (t.material.hdrCapacityMin = e.hdrCapacityMin),
      (t.material.hdrCapacityMax = e.hdrCapacityMax),
      (t.material.maxDisplayBoost = Math.pow(2, e.hdrCapacityMax)),
      (t.material.needsUpdate = !0),
      t.render();
  }
}
class j8 extends EB {
  load([t, e, n], a, r, l) {
    const u = this.prepareQuadRenderer();
    let h, p, m;
    const v = async () => {
      if (h && p && m) {
        try {
          await this.render(u, m, h, p);
        } catch (N) {
          this.manager.itemError(t),
            this.manager.itemError(e),
            this.manager.itemError(n),
            typeof l == "function" && l(N),
            u.disposeOnDemandRenderer();
          return;
        }
        typeof a == "function" && a(u),
          this.manager.itemEnd(t),
          this.manager.itemEnd(e),
          this.manager.itemEnd(n),
          u.disposeOnDemandRenderer();
      }
    };
    let x = !0,
      _ = 0,
      M = 0,
      C = !0,
      E = 0,
      S = 0,
      R = !0,
      B = 0,
      D = 0;
    const I = () => {
      if (typeof r == "function") {
        const N = _ + E + B,
          L = M + S + D,
          Y = x && C && R;
        r(
          new ProgressEvent("progress", {
            lengthComputable: Y,
            loaded: L,
            total: N,
          })
        );
      }
    };
    this.manager.itemStart(t),
      this.manager.itemStart(e),
      this.manager.itemStart(n);
    const P = new Ga(this._internalLoadingManager);
    P.setResponseType("arraybuffer"),
      P.setRequestHeader(this.requestHeader),
      P.setPath(this.path),
      P.setWithCredentials(this.withCredentials),
      P.load(
        t,
        async (N) => {
          if (typeof N == "string") throw new Error("Invalid sdr buffer");
          (h = N), await v();
        },
        (N) => {
          (x = N.lengthComputable), (M = N.loaded), (_ = N.total), I();
        },
        (N) => {
          this.manager.itemError(t), typeof l == "function" && l(N);
        }
      );
    const V = new Ga(this._internalLoadingManager);
    V.setResponseType("arraybuffer"),
      V.setRequestHeader(this.requestHeader),
      V.setPath(this.path),
      V.setWithCredentials(this.withCredentials),
      V.load(
        e,
        async (N) => {
          if (typeof N == "string") throw new Error("Invalid gainmap buffer");
          (p = N), await v();
        },
        (N) => {
          (C = N.lengthComputable), (S = N.loaded), (E = N.total), I();
        },
        (N) => {
          this.manager.itemError(e), typeof l == "function" && l(N);
        }
      );
    const F = new Ga(this._internalLoadingManager);
    return (
      F.setRequestHeader(this.requestHeader),
      F.setPath(this.path),
      F.setWithCredentials(this.withCredentials),
      F.load(
        n,
        async (N) => {
          if (typeof N != "string") throw new Error("Invalid metadata string");
          (m = JSON.parse(N)), await v();
        },
        (N) => {
          (R = N.lengthComputable), (D = N.loaded), (B = N.total), I();
        },
        (N) => {
          this.manager.itemError(n), typeof l == "function" && l(N);
        }
      ),
      u
    );
  }
}
class X8 extends EB {
  load(t, e, n, a) {
    const r = this.prepareQuadRenderer(),
      l = new Ga(this._internalLoadingManager);
    return (
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setPath(this.path),
      l.setWithCredentials(this.withCredentials),
      this.manager.itemStart(t),
      l.load(
        t,
        async (u) => {
          if (typeof u == "string")
            throw new Error(
              "Invalid buffer, received [string], was expecting [ArrayBuffer]"
            );
          const h = new Uint8Array(u);
          let p, m, v;
          try {
            const x = await k8(h);
            (p = x.sdr), (m = x.gainMap), (v = x.metadata);
          } catch (x) {
            if (x instanceof MB || x instanceof SB)
              console.warn(
                `Failure to reconstruct an HDR image from ${t}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`
              ),
                (v = {
                  gainMapMin: [0, 0, 0],
                  gainMapMax: [1, 1, 1],
                  gamma: [1, 1, 1],
                  hdrCapacityMin: 0,
                  hdrCapacityMax: 1,
                  offsetHdr: [0, 0, 0],
                  offsetSdr: [0, 0, 0],
                }),
                (p = h);
            else throw x;
          }
          try {
            await this.render(r, v, p, m);
          } catch (x) {
            this.manager.itemError(t),
              typeof a == "function" && a(x),
              r.disposeOnDemandRenderer();
            return;
          }
          typeof e == "function" && e(r),
            this.manager.itemEnd(t),
            r.disposeOnDemandRenderer();
        },
        n,
        (u) => {
          this.manager.itemError(t), typeof a == "function" && a(u);
        }
      ),
      r
    );
  }
}
const _0 = {
    apartment: "lebombo_1k.hdr",
    city: "potsdamer_platz_1k.hdr",
    dawn: "kiara_1_dawn_1k.hdr",
    forest: "forest_slope_1k.hdr",
    lobby: "st_fagans_interior_1k.hdr",
    night: "dikhololo_night_1k.hdr",
    park: "rooitou_park_1k.hdr",
    studio: "studio_small_03_1k.hdr",
    sunset: "venice_sunset_1k.hdr",
    warehouse: "empty_warehouse_01_1k.hdr",
  },
  TB =
    "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
  Gd = (i) => Array.isArray(i),
  OS = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"];
function d1({
  files: i = OS,
  path: t = "",
  preset: e = void 0,
  colorSpace: n = void 0,
  extensions: a,
} = {}) {
  e && (NS(e), (i = _0[e]), (t = TB));
  const r = Gd(i),
    { extension: l, isCubemap: u } = LS(i),
    h = IS(l);
  if (!h) throw new Error("useEnvironment: Unrecognized file extension: " + i);
  const p = Gs((_) => _.gl);
  bt.useLayoutEffect(() => {
    if (l !== "webp" && l !== "jpg" && l !== "jpeg") return;
    function _() {
      ec.clear(h, r ? [i] : i);
    }
    p.domElement.addEventListener("webglcontextlost", _, { once: !0 });
  }, [i, p.domElement]);
  const m = ec(h, r ? [i] : i, (_) => {
    (l === "webp" || l === "jpg" || l === "jpeg") && _.setRenderer(p),
      _.setPath == null || _.setPath(t),
      a && a(_);
  });
  let v = r ? m[0] : m;
  if (l === "jpg" || l === "jpeg" || l === "webp") {
    var x;
    v = (x = v.renderTarget) == null ? void 0 : x.texture;
  }
  return (
    (v.mapping = u ? dl : Vd),
    (v.colorSpace = n ?? (u ? "srgb" : "srgb-linear")),
    v
  );
}
const W8 = { files: OS, path: "", preset: void 0, extensions: void 0 };
d1.preload = (i) => {
  const t = { ...W8, ...i };
  let { files: e, path: n = "" } = t;
  const { preset: a, extensions: r } = t;
  a && (NS(a), (e = _0[a]), (n = TB));
  const { extension: l } = LS(e);
  if (l === "webp" || l === "jpg" || l === "jpeg")
    throw new Error("useEnvironment: Preloading gainmaps is not supported");
  const u = IS(l);
  if (!u) throw new Error("useEnvironment: Unrecognized file extension: " + e);
  ec.preload(u, Gd(e) ? [e] : e, (h) => {
    h.setPath == null || h.setPath(n), r && r(h);
  });
};
const Y8 = { files: OS, preset: void 0 };
d1.clear = (i) => {
  const t = { ...Y8, ...i };
  let { files: e } = t;
  const { preset: n } = t;
  n && (NS(n), (e = _0[n]));
  const { extension: a } = LS(e),
    r = IS(a);
  if (!r) throw new Error("useEnvironment: Unrecognized file extension: " + e);
  ec.clear(r, Gd(e) ? [e] : e);
};
function NS(i) {
  if (!(i in _0))
    throw new Error("Preset must be one of: " + Object.keys(_0).join(", "));
}
function LS(i) {
  var t;
  const e = Gd(i) && i.length === 6,
    n = Gd(i) && i.length === 3 && i.some((l) => l.endsWith("json")),
    a = Gd(i) ? i[0] : i;
  return {
    extension: e
      ? "cube"
      : n
      ? "webp"
      : a.startsWith("data:application/exr")
      ? "exr"
      : a.startsWith("data:application/hdr")
      ? "hdr"
      : a.startsWith("data:image/jpeg")
      ? "jpg"
      : (t = a.split(".").pop()) == null ||
        (t = t.split("?")) == null ||
        (t = t.shift()) == null
      ? void 0
      : t.toLowerCase(),
    isCubemap: e,
    isGainmap: n,
  };
}
function IS(i) {
  return i === "cube"
    ? yR
    : i === "hdr"
    ? U8
    : i === "exr"
    ? O8
    : i === "jpg" || i === "jpeg"
    ? X8
    : i === "webp"
    ? j8
    : null;
}
const q8 = (i) => i.current && i.current.isScene,
  K8 = (i) => (q8(i) ? i.current : i);
function PS(i, t, e, n, a = {}) {
  var r, l, u, h;
  a = {
    backgroundBlurriness: 0,
    backgroundIntensity: 1,
    backgroundRotation: [0, 0, 0],
    environmentIntensity: 1,
    environmentRotation: [0, 0, 0],
    ...a,
  };
  const p = K8(t || e),
    m = p.background,
    v = p.environment,
    x = {
      backgroundBlurriness: p.backgroundBlurriness,
      backgroundIntensity: p.backgroundIntensity,
      backgroundRotation:
        (r =
          (l = p.backgroundRotation) == null || l.clone == null
            ? void 0
            : l.clone()) !== null && r !== void 0
          ? r
          : [0, 0, 0],
      environmentIntensity: p.environmentIntensity,
      environmentRotation:
        (u =
          (h = p.environmentRotation) == null || h.clone == null
            ? void 0
            : h.clone()) !== null && u !== void 0
          ? u
          : [0, 0, 0],
    };
  return (
    i !== "only" && (p.environment = n),
    i && (p.background = n),
    rl(p, a),
    () => {
      i !== "only" && (p.environment = v), i && (p.background = m), rl(p, x);
    }
  );
}
function zS({ scene: i, background: t = !1, map: e, ...n }) {
  const a = Gs((r) => r.scene);
  return (
    bt.useLayoutEffect(() => {
      if (e) return PS(t, i, a, e, n);
    }),
    null
  );
}
function wB({
  background: i = !1,
  scene: t,
  blur: e,
  backgroundBlurriness: n,
  backgroundIntensity: a,
  backgroundRotation: r,
  environmentIntensity: l,
  environmentRotation: u,
  ...h
}) {
  const p = d1(h),
    m = Gs((v) => v.scene);
  return (
    bt.useLayoutEffect(() =>
      PS(i, t, m, p, {
        backgroundBlurriness: e ?? n,
        backgroundIntensity: a,
        backgroundRotation: r,
        environmentIntensity: l,
        environmentRotation: u,
      })
    ),
    bt.useEffect(
      () => () => {
        p.dispose();
      },
      [p]
    ),
    null
  );
}
function J8({
  children: i,
  near: t = 0.1,
  far: e = 1e3,
  resolution: n = 256,
  frames: a = 1,
  map: r,
  background: l = !1,
  blur: u,
  backgroundBlurriness: h,
  backgroundIntensity: p,
  backgroundRotation: m,
  environmentIntensity: v,
  environmentRotation: x,
  scene: _,
  files: M,
  path: C,
  preset: E = void 0,
  extensions: S,
}) {
  const R = Gs((F) => F.gl),
    B = Gs((F) => F.scene),
    D = bt.useRef(null),
    [I] = bt.useState(() => new N0()),
    P = bt.useMemo(() => {
      const F = new jA(n);
      return (F.texture.type = Ea), F;
    }, [n]);
  bt.useEffect(
    () => () => {
      P.dispose();
    },
    [P]
  ),
    bt.useLayoutEffect(() => {
      if (a === 1) {
        const F = R.autoClear;
        (R.autoClear = !0), D.current.update(R, I), (R.autoClear = F);
      }
      return PS(l, _, B, P.texture, {
        backgroundBlurriness: u ?? h,
        backgroundIntensity: p,
        backgroundRotation: m,
        environmentIntensity: v,
        environmentRotation: x,
      });
    }, [i, I, P.texture, _, B, l, a, R]);
  let V = 1;
  return (
    f1(() => {
      if (a === 1 / 0 || V < a) {
        const F = R.autoClear;
        (R.autoClear = !0), D.current.update(R, I), (R.autoClear = F), V++;
      }
    }),
    bt.createElement(
      bt.Fragment,
      null,
      iF(
        bt.createElement(
          bt.Fragment,
          null,
          i,
          bt.createElement("cubeCamera", { ref: D, args: [t, e, P] }),
          M || E
            ? bt.createElement(wB, {
                background: !0,
                files: M,
                preset: E,
                path: C,
                extensions: S,
              })
            : r
            ? bt.createElement(zS, { background: !0, map: r, extensions: S })
            : null
        ),
        I
      )
    )
  );
}
function Z8(i) {
  var t, e, n, a;
  const r = d1(i),
    l = i.map || r;
  bt.useMemo(() => eB({ GroundProjectedEnvImpl: zF }), []),
    bt.useEffect(
      () => () => {
        r.dispose();
      },
      [r]
    );
  const u = bt.useMemo(() => [l], [l]),
    h = (t = i.ground) == null ? void 0 : t.height,
    p = (e = i.ground) == null ? void 0 : e.radius,
    m =
      (n = (a = i.ground) == null ? void 0 : a.scale) !== null && n !== void 0
        ? n
        : 1e3;
  return bt.createElement(
    bt.Fragment,
    null,
    bt.createElement(zS, x0({}, i, { map: l })),
    bt.createElement("groundProjectedEnvImpl", {
      args: u,
      scale: m,
      height: h,
      radius: p,
    })
  );
}
function Sw(i) {
  return i.ground
    ? bt.createElement(Z8, i)
    : i.map
    ? bt.createElement(zS, i)
    : i.children
    ? bt.createElement(J8, i)
    : bt.createElement(wB, i);
}
const CB = bt.createContext({});
function RB(i) {
  const t = bt.useRef(null);
  return t.current === null && (t.current = i()), t.current;
}
const FS = typeof window < "u",
  BB = FS ? bt.useLayoutEffect : bt.useEffect,
  HS = bt.createContext(null);
function GS(i, t) {
  i.indexOf(t) === -1 && i.push(t);
}
function VS(i, t) {
  const e = i.indexOf(t);
  e > -1 && i.splice(e, 1);
}
const nc = (i, t, e) => (e > t ? t : e < i ? i : e);
let kS = () => {};
const ic = {},
  DB = (i) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(i);
function UB(i) {
  return typeof i == "object" && i !== null;
}
const OB = (i) => /^0[^.\s]+$/u.test(i);
function jS(i) {
  let t;
  return () => (t === void 0 && (t = i()), t);
}
const Pr = (i) => i,
  Q8 = (i, t) => (e) => t(i(e)),
  Y0 = (...i) => i.reduce(Q8),
  b0 = (i, t, e) => {
    const n = t - i;
    return n === 0 ? 1 : (e - i) / n;
  };
class XS {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return GS(this.subscriptions, t), () => VS(this.subscriptions, t);
  }
  notify(t, e, n) {
    const a = this.subscriptions.length;
    if (a)
      if (a === 1) this.subscriptions[0](t, e, n);
      else
        for (let r = 0; r < a; r++) {
          const l = this.subscriptions[r];
          l && l(t, e, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const cl = (i) => i * 1e3,
  ul = (i) => i / 1e3;
function NB(i, t) {
  return t ? i * (1e3 / t) : 0;
}
const LB = (i, t, e) =>
    (((1 - 3 * e + 3 * t) * i + (3 * e - 6 * t)) * i + 3 * t) * i,
  $8 = 1e-7,
  tH = 12;
function eH(i, t, e, n, a) {
  let r,
    l,
    u = 0;
  do (l = t + (e - t) / 2), (r = LB(l, n, a) - i), r > 0 ? (e = l) : (t = l);
  while (Math.abs(r) > $8 && ++u < tH);
  return l;
}
function q0(i, t, e, n) {
  if (i === t && e === n) return Pr;
  const a = (r) => eH(r, 0, 1, i, e);
  return (r) => (r === 0 || r === 1 ? r : LB(a(r), t, n));
}
const IB = (i) => (t) => t <= 0.5 ? i(2 * t) / 2 : (2 - i(2 * (1 - t))) / 2,
  PB = (i) => (t) => 1 - i(1 - t),
  zB = q0(0.33, 1.53, 0.69, 0.99),
  WS = PB(zB),
  FB = IB(WS),
  HB = (i) =>
    (i *= 2) < 1 ? 0.5 * WS(i) : 0.5 * (2 - Math.pow(2, -10 * (i - 1))),
  YS = (i) => 1 - Math.sin(Math.acos(i)),
  GB = PB(YS),
  VB = IB(YS),
  nH = q0(0.42, 0, 1, 1),
  iH = q0(0, 0, 0.58, 1),
  kB = q0(0.42, 0, 0.58, 1),
  aH = (i) => Array.isArray(i) && typeof i[0] != "number",
  jB = (i) => Array.isArray(i) && typeof i[0] == "number",
  sH = {
    linear: Pr,
    easeIn: nH,
    easeInOut: kB,
    easeOut: iH,
    circIn: YS,
    circInOut: VB,
    circOut: GB,
    backIn: WS,
    backInOut: FB,
    backOut: zB,
    anticipate: HB,
  },
  rH = (i) => typeof i == "string",
  Mw = (i) => {
    if (jB(i)) {
      kS(i.length === 4);
      const [t, e, n, a] = i;
      return q0(t, e, n, a);
    } else if (rH(i)) return sH[i];
    return i;
  },
  Ay = [
    "setup",
    "read",
    "resolveKeyframes",
    "preUpdate",
    "update",
    "preRender",
    "render",
    "postRender",
  ];
function oH(i, t) {
  let e = new Set(),
    n = new Set(),
    a = !1,
    r = !1;
  const l = new WeakSet();
  let u = { delta: 0, timestamp: 0, isProcessing: !1 };
  function h(m) {
    l.has(m) && (p.schedule(m), i()), m(u);
  }
  const p = {
    schedule: (m, v = !1, x = !1) => {
      const M = x && a ? e : n;
      return v && l.add(m), M.has(m) || M.add(m), m;
    },
    cancel: (m) => {
      n.delete(m), l.delete(m);
    },
    process: (m) => {
      if (((u = m), a)) {
        r = !0;
        return;
      }
      (a = !0),
        ([e, n] = [n, e]),
        e.forEach(h),
        e.clear(),
        (a = !1),
        r && ((r = !1), p.process(m));
    },
  };
  return p;
}
const lH = 40;
function XB(i, t) {
  let e = !1,
    n = !0;
  const a = { delta: 0, timestamp: 0, isProcessing: !1 },
    r = () => (e = !0),
    l = Ay.reduce((B, D) => ((B[D] = oH(r)), B), {}),
    {
      setup: u,
      read: h,
      resolveKeyframes: p,
      preUpdate: m,
      update: v,
      preRender: x,
      render: _,
      postRender: M,
    } = l,
    C = () => {
      const B = ic.useManualTiming ? a.timestamp : performance.now();
      (e = !1),
        ic.useManualTiming ||
          (a.delta = n ? 1e3 / 60 : Math.max(Math.min(B - a.timestamp, lH), 1)),
        (a.timestamp = B),
        (a.isProcessing = !0),
        u.process(a),
        h.process(a),
        p.process(a),
        m.process(a),
        v.process(a),
        x.process(a),
        _.process(a),
        M.process(a),
        (a.isProcessing = !1),
        e && t && ((n = !1), i(C));
    },
    E = () => {
      (e = !0), (n = !0), a.isProcessing || i(C);
    };
  return {
    schedule: Ay.reduce((B, D) => {
      const I = l[D];
      return (B[D] = (P, V = !1, F = !1) => (e || E(), I.schedule(P, V, F))), B;
    }, {}),
    cancel: (B) => {
      for (let D = 0; D < Ay.length; D++) l[Ay[D]].cancel(B);
    },
    state: a,
    steps: l,
  };
}
const {
  schedule: wi,
  cancel: mu,
  state: za,
  steps: vb,
} = XB(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Pr, !0);
let By;
function cH() {
  By = void 0;
}
const js = {
    now: () => (
      By === void 0 &&
        js.set(
          za.isProcessing || ic.useManualTiming
            ? za.timestamp
            : performance.now()
        ),
      By
    ),
    set: (i) => {
      (By = i), queueMicrotask(cH);
    },
  },
  WB = (i) => (t) => typeof t == "string" && t.startsWith(i),
  qS = WB("--"),
  uH = WB("var(--"),
  KS = (i) => (uH(i) ? fH.test(i.split("/*")[0].trim()) : !1),
  fH =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  lp = {
    test: (i) => typeof i == "number",
    parse: parseFloat,
    transform: (i) => i,
  },
  A0 = { ...lp, transform: (i) => nc(0, 1, i) },
  Sy = { ...lp, default: 1 },
  i0 = (i) => Math.round(i * 1e5) / 1e5,
  JS = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function hH(i) {
  return i == null;
}
const dH =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  ZS = (i, t) => (e) =>
    !!(
      (typeof e == "string" && dH.test(e) && e.startsWith(i)) ||
      (t && !hH(e) && Object.prototype.hasOwnProperty.call(e, t))
    ),
  YB = (i, t, e) => (n) => {
    if (typeof n != "string") return n;
    const [a, r, l, u] = n.match(JS);
    return {
      [i]: parseFloat(a),
      [t]: parseFloat(r),
      [e]: parseFloat(l),
      alpha: u !== void 0 ? parseFloat(u) : 1,
    };
  },
  pH = (i) => nc(0, 255, i),
  yb = { ...lp, transform: (i) => Math.round(pH(i)) },
  kf = {
    test: ZS("rgb", "red"),
    parse: YB("red", "green", "blue"),
    transform: ({ red: i, green: t, blue: e, alpha: n = 1 }) =>
      "rgba(" +
      yb.transform(i) +
      ", " +
      yb.transform(t) +
      ", " +
      yb.transform(e) +
      ", " +
      i0(A0.transform(n)) +
      ")",
  };
function mH(i) {
  let t = "",
    e = "",
    n = "",
    a = "";
  return (
    i.length > 5
      ? ((t = i.substring(1, 3)),
        (e = i.substring(3, 5)),
        (n = i.substring(5, 7)),
        (a = i.substring(7, 9)))
      : ((t = i.substring(1, 2)),
        (e = i.substring(2, 3)),
        (n = i.substring(3, 4)),
        (a = i.substring(4, 5)),
        (t += t),
        (e += e),
        (n += n),
        (a += a)),
    {
      red: parseInt(t, 16),
      green: parseInt(e, 16),
      blue: parseInt(n, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1,
    }
  );
}
const oA = { test: ZS("#"), parse: mH, transform: kf.transform },
  K0 = (i) => ({
    test: (t) =>
      typeof t == "string" && t.endsWith(i) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: (t) => `${t}${i}`,
  }),
  au = K0("deg"),
  fl = K0("%"),
  rn = K0("px"),
  gH = K0("vh"),
  vH = K0("vw"),
  Ew = {
    ...fl,
    parse: (i) => fl.parse(i) / 100,
    transform: (i) => fl.transform(i * 100),
  },
  Ud = {
    test: ZS("hsl", "hue"),
    parse: YB("hue", "saturation", "lightness"),
    transform: ({ hue: i, saturation: t, lightness: e, alpha: n = 1 }) =>
      "hsla(" +
      Math.round(i) +
      ", " +
      fl.transform(i0(t)) +
      ", " +
      fl.transform(i0(e)) +
      ", " +
      i0(A0.transform(n)) +
      ")",
  },
  aa = {
    test: (i) => kf.test(i) || oA.test(i) || Ud.test(i),
    parse: (i) =>
      kf.test(i) ? kf.parse(i) : Ud.test(i) ? Ud.parse(i) : oA.parse(i),
    transform: (i) =>
      typeof i == "string"
        ? i
        : i.hasOwnProperty("red")
        ? kf.transform(i)
        : Ud.transform(i),
    getAnimatableNone: (i) => {
      const t = aa.parse(i);
      return (t.alpha = 0), aa.transform(t);
    },
  },
  yH =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function xH(i) {
  return (
    isNaN(i) &&
    typeof i == "string" &&
    (i.match(JS)?.length || 0) + (i.match(yH)?.length || 0) > 0
  );
}
const qB = "number",
  KB = "color",
  _H = "var",
  bH = "var(",
  Tw = "${}",
  AH =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function S0(i) {
  const t = i.toString(),
    e = [],
    n = { color: [], number: [], var: [] },
    a = [];
  let r = 0;
  const u = t
    .replace(
      AH,
      (h) => (
        aa.test(h)
          ? (n.color.push(r), a.push(KB), e.push(aa.parse(h)))
          : h.startsWith(bH)
          ? (n.var.push(r), a.push(_H), e.push(h))
          : (n.number.push(r), a.push(qB), e.push(parseFloat(h))),
        ++r,
        Tw
      )
    )
    .split(Tw);
  return { values: e, split: u, indexes: n, types: a };
}
function JB(i) {
  return S0(i).values;
}
function ZB(i) {
  const { split: t, types: e } = S0(i),
    n = t.length;
  return (a) => {
    let r = "";
    for (let l = 0; l < n; l++)
      if (((r += t[l]), a[l] !== void 0)) {
        const u = e[l];
        u === qB
          ? (r += i0(a[l]))
          : u === KB
          ? (r += aa.transform(a[l]))
          : (r += a[l]);
      }
    return r;
  };
}
const SH = (i) =>
  typeof i == "number" ? 0 : aa.test(i) ? aa.getAnimatableNone(i) : i;
function MH(i) {
  const t = JB(i);
  return ZB(i)(t.map(SH));
}
const gu = {
  test: xH,
  parse: JB,
  createTransformer: ZB,
  getAnimatableNone: MH,
};
function xb(i, t, e) {
  return (
    e < 0 && (e += 1),
    e > 1 && (e -= 1),
    e < 1 / 6
      ? i + (t - i) * 6 * e
      : e < 1 / 2
      ? t
      : e < 2 / 3
      ? i + (t - i) * (2 / 3 - e) * 6
      : i
  );
}
function EH({ hue: i, saturation: t, lightness: e, alpha: n }) {
  (i /= 360), (t /= 100), (e /= 100);
  let a = 0,
    r = 0,
    l = 0;
  if (!t) a = r = l = e;
  else {
    const u = e < 0.5 ? e * (1 + t) : e + t - e * t,
      h = 2 * e - u;
    (a = xb(h, u, i + 1 / 3)), (r = xb(h, u, i)), (l = xb(h, u, i - 1 / 3));
  }
  return {
    red: Math.round(a * 255),
    green: Math.round(r * 255),
    blue: Math.round(l * 255),
    alpha: n,
  };
}
function wx(i, t) {
  return (e) => (e > 0 ? t : i);
}
const Ii = (i, t, e) => i + (t - i) * e,
  _b = (i, t, e) => {
    const n = i * i,
      a = e * (t * t - n) + n;
    return a < 0 ? 0 : Math.sqrt(a);
  },
  TH = [oA, kf, Ud],
  wH = (i) => TH.find((t) => t.test(i));
function ww(i) {
  const t = wH(i);
  if (!t) return !1;
  let e = t.parse(i);
  return t === Ud && (e = EH(e)), e;
}
const Cw = (i, t) => {
    const e = ww(i),
      n = ww(t);
    if (!e || !n) return wx(i, t);
    const a = { ...e };
    return (r) => (
      (a.red = _b(e.red, n.red, r)),
      (a.green = _b(e.green, n.green, r)),
      (a.blue = _b(e.blue, n.blue, r)),
      (a.alpha = Ii(e.alpha, n.alpha, r)),
      kf.transform(a)
    );
  },
  lA = new Set(["none", "hidden"]);
function CH(i, t) {
  return lA.has(i) ? (e) => (e <= 0 ? i : t) : (e) => (e >= 1 ? t : i);
}
function RH(i, t) {
  return (e) => Ii(i, t, e);
}
function QS(i) {
  return typeof i == "number"
    ? RH
    : typeof i == "string"
    ? KS(i)
      ? wx
      : aa.test(i)
      ? Cw
      : UH
    : Array.isArray(i)
    ? QB
    : typeof i == "object"
    ? aa.test(i)
      ? Cw
      : BH
    : wx;
}
function QB(i, t) {
  const e = [...i],
    n = e.length,
    a = i.map((r, l) => QS(r)(r, t[l]));
  return (r) => {
    for (let l = 0; l < n; l++) e[l] = a[l](r);
    return e;
  };
}
function BH(i, t) {
  const e = { ...i, ...t },
    n = {};
  for (const a in e)
    i[a] !== void 0 && t[a] !== void 0 && (n[a] = QS(i[a])(i[a], t[a]));
  return (a) => {
    for (const r in n) e[r] = n[r](a);
    return e;
  };
}
function DH(i, t) {
  const e = [],
    n = { color: 0, var: 0, number: 0 };
  for (let a = 0; a < t.values.length; a++) {
    const r = t.types[a],
      l = i.indexes[r][n[r]],
      u = i.values[l] ?? 0;
    (e[a] = u), n[r]++;
  }
  return e;
}
const UH = (i, t) => {
  const e = gu.createTransformer(t),
    n = S0(i),
    a = S0(t);
  return n.indexes.var.length === a.indexes.var.length &&
    n.indexes.color.length === a.indexes.color.length &&
    n.indexes.number.length >= a.indexes.number.length
    ? (lA.has(i) && !a.values.length) || (lA.has(t) && !n.values.length)
      ? CH(i, t)
      : Y0(QB(DH(n, a), a.values), e)
    : wx(i, t);
};
function $B(i, t, e) {
  return typeof i == "number" && typeof t == "number" && typeof e == "number"
    ? Ii(i, t, e)
    : QS(i)(i, t);
}
const OH = (i) => {
    const t = ({ timestamp: e }) => i(e);
    return {
      start: (e = !0) => wi.update(t, e),
      stop: () => mu(t),
      now: () => (za.isProcessing ? za.timestamp : js.now()),
    };
  },
  t3 = (i, t, e = 10) => {
    let n = "";
    const a = Math.max(Math.round(t / e), 2);
    for (let r = 0; r < a; r++)
      n += Math.round(i(r / (a - 1)) * 1e4) / 1e4 + ", ";
    return `linear(${n.substring(0, n.length - 2)})`;
  },
  Cx = 2e4;
function $S(i) {
  let t = 0;
  const e = 50;
  let n = i.next(t);
  for (; !n.done && t < Cx; ) (t += e), (n = i.next(t));
  return t >= Cx ? 1 / 0 : t;
}
function NH(i, t = 100, e) {
  const n = e({ ...i, keyframes: [0, t] }),
    a = Math.min($S(n), Cx);
  return {
    type: "keyframes",
    ease: (r) => n.next(a * r).value / t,
    duration: ul(a),
  };
}
const LH = 5;
function e3(i, t, e) {
  const n = Math.max(t - LH, 0);
  return NB(e - i(n), t - n);
}
const Vi = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  bb = 0.001;
function IH({
  duration: i = Vi.duration,
  bounce: t = Vi.bounce,
  velocity: e = Vi.velocity,
  mass: n = Vi.mass,
}) {
  let a,
    r,
    l = 1 - t;
  (l = nc(Vi.minDamping, Vi.maxDamping, l)),
    (i = nc(Vi.minDuration, Vi.maxDuration, ul(i))),
    l < 1
      ? ((a = (p) => {
          const m = p * l,
            v = m * i,
            x = m - e,
            _ = cA(p, l),
            M = Math.exp(-v);
          return bb - (x / _) * M;
        }),
        (r = (p) => {
          const v = p * l * i,
            x = v * e + e,
            _ = Math.pow(l, 2) * Math.pow(p, 2) * i,
            M = Math.exp(-v),
            C = cA(Math.pow(p, 2), l);
          return ((-a(p) + bb > 0 ? -1 : 1) * ((x - _) * M)) / C;
        }))
      : ((a = (p) => {
          const m = Math.exp(-p * i),
            v = (p - e) * i + 1;
          return -bb + m * v;
        }),
        (r = (p) => {
          const m = Math.exp(-p * i),
            v = (e - p) * (i * i);
          return m * v;
        }));
  const u = 5 / i,
    h = zH(a, r, u);
  if (((i = cl(i)), isNaN(h)))
    return { stiffness: Vi.stiffness, damping: Vi.damping, duration: i };
  {
    const p = Math.pow(h, 2) * n;
    return { stiffness: p, damping: l * 2 * Math.sqrt(n * p), duration: i };
  }
}
const PH = 12;
function zH(i, t, e) {
  let n = e;
  for (let a = 1; a < PH; a++) n = n - i(n) / t(n);
  return n;
}
function cA(i, t) {
  return i * Math.sqrt(1 - t * t);
}
const FH = ["duration", "bounce"],
  HH = ["stiffness", "damping", "mass"];
function Rw(i, t) {
  return t.some((e) => i[e] !== void 0);
}
function GH(i) {
  let t = {
    velocity: Vi.velocity,
    stiffness: Vi.stiffness,
    damping: Vi.damping,
    mass: Vi.mass,
    isResolvedFromDuration: !1,
    ...i,
  };
  if (!Rw(i, HH) && Rw(i, FH))
    if (i.visualDuration) {
      const e = i.visualDuration,
        n = (2 * Math.PI) / (e * 1.2),
        a = n * n,
        r = 2 * nc(0.05, 1, 1 - (i.bounce || 0)) * Math.sqrt(a);
      t = { ...t, mass: Vi.mass, stiffness: a, damping: r };
    } else {
      const e = IH(i);
      (t = { ...t, ...e, mass: Vi.mass }), (t.isResolvedFromDuration = !0);
    }
  return t;
}
function Rx(i = Vi.visualDuration, t = Vi.bounce) {
  const e =
    typeof i != "object"
      ? { visualDuration: i, keyframes: [0, 1], bounce: t }
      : i;
  let { restSpeed: n, restDelta: a } = e;
  const r = e.keyframes[0],
    l = e.keyframes[e.keyframes.length - 1],
    u = { done: !1, value: r },
    {
      stiffness: h,
      damping: p,
      mass: m,
      duration: v,
      velocity: x,
      isResolvedFromDuration: _,
    } = GH({ ...e, velocity: -ul(e.velocity || 0) }),
    M = x || 0,
    C = p / (2 * Math.sqrt(h * m)),
    E = l - r,
    S = ul(Math.sqrt(h / m)),
    R = Math.abs(E) < 5;
  n || (n = R ? Vi.restSpeed.granular : Vi.restSpeed.default),
    a || (a = R ? Vi.restDelta.granular : Vi.restDelta.default);
  let B;
  if (C < 1) {
    const I = cA(S, C);
    B = (P) => {
      const V = Math.exp(-C * S * P);
      return (
        l - V * (((M + C * S * E) / I) * Math.sin(I * P) + E * Math.cos(I * P))
      );
    };
  } else if (C === 1) B = (I) => l - Math.exp(-S * I) * (E + (M + S * E) * I);
  else {
    const I = S * Math.sqrt(C * C - 1);
    B = (P) => {
      const V = Math.exp(-C * S * P),
        F = Math.min(I * P, 300);
      return (
        l - (V * ((M + C * S * E) * Math.sinh(F) + I * E * Math.cosh(F))) / I
      );
    };
  }
  const D = {
    calculatedDuration: (_ && v) || null,
    next: (I) => {
      const P = B(I);
      if (_) u.done = I >= v;
      else {
        let V = I === 0 ? M : 0;
        C < 1 && (V = I === 0 ? cl(M) : e3(B, I, P));
        const F = Math.abs(V) <= n,
          N = Math.abs(l - P) <= a;
        u.done = F && N;
      }
      return (u.value = u.done ? l : P), u;
    },
    toString: () => {
      const I = Math.min($S(D), Cx),
        P = t3((V) => D.next(I * V).value, I, 30);
      return I + "ms " + P;
    },
    toTransition: () => {},
  };
  return D;
}
Rx.applyToOptions = (i) => {
  const t = NH(i, 100, Rx);
  return (
    (i.ease = t.ease), (i.duration = cl(t.duration)), (i.type = "keyframes"), i
  );
};
function uA({
  keyframes: i,
  velocity: t = 0,
  power: e = 0.8,
  timeConstant: n = 325,
  bounceDamping: a = 10,
  bounceStiffness: r = 500,
  modifyTarget: l,
  min: u,
  max: h,
  restDelta: p = 0.5,
  restSpeed: m,
}) {
  const v = i[0],
    x = { done: !1, value: v },
    _ = (F) => (u !== void 0 && F < u) || (h !== void 0 && F > h),
    M = (F) =>
      u === void 0
        ? h
        : h === void 0 || Math.abs(u - F) < Math.abs(h - F)
        ? u
        : h;
  let C = e * t;
  const E = v + C,
    S = l === void 0 ? E : l(E);
  S !== E && (C = S - v);
  const R = (F) => -C * Math.exp(-F / n),
    B = (F) => S + R(F),
    D = (F) => {
      const N = R(F),
        L = B(F);
      (x.done = Math.abs(N) <= p), (x.value = x.done ? S : L);
    };
  let I, P;
  const V = (F) => {
    _(x.value) &&
      ((I = F),
      (P = Rx({
        keyframes: [x.value, M(x.value)],
        velocity: e3(B, F, x.value),
        damping: a,
        stiffness: r,
        restDelta: p,
        restSpeed: m,
      })));
  };
  return (
    V(0),
    {
      calculatedDuration: null,
      next: (F) => {
        let N = !1;
        return (
          !P && I === void 0 && ((N = !0), D(F), V(F)),
          I !== void 0 && F >= I ? P.next(F - I) : (!N && D(F), x)
        );
      },
    }
  );
}
function VH(i, t, e) {
  const n = [],
    a = e || ic.mix || $B,
    r = i.length - 1;
  for (let l = 0; l < r; l++) {
    let u = a(i[l], i[l + 1]);
    if (t) {
      const h = Array.isArray(t) ? t[l] || Pr : t;
      u = Y0(h, u);
    }
    n.push(u);
  }
  return n;
}
function kH(i, t, { clamp: e = !0, ease: n, mixer: a } = {}) {
  const r = i.length;
  if ((kS(r === t.length), r === 1)) return () => t[0];
  if (r === 2 && t[0] === t[1]) return () => t[1];
  const l = i[0] === i[1];
  i[0] > i[r - 1] && ((i = [...i].reverse()), (t = [...t].reverse()));
  const u = VH(t, n, a),
    h = u.length,
    p = (m) => {
      if (l && m < i[0]) return t[0];
      let v = 0;
      if (h > 1) for (; v < i.length - 2 && !(m < i[v + 1]); v++);
      const x = b0(i[v], i[v + 1], m);
      return u[v](x);
    };
  return e ? (m) => p(nc(i[0], i[r - 1], m)) : p;
}
function jH(i, t) {
  const e = i[i.length - 1];
  for (let n = 1; n <= t; n++) {
    const a = b0(0, t, n);
    i.push(Ii(e, 1, a));
  }
}
function XH(i) {
  const t = [0];
  return jH(t, i.length - 1), t;
}
function WH(i, t) {
  return i.map((e) => e * t);
}
function YH(i, t) {
  return i.map(() => t || kB).splice(0, i.length - 1);
}
function a0({
  duration: i = 300,
  keyframes: t,
  times: e,
  ease: n = "easeInOut",
}) {
  const a = aH(n) ? n.map(Mw) : Mw(n),
    r = { done: !1, value: t[0] },
    l = WH(e && e.length === t.length ? e : XH(t), i),
    u = kH(l, t, { ease: Array.isArray(a) ? a : YH(t, a) });
  return {
    calculatedDuration: i,
    next: (h) => ((r.value = u(h)), (r.done = h >= i), r),
  };
}
const qH = (i) => i !== null;
function tM(i, { repeat: t, repeatType: e = "loop" }, n, a = 1) {
  const r = i.filter(qH),
    u = a < 0 || (t && e !== "loop" && t % 2 === 1) ? 0 : r.length - 1;
  return !u || n === void 0 ? r[u] : n;
}
const KH = { decay: uA, inertia: uA, tween: a0, keyframes: a0, spring: Rx };
function n3(i) {
  typeof i.type == "string" && (i.type = KH[i.type]);
}
class eM {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  then(t, e) {
    return this.finished.then(t, e);
  }
}
const JH = (i) => i / 100;
class nM extends eM {
  constructor(t) {
    super(),
      (this.state = "idle"),
      (this.startTime = null),
      (this.isStopped = !1),
      (this.currentTime = 0),
      (this.holdTime = null),
      (this.playbackSpeed = 1),
      (this.stop = () => {
        const { motionValue: e } = this.options;
        e && e.updatedAt !== js.now() && this.tick(js.now()),
          (this.isStopped = !0),
          this.state !== "idle" && (this.teardown(), this.options.onStop?.());
      }),
      (this.options = t),
      this.initAnimation(),
      this.play(),
      t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    n3(t);
    const {
      type: e = a0,
      repeat: n = 0,
      repeatDelay: a = 0,
      repeatType: r,
      velocity: l = 0,
    } = t;
    let { keyframes: u } = t;
    const h = e || a0;
    h !== a0 &&
      typeof u[0] != "number" &&
      ((this.mixKeyframes = Y0(JH, $B(u[0], u[1]))), (u = [0, 100]));
    const p = h({ ...t, keyframes: u });
    r === "mirror" &&
      (this.mirroredGenerator = h({
        ...t,
        keyframes: [...u].reverse(),
        velocity: -l,
      })),
      p.calculatedDuration === null && (p.calculatedDuration = $S(p));
    const { calculatedDuration: m } = p;
    (this.calculatedDuration = m),
      (this.resolvedDuration = m + a),
      (this.totalDuration = this.resolvedDuration * (n + 1) - a),
      (this.generator = p);
  }
  updateTime(t) {
    const e = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null
      ? (this.currentTime = this.holdTime)
      : (this.currentTime = e);
  }
  tick(t, e = !1) {
    const {
      generator: n,
      totalDuration: a,
      mixKeyframes: r,
      mirroredGenerator: l,
      resolvedDuration: u,
      calculatedDuration: h,
    } = this;
    if (this.startTime === null) return n.next(0);
    const {
      delay: p = 0,
      keyframes: m,
      repeat: v,
      repeatType: x,
      repeatDelay: _,
      type: M,
      onUpdate: C,
      finalKeyframe: E,
    } = this.options;
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, t))
      : this.speed < 0 &&
        (this.startTime = Math.min(t - a / this.speed, this.startTime)),
      e ? (this.currentTime = t) : this.updateTime(t);
    const S = this.currentTime - p * (this.playbackSpeed >= 0 ? 1 : -1),
      R = this.playbackSpeed >= 0 ? S < 0 : S > a;
    (this.currentTime = Math.max(S, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = a);
    let B = this.currentTime,
      D = n;
    if (v) {
      const F = Math.min(this.currentTime, a) / u;
      let N = Math.floor(F),
        L = F % 1;
      !L && F >= 1 && (L = 1),
        L === 1 && N--,
        (N = Math.min(N, v + 1)),
        !!(N % 2) &&
          (x === "reverse"
            ? ((L = 1 - L), _ && (L -= _ / u))
            : x === "mirror" && (D = l)),
        (B = nc(0, 1, L) * u);
    }
    const I = R ? { done: !1, value: m[0] } : D.next(B);
    r && (I.value = r(I.value));
    let { done: P } = I;
    !R &&
      h !== null &&
      (P =
        this.playbackSpeed >= 0
          ? this.currentTime >= a
          : this.currentTime <= 0);
    const V =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && P));
    return (
      V && M !== uA && (I.value = tM(m, this.options, E, this.speed)),
      C && C(I.value),
      V && this.finish(),
      I
    );
  }
  then(t, e) {
    return this.finished.then(t, e);
  }
  get duration() {
    return ul(this.calculatedDuration);
  }
  get time() {
    return ul(this.currentTime);
  }
  set time(t) {
    (t = cl(t)),
      (this.currentTime = t),
      this.startTime === null ||
      this.holdTime !== null ||
      this.playbackSpeed === 0
        ? (this.holdTime = t)
        : this.driver &&
          (this.startTime = this.driver.now() - t / this.playbackSpeed),
      this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(js.now());
    const e = this.playbackSpeed !== t;
    (this.playbackSpeed = t), e && (this.time = ul(this.currentTime));
  }
  play() {
    if (this.isStopped) return;
    const { driver: t = OH, startTime: e } = this.options;
    this.driver || (this.driver = t((a) => this.tick(a))),
      this.options.onPlay?.();
    const n = this.driver.now();
    this.state === "finished"
      ? (this.updateFinished(), (this.startTime = n))
      : this.holdTime !== null
      ? (this.startTime = n - this.holdTime)
      : this.startTime || (this.startTime = e ?? n),
      this.state === "finished" &&
        this.speed < 0 &&
        (this.startTime += this.calculatedDuration),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start();
  }
  pause() {
    (this.state = "paused"),
      this.updateTime(js.now()),
      (this.holdTime = this.currentTime);
  }
  complete() {
    this.state !== "running" && this.play(),
      (this.state = "finished"),
      (this.holdTime = null);
  }
  finish() {
    this.notifyFinished(),
      this.teardown(),
      (this.state = "finished"),
      this.options.onComplete?.();
  }
  cancel() {
    (this.holdTime = null),
      (this.startTime = 0),
      this.tick(0),
      this.teardown(),
      this.options.onCancel?.();
  }
  teardown() {
    (this.state = "idle"),
      this.stopDriver(),
      (this.startTime = this.holdTime = null);
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(t) {
    return (this.startTime = 0), this.tick(t, !0);
  }
  attachTimeline(t) {
    return (
      this.options.allowFlatten &&
        ((this.options.type = "keyframes"),
        (this.options.ease = "linear"),
        this.initAnimation()),
      this.driver?.stop(),
      t.observe(this)
    );
  }
}
function ZH(i) {
  for (let t = 1; t < i.length; t++) i[t] ?? (i[t] = i[t - 1]);
}
const jf = (i) => (i * 180) / Math.PI,
  fA = (i) => {
    const t = jf(Math.atan2(i[1], i[0]));
    return hA(t);
  },
  QH = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (i) => (Math.abs(i[0]) + Math.abs(i[3])) / 2,
    rotate: fA,
    rotateZ: fA,
    skewX: (i) => jf(Math.atan(i[1])),
    skewY: (i) => jf(Math.atan(i[2])),
    skew: (i) => (Math.abs(i[1]) + Math.abs(i[2])) / 2,
  },
  hA = (i) => ((i = i % 360), i < 0 && (i += 360), i),
  Bw = fA,
  Dw = (i) => Math.sqrt(i[0] * i[0] + i[1] * i[1]),
  Uw = (i) => Math.sqrt(i[4] * i[4] + i[5] * i[5]),
  $H = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: Dw,
    scaleY: Uw,
    scale: (i) => (Dw(i) + Uw(i)) / 2,
    rotateX: (i) => hA(jf(Math.atan2(i[6], i[5]))),
    rotateY: (i) => hA(jf(Math.atan2(-i[2], i[0]))),
    rotateZ: Bw,
    rotate: Bw,
    skewX: (i) => jf(Math.atan(i[4])),
    skewY: (i) => jf(Math.atan(i[1])),
    skew: (i) => (Math.abs(i[1]) + Math.abs(i[4])) / 2,
  };
function dA(i) {
  return i.includes("scale") ? 1 : 0;
}
function pA(i, t) {
  if (!i || i === "none") return dA(t);
  const e = i.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let n, a;
  if (e) (n = $H), (a = e);
  else {
    const u = i.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    (n = QH), (a = u);
  }
  if (!a) return dA(t);
  const r = n[t],
    l = a[1].split(",").map(eG);
  return typeof r == "function" ? r(l) : l[r];
}
const tG = (i, t) => {
  const { transform: e = "none" } = getComputedStyle(i);
  return pA(e, t);
};
function eG(i) {
  return parseFloat(i.trim());
}
const cp = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  up = new Set(cp),
  Ow = (i) => i === lp || i === rn,
  nG = new Set(["x", "y", "z"]),
  iG = cp.filter((i) => !nG.has(i));
function aG(i) {
  const t = [];
  return (
    iG.forEach((e) => {
      const n = i.getValue(e);
      n !== void 0 &&
        (t.push([e, n.get()]), n.set(e.startsWith("scale") ? 1 : 0));
    }),
    t
  );
}
const qf = {
  width: ({ x: i }, { paddingLeft: t = "0", paddingRight: e = "0" }) =>
    i.max - i.min - parseFloat(t) - parseFloat(e),
  height: ({ y: i }, { paddingTop: t = "0", paddingBottom: e = "0" }) =>
    i.max - i.min - parseFloat(t) - parseFloat(e),
  top: (i, { top: t }) => parseFloat(t),
  left: (i, { left: t }) => parseFloat(t),
  bottom: ({ y: i }, { top: t }) => parseFloat(t) + (i.max - i.min),
  right: ({ x: i }, { left: t }) => parseFloat(t) + (i.max - i.min),
  x: (i, { transform: t }) => pA(t, "x"),
  y: (i, { transform: t }) => pA(t, "y"),
};
qf.translateX = qf.x;
qf.translateY = qf.y;
const Kf = new Set();
let mA = !1,
  gA = !1,
  vA = !1;
function i3() {
  if (gA) {
    const i = Array.from(Kf).filter((n) => n.needsMeasurement),
      t = new Set(i.map((n) => n.element)),
      e = new Map();
    t.forEach((n) => {
      const a = aG(n);
      a.length && (e.set(n, a), n.render());
    }),
      i.forEach((n) => n.measureInitialState()),
      t.forEach((n) => {
        n.render();
        const a = e.get(n);
        a &&
          a.forEach(([r, l]) => {
            n.getValue(r)?.set(l);
          });
      }),
      i.forEach((n) => n.measureEndState()),
      i.forEach((n) => {
        n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY);
      });
  }
  (gA = !1), (mA = !1), Kf.forEach((i) => i.complete(vA)), Kf.clear();
}
function a3() {
  Kf.forEach((i) => {
    i.readKeyframes(), i.needsMeasurement && (gA = !0);
  });
}
function sG() {
  (vA = !0), a3(), i3(), (vA = !1);
}
class iM {
  constructor(t, e, n, a, r, l = !1) {
    (this.state = "pending"),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.unresolvedKeyframes = [...t]),
      (this.onComplete = e),
      (this.name = n),
      (this.motionValue = a),
      (this.element = r),
      (this.isAsync = l);
  }
  scheduleResolve() {
    (this.state = "scheduled"),
      this.isAsync
        ? (Kf.add(this),
          mA || ((mA = !0), wi.read(a3), wi.resolveKeyframes(i3)))
        : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: t,
      name: e,
      element: n,
      motionValue: a,
    } = this;
    if (t[0] === null) {
      const r = a?.get(),
        l = t[t.length - 1];
      if (r !== void 0) t[0] = r;
      else if (n && e) {
        const u = n.readValue(e, l);
        u != null && (t[0] = u);
      }
      t[0] === void 0 && (t[0] = l), a && r === void 0 && a.set(t[0]);
    }
    ZH(t);
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(t = !1) {
    (this.state = "complete"),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t),
      Kf.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (Kf.delete(this), (this.state = "pending"));
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const rG = (i) => i.startsWith("--");
function oG(i, t, e) {
  rG(t) ? i.style.setProperty(t, e) : (i.style[t] = e);
}
const lG = jS(() => window.ScrollTimeline !== void 0),
  cG = {};
function uG(i, t) {
  const e = jS(i);
  return () => cG[t] ?? e();
}
const s3 = uG(() => {
    try {
      document
        .createElement("div")
        .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  Xm = ([i, t, e, n]) => `cubic-bezier(${i}, ${t}, ${e}, ${n})`,
  Nw = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Xm([0, 0.65, 0.55, 1]),
    circOut: Xm([0.55, 0, 1, 0.45]),
    backIn: Xm([0.31, 0.01, 0.66, -0.59]),
    backOut: Xm([0.33, 1.53, 0.69, 0.99]),
  };
function r3(i, t) {
  if (i)
    return typeof i == "function"
      ? s3()
        ? t3(i, t)
        : "ease-out"
      : jB(i)
      ? Xm(i)
      : Array.isArray(i)
      ? i.map((e) => r3(e, t) || Nw.easeOut)
      : Nw[i];
}
function fG(
  i,
  t,
  e,
  {
    delay: n = 0,
    duration: a = 300,
    repeat: r = 0,
    repeatType: l = "loop",
    ease: u = "easeOut",
    times: h,
  } = {},
  p = void 0
) {
  const m = { [t]: e };
  h && (m.offset = h);
  const v = r3(u, a);
  Array.isArray(v) && (m.easing = v);
  const x = {
    delay: n,
    duration: a,
    easing: Array.isArray(v) ? "linear" : v,
    fill: "both",
    iterations: r + 1,
    direction: l === "reverse" ? "alternate" : "normal",
  };
  return p && (x.pseudoElement = p), i.animate(m, x);
}
function o3(i) {
  return typeof i == "function" && "applyToOptions" in i;
}
function hG({ type: i, ...t }) {
  return o3(i) && s3()
    ? i.applyToOptions(t)
    : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class dG extends eM {
  constructor(t) {
    if ((super(), (this.finishedTime = null), (this.isStopped = !1), !t))
      return;
    const {
      element: e,
      name: n,
      keyframes: a,
      pseudoElement: r,
      allowFlatten: l = !1,
      finalKeyframe: u,
      onComplete: h,
    } = t;
    (this.isPseudoElement = !!r),
      (this.allowFlatten = l),
      (this.options = t),
      kS(typeof t.type != "string");
    const p = hG(t);
    (this.animation = fG(e, n, a, p, r)),
      p.autoplay === !1 && this.animation.pause(),
      (this.animation.onfinish = () => {
        if (((this.finishedTime = this.time), !r)) {
          const m = tM(a, this.options, u, this.speed);
          this.updateMotionValue ? this.updateMotionValue(m) : oG(e, n, m),
            this.animation.cancel();
        }
        h?.(), this.notifyFinished();
      });
  }
  play() {
    this.isStopped ||
      (this.animation.play(),
      this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {}
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" ||
      t === "finished" ||
      (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
      this.isPseudoElement || this.cancel());
  }
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.();
  }
  get duration() {
    const t = this.animation.effect?.getComputedTiming?.().duration || 0;
    return ul(Number(t));
  }
  get time() {
    return ul(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    (this.finishedTime = null), (this.animation.currentTime = cl(t));
  }
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), (this.animation.playbackRate = t);
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  attachTimeline({ timeline: t, observe: e }) {
    return (
      this.allowFlatten &&
        this.animation.effect?.updateTiming({ easing: "linear" }),
      (this.animation.onfinish = null),
      t && lG() ? ((this.animation.timeline = t), Pr) : e(this)
    );
  }
}
const l3 = { anticipate: HB, backInOut: FB, circInOut: VB };
function pG(i) {
  return i in l3;
}
function mG(i) {
  typeof i.ease == "string" && pG(i.ease) && (i.ease = l3[i.ease]);
}
const Lw = 10;
class gG extends dG {
  constructor(t) {
    mG(t),
      n3(t),
      super(t),
      t.startTime && (this.startTime = t.startTime),
      (this.options = t);
  }
  updateMotionValue(t) {
    const {
      motionValue: e,
      onUpdate: n,
      onComplete: a,
      element: r,
      ...l
    } = this.options;
    if (!e) return;
    if (t !== void 0) {
      e.set(t);
      return;
    }
    const u = new nM({ ...l, autoplay: !1 }),
      h = cl(this.finishedTime ?? this.time);
    e.setWithVelocity(u.sample(h - Lw).value, u.sample(h).value, Lw), u.stop();
  }
}
const Iw = (i, t) =>
  t === "zIndex"
    ? !1
    : !!(
        typeof i == "number" ||
        Array.isArray(i) ||
        (typeof i == "string" &&
          (gu.test(i) || i === "0") &&
          !i.startsWith("url("))
      );
function vG(i) {
  const t = i[0];
  if (i.length === 1) return !0;
  for (let e = 0; e < i.length; e++) if (i[e] !== t) return !0;
}
function yG(i, t, e, n) {
  const a = i[0];
  if (a === null) return !1;
  if (t === "display" || t === "visibility") return !0;
  const r = i[i.length - 1],
    l = Iw(a, t),
    u = Iw(r, t);
  return !l || !u ? !1 : vG(i) || ((e === "spring" || o3(e)) && n);
}
const xG = new Set(["opacity", "clipPath", "filter", "transform"]),
  _G = jS(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function bG(i) {
  const {
    motionValue: t,
    name: e,
    repeatDelay: n,
    repeatType: a,
    damping: r,
    type: l,
  } = i;
  if (!(t?.owner?.current instanceof HTMLElement)) return !1;
  const { onUpdate: h, transformTemplate: p } = t.owner.getProps();
  return (
    _G() &&
    e &&
    xG.has(e) &&
    (e !== "transform" || !p) &&
    !h &&
    !n &&
    a !== "mirror" &&
    r !== 0 &&
    l !== "inertia"
  );
}
const AG = 40;
class SG extends eM {
  constructor({
    autoplay: t = !0,
    delay: e = 0,
    type: n = "keyframes",
    repeat: a = 0,
    repeatDelay: r = 0,
    repeatType: l = "loop",
    keyframes: u,
    name: h,
    motionValue: p,
    element: m,
    ...v
  }) {
    super(),
      (this.stop = () => {
        this._animation && (this._animation.stop(), this.stopTimeline?.()),
          this.keyframeResolver?.cancel();
      }),
      (this.createdAt = js.now());
    const x = {
        autoplay: t,
        delay: e,
        type: n,
        repeat: a,
        repeatDelay: r,
        repeatType: l,
        name: h,
        motionValue: p,
        element: m,
        ...v,
      },
      _ = m?.KeyframeResolver || iM;
    (this.keyframeResolver = new _(
      u,
      (M, C, E) => this.onKeyframesResolved(M, C, x, !E),
      h,
      p,
      m
    )),
      this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, e, n, a) {
    this.keyframeResolver = void 0;
    const {
      name: r,
      type: l,
      velocity: u,
      delay: h,
      isHandoff: p,
      onUpdate: m,
    } = n;
    (this.resolvedAt = js.now()),
      yG(t, r, l, u) ||
        ((ic.instantAnimations || !h) && m?.(tM(t, n, e)),
        (t[0] = t[t.length - 1]),
        (n.duration = 0),
        (n.repeat = 0));
    const x = {
        startTime: a
          ? this.resolvedAt
            ? this.resolvedAt - this.createdAt > AG
              ? this.resolvedAt
              : this.createdAt
            : this.createdAt
          : void 0,
        finalKeyframe: e,
        ...n,
        keyframes: t,
      },
      _ =
        !p && bG(x)
          ? new gG({ ...x, element: x.motionValue.owner.current })
          : new nM(x);
    _.finished.then(() => this.notifyFinished()).catch(Pr),
      this.pendingTimeline &&
        ((this.stopTimeline = _.attachTimeline(this.pendingTimeline)),
        (this.pendingTimeline = void 0)),
      (this._animation = _);
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, e) {
    return this.finished.finally(t).then(() => {});
  }
  get animation() {
    return (
      this._animation || (this.keyframeResolver?.resume(), sG()),
      this._animation
    );
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return (
      this._animation
        ? (this.stopTimeline = this.animation.attachTimeline(t))
        : (this.pendingTimeline = t),
      () => this.stop()
    );
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
const MG = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function EG(i) {
  const t = MG.exec(i);
  if (!t) return [,];
  const [, e, n, a] = t;
  return [`--${e ?? n}`, a];
}
function c3(i, t, e = 1) {
  const [n, a] = EG(i);
  if (!n) return;
  const r = window.getComputedStyle(t).getPropertyValue(n);
  if (r) {
    const l = r.trim();
    return DB(l) ? parseFloat(l) : l;
  }
  return KS(a) ? c3(a, t, e + 1) : a;
}
function aM(i, t) {
  return i?.[t] ?? i?.default ?? i;
}
const u3 = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...cp,
  ]),
  TG = { test: (i) => i === "auto", parse: (i) => i },
  f3 = (i) => (t) => t.test(i),
  h3 = [lp, rn, fl, au, vH, gH, TG],
  Pw = (i) => h3.find(f3(i));
function wG(i) {
  return typeof i == "number"
    ? i === 0
    : i !== null
    ? i === "none" || i === "0" || OB(i)
    : !0;
}
const CG = new Set(["brightness", "contrast", "saturate", "opacity"]);
function RG(i) {
  const [t, e] = i.slice(0, -1).split("(");
  if (t === "drop-shadow") return i;
  const [n] = e.match(JS) || [];
  if (!n) return i;
  const a = e.replace(n, "");
  let r = CG.has(t) ? 1 : 0;
  return n !== e && (r *= 100), t + "(" + r + a + ")";
}
const BG = /\b([a-z-]*)\(.*?\)/gu,
  yA = {
    ...gu,
    getAnimatableNone: (i) => {
      const t = i.match(BG);
      return t ? t.map(RG).join(" ") : i;
    },
  },
  zw = { ...lp, transform: Math.round },
  DG = {
    rotate: au,
    rotateX: au,
    rotateY: au,
    rotateZ: au,
    scale: Sy,
    scaleX: Sy,
    scaleY: Sy,
    scaleZ: Sy,
    skew: au,
    skewX: au,
    skewY: au,
    distance: rn,
    translateX: rn,
    translateY: rn,
    translateZ: rn,
    x: rn,
    y: rn,
    z: rn,
    perspective: rn,
    transformPerspective: rn,
    opacity: A0,
    originX: Ew,
    originY: Ew,
    originZ: rn,
  },
  sM = {
    borderWidth: rn,
    borderTopWidth: rn,
    borderRightWidth: rn,
    borderBottomWidth: rn,
    borderLeftWidth: rn,
    borderRadius: rn,
    radius: rn,
    borderTopLeftRadius: rn,
    borderTopRightRadius: rn,
    borderBottomRightRadius: rn,
    borderBottomLeftRadius: rn,
    width: rn,
    maxWidth: rn,
    height: rn,
    maxHeight: rn,
    top: rn,
    right: rn,
    bottom: rn,
    left: rn,
    padding: rn,
    paddingTop: rn,
    paddingRight: rn,
    paddingBottom: rn,
    paddingLeft: rn,
    margin: rn,
    marginTop: rn,
    marginRight: rn,
    marginBottom: rn,
    marginLeft: rn,
    backgroundPositionX: rn,
    backgroundPositionY: rn,
    ...DG,
    zIndex: zw,
    fillOpacity: A0,
    strokeOpacity: A0,
    numOctaves: zw,
  },
  UG = {
    ...sM,
    color: aa,
    backgroundColor: aa,
    outlineColor: aa,
    fill: aa,
    stroke: aa,
    borderColor: aa,
    borderTopColor: aa,
    borderRightColor: aa,
    borderBottomColor: aa,
    borderLeftColor: aa,
    filter: yA,
    WebkitFilter: yA,
  },
  d3 = (i) => UG[i];
function p3(i, t) {
  let e = d3(i);
  return (
    e !== yA && (e = gu), e.getAnimatableNone ? e.getAnimatableNone(t) : void 0
  );
}
const OG = new Set(["auto", "none", "0"]);
function NG(i, t, e) {
  let n = 0,
    a;
  for (; n < i.length && !a; ) {
    const r = i[n];
    typeof r == "string" && !OG.has(r) && S0(r).values.length && (a = i[n]),
      n++;
  }
  if (a && e) for (const r of t) i[r] = p3(e, a);
}
class LG extends iM {
  constructor(t, e, n, a, r) {
    super(t, e, n, a, r, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: e, name: n } = this;
    if (!e || !e.current) return;
    super.readKeyframes();
    for (let h = 0; h < t.length; h++) {
      let p = t[h];
      if (typeof p == "string" && ((p = p.trim()), KS(p))) {
        const m = c3(p, e.current);
        m !== void 0 && (t[h] = m),
          h === t.length - 1 && (this.finalKeyframe = p);
      }
    }
    if ((this.resolveNoneKeyframes(), !u3.has(n) || t.length !== 2)) return;
    const [a, r] = t,
      l = Pw(a),
      u = Pw(r);
    if (l !== u)
      if (Ow(l) && Ow(u))
        for (let h = 0; h < t.length; h++) {
          const p = t[h];
          typeof p == "string" && (t[h] = parseFloat(p));
        }
      else qf[n] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: e } = this,
      n = [];
    for (let a = 0; a < t.length; a++) (t[a] === null || wG(t[a])) && n.push(a);
    n.length && NG(t, n, e);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: e, name: n } = this;
    if (!t || !t.current) return;
    n === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = qf[n](
        t.measureViewportBox(),
        window.getComputedStyle(t.current)
      )),
      (e[0] = this.measuredOrigin);
    const a = e[e.length - 1];
    a !== void 0 && t.getValue(n, a).jump(a, !1);
  }
  measureEndState() {
    const { element: t, name: e, unresolvedKeyframes: n } = this;
    if (!t || !t.current) return;
    const a = t.getValue(e);
    a && a.jump(this.measuredOrigin, !1);
    const r = n.length - 1,
      l = n[r];
    (n[r] = qf[e](t.measureViewportBox(), window.getComputedStyle(t.current))),
      l !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = l),
      this.removedTransforms?.length &&
        this.removedTransforms.forEach(([u, h]) => {
          t.getValue(u).set(h);
        }),
      this.resolveNoneKeyframes();
  }
}
function IG(i, t, e) {
  if (i instanceof EventTarget) return [i];
  if (typeof i == "string") {
    let n = document;
    const a = e?.[i] ?? n.querySelectorAll(i);
    return a ? Array.from(a) : [];
  }
  return Array.from(i);
}
const m3 = (i, t) => (t && typeof i == "number" ? t.transform(i) : i);
function PG(i) {
  return UB(i) && "offsetHeight" in i;
}
const Fw = 30,
  zG = (i) => !isNaN(parseFloat(i));
class FG {
  constructor(t, e = {}) {
    (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (n, a = !0) => {
        const r = js.now();
        if (
          (this.updatedAt !== r && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(n),
          this.current !== this.prev &&
            (this.events.change?.notify(this.current), this.dependents))
        )
          for (const l of this.dependents) l.dirty();
        a && this.events.renderRequest?.notify(this.current);
      }),
      (this.hasAnimated = !1),
      this.setCurrent(t),
      (this.owner = e.owner);
  }
  setCurrent(t) {
    (this.current = t),
      (this.updatedAt = js.now()),
      this.canTrackVelocity === null &&
        t !== void 0 &&
        (this.canTrackVelocity = zG(this.current));
  }
  setPrevFrameValue(t = this.current) {
    (this.prevFrameValue = t), (this.prevUpdatedAt = this.updatedAt);
  }
  onChange(t) {
    return this.on("change", t);
  }
  on(t, e) {
    this.events[t] || (this.events[t] = new XS());
    const n = this.events[t].add(e);
    return t === "change"
      ? () => {
          n(),
            wi.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : n;
  }
  clearListeners() {
    for (const t in this.events) this.events[t].clear();
  }
  attach(t, e) {
    (this.passiveEffect = t), (this.stopPassiveEffect = e);
  }
  set(t, e = !0) {
    !e || !this.passiveEffect
      ? this.updateAndNotify(t, e)
      : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, e, n) {
    this.set(e),
      (this.prev = void 0),
      (this.prevFrameValue = t),
      (this.prevUpdatedAt = this.updatedAt - n);
  }
  jump(t, e = !0) {
    this.updateAndNotify(t),
      (this.prev = t),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      e && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const t = js.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      t - this.updatedAt > Fw
    )
      return 0;
    const e = Math.min(this.updatedAt - this.prevUpdatedAt, Fw);
    return NB(parseFloat(this.current) - parseFloat(this.prevFrameValue), e);
  }
  start(t) {
    return (
      this.stop(),
      new Promise((e) => {
        (this.hasAnimated = !0),
          (this.animation = t(e)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.dependents?.clear(),
      this.events.destroy?.notify(),
      this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function ep(i, t) {
  return new FG(i, t);
}
const { schedule: rM } = XB(queueMicrotask, !1),
  go = { x: !1, y: !1 };
function g3() {
  return go.x || go.y;
}
function HG(i) {
  return i === "x" || i === "y"
    ? go[i]
      ? null
      : ((go[i] = !0),
        () => {
          go[i] = !1;
        })
    : go.x || go.y
    ? null
    : ((go.x = go.y = !0),
      () => {
        go.x = go.y = !1;
      });
}
function v3(i, t) {
  const e = IG(i),
    n = new AbortController(),
    a = { passive: !0, ...t, signal: n.signal };
  return [e, a, () => n.abort()];
}
function Hw(i) {
  return !(i.pointerType === "touch" || g3());
}
function GG(i, t, e = {}) {
  const [n, a, r] = v3(i, e),
    l = (u) => {
      if (!Hw(u)) return;
      const { target: h } = u,
        p = t(h, u);
      if (typeof p != "function" || !h) return;
      const m = (v) => {
        Hw(v) && (p(v), h.removeEventListener("pointerleave", m));
      };
      h.addEventListener("pointerleave", m, a);
    };
  return (
    n.forEach((u) => {
      u.addEventListener("pointerenter", l, a);
    }),
    r
  );
}
const y3 = (i, t) => (t ? (i === t ? !0 : y3(i, t.parentElement)) : !1),
  oM = (i) =>
    i.pointerType === "mouse"
      ? typeof i.button != "number" || i.button <= 0
      : i.isPrimary !== !1,
  VG = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function kG(i) {
  return VG.has(i.tagName) || i.tabIndex !== -1;
}
const Dy = new WeakSet();
function Gw(i) {
  return (t) => {
    t.key === "Enter" && i(t);
  };
}
function Ab(i, t) {
  i.dispatchEvent(
    new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })
  );
}
const jG = (i, t) => {
  const e = i.currentTarget;
  if (!e) return;
  const n = Gw(() => {
    if (Dy.has(e)) return;
    Ab(e, "down");
    const a = Gw(() => {
        Ab(e, "up");
      }),
      r = () => Ab(e, "cancel");
    e.addEventListener("keyup", a, t), e.addEventListener("blur", r, t);
  });
  e.addEventListener("keydown", n, t),
    e.addEventListener("blur", () => e.removeEventListener("keydown", n), t);
};
function Vw(i) {
  return oM(i) && !g3();
}
function XG(i, t, e = {}) {
  const [n, a, r] = v3(i, e),
    l = (u) => {
      const h = u.currentTarget;
      if (!Vw(u)) return;
      Dy.add(h);
      const p = t(h, u),
        m = (_, M) => {
          window.removeEventListener("pointerup", v),
            window.removeEventListener("pointercancel", x),
            Dy.has(h) && Dy.delete(h),
            Vw(_) && typeof p == "function" && p(_, { success: M });
        },
        v = (_) => {
          m(
            _,
            h === window ||
              h === document ||
              e.useGlobalTarget ||
              y3(h, _.target)
          );
        },
        x = (_) => {
          m(_, !1);
        };
      window.addEventListener("pointerup", v, a),
        window.addEventListener("pointercancel", x, a);
    };
  return (
    n.forEach((u) => {
      (e.useGlobalTarget ? window : u).addEventListener("pointerdown", l, a),
        PG(u) &&
          (u.addEventListener("focus", (p) => jG(p, a)),
          !kG(u) && !u.hasAttribute("tabindex") && (u.tabIndex = 0));
    }),
    r
  );
}
function x3(i) {
  return UB(i) && "ownerSVGElement" in i;
}
function WG(i) {
  return x3(i) && i.tagName === "svg";
}
const ns = (i) => !!(i && i.getVelocity),
  YG = [...h3, aa, gu],
  qG = (i) => YG.find(f3(i)),
  _3 = bt.createContext({
    transformPagePoint: (i) => i,
    isStatic: !1,
    reducedMotion: "never",
  });
function KG(i = !0) {
  const t = bt.useContext(HS);
  if (t === null) return [!0, null];
  const { isPresent: e, onExitComplete: n, register: a } = t,
    r = bt.useId();
  bt.useEffect(() => {
    if (i) return a(r);
  }, [i]);
  const l = bt.useCallback(() => i && n && n(r), [r, n, i]);
  return !e && n ? [!1, l] : [!0];
}
const b3 = bt.createContext({ strict: !1 }),
  kw = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  np = {};
for (const i in kw) np[i] = { isEnabled: (t) => kw[i].some((e) => !!t[e]) };
function JG(i) {
  for (const t in i) np[t] = { ...np[t], ...i[t] };
}
const ZG = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function Bx(i) {
  return (
    i.startsWith("while") ||
    (i.startsWith("drag") && i !== "draggable") ||
    i.startsWith("layout") ||
    i.startsWith("onTap") ||
    i.startsWith("onPan") ||
    i.startsWith("onLayout") ||
    ZG.has(i)
  );
}
let A3 = (i) => !Bx(i);
function QG(i) {
  typeof i == "function" && (A3 = (t) => (t.startsWith("on") ? !Bx(t) : i(t)));
}
try {
  QG(require("@emotion/is-prop-valid").default);
} catch {}
function $G(i, t, e) {
  const n = {};
  for (const a in i)
    (a === "values" && typeof i.values == "object") ||
      ((A3(a) ||
        (e === !0 && Bx(a)) ||
        (!t && !Bx(a)) ||
        (i.draggable && a.startsWith("onDrag"))) &&
        (n[a] = i[a]));
  return n;
}
const p1 = bt.createContext({});
function m1(i) {
  return i !== null && typeof i == "object" && typeof i.start == "function";
}
function M0(i) {
  return typeof i == "string" || Array.isArray(i);
}
const lM = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  cM = ["initial", ...lM];
function g1(i) {
  return m1(i.animate) || cM.some((t) => M0(i[t]));
}
function S3(i) {
  return !!(g1(i) || i.variants);
}
function t9(i, t) {
  if (g1(i)) {
    const { initial: e, animate: n } = i;
    return {
      initial: e === !1 || M0(e) ? e : void 0,
      animate: M0(n) ? n : void 0,
    };
  }
  return i.inherit !== !1 ? t : {};
}
function e9(i) {
  const { initial: t, animate: e } = t9(i, bt.useContext(p1));
  return bt.useMemo(() => ({ initial: t, animate: e }), [jw(t), jw(e)]);
}
function jw(i) {
  return Array.isArray(i) ? i.join(" ") : i;
}
const E0 = {};
function n9(i) {
  for (const t in i) (E0[t] = i[t]), qS(t) && (E0[t].isCSSVariable = !0);
}
function M3(i, { layout: t, layoutId: e }) {
  return (
    up.has(i) ||
    i.startsWith("origin") ||
    ((t || e !== void 0) && (!!E0[i] || i === "opacity"))
  );
}
const i9 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  a9 = cp.length;
function s9(i, t, e) {
  let n = "",
    a = !0;
  for (let r = 0; r < a9; r++) {
    const l = cp[r],
      u = i[l];
    if (u === void 0) continue;
    let h = !0;
    if (
      (typeof u == "number"
        ? (h = u === (l.startsWith("scale") ? 1 : 0))
        : (h = parseFloat(u) === 0),
      !h || e)
    ) {
      const p = m3(u, sM[l]);
      if (!h) {
        a = !1;
        const m = i9[l] || l;
        n += `${m}(${p}) `;
      }
      e && (t[l] = p);
    }
  }
  return (n = n.trim()), e ? (n = e(t, a ? "" : n)) : a && (n = "none"), n;
}
function uM(i, t, e) {
  const { style: n, vars: a, transformOrigin: r } = i;
  let l = !1,
    u = !1;
  for (const h in t) {
    const p = t[h];
    if (up.has(h)) {
      l = !0;
      continue;
    } else if (qS(h)) {
      a[h] = p;
      continue;
    } else {
      const m = m3(p, sM[h]);
      h.startsWith("origin") ? ((u = !0), (r[h] = m)) : (n[h] = m);
    }
  }
  if (
    (t.transform ||
      (l || e
        ? (n.transform = s9(t, i.transform, e))
        : n.transform && (n.transform = "none")),
    u)
  ) {
    const { originX: h = "50%", originY: p = "50%", originZ: m = 0 } = r;
    n.transformOrigin = `${h} ${p} ${m}`;
  }
}
const fM = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function E3(i, t, e) {
  for (const n in t) !ns(t[n]) && !M3(n, e) && (i[n] = t[n]);
}
function r9({ transformTemplate: i }, t) {
  return bt.useMemo(() => {
    const e = fM();
    return uM(e, t, i), Object.assign({}, e.vars, e.style);
  }, [t]);
}
function o9(i, t) {
  const e = i.style || {},
    n = {};
  return E3(n, e, i), Object.assign(n, r9(i, t)), n;
}
function l9(i, t) {
  const e = {},
    n = o9(i, t);
  return (
    i.drag &&
      i.dragListener !== !1 &&
      ((e.draggable = !1),
      (n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none"),
      (n.touchAction =
        i.drag === !0 ? "none" : `pan-${i.drag === "x" ? "y" : "x"}`)),
    i.tabIndex === void 0 &&
      (i.onTap || i.onTapStart || i.whileTap) &&
      (e.tabIndex = 0),
    (e.style = n),
    e
  );
}
const c9 = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  u9 = { offset: "strokeDashoffset", array: "strokeDasharray" };
function f9(i, t, e = 1, n = 0, a = !0) {
  i.pathLength = 1;
  const r = a ? c9 : u9;
  i[r.offset] = rn.transform(-n);
  const l = rn.transform(t),
    u = rn.transform(e);
  i[r.array] = `${l} ${u}`;
}
function T3(
  i,
  {
    attrX: t,
    attrY: e,
    attrScale: n,
    pathLength: a,
    pathSpacing: r = 1,
    pathOffset: l = 0,
    ...u
  },
  h,
  p,
  m
) {
  if ((uM(i, u, p), h)) {
    i.style.viewBox && (i.attrs.viewBox = i.style.viewBox);
    return;
  }
  (i.attrs = i.style), (i.style = {});
  const { attrs: v, style: x } = i;
  v.transform && ((x.transform = v.transform), delete v.transform),
    (x.transform || v.transformOrigin) &&
      ((x.transformOrigin = v.transformOrigin ?? "50% 50%"),
      delete v.transformOrigin),
    x.transform &&
      ((x.transformBox = m?.transformBox ?? "fill-box"), delete v.transformBox),
    t !== void 0 && (v.x = t),
    e !== void 0 && (v.y = e),
    n !== void 0 && (v.scale = n),
    a !== void 0 && f9(v, a, r, l, !1);
}
const w3 = () => ({ ...fM(), attrs: {} }),
  C3 = (i) => typeof i == "string" && i.toLowerCase() === "svg";
function h9(i, t, e, n) {
  const a = bt.useMemo(() => {
    const r = w3();
    return (
      T3(r, t, C3(n), i.transformTemplate, i.style),
      { ...r.attrs, style: { ...r.style } }
    );
  }, [t]);
  if (i.style) {
    const r = {};
    E3(r, i.style, i), (a.style = { ...r, ...a.style });
  }
  return a;
}
const d9 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function hM(i) {
  return typeof i != "string" || i.includes("-")
    ? !1
    : !!(d9.indexOf(i) > -1 || /[A-Z]/u.test(i));
}
function p9(i, t, e, { latestValues: n }, a, r = !1) {
  const u = (hM(i) ? h9 : l9)(t, n, a, i),
    h = $G(t, typeof i == "string", r),
    p = i !== bt.Fragment ? { ...h, ...u, ref: e } : {},
    { children: m } = t,
    v = bt.useMemo(() => (ns(m) ? m.get() : m), [m]);
  return bt.createElement(i, { ...p, children: v });
}
function Xw(i) {
  const t = [{}, {}];
  return (
    i?.values.forEach((e, n) => {
      (t[0][n] = e.get()), (t[1][n] = e.getVelocity());
    }),
    t
  );
}
function dM(i, t, e, n) {
  if (typeof t == "function") {
    const [a, r] = Xw(n);
    t = t(e !== void 0 ? e : i.custom, a, r);
  }
  if (
    (typeof t == "string" && (t = i.variants && i.variants[t]),
    typeof t == "function")
  ) {
    const [a, r] = Xw(n);
    t = t(e !== void 0 ? e : i.custom, a, r);
  }
  return t;
}
function Uy(i) {
  return ns(i) ? i.get() : i;
}
function m9({ scrapeMotionValuesFromProps: i, createRenderState: t }, e, n, a) {
  return { latestValues: g9(e, n, a, i), renderState: t() };
}
function g9(i, t, e, n) {
  const a = {},
    r = n(i, {});
  for (const x in r) a[x] = Uy(r[x]);
  let { initial: l, animate: u } = i;
  const h = g1(i),
    p = S3(i);
  t &&
    p &&
    !h &&
    i.inherit !== !1 &&
    (l === void 0 && (l = t.initial), u === void 0 && (u = t.animate));
  let m = e ? e.initial === !1 : !1;
  m = m || l === !1;
  const v = m ? u : l;
  if (v && typeof v != "boolean" && !m1(v)) {
    const x = Array.isArray(v) ? v : [v];
    for (let _ = 0; _ < x.length; _++) {
      const M = dM(i, x[_]);
      if (M) {
        const { transitionEnd: C, transition: E, ...S } = M;
        for (const R in S) {
          let B = S[R];
          if (Array.isArray(B)) {
            const D = m ? B.length - 1 : 0;
            B = B[D];
          }
          B !== null && (a[R] = B);
        }
        for (const R in C) a[R] = C[R];
      }
    }
  }
  return a;
}
const R3 = (i) => (t, e) => {
  const n = bt.useContext(p1),
    a = bt.useContext(HS),
    r = () => m9(i, t, n, a);
  return e ? r() : RB(r);
};
function pM(i, t, e) {
  const { style: n } = i,
    a = {};
  for (const r in n)
    (ns(n[r]) ||
      (t.style && ns(t.style[r])) ||
      M3(r, i) ||
      e?.getValue(r)?.liveStyle !== void 0) &&
      (a[r] = n[r]);
  return a;
}
const v9 = R3({ scrapeMotionValuesFromProps: pM, createRenderState: fM });
function B3(i, t, e) {
  const n = pM(i, t, e);
  for (const a in i)
    if (ns(i[a]) || ns(t[a])) {
      const r =
        cp.indexOf(a) !== -1
          ? "attr" + a.charAt(0).toUpperCase() + a.substring(1)
          : a;
      n[r] = i[a];
    }
  return n;
}
const y9 = R3({ scrapeMotionValuesFromProps: B3, createRenderState: w3 }),
  x9 = Symbol.for("motionComponentSymbol");
function Od(i) {
  return (
    i &&
    typeof i == "object" &&
    Object.prototype.hasOwnProperty.call(i, "current")
  );
}
function _9(i, t, e) {
  return bt.useCallback(
    (n) => {
      n && i.onMount && i.onMount(n),
        t && (n ? t.mount(n) : t.unmount()),
        e && (typeof e == "function" ? e(n) : Od(e) && (e.current = n));
    },
    [t]
  );
}
const mM = (i) => i.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  b9 = "framerAppearId",
  D3 = "data-" + mM(b9),
  U3 = bt.createContext({});
function A9(i, t, e, n, a) {
  const { visualElement: r } = bt.useContext(p1),
    l = bt.useContext(b3),
    u = bt.useContext(HS),
    h = bt.useContext(_3).reducedMotion,
    p = bt.useRef(null);
  (n = n || l.renderer),
    !p.current &&
      n &&
      (p.current = n(i, {
        visualState: t,
        parent: r,
        props: e,
        presenceContext: u,
        blockInitialAnimation: u ? u.initial === !1 : !1,
        reducedMotionConfig: h,
      }));
  const m = p.current,
    v = bt.useContext(U3);
  m &&
    !m.projection &&
    a &&
    (m.type === "html" || m.type === "svg") &&
    S9(p.current, e, a, v);
  const x = bt.useRef(!1);
  bt.useInsertionEffect(() => {
    m && x.current && m.update(e, u);
  });
  const _ = e[D3],
    M = bt.useRef(
      !!_ &&
        !window.MotionHandoffIsComplete?.(_) &&
        window.MotionHasOptimisedAnimation?.(_)
    );
  return (
    BB(() => {
      m &&
        ((x.current = !0),
        (window.MotionIsMounted = !0),
        m.updateFeatures(),
        m.scheduleRenderMicrotask(),
        M.current && m.animationState && m.animationState.animateChanges());
    }),
    bt.useEffect(() => {
      m &&
        (!M.current && m.animationState && m.animationState.animateChanges(),
        M.current &&
          (queueMicrotask(() => {
            window.MotionHandoffMarkAsComplete?.(_);
          }),
          (M.current = !1)));
    }),
    m
  );
}
function S9(i, t, e, n) {
  const {
    layoutId: a,
    layout: r,
    drag: l,
    dragConstraints: u,
    layoutScroll: h,
    layoutRoot: p,
    layoutCrossfade: m,
  } = t;
  (i.projection = new e(
    i.latestValues,
    t["data-framer-portal-id"] ? void 0 : O3(i.parent)
  )),
    i.projection.setOptions({
      layoutId: a,
      layout: r,
      alwaysMeasureLayout: !!l || (u && Od(u)),
      visualElement: i,
      animationType: typeof r == "string" ? r : "both",
      initialPromotionConfig: n,
      crossfade: m,
      layoutScroll: h,
      layoutRoot: p,
    });
}
function O3(i) {
  if (i) return i.options.allowProjection !== !1 ? i.projection : O3(i.parent);
}
function Sb(i, { forwardMotionProps: t = !1 } = {}, e, n) {
  e && JG(e);
  const a = hM(i) ? y9 : v9;
  function r(u, h) {
    let p;
    const m = { ...bt.useContext(_3), ...u, layoutId: M9(u) },
      { isStatic: v } = m,
      x = e9(u),
      _ = a(u, v);
    if (!v && FS) {
      E9();
      const M = T9(m);
      (p = M.MeasureLayout),
        (x.visualElement = A9(i, _, m, n, M.ProjectionNode));
    }
    return O.jsxs(p1.Provider, {
      value: x,
      children: [
        p && x.visualElement
          ? O.jsx(p, { visualElement: x.visualElement, ...m })
          : null,
        p9(i, u, _9(_, x.visualElement, h), _, v, t),
      ],
    });
  }
  r.displayName = `motion.${
    typeof i == "string" ? i : `create(${i.displayName ?? i.name ?? ""})`
  }`;
  const l = bt.forwardRef(r);
  return (l[x9] = i), l;
}
function M9({ layoutId: i }) {
  const t = bt.useContext(CB).id;
  return t && i !== void 0 ? t + "-" + i : i;
}
function E9(i, t) {
  bt.useContext(b3).strict;
}
function T9(i) {
  const { drag: t, layout: e } = np;
  if (!t && !e) return {};
  const n = { ...t, ...e };
  return {
    MeasureLayout:
      t?.isEnabled(i) || e?.isEnabled(i) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode,
  };
}
function w9(i, t) {
  if (typeof Proxy > "u") return Sb;
  const e = new Map(),
    n = (r, l) => Sb(r, l, i, t),
    a = (r, l) => n(r, l);
  return new Proxy(a, {
    get: (r, l) =>
      l === "create"
        ? n
        : (e.has(l) || e.set(l, Sb(l, void 0, i, t)), e.get(l)),
  });
}
function N3({ top: i, left: t, right: e, bottom: n }) {
  return { x: { min: t, max: e }, y: { min: i, max: n } };
}
function C9({ x: i, y: t }) {
  return { top: t.min, right: i.max, bottom: t.max, left: i.min };
}
function R9(i, t) {
  if (!t) return i;
  const e = t({ x: i.left, y: i.top }),
    n = t({ x: i.right, y: i.bottom });
  return { top: e.y, left: e.x, bottom: n.y, right: n.x };
}
function Mb(i) {
  return i === void 0 || i === 1;
}
function xA({ scale: i, scaleX: t, scaleY: e }) {
  return !Mb(i) || !Mb(t) || !Mb(e);
}
function Nf(i) {
  return (
    xA(i) ||
    L3(i) ||
    i.z ||
    i.rotate ||
    i.rotateX ||
    i.rotateY ||
    i.skewX ||
    i.skewY
  );
}
function L3(i) {
  return Ww(i.x) || Ww(i.y);
}
function Ww(i) {
  return i && i !== "0%";
}
function Dx(i, t, e) {
  const n = i - e,
    a = t * n;
  return e + a;
}
function Yw(i, t, e, n, a) {
  return a !== void 0 && (i = Dx(i, a, n)), Dx(i, e, n) + t;
}
function _A(i, t = 0, e = 1, n, a) {
  (i.min = Yw(i.min, t, e, n, a)), (i.max = Yw(i.max, t, e, n, a));
}
function I3(i, { x: t, y: e }) {
  _A(i.x, t.translate, t.scale, t.originPoint),
    _A(i.y, e.translate, e.scale, e.originPoint);
}
const qw = 0.999999999999,
  Kw = 1.0000000000001;
function B9(i, t, e, n = !1) {
  const a = e.length;
  if (!a) return;
  t.x = t.y = 1;
  let r, l;
  for (let u = 0; u < a; u++) {
    (r = e[u]), (l = r.projectionDelta);
    const { visualElement: h } = r.options;
    (h && h.props.style && h.props.style.display === "contents") ||
      (n &&
        r.options.layoutScroll &&
        r.scroll &&
        r !== r.root &&
        Ld(i, { x: -r.scroll.offset.x, y: -r.scroll.offset.y }),
      l && ((t.x *= l.x.scale), (t.y *= l.y.scale), I3(i, l)),
      n && Nf(r.latestValues) && Ld(i, r.latestValues));
  }
  t.x < Kw && t.x > qw && (t.x = 1), t.y < Kw && t.y > qw && (t.y = 1);
}
function Nd(i, t) {
  (i.min = i.min + t), (i.max = i.max + t);
}
function Jw(i, t, e, n, a = 0.5) {
  const r = Ii(i.min, i.max, a);
  _A(i, t, e, r, n);
}
function Ld(i, t) {
  Jw(i.x, t.x, t.scaleX, t.scale, t.originX),
    Jw(i.y, t.y, t.scaleY, t.scale, t.originY);
}
function P3(i, t) {
  return N3(R9(i.getBoundingClientRect(), t));
}
function D9(i, t, e) {
  const n = P3(i, e),
    { scroll: a } = t;
  return a && (Nd(n.x, a.offset.x), Nd(n.y, a.offset.y)), n;
}
const Zw = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  Id = () => ({ x: Zw(), y: Zw() }),
  Qw = () => ({ min: 0, max: 0 }),
  qi = () => ({ x: Qw(), y: Qw() }),
  bA = { current: null },
  z3 = { current: !1 };
function U9() {
  if (((z3.current = !0), !!FS))
    if (window.matchMedia) {
      const i = window.matchMedia("(prefers-reduced-motion)"),
        t = () => (bA.current = i.matches);
      i.addEventListener("change", t), t();
    } else bA.current = !1;
}
const O9 = new WeakMap();
function N9(i, t, e) {
  for (const n in t) {
    const a = t[n],
      r = e[n];
    if (ns(a)) i.addValue(n, a);
    else if (ns(r)) i.addValue(n, ep(a, { owner: i }));
    else if (r !== a)
      if (i.hasValue(n)) {
        const l = i.getValue(n);
        l.liveStyle === !0 ? l.jump(a) : l.hasAnimated || l.set(a);
      } else {
        const l = i.getStaticValue(n);
        i.addValue(n, ep(l !== void 0 ? l : a, { owner: i }));
      }
  }
  for (const n in e) t[n] === void 0 && i.removeValue(n);
  return t;
}
const $w = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
class L9 {
  scrapeMotionValuesFromProps(t, e, n) {
    return {};
  }
  constructor(
    {
      parent: t,
      props: e,
      presenceContext: n,
      reducedMotionConfig: a,
      blockInitialAnimation: r,
      visualState: l,
    },
    u = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = iM),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const x = js.now();
        this.renderScheduledAt < x &&
          ((this.renderScheduledAt = x), wi.render(this.render, !1, !0));
      });
    const { latestValues: h, renderState: p } = l;
    (this.latestValues = h),
      (this.baseTarget = { ...h }),
      (this.initialValues = e.initial ? { ...h } : {}),
      (this.renderState = p),
      (this.parent = t),
      (this.props = e),
      (this.presenceContext = n),
      (this.depth = t ? t.depth + 1 : 0),
      (this.reducedMotionConfig = a),
      (this.options = u),
      (this.blockInitialAnimation = !!r),
      (this.isControllingVariants = g1(e)),
      (this.isVariantNode = S3(e)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(t && t.current));
    const { willChange: m, ...v } = this.scrapeMotionValuesFromProps(
      e,
      {},
      this
    );
    for (const x in v) {
      const _ = v[x];
      h[x] !== void 0 && ns(_) && _.set(h[x], !1);
    }
  }
  mount(t) {
    (this.current = t),
      O9.set(t, this),
      this.projection && !this.projection.instance && this.projection.mount(t),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((e, n) => this.bindToMotionValue(n, e)),
      z3.current || U9(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : bA.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(),
      mu(this.notifyUpdate),
      mu(this.render),
      this.valueSubscriptions.forEach((t) => t()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const t in this.events) this.events[t].clear();
    for (const t in this.features) {
      const e = this.features[t];
      e && (e.unmount(), (e.isMounted = !1));
    }
    this.current = null;
  }
  bindToMotionValue(t, e) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const n = up.has(t);
    n && this.onBindTransform && this.onBindTransform();
    const a = e.on("change", (u) => {
        (this.latestValues[t] = u),
          this.props.onUpdate && wi.preRender(this.notifyUpdate),
          n && this.projection && (this.projection.isTransformDirty = !0);
      }),
      r = e.on("renderRequest", this.scheduleRender);
    let l;
    window.MotionCheckAppearSync &&
      (l = window.MotionCheckAppearSync(this, t, e)),
      this.valueSubscriptions.set(t, () => {
        a(), r(), l && l(), e.owner && e.stop();
      });
  }
  sortNodePosition(t) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== t.type
      ? 0
      : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in np) {
      const e = np[t];
      if (!e) continue;
      const { isEnabled: n, Feature: a } = e;
      if (
        (!this.features[t] &&
          a &&
          n(this.props) &&
          (this.features[t] = new a(this)),
        this.features[t])
      ) {
        const r = this.features[t];
        r.isMounted ? r.update() : (r.mount(), (r.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : qi();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, e) {
    this.latestValues[t] = e;
  }
  update(t, e) {
    (t.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = t),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = e);
    for (let n = 0; n < $w.length; n++) {
      const a = $w[n];
      this.propEventSubscriptions[a] &&
        (this.propEventSubscriptions[a](),
        delete this.propEventSubscriptions[a]);
      const r = "on" + a,
        l = t[r];
      l && (this.propEventSubscriptions[a] = this.on(a, l));
    }
    (this.prevMotionValues = N9(
      this,
      this.scrapeMotionValuesFromProps(t, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  addVariantChild(t) {
    const e = this.getClosestVariantNode();
    if (e)
      return (
        e.variantChildren && e.variantChildren.add(t),
        () => e.variantChildren.delete(t)
      );
  }
  addValue(t, e) {
    const n = this.values.get(t);
    e !== n &&
      (n && this.removeValue(t),
      this.bindToMotionValue(t, e),
      this.values.set(t, e),
      (this.latestValues[t] = e.get()));
  }
  removeValue(t) {
    this.values.delete(t);
    const e = this.valueSubscriptions.get(t);
    e && (e(), this.valueSubscriptions.delete(t)),
      delete this.latestValues[t],
      this.removeValueFromRenderState(t, this.renderState);
  }
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, e) {
    if (this.props.values && this.props.values[t]) return this.props.values[t];
    let n = this.values.get(t);
    return (
      n === void 0 &&
        e !== void 0 &&
        ((n = ep(e === null ? void 0 : e, { owner: this })),
        this.addValue(t, n)),
      n
    );
  }
  readValue(t, e) {
    let n =
      this.latestValues[t] !== void 0 || !this.current
        ? this.latestValues[t]
        : this.getBaseTargetFromProps(this.props, t) ??
          this.readValueFromInstance(this.current, t, this.options);
    return (
      n != null &&
        (typeof n == "string" && (DB(n) || OB(n))
          ? (n = parseFloat(n))
          : !qG(n) && gu.test(e) && (n = p3(t, e)),
        this.setBaseTarget(t, ns(n) ? n.get() : n)),
      ns(n) ? n.get() : n
    );
  }
  setBaseTarget(t, e) {
    this.baseTarget[t] = e;
  }
  getBaseTarget(t) {
    const { initial: e } = this.props;
    let n;
    if (typeof e == "string" || typeof e == "object") {
      const r = dM(this.props, e, this.presenceContext?.custom);
      r && (n = r[t]);
    }
    if (e && n !== void 0) return n;
    const a = this.getBaseTargetFromProps(this.props, t);
    return a !== void 0 && !ns(a)
      ? a
      : this.initialValues[t] !== void 0 && n === void 0
      ? void 0
      : this.baseTarget[t];
  }
  on(t, e) {
    return this.events[t] || (this.events[t] = new XS()), this.events[t].add(e);
  }
  notify(t, ...e) {
    this.events[t] && this.events[t].notify(...e);
  }
  scheduleRenderMicrotask() {
    rM.render(this.render);
  }
}
class F3 extends L9 {
  constructor() {
    super(...arguments), (this.KeyframeResolver = LG);
  }
  sortInstanceNodePosition(t, e) {
    return t.compareDocumentPosition(e) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, e) {
    return t.style ? t.style[e] : void 0;
  }
  removeValueFromRenderState(t, { vars: e, style: n }) {
    delete e[t], delete n[t];
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    ns(t) &&
      (this.childSubscription = t.on("change", (e) => {
        this.current && (this.current.textContent = `${e}`);
      }));
  }
}
function H3(i, { style: t, vars: e }, n, a) {
  const r = i.style;
  let l;
  for (l in t) r[l] = t[l];
  a?.applyProjectionStyles(r, n);
  for (l in e) r.setProperty(l, e[l]);
}
function I9(i) {
  return window.getComputedStyle(i);
}
class P9 extends F3 {
  constructor() {
    super(...arguments), (this.type = "html"), (this.renderInstance = H3);
  }
  readValueFromInstance(t, e) {
    if (up.has(e)) return this.projection?.isProjecting ? dA(e) : tG(t, e);
    {
      const n = I9(t),
        a = (qS(e) ? n.getPropertyValue(e) : n[e]) || 0;
      return typeof a == "string" ? a.trim() : a;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: e }) {
    return P3(t, e);
  }
  build(t, e, n) {
    uM(t, e, n.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, e, n) {
    return pM(t, e, n);
  }
}
const G3 = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function z9(i, t, e, n) {
  H3(i, t, void 0, n);
  for (const a in t.attrs) i.setAttribute(G3.has(a) ? a : mM(a), t.attrs[a]);
}
class F9 extends F3 {
  constructor() {
    super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = qi);
  }
  getBaseTargetFromProps(t, e) {
    return t[e];
  }
  readValueFromInstance(t, e) {
    if (up.has(e)) {
      const n = d3(e);
      return (n && n.default) || 0;
    }
    return (e = G3.has(e) ? e : mM(e)), t.getAttribute(e);
  }
  scrapeMotionValuesFromProps(t, e, n) {
    return B3(t, e, n);
  }
  build(t, e, n) {
    T3(t, e, this.isSVGTag, n.transformTemplate, n.style);
  }
  renderInstance(t, e, n, a) {
    z9(t, e, n, a);
  }
  mount(t) {
    (this.isSVGTag = C3(t.tagName)), super.mount(t);
  }
}
const H9 = (i, t) =>
  hM(i) ? new F9(t) : new P9(t, { allowProjection: i !== bt.Fragment });
function T0(i, t, e) {
  const n = i.getProps();
  return dM(n, t, e !== void 0 ? e : n.custom, i);
}
const AA = (i) => Array.isArray(i);
function G9(i, t, e) {
  i.hasValue(t) ? i.getValue(t).set(e) : i.addValue(t, ep(e));
}
function V9(i) {
  return AA(i) ? i[i.length - 1] || 0 : i;
}
function gM(i, t) {
  const e = T0(i, t);
  let { transitionEnd: n = {}, transition: a = {}, ...r } = e || {};
  r = { ...r, ...n };
  for (const l in r) {
    const u = V9(r[l]);
    G9(i, l, u);
  }
}
function k9(i) {
  return !!(ns(i) && i.add);
}
function SA(i, t) {
  const e = i.getValue("willChange");
  if (k9(e)) return e.add(t);
  if (!e && ic.WillChange) {
    const n = new ic.WillChange("auto");
    i.addValue("willChange", n), n.add(t);
  }
}
function V3(i) {
  return i.props[D3];
}
const j9 = (i) => i !== null;
function X9(i, { repeat: t, repeatType: e = "loop" }, n) {
  const a = i.filter(j9),
    r = t && e !== "loop" && t % 2 === 1 ? 0 : a.length - 1;
  return a[r];
}
const W9 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  Y9 = (i) => ({
    type: "spring",
    stiffness: 550,
    damping: i === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  q9 = { type: "keyframes", duration: 0.8 },
  K9 = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  J9 = (i, { keyframes: t }) =>
    t.length > 2
      ? q9
      : up.has(i)
      ? i.startsWith("scale")
        ? Y9(t[1])
        : W9
      : K9;
function Z9({
  when: i,
  delay: t,
  delayChildren: e,
  staggerChildren: n,
  staggerDirection: a,
  repeat: r,
  repeatType: l,
  repeatDelay: u,
  from: h,
  elapsed: p,
  ...m
}) {
  return !!Object.keys(m).length;
}
const vM =
  (i, t, e, n = {}, a, r) =>
  (l) => {
    const u = aM(n, i) || {},
      h = u.delay || n.delay || 0;
    let { elapsed: p = 0 } = n;
    p = p - cl(h);
    const m = {
      keyframes: Array.isArray(e) ? e : [null, e],
      ease: "easeOut",
      velocity: t.getVelocity(),
      ...u,
      delay: -p,
      onUpdate: (x) => {
        t.set(x), u.onUpdate && u.onUpdate(x);
      },
      onComplete: () => {
        l(), u.onComplete && u.onComplete();
      },
      name: i,
      motionValue: t,
      element: r ? void 0 : a,
    };
    Z9(u) || Object.assign(m, J9(i, m)),
      m.duration && (m.duration = cl(m.duration)),
      m.repeatDelay && (m.repeatDelay = cl(m.repeatDelay)),
      m.from !== void 0 && (m.keyframes[0] = m.from);
    let v = !1;
    if (
      ((m.type === !1 || (m.duration === 0 && !m.repeatDelay)) &&
        ((m.duration = 0), m.delay === 0 && (v = !0)),
      (ic.instantAnimations || ic.skipAnimations) &&
        ((v = !0), (m.duration = 0), (m.delay = 0)),
      (m.allowFlatten = !u.type && !u.ease),
      v && !r && t.get() !== void 0)
    ) {
      const x = X9(m.keyframes, u);
      if (x !== void 0) {
        wi.update(() => {
          m.onUpdate(x), m.onComplete();
        });
        return;
      }
    }
    return u.isSync ? new nM(m) : new SG(m);
  };
function Q9({ protectedKeys: i, needsAnimating: t }, e) {
  const n = i.hasOwnProperty(e) && t[e] !== !0;
  return (t[e] = !1), n;
}
function k3(i, t, { delay: e = 0, transitionOverride: n, type: a } = {}) {
  let { transition: r = i.getDefaultTransition(), transitionEnd: l, ...u } = t;
  n && (r = n);
  const h = [],
    p = a && i.animationState && i.animationState.getState()[a];
  for (const m in u) {
    const v = i.getValue(m, i.latestValues[m] ?? null),
      x = u[m];
    if (x === void 0 || (p && Q9(p, m))) continue;
    const _ = { delay: e, ...aM(r || {}, m) },
      M = v.get();
    if (
      M !== void 0 &&
      !v.isAnimating &&
      !Array.isArray(x) &&
      x === M &&
      !_.velocity
    )
      continue;
    let C = !1;
    if (window.MotionHandoffAnimation) {
      const S = V3(i);
      if (S) {
        const R = window.MotionHandoffAnimation(S, m, wi);
        R !== null && ((_.startTime = R), (C = !0));
      }
    }
    SA(i, m),
      v.start(
        vM(m, v, x, i.shouldReduceMotion && u3.has(m) ? { type: !1 } : _, i, C)
      );
    const E = v.animation;
    E && h.push(E);
  }
  return (
    l &&
      Promise.all(h).then(() => {
        wi.update(() => {
          l && gM(i, l);
        });
      }),
    h
  );
}
function MA(i, t, e = {}) {
  const n = T0(i, t, e.type === "exit" ? i.presenceContext?.custom : void 0);
  let { transition: a = i.getDefaultTransition() || {} } = n || {};
  e.transitionOverride && (a = e.transitionOverride);
  const r = n ? () => Promise.all(k3(i, n, e)) : () => Promise.resolve(),
    l =
      i.variantChildren && i.variantChildren.size
        ? (h = 0) => {
            const {
              delayChildren: p = 0,
              staggerChildren: m,
              staggerDirection: v,
            } = a;
            return $9(i, t, h, p, m, v, e);
          }
        : () => Promise.resolve(),
    { when: u } = a;
  if (u) {
    const [h, p] = u === "beforeChildren" ? [r, l] : [l, r];
    return h().then(() => p());
  } else return Promise.all([r(), l(e.delay)]);
}
function $9(i, t, e = 0, n = 0, a = 0, r = 1, l) {
  const u = [],
    h = i.variantChildren.size,
    p = (h - 1) * a,
    m = typeof n == "function",
    v = m ? (x) => n(x, h) : r === 1 ? (x = 0) => x * a : (x = 0) => p - x * a;
  return (
    Array.from(i.variantChildren)
      .sort(t6)
      .forEach((x, _) => {
        x.notify("AnimationStart", t),
          u.push(
            MA(x, t, { ...l, delay: e + (m ? 0 : n) + v(_) }).then(() =>
              x.notify("AnimationComplete", t)
            )
          );
      }),
    Promise.all(u)
  );
}
function t6(i, t) {
  return i.sortNodePosition(t);
}
function j3(i, t, e = {}) {
  i.notify("AnimationStart", t);
  let n;
  if (Array.isArray(t)) {
    const a = t.map((r) => MA(i, r, e));
    n = Promise.all(a);
  } else if (typeof t == "string") n = MA(i, t, e);
  else {
    const a = typeof t == "function" ? T0(i, t, e.custom) : t;
    n = Promise.all(k3(i, a, e));
  }
  return n.then(() => {
    i.notify("AnimationComplete", t);
  });
}
function X3(i, t) {
  if (!Array.isArray(t)) return !1;
  const e = t.length;
  if (e !== i.length) return !1;
  for (let n = 0; n < e; n++) if (t[n] !== i[n]) return !1;
  return !0;
}
const e6 = cM.length;
function W3(i) {
  if (!i) return;
  if (!i.isControllingVariants) {
    const e = i.parent ? W3(i.parent) || {} : {};
    return i.props.initial !== void 0 && (e.initial = i.props.initial), e;
  }
  const t = {};
  for (let e = 0; e < e6; e++) {
    const n = cM[e],
      a = i.props[n];
    (M0(a) || a === !1) && (t[n] = a);
  }
  return t;
}
const n6 = [...lM].reverse(),
  i6 = lM.length;
function a6(i) {
  return (t) =>
    Promise.all(t.map(({ animation: e, options: n }) => j3(i, e, n)));
}
function s6(i) {
  let t = a6(i),
    e = t2(),
    n = !0;
  const a = (h) => (p, m) => {
    const v = T0(i, m, h === "exit" ? i.presenceContext?.custom : void 0);
    if (v) {
      const { transition: x, transitionEnd: _, ...M } = v;
      p = { ...p, ...M, ..._ };
    }
    return p;
  };
  function r(h) {
    t = h(i);
  }
  function l(h) {
    const { props: p } = i,
      m = W3(i.parent) || {},
      v = [],
      x = new Set();
    let _ = {},
      M = 1 / 0;
    for (let E = 0; E < i6; E++) {
      const S = n6[E],
        R = e[S],
        B = p[S] !== void 0 ? p[S] : m[S],
        D = M0(B),
        I = S === h ? R.isActive : null;
      I === !1 && (M = E);
      let P = B === m[S] && B !== p[S] && D;
      if (
        (P && n && i.manuallyAnimateOnMount && (P = !1),
        (R.protectedKeys = { ..._ }),
        (!R.isActive && I === null) ||
          (!B && !R.prevProp) ||
          m1(B) ||
          typeof B == "boolean")
      )
        continue;
      const V = r6(R.prevProp, B);
      let F = V || (S === h && R.isActive && !P && D) || (E > M && D),
        N = !1;
      const L = Array.isArray(B) ? B : [B];
      let Y = L.reduce(a(S), {});
      I === !1 && (Y = {});
      const { prevResolvedValues: ct = {} } = R,
        nt = { ...ct, ...Y },
        dt = (Q) => {
          (F = !0),
            x.has(Q) && ((N = !0), x.delete(Q)),
            (R.needsAnimating[Q] = !0);
          const et = i.getValue(Q);
          et && (et.liveStyle = !1);
        };
      for (const Q in nt) {
        const et = Y[Q],
          xt = ct[Q];
        if (_.hasOwnProperty(Q)) continue;
        let X = !1;
        AA(et) && AA(xt) ? (X = !X3(et, xt)) : (X = et !== xt),
          X
            ? et != null
              ? dt(Q)
              : x.add(Q)
            : et !== void 0 && x.has(Q)
            ? dt(Q)
            : (R.protectedKeys[Q] = !0);
      }
      (R.prevProp = B),
        (R.prevResolvedValues = Y),
        R.isActive && (_ = { ..._, ...Y }),
        n && i.blockInitialAnimation && (F = !1),
        F &&
          (!(P && V) || N) &&
          v.push(...L.map((Q) => ({ animation: Q, options: { type: S } })));
    }
    if (x.size) {
      const E = {};
      if (typeof p.initial != "boolean") {
        const S = T0(i, Array.isArray(p.initial) ? p.initial[0] : p.initial);
        S && S.transition && (E.transition = S.transition);
      }
      x.forEach((S) => {
        const R = i.getBaseTarget(S),
          B = i.getValue(S);
        B && (B.liveStyle = !0), (E[S] = R ?? null);
      }),
        v.push({ animation: E });
    }
    let C = !!v.length;
    return (
      n &&
        (p.initial === !1 || p.initial === p.animate) &&
        !i.manuallyAnimateOnMount &&
        (C = !1),
      (n = !1),
      C ? t(v) : Promise.resolve()
    );
  }
  function u(h, p) {
    if (e[h].isActive === p) return Promise.resolve();
    i.variantChildren?.forEach((v) => v.animationState?.setActive(h, p)),
      (e[h].isActive = p);
    const m = l(h);
    for (const v in e) e[v].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: l,
    setActive: u,
    setAnimateFunction: r,
    getState: () => e,
    reset: () => {
      (e = t2()), (n = !0);
    },
  };
}
function r6(i, t) {
  return typeof t == "string" ? t !== i : Array.isArray(t) ? !X3(t, i) : !1;
}
function Rf(i = !1) {
  return {
    isActive: i,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function t2() {
  return {
    animate: Rf(!0),
    whileInView: Rf(),
    whileHover: Rf(),
    whileTap: Rf(),
    whileDrag: Rf(),
    whileFocus: Rf(),
    exit: Rf(),
  };
}
class bu {
  constructor(t) {
    (this.isMounted = !1), (this.node = t);
  }
  update() {}
}
class o6 extends bu {
  constructor(t) {
    super(t), t.animationState || (t.animationState = s6(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    m1(t) && (this.unmountControls = t.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(),
      { animate: e } = this.node.prevProps || {};
    t !== e && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let l6 = 0;
class c6 extends bu {
  constructor() {
    super(...arguments), (this.id = l6++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: t, onExitComplete: e } = this.node.presenceContext,
      { isPresent: n } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === n) return;
    const a = this.node.animationState.setActive("exit", !t);
    e &&
      !t &&
      a.then(() => {
        e(this.id);
      });
  }
  mount() {
    const { register: t, onExitComplete: e } = this.node.presenceContext || {};
    e && e(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {}
}
const u6 = { animation: { Feature: o6 }, exit: { Feature: c6 } };
function w0(i, t, e, n = { passive: !0 }) {
  return i.addEventListener(t, e, n), () => i.removeEventListener(t, e);
}
function J0(i) {
  return { point: { x: i.pageX, y: i.pageY } };
}
const f6 = (i) => (t) => oM(t) && i(t, J0(t));
function s0(i, t, e, n) {
  return w0(i, t, f6(e), n);
}
const Y3 = 1e-4,
  h6 = 1 - Y3,
  d6 = 1 + Y3,
  q3 = 0.01,
  p6 = 0 - q3,
  m6 = 0 + q3;
function Ss(i) {
  return i.max - i.min;
}
function g6(i, t, e) {
  return Math.abs(i - t) <= e;
}
function e2(i, t, e, n = 0.5) {
  (i.origin = n),
    (i.originPoint = Ii(t.min, t.max, i.origin)),
    (i.scale = Ss(e) / Ss(t)),
    (i.translate = Ii(e.min, e.max, i.origin) - i.originPoint),
    ((i.scale >= h6 && i.scale <= d6) || isNaN(i.scale)) && (i.scale = 1),
    ((i.translate >= p6 && i.translate <= m6) || isNaN(i.translate)) &&
      (i.translate = 0);
}
function r0(i, t, e, n) {
  e2(i.x, t.x, e.x, n ? n.originX : void 0),
    e2(i.y, t.y, e.y, n ? n.originY : void 0);
}
function n2(i, t, e) {
  (i.min = e.min + t.min), (i.max = i.min + Ss(t));
}
function v6(i, t, e) {
  n2(i.x, t.x, e.x), n2(i.y, t.y, e.y);
}
function i2(i, t, e) {
  (i.min = t.min - e.min), (i.max = i.min + Ss(t));
}
function o0(i, t, e) {
  i2(i.x, t.x, e.x), i2(i.y, t.y, e.y);
}
function Dr(i) {
  return [i("x"), i("y")];
}
const K3 = ({ current: i }) => (i ? i.ownerDocument.defaultView : null),
  a2 = (i, t) => Math.abs(i - t);
function y6(i, t) {
  const e = a2(i.x, t.x),
    n = a2(i.y, t.y);
  return Math.sqrt(e ** 2 + n ** 2);
}
class J3 {
  constructor(
    t,
    e,
    {
      transformPagePoint: n,
      contextWindow: a = window,
      dragSnapToOrigin: r = !1,
      distanceThreshold: l = 3,
    } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const x = Tb(this.lastMoveEventInfo, this.history),
          _ = this.startEvent !== null,
          M = y6(x.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!_ && !M) return;
        const { point: C } = x,
          { timestamp: E } = za;
        this.history.push({ ...C, timestamp: E });
        const { onStart: S, onMove: R } = this.handlers;
        _ ||
          (S && S(this.lastMoveEvent, x),
          (this.startEvent = this.lastMoveEvent)),
          R && R(this.lastMoveEvent, x);
      }),
      (this.handlePointerMove = (x, _) => {
        (this.lastMoveEvent = x),
          (this.lastMoveEventInfo = Eb(_, this.transformPagePoint)),
          wi.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (x, _) => {
        this.end();
        const { onEnd: M, onSessionEnd: C, resumeAnimation: E } = this.handlers;
        if (
          (this.dragSnapToOrigin && E && E(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const S = Tb(
          x.type === "pointercancel"
            ? this.lastMoveEventInfo
            : Eb(_, this.transformPagePoint),
          this.history
        );
        this.startEvent && M && M(x, S), C && C(x, S);
      }),
      !oM(t))
    )
      return;
    (this.dragSnapToOrigin = r),
      (this.handlers = e),
      (this.transformPagePoint = n),
      (this.distanceThreshold = l),
      (this.contextWindow = a || window);
    const u = J0(t),
      h = Eb(u, this.transformPagePoint),
      { point: p } = h,
      { timestamp: m } = za;
    this.history = [{ ...p, timestamp: m }];
    const { onSessionStart: v } = e;
    v && v(t, Tb(h, this.history)),
      (this.removeListeners = Y0(
        s0(this.contextWindow, "pointermove", this.handlePointerMove),
        s0(this.contextWindow, "pointerup", this.handlePointerUp),
        s0(this.contextWindow, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), mu(this.updatePoint);
  }
}
function Eb(i, t) {
  return t ? { point: t(i.point) } : i;
}
function s2(i, t) {
  return { x: i.x - t.x, y: i.y - t.y };
}
function Tb({ point: i }, t) {
  return {
    point: i,
    delta: s2(i, Z3(t)),
    offset: s2(i, x6(t)),
    velocity: _6(t, 0.1),
  };
}
function x6(i) {
  return i[0];
}
function Z3(i) {
  return i[i.length - 1];
}
function _6(i, t) {
  if (i.length < 2) return { x: 0, y: 0 };
  let e = i.length - 1,
    n = null;
  const a = Z3(i);
  for (; e >= 0 && ((n = i[e]), !(a.timestamp - n.timestamp > cl(t))); ) e--;
  if (!n) return { x: 0, y: 0 };
  const r = ul(a.timestamp - n.timestamp);
  if (r === 0) return { x: 0, y: 0 };
  const l = { x: (a.x - n.x) / r, y: (a.y - n.y) / r };
  return l.x === 1 / 0 && (l.x = 0), l.y === 1 / 0 && (l.y = 0), l;
}
function b6(i, { min: t, max: e }, n) {
  return (
    t !== void 0 && i < t
      ? (i = n ? Ii(t, i, n.min) : Math.max(i, t))
      : e !== void 0 && i > e && (i = n ? Ii(e, i, n.max) : Math.min(i, e)),
    i
  );
}
function r2(i, t, e) {
  return {
    min: t !== void 0 ? i.min + t : void 0,
    max: e !== void 0 ? i.max + e - (i.max - i.min) : void 0,
  };
}
function A6(i, { top: t, left: e, bottom: n, right: a }) {
  return { x: r2(i.x, e, a), y: r2(i.y, t, n) };
}
function o2(i, t) {
  let e = t.min - i.min,
    n = t.max - i.max;
  return t.max - t.min < i.max - i.min && ([e, n] = [n, e]), { min: e, max: n };
}
function S6(i, t) {
  return { x: o2(i.x, t.x), y: o2(i.y, t.y) };
}
function M6(i, t) {
  let e = 0.5;
  const n = Ss(i),
    a = Ss(t);
  return (
    a > n
      ? (e = b0(t.min, t.max - n, i.min))
      : n > a && (e = b0(i.min, i.max - a, t.min)),
    nc(0, 1, e)
  );
}
function E6(i, t) {
  const e = {};
  return (
    t.min !== void 0 && (e.min = t.min - i.min),
    t.max !== void 0 && (e.max = t.max - i.min),
    e
  );
}
const EA = 0.35;
function T6(i = EA) {
  return (
    i === !1 ? (i = 0) : i === !0 && (i = EA),
    { x: l2(i, "left", "right"), y: l2(i, "top", "bottom") }
  );
}
function l2(i, t, e) {
  return { min: c2(i, t), max: c2(i, e) };
}
function c2(i, t) {
  return typeof i == "number" ? i : i[t] || 0;
}
const w6 = new WeakMap();
class C6 {
  constructor(t) {
    (this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = qi()),
      (this.latestPointerEvent = null),
      (this.latestPanInfo = null),
      (this.visualElement = t);
  }
  start(t, { snapToCursor: e = !1, distanceThreshold: n } = {}) {
    const { presenceContext: a } = this.visualElement;
    if (a && a.isPresent === !1) return;
    const r = (v) => {
        const { dragSnapToOrigin: x } = this.getProps();
        x ? this.pauseAnimation() : this.stopAnimation(),
          e && this.snapToCursor(J0(v).point);
      },
      l = (v, x) => {
        const { drag: _, dragPropagation: M, onDragStart: C } = this.getProps();
        if (
          _ &&
          !M &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = HG(_)),
          !this.openDragLock)
        )
          return;
        (this.latestPointerEvent = v),
          (this.latestPanInfo = x),
          (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Dr((S) => {
            let R = this.getAxisMotionValue(S).get() || 0;
            if (fl.test(R)) {
              const { projection: B } = this.visualElement;
              if (B && B.layout) {
                const D = B.layout.layoutBox[S];
                D && (R = Ss(D) * (parseFloat(R) / 100));
              }
            }
            this.originPoint[S] = R;
          }),
          C && wi.postRender(() => C(v, x)),
          SA(this.visualElement, "transform");
        const { animationState: E } = this.visualElement;
        E && E.setActive("whileDrag", !0);
      },
      u = (v, x) => {
        (this.latestPointerEvent = v), (this.latestPanInfo = x);
        const {
          dragPropagation: _,
          dragDirectionLock: M,
          onDirectionLock: C,
          onDrag: E,
        } = this.getProps();
        if (!_ && !this.openDragLock) return;
        const { offset: S } = x;
        if (M && this.currentDirection === null) {
          (this.currentDirection = R6(S)),
            this.currentDirection !== null && C && C(this.currentDirection);
          return;
        }
        this.updateAxis("x", x.point, S),
          this.updateAxis("y", x.point, S),
          this.visualElement.render(),
          E && E(v, x);
      },
      h = (v, x) => {
        (this.latestPointerEvent = v),
          (this.latestPanInfo = x),
          this.stop(v, x),
          (this.latestPointerEvent = null),
          (this.latestPanInfo = null);
      },
      p = () =>
        Dr(
          (v) =>
            this.getAnimationState(v) === "paused" &&
            this.getAxisMotionValue(v).animation?.play()
        ),
      { dragSnapToOrigin: m } = this.getProps();
    this.panSession = new J3(
      t,
      {
        onSessionStart: r,
        onStart: l,
        onMove: u,
        onSessionEnd: h,
        resumeAnimation: p,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: m,
        distanceThreshold: n,
        contextWindow: K3(this.visualElement),
      }
    );
  }
  stop(t, e) {
    const n = t || this.latestPointerEvent,
      a = e || this.latestPanInfo,
      r = this.isDragging;
    if ((this.cancel(), !r || !a || !n)) return;
    const { velocity: l } = a;
    this.startAnimation(l);
    const { onDragEnd: u } = this.getProps();
    u && wi.postRender(() => u(n, a));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: e } = this.visualElement;
    t && (t.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: n } = this.getProps();
    !n &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      e && e.setActive("whileDrag", !1);
  }
  updateAxis(t, e, n) {
    const { drag: a } = this.getProps();
    if (!n || !My(t, a, this.currentDirection)) return;
    const r = this.getAxisMotionValue(t);
    let l = this.originPoint[t] + n[t];
    this.constraints &&
      this.constraints[t] &&
      (l = b6(l, this.constraints[t], this.elastic[t])),
      r.set(l);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: e } = this.getProps(),
      n =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : this.visualElement.projection?.layout,
      a = this.constraints;
    t && Od(t)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : t && n
      ? (this.constraints = A6(n.layoutBox, t))
      : (this.constraints = !1),
      (this.elastic = T6(e)),
      a !== this.constraints &&
        n &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Dr((r) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(r) &&
            (this.constraints[r] = E6(n.layoutBox[r], this.constraints[r]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: e } = this.getProps();
    if (!t || !Od(t)) return !1;
    const n = t.current,
      { projection: a } = this.visualElement;
    if (!a || !a.layout) return !1;
    const r = D9(n, a.root, this.visualElement.getTransformPagePoint());
    let l = S6(a.layout.layoutBox, r);
    if (e) {
      const u = e(C9(l));
      (this.hasMutatedConstraints = !!u), u && (l = N3(u));
    }
    return l;
  }
  startAnimation(t) {
    const {
        drag: e,
        dragMomentum: n,
        dragElastic: a,
        dragTransition: r,
        dragSnapToOrigin: l,
        onDragTransitionEnd: u,
      } = this.getProps(),
      h = this.constraints || {},
      p = Dr((m) => {
        if (!My(m, e, this.currentDirection)) return;
        let v = (h && h[m]) || {};
        l && (v = { min: 0, max: 0 });
        const x = a ? 200 : 1e6,
          _ = a ? 40 : 1e7,
          M = {
            type: "inertia",
            velocity: n ? t[m] : 0,
            bounceStiffness: x,
            bounceDamping: _,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...r,
            ...v,
          };
        return this.startAxisValueAnimation(m, M);
      });
    return Promise.all(p).then(u);
  }
  startAxisValueAnimation(t, e) {
    const n = this.getAxisMotionValue(t);
    return (
      SA(this.visualElement, t), n.start(vM(t, n, 0, e, this.visualElement, !1))
    );
  }
  stopAnimation() {
    Dr((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    Dr((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  getAxisMotionValue(t) {
    const e = `_drag${t.toUpperCase()}`,
      n = this.visualElement.getProps(),
      a = n[e];
    return (
      a ||
      this.visualElement.getValue(t, (n.initial ? n.initial[t] : void 0) || 0)
    );
  }
  snapToCursor(t) {
    Dr((e) => {
      const { drag: n } = this.getProps();
      if (!My(e, n, this.currentDirection)) return;
      const { projection: a } = this.visualElement,
        r = this.getAxisMotionValue(e);
      if (a && a.layout) {
        const { min: l, max: u } = a.layout.layoutBox[e];
        r.set(t[e] - Ii(l, u, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: t, dragConstraints: e } = this.getProps(),
      { projection: n } = this.visualElement;
    if (!Od(e) || !n || !this.constraints) return;
    this.stopAnimation();
    const a = { x: 0, y: 0 };
    Dr((l) => {
      const u = this.getAxisMotionValue(l);
      if (u && this.constraints !== !1) {
        const h = u.get();
        a[l] = M6({ min: h, max: h }, this.constraints[l]);
      }
    });
    const { transformTemplate: r } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = r ? r({}, "") : "none"),
      n.root && n.root.updateScroll(),
      n.updateLayout(),
      this.resolveConstraints(),
      Dr((l) => {
        if (!My(l, t, null)) return;
        const u = this.getAxisMotionValue(l),
          { min: h, max: p } = this.constraints[l];
        u.set(Ii(h, p, a[l]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    w6.set(this.visualElement, this);
    const t = this.visualElement.current,
      e = s0(t, "pointerdown", (h) => {
        const { drag: p, dragListener: m = !0 } = this.getProps();
        p && m && this.start(h);
      }),
      n = () => {
        const { dragConstraints: h } = this.getProps();
        Od(h) && h.current && (this.constraints = this.resolveRefConstraints());
      },
      { projection: a } = this.visualElement,
      r = a.addEventListener("measure", n);
    a && !a.layout && (a.root && a.root.updateScroll(), a.updateLayout()),
      wi.read(n);
    const l = w0(window, "resize", () => this.scalePositionWithinConstraints()),
      u = a.addEventListener(
        "didUpdate",
        ({ delta: h, hasLayoutChanged: p }) => {
          this.isDragging &&
            p &&
            (Dr((m) => {
              const v = this.getAxisMotionValue(m);
              v &&
                ((this.originPoint[m] += h[m].translate),
                v.set(v.get() + h[m].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      l(), e(), r(), u && u();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(),
      {
        drag: e = !1,
        dragDirectionLock: n = !1,
        dragPropagation: a = !1,
        dragConstraints: r = !1,
        dragElastic: l = EA,
        dragMomentum: u = !0,
      } = t;
    return {
      ...t,
      drag: e,
      dragDirectionLock: n,
      dragPropagation: a,
      dragConstraints: r,
      dragElastic: l,
      dragMomentum: u,
    };
  }
}
function My(i, t, e) {
  return (t === !0 || t === i) && (e === null || e === i);
}
function R6(i, t = 10) {
  let e = null;
  return Math.abs(i.y) > t ? (e = "y") : Math.abs(i.x) > t && (e = "x"), e;
}
class B6 extends bu {
  constructor(t) {
    super(t),
      (this.removeGroupControls = Pr),
      (this.removeListeners = Pr),
      (this.controls = new C6(t));
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Pr);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const u2 = (i) => (t, e) => {
  i && wi.postRender(() => i(t, e));
};
class D6 extends bu {
  constructor() {
    super(...arguments), (this.removePointerDownListener = Pr);
  }
  onPointerDown(t) {
    this.session = new J3(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: K3(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: t,
      onPanStart: e,
      onPan: n,
      onPanEnd: a,
    } = this.node.getProps();
    return {
      onSessionStart: u2(t),
      onStart: u2(e),
      onMove: n,
      onEnd: (r, l) => {
        delete this.session, a && wi.postRender(() => a(r, l));
      },
    };
  }
  mount() {
    this.removePointerDownListener = s0(this.node.current, "pointerdown", (t) =>
      this.onPointerDown(t)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Oy = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function f2(i, t) {
  return t.max === t.min ? 0 : (i / (t.max - t.min)) * 100;
}
const Gm = {
    correct: (i, t) => {
      if (!t.target) return i;
      if (typeof i == "string")
        if (rn.test(i)) i = parseFloat(i);
        else return i;
      const e = f2(i, t.target.x),
        n = f2(i, t.target.y);
      return `${e}% ${n}%`;
    },
  },
  U6 = {
    correct: (i, { treeScale: t, projectionDelta: e }) => {
      const n = i,
        a = gu.parse(i);
      if (a.length > 5) return n;
      const r = gu.createTransformer(i),
        l = typeof a[0] != "number" ? 1 : 0,
        u = e.x.scale * t.x,
        h = e.y.scale * t.y;
      (a[0 + l] /= u), (a[1 + l] /= h);
      const p = Ii(u, h, 0.5);
      return (
        typeof a[2 + l] == "number" && (a[2 + l] /= p),
        typeof a[3 + l] == "number" && (a[3 + l] /= p),
        r(a)
      );
    },
  };
let h2 = !1;
class O6 extends bt.Component {
  componentDidMount() {
    const {
        visualElement: t,
        layoutGroup: e,
        switchLayoutGroup: n,
        layoutId: a,
      } = this.props,
      { projection: r } = t;
    n9(N6),
      r &&
        (e.group && e.group.add(r),
        n && n.register && a && n.register(r),
        h2 && r.root.didUpdate(),
        r.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        r.setOptions({
          ...r.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Oy.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(t) {
    const {
        layoutDependency: e,
        visualElement: n,
        drag: a,
        isPresent: r,
      } = this.props,
      { projection: l } = n;
    return (
      l &&
        ((l.isPresent = r),
        (h2 = !0),
        a || t.layoutDependency !== e || e === void 0 || t.isPresent !== r
          ? l.willUpdate()
          : this.safeToRemove(),
        t.isPresent !== r &&
          (r
            ? l.promote()
            : l.relegate() ||
              wi.postRender(() => {
                const u = l.getStack();
                (!u || !u.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t &&
      (t.root.didUpdate(),
      rM.postRender(() => {
        !t.currentAnimation && t.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: t,
        layoutGroup: e,
        switchLayoutGroup: n,
      } = this.props,
      { projection: a } = t;
    a &&
      (a.scheduleCheckAfterUnmount(),
      e && e.group && e.group.remove(a),
      n && n.deregister && n.deregister(a));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function Q3(i) {
  const [t, e] = KG(),
    n = bt.useContext(CB);
  return O.jsx(O6, {
    ...i,
    layoutGroup: n,
    switchLayoutGroup: bt.useContext(U3),
    isPresent: t,
    safeToRemove: e,
  });
}
const N6 = {
  borderRadius: {
    ...Gm,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: Gm,
  borderTopRightRadius: Gm,
  borderBottomLeftRadius: Gm,
  borderBottomRightRadius: Gm,
  boxShadow: U6,
};
function L6(i, t, e) {
  const n = ns(i) ? i : ep(i);
  return n.start(vM("", n, t, e)), n.animation;
}
const I6 = (i, t) => i.depth - t.depth;
class P6 {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(t) {
    GS(this.children, t), (this.isDirty = !0);
  }
  remove(t) {
    VS(this.children, t), (this.isDirty = !0);
  }
  forEach(t) {
    this.isDirty && this.children.sort(I6),
      (this.isDirty = !1),
      this.children.forEach(t);
  }
}
function z6(i, t) {
  const e = js.now(),
    n = ({ timestamp: a }) => {
      const r = a - e;
      r >= t && (mu(n), i(r - t));
    };
  return wi.setup(n, !0), () => mu(n);
}
const $3 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  F6 = $3.length,
  d2 = (i) => (typeof i == "string" ? parseFloat(i) : i),
  p2 = (i) => typeof i == "number" || rn.test(i);
function H6(i, t, e, n, a, r) {
  a
    ? ((i.opacity = Ii(0, e.opacity ?? 1, G6(n))),
      (i.opacityExit = Ii(t.opacity ?? 1, 0, V6(n))))
    : r && (i.opacity = Ii(t.opacity ?? 1, e.opacity ?? 1, n));
  for (let l = 0; l < F6; l++) {
    const u = `border${$3[l]}Radius`;
    let h = m2(t, u),
      p = m2(e, u);
    if (h === void 0 && p === void 0) continue;
    h || (h = 0),
      p || (p = 0),
      h === 0 || p === 0 || p2(h) === p2(p)
        ? ((i[u] = Math.max(Ii(d2(h), d2(p), n), 0)),
          (fl.test(p) || fl.test(h)) && (i[u] += "%"))
        : (i[u] = p);
  }
  (t.rotate || e.rotate) && (i.rotate = Ii(t.rotate || 0, e.rotate || 0, n));
}
function m2(i, t) {
  return i[t] !== void 0 ? i[t] : i.borderRadius;
}
const G6 = tD(0, 0.5, GB),
  V6 = tD(0.5, 0.95, Pr);
function tD(i, t, e) {
  return (n) => (n < i ? 0 : n > t ? 1 : e(b0(i, t, n)));
}
function g2(i, t) {
  (i.min = t.min), (i.max = t.max);
}
function Br(i, t) {
  g2(i.x, t.x), g2(i.y, t.y);
}
function v2(i, t) {
  (i.translate = t.translate),
    (i.scale = t.scale),
    (i.originPoint = t.originPoint),
    (i.origin = t.origin);
}
function y2(i, t, e, n, a) {
  return (
    (i -= t), (i = Dx(i, 1 / e, n)), a !== void 0 && (i = Dx(i, 1 / a, n)), i
  );
}
function k6(i, t = 0, e = 1, n = 0.5, a, r = i, l = i) {
  if (
    (fl.test(t) &&
      ((t = parseFloat(t)), (t = Ii(l.min, l.max, t / 100) - l.min)),
    typeof t != "number")
  )
    return;
  let u = Ii(r.min, r.max, n);
  i === r && (u -= t),
    (i.min = y2(i.min, t, e, u, a)),
    (i.max = y2(i.max, t, e, u, a));
}
function x2(i, t, [e, n, a], r, l) {
  k6(i, t[e], t[n], t[a], t.scale, r, l);
}
const j6 = ["x", "scaleX", "originX"],
  X6 = ["y", "scaleY", "originY"];
function _2(i, t, e, n) {
  x2(i.x, t, j6, e ? e.x : void 0, n ? n.x : void 0),
    x2(i.y, t, X6, e ? e.y : void 0, n ? n.y : void 0);
}
function b2(i) {
  return i.translate === 0 && i.scale === 1;
}
function eD(i) {
  return b2(i.x) && b2(i.y);
}
function A2(i, t) {
  return i.min === t.min && i.max === t.max;
}
function W6(i, t) {
  return A2(i.x, t.x) && A2(i.y, t.y);
}
function S2(i, t) {
  return (
    Math.round(i.min) === Math.round(t.min) &&
    Math.round(i.max) === Math.round(t.max)
  );
}
function nD(i, t) {
  return S2(i.x, t.x) && S2(i.y, t.y);
}
function M2(i) {
  return Ss(i.x) / Ss(i.y);
}
function E2(i, t) {
  return (
    i.translate === t.translate &&
    i.scale === t.scale &&
    i.originPoint === t.originPoint
  );
}
class Y6 {
  constructor() {
    this.members = [];
  }
  add(t) {
    GS(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (
      (VS(this.members, t),
      t === this.prevLead && (this.prevLead = void 0),
      t === this.lead)
    ) {
      const e = this.members[this.members.length - 1];
      e && this.promote(e);
    }
  }
  relegate(t) {
    const e = this.members.findIndex((a) => t === a);
    if (e === 0) return !1;
    let n;
    for (let a = e; a >= 0; a--) {
      const r = this.members[a];
      if (r.isPresent !== !1) {
        n = r;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(t, e) {
    const n = this.lead;
    if (t !== n && ((this.prevLead = n), (this.lead = t), t.show(), n)) {
      n.instance && n.scheduleRender(),
        t.scheduleRender(),
        (t.resumeFrom = n),
        e && (t.resumeFrom.preserveOpacity = !0),
        n.snapshot &&
          ((t.snapshot = n.snapshot),
          (t.snapshot.latestValues = n.animationValues || n.latestValues)),
        t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: a } = t.options;
      a === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: e, resumingFrom: n } = t;
      e.onExitComplete && e.onExitComplete(),
        n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function q6(i, t, e) {
  let n = "";
  const a = i.x.translate / t.x,
    r = i.y.translate / t.y,
    l = e?.z || 0;
  if (
    ((a || r || l) && (n = `translate3d(${a}px, ${r}px, ${l}px) `),
    (t.x !== 1 || t.y !== 1) && (n += `scale(${1 / t.x}, ${1 / t.y}) `),
    e)
  ) {
    const {
      transformPerspective: p,
      rotate: m,
      rotateX: v,
      rotateY: x,
      skewX: _,
      skewY: M,
    } = e;
    p && (n = `perspective(${p}px) ${n}`),
      m && (n += `rotate(${m}deg) `),
      v && (n += `rotateX(${v}deg) `),
      x && (n += `rotateY(${x}deg) `),
      _ && (n += `skewX(${_}deg) `),
      M && (n += `skewY(${M}deg) `);
  }
  const u = i.x.scale * t.x,
    h = i.y.scale * t.y;
  return (u !== 1 || h !== 1) && (n += `scale(${u}, ${h})`), n || "none";
}
const wb = ["", "X", "Y", "Z"],
  K6 = 1e3;
let J6 = 0;
function Cb(i, t, e, n) {
  const { latestValues: a } = t;
  a[i] && ((e[i] = a[i]), t.setStaticValue(i, 0), n && (n[i] = 0));
}
function iD(i) {
  if (((i.hasCheckedOptimisedAppear = !0), i.root === i)) return;
  const { visualElement: t } = i.options;
  if (!t) return;
  const e = V3(t);
  if (window.MotionHasOptimisedAnimation(e, "transform")) {
    const { layout: a, layoutId: r } = i.options;
    window.MotionCancelOptimisedAnimation(e, "transform", wi, !(a || r));
  }
  const { parent: n } = i;
  n && !n.hasCheckedOptimisedAppear && iD(n);
}
function aD({
  attachResizeListener: i,
  defaultParent: t,
  measureScroll: e,
  checkIsScrollRoot: n,
  resetTransform: a,
}) {
  return class {
    constructor(l = {}, u = t?.()) {
      (this.id = J6++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (this.projectionUpdateScheduled = !1),
            this.nodes.forEach($6),
            this.nodes.forEach(iV),
            this.nodes.forEach(aV),
            this.nodes.forEach(tV);
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = l),
        (this.root = u ? u.root || u : this),
        (this.path = u ? [...u.path, u] : []),
        (this.parent = u),
        (this.depth = u ? u.depth + 1 : 0);
      for (let h = 0; h < this.path.length; h++)
        this.path[h].shouldResetTransform = !0;
      this.root === this && (this.nodes = new P6());
    }
    addEventListener(l, u) {
      return (
        this.eventHandlers.has(l) || this.eventHandlers.set(l, new XS()),
        this.eventHandlers.get(l).add(u)
      );
    }
    notifyListeners(l, ...u) {
      const h = this.eventHandlers.get(l);
      h && h.notify(...u);
    }
    hasListeners(l) {
      return this.eventHandlers.has(l);
    }
    mount(l) {
      if (this.instance) return;
      (this.isSVG = x3(l) && !WG(l)), (this.instance = l);
      const { layoutId: u, layout: h, visualElement: p } = this.options;
      if (
        (p && !p.current && p.mount(l),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (h || u) && (this.isLayoutDirty = !0),
        i)
      ) {
        let m,
          v = 0;
        const x = () => (this.root.updateBlockedByResize = !1);
        wi.read(() => {
          v = window.innerWidth;
        }),
          i(l, () => {
            const _ = window.innerWidth;
            _ !== v &&
              ((v = _),
              (this.root.updateBlockedByResize = !0),
              m && m(),
              (m = z6(x, 250)),
              Oy.hasAnimatedSinceResize &&
                ((Oy.hasAnimatedSinceResize = !1), this.nodes.forEach(C2)));
          });
      }
      u && this.root.registerSharedNode(u, this),
        this.options.animate !== !1 &&
          p &&
          (u || h) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: m,
              hasLayoutChanged: v,
              hasRelativeLayoutChanged: x,
              layout: _,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const M =
                  this.options.transition || p.getDefaultTransition() || cV,
                { onLayoutAnimationStart: C, onLayoutAnimationComplete: E } =
                  p.getProps(),
                S = !this.targetLayout || !nD(this.targetLayout, _),
                R = !v && x;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                R ||
                (v && (S || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0));
                const B = { ...aM(M, "layout"), onPlay: C, onComplete: E };
                (p.shouldReduceMotion || this.options.layoutRoot) &&
                  ((B.delay = 0), (B.type = !1)),
                  this.startAnimation(B),
                  this.setAnimationOrigin(m, R);
              } else
                v || C2(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = _;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const l = this.getStack();
      l && l.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        mu(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(sV),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: l } = this.options;
      return l && l.getProps().transformTemplate;
    }
    willUpdate(l = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          iD(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let m = 0; m < this.path.length; m++) {
        const v = this.path[m];
        (v.shouldResetTransform = !0),
          v.updateScroll("snapshot"),
          v.options.layoutRoot && v.willUpdate(!1);
      }
      const { layoutId: u, layout: h } = this.options;
      if (u === void 0 && !h) return;
      const p = this.getTransformTemplate();
      (this.prevTransformTemplateValue = p ? p(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        l && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(T2);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(w2);
        return;
      }
      (this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(nV),
            this.nodes.forEach(Z6),
            this.nodes.forEach(Q6))
          : this.nodes.forEach(w2),
        this.clearAllSnapshots();
      const u = js.now();
      (za.delta = nc(0, 1e3 / 60, u - za.timestamp)),
        (za.timestamp = u),
        (za.isProcessing = !0),
        vb.update.process(za),
        vb.preRender.process(za),
        vb.render.process(za),
        (za.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), rM.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(eV), this.sharedNodes.forEach(rV);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        wi.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      wi.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !Ss(this.snapshot.measuredBox.x) &&
          !Ss(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0));
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let h = 0; h < this.path.length; h++) this.path[h].updateScroll();
      const l = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = qi()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: u } = this.options;
      u &&
        u.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          l ? l.layoutBox : void 0
        );
    }
    updateScroll(l = "measure") {
      let u = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === l &&
          (u = !1),
        u && this.instance)
      ) {
        const h = n(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: l,
          isRoot: h,
          offset: e(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : h,
        };
      }
    }
    resetTransform() {
      if (!a) return;
      const l =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        u = this.projectionDelta && !eD(this.projectionDelta),
        h = this.getTransformTemplate(),
        p = h ? h(this.latestValues, "") : void 0,
        m = p !== this.prevTransformTemplateValue;
      l &&
        this.instance &&
        (u || Nf(this.latestValues) || m) &&
        (a(this.instance, p),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(l = !0) {
      const u = this.measurePageBox();
      let h = this.removeElementScroll(u);
      return (
        l && (h = this.removeTransform(h)),
        uV(h),
        {
          animationId: this.root.animationId,
          measuredBox: u,
          layoutBox: h,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: l } = this.options;
      if (!l) return qi();
      const u = l.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(fV))) {
        const { scroll: p } = this.root;
        p && (Nd(u.x, p.offset.x), Nd(u.y, p.offset.y));
      }
      return u;
    }
    removeElementScroll(l) {
      const u = qi();
      if ((Br(u, l), this.scroll?.wasRoot)) return u;
      for (let h = 0; h < this.path.length; h++) {
        const p = this.path[h],
          { scroll: m, options: v } = p;
        p !== this.root &&
          m &&
          v.layoutScroll &&
          (m.wasRoot && Br(u, l), Nd(u.x, m.offset.x), Nd(u.y, m.offset.y));
      }
      return u;
    }
    applyTransform(l, u = !1) {
      const h = qi();
      Br(h, l);
      for (let p = 0; p < this.path.length; p++) {
        const m = this.path[p];
        !u &&
          m.options.layoutScroll &&
          m.scroll &&
          m !== m.root &&
          Ld(h, { x: -m.scroll.offset.x, y: -m.scroll.offset.y }),
          Nf(m.latestValues) && Ld(h, m.latestValues);
      }
      return Nf(this.latestValues) && Ld(h, this.latestValues), h;
    }
    removeTransform(l) {
      const u = qi();
      Br(u, l);
      for (let h = 0; h < this.path.length; h++) {
        const p = this.path[h];
        if (!p.instance || !Nf(p.latestValues)) continue;
        xA(p.latestValues) && p.updateSnapshot();
        const m = qi(),
          v = p.measurePageBox();
        Br(m, v),
          _2(u, p.latestValues, p.snapshot ? p.snapshot.layoutBox : void 0, m);
      }
      return Nf(this.latestValues) && _2(u, this.latestValues), u;
    }
    setTargetDelta(l) {
      (this.targetDelta = l),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(l) {
      this.options = {
        ...this.options,
        ...l,
        crossfade: l.crossfade !== void 0 ? l.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== za.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(l = !1) {
      const u = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
      const h = !!this.resumingFrom || this !== u;
      if (
        !(
          l ||
          (h && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          this.parent?.isProjectionDirty ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: m, layoutId: v } = this.options;
      if (!(!this.layout || !(m || v))) {
        if (
          ((this.resolvedRelativeTargetAt = za.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const x = this.getClosestProjectingParent();
          x && x.layout && this.animationProgress !== 1
            ? ((this.relativeParent = x),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = qi()),
              (this.relativeTargetOrigin = qi()),
              o0(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                x.layout.layoutBox
              ),
              Br(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (
          !(!this.relativeTarget && !this.targetDelta) &&
          (this.target ||
            ((this.target = qi()), (this.targetWithTransforms = qi())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              v6(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
            ? (this.resumingFrom
                ? (this.target = this.applyTransform(this.layout.layoutBox))
                : Br(this.target, this.layout.layoutBox),
              I3(this.target, this.targetDelta))
            : Br(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget)
        ) {
          this.attemptToResolveRelativeTarget = !1;
          const x = this.getClosestProjectingParent();
          x &&
          !!x.resumingFrom == !!this.resumingFrom &&
          !x.options.layoutScroll &&
          x.target &&
          this.animationProgress !== 1
            ? ((this.relativeParent = x),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = qi()),
              (this.relativeTargetOrigin = qi()),
              o0(this.relativeTargetOrigin, this.target, x.target),
              Br(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          xA(this.parent.latestValues) ||
          L3(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      const l = this.getLead(),
        u = !!this.resumingFrom || this !== l;
      let h = !0;
      if (
        ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (h = !1),
        u &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (h = !1),
        this.resolvedRelativeTargetAt === za.timestamp && (h = !1),
        h)
      )
        return;
      const { layout: p, layoutId: m } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(p || m))
      )
        return;
      Br(this.layoutCorrected, this.layout.layoutBox);
      const v = this.treeScale.x,
        x = this.treeScale.y;
      B9(this.layoutCorrected, this.treeScale, this.path, u),
        l.layout &&
          !l.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((l.target = l.layout.layoutBox), (l.targetWithTransforms = qi()));
      const { target: _ } = l;
      if (!_) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (v2(this.prevProjectionDelta.x, this.projectionDelta.x),
          v2(this.prevProjectionDelta.y, this.projectionDelta.y)),
        r0(this.projectionDelta, this.layoutCorrected, _, this.latestValues),
        (this.treeScale.x !== v ||
          this.treeScale.y !== x ||
          !E2(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !E2(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", _));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(l = !0) {
      if ((this.options.visualElement?.scheduleRender(), l)) {
        const u = this.getStack();
        u && u.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      (this.prevProjectionDelta = Id()),
        (this.projectionDelta = Id()),
        (this.projectionDeltaWithTransform = Id());
    }
    setAnimationOrigin(l, u = !1) {
      const h = this.snapshot,
        p = h ? h.latestValues : {},
        m = { ...this.latestValues },
        v = Id();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !u);
      const x = qi(),
        _ = h ? h.source : void 0,
        M = this.layout ? this.layout.source : void 0,
        C = _ !== M,
        E = this.getStack(),
        S = !E || E.members.length <= 1,
        R = !!(C && !S && this.options.crossfade === !0 && !this.path.some(lV));
      this.animationProgress = 0;
      let B;
      (this.mixTargetDelta = (D) => {
        const I = D / 1e3;
        R2(v.x, l.x, I),
          R2(v.y, l.y, I),
          this.setTargetDelta(v),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (o0(x, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            oV(this.relativeTarget, this.relativeTargetOrigin, x, I),
            B && W6(this.relativeTarget, B) && (this.isProjectionDirty = !1),
            B || (B = qi()),
            Br(B, this.relativeTarget)),
          C &&
            ((this.animationValues = m), H6(m, p, this.latestValues, I, R, S)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = I);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(l) {
      this.notifyListeners("animationStart"),
        this.currentAnimation?.stop(),
        this.resumingFrom?.currentAnimation?.stop(),
        this.pendingAnimation &&
          (mu(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = wi.update(() => {
          (Oy.hasAnimatedSinceResize = !0),
            this.motionValue || (this.motionValue = ep(0)),
            (this.currentAnimation = L6(this.motionValue, [0, 1e3], {
              ...l,
              velocity: 0,
              isSync: !0,
              onUpdate: (u) => {
                this.mixTargetDelta(u), l.onUpdate && l.onUpdate(u);
              },
              onStop: () => {},
              onComplete: () => {
                l.onComplete && l.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const l = this.getStack();
      l && l.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(K6),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const l = this.getLead();
      let {
        targetWithTransforms: u,
        target: h,
        layout: p,
        latestValues: m,
      } = l;
      if (!(!u || !h || !p)) {
        if (
          this !== l &&
          this.layout &&
          p &&
          sD(this.options.animationType, this.layout.layoutBox, p.layoutBox)
        ) {
          h = this.target || qi();
          const v = Ss(this.layout.layoutBox.x);
          (h.x.min = l.target.x.min), (h.x.max = h.x.min + v);
          const x = Ss(this.layout.layoutBox.y);
          (h.y.min = l.target.y.min), (h.y.max = h.y.min + x);
        }
        Br(u, h),
          Ld(u, m),
          r0(this.projectionDeltaWithTransform, this.layoutCorrected, u, m);
      }
    }
    registerSharedNode(l, u) {
      this.sharedNodes.has(l) || this.sharedNodes.set(l, new Y6()),
        this.sharedNodes.get(l).add(u);
      const p = u.options.initialPromotionConfig;
      u.promote({
        transition: p ? p.transition : void 0,
        preserveFollowOpacity:
          p && p.shouldPreserveFollowOpacity
            ? p.shouldPreserveFollowOpacity(u)
            : void 0,
      });
    }
    isLead() {
      const l = this.getStack();
      return l ? l.lead === this : !0;
    }
    getLead() {
      const { layoutId: l } = this.options;
      return l ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: l } = this.options;
      return l ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: l } = this.options;
      if (l) return this.root.sharedNodes.get(l);
    }
    promote({ needsReset: l, transition: u, preserveFollowOpacity: h } = {}) {
      const p = this.getStack();
      p && p.promote(this, h),
        l && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        u && this.setOptions({ transition: u });
    }
    relegate() {
      const l = this.getStack();
      return l ? l.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: l } = this.options;
      if (!l) return;
      let u = !1;
      const { latestValues: h } = l;
      if (
        ((h.z ||
          h.rotate ||
          h.rotateX ||
          h.rotateY ||
          h.rotateZ ||
          h.skewX ||
          h.skewY) &&
          (u = !0),
        !u)
      )
        return;
      const p = {};
      h.z && Cb("z", l, p, this.animationValues);
      for (let m = 0; m < wb.length; m++)
        Cb(`rotate${wb[m]}`, l, p, this.animationValues),
          Cb(`skew${wb[m]}`, l, p, this.animationValues);
      l.render();
      for (const m in p)
        l.setStaticValue(m, p[m]),
          this.animationValues && (this.animationValues[m] = p[m]);
      l.scheduleRender();
    }
    applyProjectionStyles(l, u) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        l.visibility = "hidden";
        return;
      }
      const h = this.getTransformTemplate();
      if (this.needsReset) {
        (this.needsReset = !1),
          (l.visibility = ""),
          (l.opacity = ""),
          (l.pointerEvents = Uy(u?.pointerEvents) || ""),
          (l.transform = h ? h(this.latestValues, "") : "none");
        return;
      }
      const p = this.getLead();
      if (!this.projectionDelta || !this.layout || !p.target) {
        this.options.layoutId &&
          ((l.opacity =
            this.latestValues.opacity !== void 0
              ? this.latestValues.opacity
              : 1),
          (l.pointerEvents = Uy(u?.pointerEvents) || "")),
          this.hasProjected &&
            !Nf(this.latestValues) &&
            ((l.transform = h ? h({}, "") : "none"), (this.hasProjected = !1));
        return;
      }
      l.visibility = "";
      const m = p.animationValues || p.latestValues;
      this.applyTransformsToTarget();
      let v = q6(this.projectionDeltaWithTransform, this.treeScale, m);
      h && (v = h(m, v)), (l.transform = v);
      const { x, y: _ } = this.projectionDelta;
      (l.transformOrigin = `${x.origin * 100}% ${_.origin * 100}% 0`),
        p.animationValues
          ? (l.opacity =
              p === this
                ? m.opacity ?? this.latestValues.opacity ?? 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : m.opacityExit)
          : (l.opacity =
              p === this
                ? m.opacity !== void 0
                  ? m.opacity
                  : ""
                : m.opacityExit !== void 0
                ? m.opacityExit
                : 0);
      for (const M in E0) {
        if (m[M] === void 0) continue;
        const { correct: C, applyTo: E, isCSSVariable: S } = E0[M],
          R = v === "none" ? m[M] : C(m[M], p);
        if (E) {
          const B = E.length;
          for (let D = 0; D < B; D++) l[E[D]] = R;
        } else
          S ? (this.options.visualElement.renderState.vars[M] = R) : (l[M] = R);
      }
      this.options.layoutId &&
        (l.pointerEvents = p === this ? Uy(u?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((l) => l.currentAnimation?.stop()),
        this.root.nodes.forEach(T2),
        this.root.sharedNodes.clear();
    }
  };
}
function Z6(i) {
  i.updateLayout();
}
function Q6(i) {
  const t = i.resumeFrom?.snapshot || i.snapshot;
  if (i.isLead() && i.layout && t && i.hasListeners("didUpdate")) {
    const { layoutBox: e, measuredBox: n } = i.layout,
      { animationType: a } = i.options,
      r = t.source !== i.layout.source;
    a === "size"
      ? Dr((m) => {
          const v = r ? t.measuredBox[m] : t.layoutBox[m],
            x = Ss(v);
          (v.min = e[m].min), (v.max = v.min + x);
        })
      : sD(a, t.layoutBox, e) &&
        Dr((m) => {
          const v = r ? t.measuredBox[m] : t.layoutBox[m],
            x = Ss(e[m]);
          (v.max = v.min + x),
            i.relativeTarget &&
              !i.currentAnimation &&
              ((i.isProjectionDirty = !0),
              (i.relativeTarget[m].max = i.relativeTarget[m].min + x));
        });
    const l = Id();
    r0(l, e, t.layoutBox);
    const u = Id();
    r ? r0(u, i.applyTransform(n, !0), t.measuredBox) : r0(u, e, t.layoutBox);
    const h = !eD(l);
    let p = !1;
    if (!i.resumeFrom) {
      const m = i.getClosestProjectingParent();
      if (m && !m.resumeFrom) {
        const { snapshot: v, layout: x } = m;
        if (v && x) {
          const _ = qi();
          o0(_, t.layoutBox, v.layoutBox);
          const M = qi();
          o0(M, e, x.layoutBox),
            nD(_, M) || (p = !0),
            m.options.layoutRoot &&
              ((i.relativeTarget = M),
              (i.relativeTargetOrigin = _),
              (i.relativeParent = m));
        }
      }
    }
    i.notifyListeners("didUpdate", {
      layout: e,
      snapshot: t,
      delta: u,
      layoutDelta: l,
      hasLayoutChanged: h,
      hasRelativeLayoutChanged: p,
    });
  } else if (i.isLead()) {
    const { onExitComplete: e } = i.options;
    e && e();
  }
  i.options.transition = void 0;
}
function $6(i) {
  i.parent &&
    (i.isProjecting() || (i.isProjectionDirty = i.parent.isProjectionDirty),
    i.isSharedProjectionDirty ||
      (i.isSharedProjectionDirty = !!(
        i.isProjectionDirty ||
        i.parent.isProjectionDirty ||
        i.parent.isSharedProjectionDirty
      )),
    i.isTransformDirty || (i.isTransformDirty = i.parent.isTransformDirty));
}
function tV(i) {
  i.isProjectionDirty = i.isSharedProjectionDirty = i.isTransformDirty = !1;
}
function eV(i) {
  i.clearSnapshot();
}
function T2(i) {
  i.clearMeasurements();
}
function w2(i) {
  i.isLayoutDirty = !1;
}
function nV(i) {
  const { visualElement: t } = i.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
    i.resetTransform();
}
function C2(i) {
  i.finishAnimation(),
    (i.targetDelta = i.relativeTarget = i.target = void 0),
    (i.isProjectionDirty = !0);
}
function iV(i) {
  i.resolveTargetDelta();
}
function aV(i) {
  i.calcProjection();
}
function sV(i) {
  i.resetSkewAndRotation();
}
function rV(i) {
  i.removeLeadSnapshot();
}
function R2(i, t, e) {
  (i.translate = Ii(t.translate, 0, e)),
    (i.scale = Ii(t.scale, 1, e)),
    (i.origin = t.origin),
    (i.originPoint = t.originPoint);
}
function B2(i, t, e, n) {
  (i.min = Ii(t.min, e.min, n)), (i.max = Ii(t.max, e.max, n));
}
function oV(i, t, e, n) {
  B2(i.x, t.x, e.x, n), B2(i.y, t.y, e.y, n);
}
function lV(i) {
  return i.animationValues && i.animationValues.opacityExit !== void 0;
}
const cV = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  D2 = (i) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(i),
  U2 = D2("applewebkit/") && !D2("chrome/") ? Math.round : Pr;
function O2(i) {
  (i.min = U2(i.min)), (i.max = U2(i.max));
}
function uV(i) {
  O2(i.x), O2(i.y);
}
function sD(i, t, e) {
  return (
    i === "position" || (i === "preserve-aspect" && !g6(M2(t), M2(e), 0.2))
  );
}
function fV(i) {
  return i !== i.root && i.scroll?.wasRoot;
}
const hV = aD({
    attachResizeListener: (i, t) => w0(i, "resize", t),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  Rb = { current: void 0 },
  rD = aD({
    measureScroll: (i) => ({ x: i.scrollLeft, y: i.scrollTop }),
    defaultParent: () => {
      if (!Rb.current) {
        const i = new hV({});
        i.mount(window), i.setOptions({ layoutScroll: !0 }), (Rb.current = i);
      }
      return Rb.current;
    },
    resetTransform: (i, t) => {
      i.style.transform = t !== void 0 ? t : "none";
    },
    checkIsScrollRoot: (i) => window.getComputedStyle(i).position === "fixed",
  }),
  dV = {
    pan: { Feature: D6 },
    drag: { Feature: B6, ProjectionNode: rD, MeasureLayout: Q3 },
  };
function N2(i, t, e) {
  const { props: n } = i;
  i.animationState &&
    n.whileHover &&
    i.animationState.setActive("whileHover", e === "Start");
  const a = "onHover" + e,
    r = n[a];
  r && wi.postRender(() => r(t, J0(t)));
}
class pV extends bu {
  mount() {
    const { current: t } = this.node;
    t &&
      (this.unmount = GG(
        t,
        (e, n) => (N2(this.node, n, "Start"), (a) => N2(this.node, a, "End"))
      ));
  }
  unmount() {}
}
class mV extends bu {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = Y0(
      w0(this.node.current, "focus", () => this.onFocus()),
      w0(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
function L2(i, t, e) {
  const { props: n } = i;
  if (i.current instanceof HTMLButtonElement && i.current.disabled) return;
  i.animationState &&
    n.whileTap &&
    i.animationState.setActive("whileTap", e === "Start");
  const a = "onTap" + (e === "End" ? "" : e),
    r = n[a];
  r && wi.postRender(() => r(t, J0(t)));
}
class gV extends bu {
  mount() {
    const { current: t } = this.node;
    t &&
      (this.unmount = XG(
        t,
        (e, n) => (
          L2(this.node, n, "Start"),
          (a, { success: r }) => L2(this.node, a, r ? "End" : "Cancel")
        ),
        { useGlobalTarget: this.node.props.globalTapTarget }
      ));
  }
  unmount() {}
}
const TA = new WeakMap(),
  Bb = new WeakMap(),
  vV = (i) => {
    const t = TA.get(i.target);
    t && t(i);
  },
  yV = (i) => {
    i.forEach(vV);
  };
function xV({ root: i, ...t }) {
  const e = i || document;
  Bb.has(e) || Bb.set(e, {});
  const n = Bb.get(e),
    a = JSON.stringify(t);
  return n[a] || (n[a] = new IntersectionObserver(yV, { root: i, ...t })), n[a];
}
function _V(i, t, e) {
  const n = xV(t);
  return (
    TA.set(i, e),
    n.observe(i),
    () => {
      TA.delete(i), n.unobserve(i);
    }
  );
}
const bV = { some: 0, all: 1 };
class AV extends bu {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(),
      { root: e, margin: n, amount: a = "some", once: r } = t,
      l = {
        root: e ? e.current : void 0,
        rootMargin: n,
        threshold: typeof a == "number" ? a : bV[a],
      },
      u = (h) => {
        const { isIntersecting: p } = h;
        if (
          this.isInView === p ||
          ((this.isInView = p), r && !p && this.hasEnteredView)
        )
          return;
        p && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", p);
        const { onViewportEnter: m, onViewportLeave: v } = this.node.getProps(),
          x = p ? m : v;
        x && x(h);
      };
    return _V(this.node.current, l, u);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: t, prevProps: e } = this.node;
    ["amount", "margin", "root"].some(SV(t, e)) && this.startObserver();
  }
  unmount() {}
}
function SV({ viewport: i = {} }, { viewport: t = {} } = {}) {
  return (e) => i[e] !== t[e];
}
const MV = {
    inView: { Feature: AV },
    tap: { Feature: gV },
    focus: { Feature: mV },
    hover: { Feature: pV },
  },
  EV = { layout: { ProjectionNode: rD, MeasureLayout: Q3 } },
  TV = { ...u6, ...MV, ...dV, ...EV },
  Be = w9(TV, H9);
function wV(i) {
  i.values.forEach((t) => t.stop());
}
function wA(i, t) {
  [...t].reverse().forEach((n) => {
    const a = i.getVariant(n);
    a && gM(i, a),
      i.variantChildren &&
        i.variantChildren.forEach((r) => {
          wA(r, t);
        });
  });
}
function CV(i, t) {
  if (Array.isArray(t)) return wA(i, t);
  if (typeof t == "string") return wA(i, [t]);
  gM(i, t);
}
function RV() {
  const i = new Set(),
    t = {
      subscribe(e) {
        return i.add(e), () => void i.delete(e);
      },
      start(e, n) {
        const a = [];
        return (
          i.forEach((r) => {
            a.push(j3(r, e, { transitionOverride: n }));
          }),
          Promise.all(a)
        );
      },
      set(e) {
        return i.forEach((n) => {
          CV(n, e);
        });
      },
      stop() {
        i.forEach((e) => {
          wV(e);
        });
      },
      mount() {
        return () => {
          t.stop();
        };
      },
    };
  return t;
}
function BV() {
  const i = RB(RV);
  return BB(i.mount, []), i;
}
const Db = BV;
var Rd = {},
  I2;
function DV() {
  if (I2) return Rd;
  (I2 = 1), Object.defineProperty(Rd, "__esModule", { value: !0 });
  var i = k2(),
    t = nh(),
    e = function () {
      return (
        (e =
          Object.assign ||
          function (h) {
            for (var p, m = 1, v = arguments.length; m < v; m++)
              for (var x in (p = arguments[m]))
                Object.prototype.hasOwnProperty.call(p, x) && (h[x] = p[x]);
            return h;
          }),
        e.apply(this, arguments)
      );
    };
  function n(h, p) {
    var m, v;
    switch (p.type) {
      case "TYPE":
        return e(e({}, h), {
          speed: p.speed,
          text:
            (m = p.payload) === null || m === void 0
              ? void 0
              : m.substring(0, h.text.length + 1),
        });
      case "DELAY":
        return e(e({}, h), { speed: p.payload });
      case "DELETE":
        return e(e({}, h), {
          speed: p.speed,
          text:
            (v = p.payload) === null || v === void 0
              ? void 0
              : v.substring(0, h.text.length - 1),
        });
      case "COUNT":
        return e(e({}, h), { count: h.count + 1 });
      default:
        return h;
    }
  }
  var a = function (h) {
      var p = h.words,
        m =
          p === void 0 ? ["Hello World!", "This is", "a simple Typewriter"] : p,
        v = h.loop,
        x = v === void 0 ? 1 : v,
        _ = h.typeSpeed,
        M = _ === void 0 ? 80 : _,
        C = h.deleteSpeed,
        E = C === void 0 ? 50 : C,
        S = h.delaySpeed,
        R = S === void 0 ? 1500 : S,
        B = h.onLoopDone,
        D = h.onType,
        I = h.onDelete,
        P = h.onDelay,
        V = t.useReducer(n, { speed: M, text: "", count: 0 }),
        F = V[0],
        N = F.speed,
        L = F.text,
        Y = F.count,
        ct = V[1],
        nt = t.useRef(0),
        dt = t.useRef(!1),
        pt = t.useRef(!1),
        j = t.useRef(!1),
        Q = t.useRef(!1),
        et = t.useCallback(
          function () {
            var xt = Y % m.length,
              X = m[xt];
            pt.current
              ? (ct({ type: "DELETE", payload: X, speed: E }),
                L === "" && ((pt.current = !1), ct({ type: "COUNT" })))
              : (ct({ type: "TYPE", payload: X, speed: M }),
                (j.current = !0),
                L === X &&
                  (ct({ type: "DELAY", payload: R }),
                  (j.current = !1),
                  (Q.current = !0),
                  setTimeout(function () {
                    (Q.current = !1), (pt.current = !0);
                  }, R),
                  x > 0 &&
                    ((nt.current += 1),
                    nt.current / m.length === x &&
                      ((Q.current = !1), (dt.current = !0))))),
              j.current && D && D(nt.current),
              pt.current && I && I(),
              Q.current && P && P();
          },
          [Y, R, E, x, M, m, L, D, I, P]
        );
      return (
        t.useEffect(
          function () {
            var xt = setTimeout(et, N);
            return (
              dt.current && clearTimeout(xt),
              function () {
                return clearTimeout(xt);
              }
            );
          },
          [et, N]
        ),
        t.useEffect(
          function () {
            B && dt.current && B();
          },
          [B]
        ),
        [
          L,
          {
            isType: j.current,
            isDelay: Q.current,
            isDelete: pt.current,
            isDone: dt.current,
          },
        ]
      );
    },
    r = "styles-module_blinkingCursor__yugAC",
    l = "styles-module_blinking__9VXRT";
  (function (h, p) {
    p === void 0 && (p = {});
    var m = p.insertAt;
    if (typeof document < "u") {
      var v = document.head || document.getElementsByTagName("head")[0],
        x = document.createElement("style");
      (x.type = "text/css"),
        m === "top" && v.firstChild
          ? v.insertBefore(x, v.firstChild)
          : v.appendChild(x),
        x.styleSheet
          ? (x.styleSheet.cssText = h)
          : x.appendChild(document.createTextNode(h));
    }
  })(
    ".styles-module_blinkingCursor__yugAC{color:inherit;font:inherit;left:3px;line-height:inherit;opacity:1;position:relative;top:0}.styles-module_blinking__9VXRT{animation-duration:.8s;animation-iteration-count:infinite;animation-name:styles-module_blink__rqfaf}@keyframes styles-module_blink__rqfaf{0%{opacity:1}to{opacity:0}}"
  );
  var u = t.memo(function (h) {
    var p = h.cursorBlinking,
      m = p === void 0 || p,
      v = h.cursorStyle,
      x = v === void 0 ? "|" : v,
      _ = h.cursorColor,
      M = _ === void 0 ? "inherit" : _;
    return i.jsx(
      "span",
      e(
        {
          style: { color: M },
          className: "".concat(r, " ").concat(m ? l : ""),
        },
        { children: x }
      )
    );
  });
  return (
    (Rd.Cursor = u),
    (Rd.Typewriter = function (h) {
      var p = h.words,
        m =
          p === void 0 ? ["Hello World!", "This is", "a simple Typewriter"] : p,
        v = h.loop,
        x = v === void 0 ? 1 : v,
        _ = h.typeSpeed,
        M = _ === void 0 ? 80 : _,
        C = h.deleteSpeed,
        E = C === void 0 ? 50 : C,
        S = h.delaySpeed,
        R = S === void 0 ? 1500 : S,
        B = h.cursor,
        D = B !== void 0 && B,
        I = h.cursorStyle,
        P = I === void 0 ? "|" : I,
        V = h.cursorColor,
        F = V === void 0 ? "inherit" : V,
        N = h.cursorBlinking,
        L = N === void 0 || N,
        Y = h.onLoopDone,
        ct = h.onType,
        nt = h.onDelay,
        dt = h.onDelete,
        pt = a({
          words: m,
          loop: x,
          typeSpeed: M,
          deleteSpeed: E,
          delaySpeed: R,
          onLoopDone: Y,
          onType: ct,
          onDelay: nt,
          onDelete: dt,
        })[0];
      return i.jsxs(i.Fragment, {
        children: [
          i.jsx("span", { children: pt }),
          D && i.jsx(u, { cursorStyle: P, cursorColor: F, cursorBlinking: L }),
        ],
      });
    }),
    (Rd.useTypewriter = a),
    Rd
  );
}
var P2 = DV();
const z2 =
  "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/bd16ebd32caee97543484bec8e7922a8.png";
function F2(i) {
  const { selectedIndex: t, ...e } = i,
    n = bt.useRef(),
    { scene: a, animations: r } = W0("/shiba_inu_texture_updated.glb"),
    { actions: l } = I8(r, n),
    [u, h] = bt.useState(typeof t == "number" ? t : 0),
    p = RA.useMemo(() => VF.clone(a), [a]);
  return (
    bt.useEffect(() => {
      p.traverse((m) => {
        m.isMesh && (m.castShadow = !0);
      });
    }, [p]),
    bt.useEffect(() => {
      if (!l || r.length === 0) return;
      const m = r.map((M) => M.name);
      let v = u;
      typeof t == "number" &&
        t >= 0 &&
        t < m.length &&
        ((v = t), u !== t && h(t));
      const x = m[v],
        _ = l[x];
      if (_)
        return (
          _.reset().play(),
          (_.clampWhenFinished = !1),
          _.setLoop(IA, 1 / 0),
          (_.onFinished = null),
          () => {
            _.stop(), (_.onFinished = null);
          }
        );
    }, [l, r, u, t]),
    O.jsx("group", {
      ref: n,
      ...e,
      children: O.jsx("primitive", { object: p }),
    })
  );
}
W0.preload("/shiba_inu_texture_updated.glb");
const H2 = [
  { initial: { opacity: 0, y: 40 }, animate: { opacity: 1, y: 0 } },
  { initial: { opacity: 0, x: -60 }, animate: { opacity: 1, x: 0 } },
  { initial: { opacity: 0, x: 60 }, animate: { opacity: 1, x: 0 } },
  { initial: { opacity: 0, scale: 0.7 }, animate: { opacity: 1, scale: 1 } },
  { initial: { opacity: 0, rotate: -30 }, animate: { opacity: 1, rotate: 0 } },
  { initial: { opacity: 0, rotate: 30 }, animate: { opacity: 1, rotate: 0 } },
  {
    initial: { opacity: 0, y: 60, scale: 0.8 },
    animate: { opacity: 1, y: 0, scale: 1 },
    transition: { type: "spring", bounce: 0.4, duration: 1 },
  },
];
function G2() {
  return typeof window < "u" ? window.innerWidth <= 900 : !1;
}
function UV() {
  const [i, t] = bt.useState(!1),
    [e, n] = bt.useState(!1),
    a = Db();
  bt.useEffect(() => {
    a.start({ opacity: 1, y: 0 }).then(() => n(!0));
  }, [a]),
    bt.useEffect(() => {
      const x = () => t(window.innerWidth <= 900);
      return (
        x(),
        window.addEventListener("resize", x),
        () => window.removeEventListener("resize", x)
      );
    }, []);
  const [r, l] = bt.useState(1),
    u = [
      "play_dead_skeletal.3",
      "rollover_skeletal.3",
      "shake_skeletal.3",
      "sitting_skeletal.3",
      "standing_skeletal.3",
    ],
    h = bt.useMemo(() => {
      const x = Math.floor(Math.random() * H2.length);
      return H2[x];
    }, []),
    p = Db(),
    m = Db(),
    v = async (x) => {
      G2() &&
        (await x.start(
          { scale: [1, 1.15, 1] },
          { duration: 0.32, ease: "easeOut" }
        ));
    };
  return (
    bt.useEffect(() => {
      G2() &&
        (p.start({ scale: [1, 1.15, 1] }, { duration: 0.32, ease: "easeOut" }),
        setTimeout(() => {
          m.start({ scale: [1, 1.15, 1] }, { duration: 0.32, ease: "easeOut" });
        }, 200));
    }, []),
    O.jsxs(O.Fragment, {
      children: [
        O.jsx("style", {
          children: `
        .hero3d-flex {
          width: 100%;
          min-height: 100vh;
          display: flex;
          flex-direction: row;
          align-items: stretch;
          justify-content: center;
          position: relative;
          z-index: 1;
        }
        .hero3d-left {
          flex: 1 1 0;
          min-width: 0;
          display: flex;
          align-items: stretch;
          justify-content: center;
          background: transparent;
          padding: 0;
          height: 100vh;
          min-height: 100vh;
        }
        .hero3d-right {
          flex: 1 1 0;
          min-width: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          background: transparent;
          padding: 0;
          height: 100vh;
          min-height: 100vh;
        }
        .hero-title-content {
          width: 100%;
          max-width: 540px;
          min-width: 260px;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          background: rgba(24, 25, 28, 0.65);
          backdrop-filter: blur(12px);
          -webkit-backdrop-filter: blur(12px);
          border-radius: 1vw;
          border: 1.5px solid rgba(255,255,255,0.10);
          box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.18);
          padding: 2vw 2vw 2vw 2vw;
        }
        .hero-title-logo {
          width: 110px;
          height: 110px;
          border-radius: 50%;
          box-shadow: 0 0 2vw 0.5vw #064e3b55;
          background: #18191c;
          margin-bottom: 1.5vw;
        }
        .hero-title-main {
          color: #064e3b;
          font-size: 2.7vw;
          font-weight: 800;
          margin-bottom: 0.7vw;
          text-align: center;
          text-shadow: 0 0.2vw 1vw #000a;
        }
        .hero-title-sub {
          color: #fff;
          font-size: 1.2vw;
          font-weight: 500;
          margin-bottom: 2.5vw;
          text-align: center;
          line-height: 1.5;
          text-shadow: 0 0.1vw 0.5vw #000a;
        }
        .hero-title-btns {
          display: flex;
          gap: 1vw;
          margin-top: 1vw;
        }
        .hero-title-btn {
          background: linear-gradient(90deg, #064e3b 60%, #2cb979 100%);
          color: #fff;
          font-weight: 700;
          font-size: 1.1vw;
          border: none;
          border-radius: 0.5vw;
          padding: 0.8vw 2vw;
          cursor: pointer;
          box-shadow: 0 0.2vw 1vw #064e3b44;
          text-decoration: none;
          transition: background 0.2s, transform 0.2s;
        }
        .hero-title-btn.secondary {
          background: transparent;
          color: #064e3b;
          border: 0.2vw solid #064e3b;
        }
        .animation-controls {
          display: flex;
          justify-content: center;
          gap: 0.7vw;
          margin: 1vw 0 0.5vw 0;
          position: relative;
          z-index: 10;
          flex-wrap: nowrap;
          box-sizing: border-box;
        }
        .animation-btn {
          background: #fff8dc;
          color: #064e3b;
          border: 2px solid #064e3b;
          border-radius: 0.4vw;
          padding: 0.5vw 1.2vw;
          font-size: 1vw;
          font-weight: 600;
          cursor: pointer;
          transition: background 0.2s, color 0.2s, border 0.2s;
          min-width: 36px;
          min-height: 36px;
          touch-action: manipulation;
          box-sizing: border-box;
        }
        .animation-btn.active {
          background: #064e3b;
          color: #fff;
          border: 2px solid #2cb979;
        }
        @media (max-width: 900px) {
          .hero3d-flex {
            flex-direction: column;
            min-height: 0;
          }
          .hero3d-left, .hero3d-right {
            width: 100%;
            min-width: 0;
            height: 50vh;
            min-height: 50vh;
          }
          .hero-title-content {
            max-width: 100%;
            padding: 6vw 2vw;
            box-shadow: none !important;
            background: transparent !important;
          }
          .hero-title-main {
            font-size: clamp(0.7rem, 3.8vw, 1.3rem) !important;
            text-shadow: none !important;
          }
          .hero-title-sub {
            font-size: 3.5vw;
          }
          .hero-title-logo {
            width: 80px;
            height: 80px;
            margin-top: 0 !important;
            margin-bottom: 2vw !important;
          }
          .hero-title-btn {
            font-size: 3vw;
            padding: 2vw 6vw;
          }
          .animation-controls {
            gap: 2vw;
            position: absolute;
            top: 2vw;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            flex-wrap: nowrap;
            max-width: 90vw;
            overflow-x: auto;
            box-sizing: border-box;
          }
          .animation-btn {
            font-size: 3vw;
            padding: 1vw 3vw;
            min-width: unset;
            min-height: unset;
            touch-action: manipulation;
            box-sizing: border-box;
            border: 1px solid #000 !important;
            background: linear-gradient(120deg, #e5e7eb 0%, #ffb3b3 60%, #2cb979 100%) !important;
            color: #000 !important;
            border-radius: 2vw;
          }
        }
        
        /* Medium mobile screens */
        @media (max-width: 768px) {
          .hero-title-main {
            font-size: clamp(1rem, 5.5vw, 2.2rem) !important;
          }
          .hero-title-sub {
            font-size: clamp(0.9rem, 3.5vw, 1.8rem);
          }
          .hero-title-logo {
            width: 70px;
            height: 70px;
          }
          .hero-title-btn {
            font-size: clamp(0.8rem, 2.8vw, 1.4rem);
            padding: 1.5vw 5vw;
          }
          .animation-btn {
            font-size: clamp(0.7rem, 2.5vw, 1.2rem);
            padding: 0.8vw 2.5vw;
          }
        }
        
        /* Small mobile screens */
        @media (max-width: 480px) {
          .hero-title-main {
            font-size: clamp(0.9rem, 5vw, 2rem) !important;
          }
          .hero-title-sub {
            font-size: clamp(0.8rem, 3vw, 1.6rem);
          }
          .hero-title-logo {
            width: 60px;
            height: 60px;
          }
          .hero-title-btn {
            font-size: clamp(0.7rem, 2.5vw, 1.2rem);
            padding: 1.2vw 4vw;
          }
          .animation-btn {
            font-size: clamp(0.6rem, 2.2vw, 1rem);
            padding: 0.6vw 2vw;
          }
        }
        
        /* Very small mobile screens */
        @media (max-width: 360px) {
          .hero-title-main {
            font-size: clamp(0.8rem, 4.5vw, 1.8rem) !important;
          }
          .hero-title-sub {
            font-size: clamp(0.7rem, 2.8vw, 1.4rem);
          }
          .hero-title-logo {
            width: 50px;
            height: 50px;
          }
          .hero-title-btn {
            font-size: clamp(0.6rem, 2.2vw, 1rem);
            padding: 1vw 3.5vw;
          }
          .animation-btn {
            font-size: clamp(0.5rem, 2vw, 0.9rem);
            padding: 0.5vw 1.8vw;
          }
        }
        
        /* iPad Mini responsive styles (768x1024) */
        @media (min-width: 768px) and (max-width: 900px) {
          .hero-title-content {
            margin-top: 6vw !important;
            padding-top: 8vw !important;
          }
          .hero-title-main {
            font-size: clamp(1.2rem, 3vw, 1.8rem) !important;
          }
          .hero-title-sub {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
          }
          .hero-title-logo {
            width: 70px;
            height: 70px;
          }
        }

        /* iPad Air responsive styles (820x1180) */
        @media (min-width: 820px) and (max-width: 900px) {
          .hero-title-content {
            margin-top: 7vw !important;
            padding-top: 9vw !important;
          }
          .hero-title-main {
            font-size: clamp(1.3rem, 3.2vw, 1.9rem) !important;
          }
          .hero-title-sub {
            font-size: clamp(0.9rem, 2.1vw, 1.3rem);
          }
          .hero-title-logo {
            width: 75px;
            height: 75px;
          }
        }

        /* Tablet and iPad responsive styles */
        @media (min-width: 901px) and (max-width: 1024px) {
          .hero3d-flex {
            min-height: 100vh;
          }
          .hero3d-left, .hero3d-right {
            height: 100vh;
            min-height: 100vh;
          }
          .hero-title-content {
            max-width: 600px;
            padding: 3vw 2.5vw;
            margin-top: 8vw !important;
            padding-top: 10vw !important;
          }
          .hero-title-main {
            font-size: clamp(1.4rem, 3.5vw, 2.2rem) !important;
          }
          .hero-title-sub {
            font-size: clamp(0.9rem, 2.2vw, 1.4rem);
          }
          .hero-title-logo {
            width: 85px;
            height: 85px;
            margin-bottom: 1.5vw !important;
          }
          .hero-title-btn {
            font-size: clamp(1rem, 2.2vw, 1.4rem);
            padding: 1.2vw 3vw;
          }
          .animation-controls {
            gap: 1.5vw;
            margin: 1.5vw 0 1vw 0;
          }
          .animation-btn {
            font-size: clamp(0.9rem, 2vw, 1.2rem);
            padding: 0.8vw 2vw;
            border-radius: 0.8vw;
          }
        }
        
        /* Large tablet and small laptop styles */
        @media (min-width: 1025px) and (max-width: 1200px) {
          .hero-title-content {
            max-width: 650px;
            padding: 2.5vw 2vw;
            margin-top: 9vw !important;
            padding-top: 11vw !important;
          }
          .hero-title-main {
            font-size: clamp(1.6rem, 3.2vw, 2.5rem) !important;
          }
          .hero-title-sub {
            font-size: clamp(1rem, 2.1vw, 1.4rem);
          }
          .hero-title-logo {
            width: 90px;
            height: 90px;
            margin-bottom: 1.2vw !important;
          }
          .hero-title-btn {
            font-size: clamp(1.1rem, 2vw, 1.5rem);
            padding: 1vw 2.5vw;
          }
          .animation-controls {
            gap: 1.2vw;
            margin: 1.2vw 0 0.8vw 0;
          }
          .animation-btn {
            font-size: clamp(1rem, 1.8vw, 1.3rem);
            padding: 0.7vw 1.8vw;
            border-radius: 0.6vw;
          }
        }
        
        @keyframes paw-float {
          0% { transform: translateY(0); }
          50% { transform: translateY(-12px); }
          100% { transform: translateY(0); }
        }
      `,
        }),
        O.jsx("div", {
          className: "hero3d-flex",
          id: "home",
          children: i
            ? O.jsxs(O.Fragment, {
                children: [
                  O.jsx("div", {
                    className: "hero3d-right",
                    children: O.jsxs(Be.div, {
                      className: "hero-title-content",
                      initial: { opacity: 0, y: 40 },
                      animate: { opacity: 1, y: 0 },
                      transition: { duration: 0.7, delay: 0.2 },
                      style: { position: "relative" },
                      children: [
                        O.jsxs("div", {
                          className: "hero-logo-wrapper",
                          style: {
                            position: "relative",
                            width: "fit-content",
                            margin: "0 auto 1.5vw auto",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                          },
                          children: [
                            O.jsxs("div", {
                              style: {
                                position: "relative",
                                width: "110px",
                                height: "110px",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                              },
                              children: [
                                O.jsx("style", {
                                  children: `
                      @keyframes logo-pulse {
                        0% { opacity: 0.7; transform: scale(1); }
                        50% { opacity: 1; transform: scale(1.12); }
                        100% { opacity: 0.7; transform: scale(1); }
                      }
                    `,
                                }),
                                O.jsx("div", {
                                  style: {
                                    position: "absolute",
                                    top: "-10px",
                                    left: 0,
                                    width: "110px",
                                    height: "110px",
                                    background:
                                      "radial-gradient(circle, #ffb84c55 0%, #ffb84c22 70%, transparent 100%)",
                                    borderRadius: "50%",
                                    filter: "blur(6px)",
                                    zIndex: 0,
                                    animation:
                                      "logo-pulse 3.5s ease-in-out infinite",
                                    pointerEvents: "none",
                                  },
                                }),
                                O.jsx(Be.img, {
                                  className: "hero-title-logo",
                                  src: z2,
                                  alt: "$PAUL Logo",
                                  initial: h.initial,
                                  animate: h.animate,
                                  transition: h.transition || {
                                    duration: 0.8,
                                    ease: "easeOut",
                                  },
                                  style: {
                                    backfaceVisibility: "hidden",
                                    display: "block",
                                    position: "relative",
                                    zIndex: 1,
                                    width: "110px",
                                    height: "110px",
                                  },
                                }),
                              ],
                            }),
                            O.jsx("div", {
                              style: {
                                position: "absolute",
                                top: "1px",
                                right: "-50px",
                                width: "36px",
                                height: "36px",
                                background: "rgba(24,25,28,0.75)",
                                borderRadius: "50%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                boxShadow: "0 4px 16px #0008",
                                backdropFilter: "blur(2px)",
                                zIndex: 2,
                                animation:
                                  "paw-float 2.5s ease-in-out infinite",
                              },
                              children: O.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: "22",
                                height: "22",
                                viewBox: "0 0 24 24",
                                fill: "none",
                                stroke: "url(#redWhiteGradient)",
                                strokeWidth: "2",
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                style: {
                                  opacity: 0.9,
                                  transform: "rotate(-15deg)",
                                },
                                children: [
                                  O.jsx("defs", {
                                    children: O.jsxs("linearGradient", {
                                      id: "redWhiteGradient",
                                      x1: "0",
                                      y1: "0",
                                      x2: "24",
                                      y2: "24",
                                      gradientUnits: "userSpaceOnUse",
                                      children: [
                                        O.jsx("stop", { stopColor: "#064e3b" }),
                                        O.jsx("stop", {
                                          offset: "1",
                                          stopColor: "#fff",
                                        }),
                                      ],
                                    }),
                                  }),
                                  O.jsx("circle", {
                                    cx: "11",
                                    cy: "4",
                                    r: "2",
                                  }),
                                  O.jsx("circle", {
                                    cx: "18",
                                    cy: "8",
                                    r: "2",
                                  }),
                                  O.jsx("circle", {
                                    cx: "20",
                                    cy: "16",
                                    r: "2",
                                  }),
                                  O.jsx("path", {
                                    d: "M9 10a5 5 0 0 1 5 5v3.5a3.5 3.5 0 0 1-6.84 1.045Q6.52 17.48 4.46 16.84A3.5 3.5 0 0 1 5.5 10Z",
                                  }),
                                ],
                              }),
                            }),
                            O.jsx("div", {
                              style: {
                                position: "absolute",
                                bottom: "1px",
                                left: "-50px",
                                width: "40px",
                                height: "40px",
                                background: "rgba(100,180,255,0.18)",
                                borderRadius: "50%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                boxShadow: "0 4px 16px #0008",
                                color: "#5ec6fa",
                                zIndex: 2,
                                opacity: 0.7,
                                animation:
                                  "bone-float 2.5s ease-in-out infinite",
                                animationDirection: "reverse",
                              },
                              children: O.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: "22",
                                height: "22",
                                viewBox: "0 0 24 24",
                                fill: "none",
                                stroke: "url(#redWhiteGradient2)",
                                strokeWidth: "2",
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                style: {
                                  opacity: 0.8,
                                  transform: "rotate(20deg)",
                                },
                                children: [
                                  O.jsx("defs", {
                                    children: O.jsxs("linearGradient", {
                                      id: "redWhiteGradient2",
                                      x1: "0",
                                      y1: "0",
                                      x2: "24",
                                      y2: "24",
                                      gradientUnits: "userSpaceOnUse",
                                      children: [
                                        O.jsx("stop", { stopColor: "#064e3b" }),
                                        O.jsx("stop", {
                                          offset: "1",
                                          stopColor: "#fff",
                                        }),
                                      ],
                                    }),
                                  }),
                                  O.jsx("path", {
                                    d: "M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5Z",
                                  }),
                                ],
                              }),
                            }),
                            O.jsx("style", {
                              children: `
                    @keyframes bone-float {
                      0% { transform: translateY(0); }
                      50% { transform: translateY(12px); }
                      100% { transform: translateY(0); }
                    }
                  `,
                            }),
                          ],
                        }),
                        O.jsxs(Be.div, {
                          className: "meet-taiki-heading",
                          initial: {
                            opacity: 0,
                            filter: "blur(8px)",
                            scale: 0.92,
                          },
                          animate: {
                            opacity: 1,
                            filter: "blur(0px)",
                            scale: [1.12, 1],
                          },
                          transition: { duration: 0.7, delay: 0.35 },
                          style: {
                            color: "#fff",
                            fontWeight: 900,
                            fontSize: "clamp(0.9rem, 4vw, 1.6rem)",
                            textAlign: "center",
                            marginBottom: "0.7em",
                            marginTop: 0,
                            letterSpacing: "0.01em",
                            textShadow: "0 0.1vw 0.5vw #000",
                          },
                          children: [
                            O.jsx("span", {
                              style: { color: "#fff" },
                              children: "Meet ",
                            }),
                            O.jsx("span", {
                              style: { color: "#064e3b" },
                              children: "$PAUL",
                            }),
                          ],
                        }),
                        O.jsx(Be.div, {
                          className: "hero-title-main",
                          initial: { opacity: 0, y: 40 },
                          animate: { opacity: 1, y: 0 },
                          transition: { duration: 0.7, delay: 1.1 },
                          style: {
                            background:
                              "linear-gradient(90deg, #fff 0%, #064e3b 100%)",
                            WebkitBackgroundClip: "text",
                            WebkitTextFillColor: "transparent",
                            backgroundClip: "text",
                            color: "transparent",
                            fontWeight: 900,
                            fontSize: "clamp(0.7rem, 3.8vw, 1.3rem)",
                            textAlign: "center",
                            margin: "0.5em 0 0.3em 0",
                            letterSpacing: "0.01em",
                            textShadow: "none",
                          },
                          children: "The OG Dog Meme",
                        }),
                        O.jsx(Be.div, {
                          className: "hero-title-sub",
                          initial: { opacity: 0 },
                          animate: { opacity: 1 },
                          transition: { duration: 0.7, delay: 1.2 },
                          style: { minHeight: 0, paddingBottom: 0 },
                          children: O.jsx(P2.Typewriter, {
                            words: [
                              `Before Doge, before SHIB. There was PAUL. 
In 2008, a single photo captured the soul of the Shiba Inu: calm, proud, timeless. 
That image became the face of Shiba Inu online, from Wikipedia to meme forums, and even earned a nod from Plasma himself. 
But Paul was never given a token. Until now.`,
                            ],
                            loop: 1,
                            cursor: !0,
                            cursorStyle: "|",
                            typeSpeed: 18,
                            deleteSpeed: 0,
                            delaySpeed: 1e3,
                          }),
                        }),
                        O.jsxs(Be.div, {
                          className: "hero-title-btns",
                          initial: { opacity: 0, scale: 0.7 },
                          animate: { opacity: 1, scale: 1 },
                          transition: { duration: 0.5, delay: 2.7 },
                          style: {
                            display: "flex",
                            gap: "1vw",
                            marginTop: 0,
                            paddingTop: 0,
                          },
                          children: [
                            // O.jsx(Be.a, {
                            //   className: "hero-title-btn",
                            //   href: "https://app.uniswap.org/#/swap?inputCurrency=eth&outputCurrency=0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
                            //   target: "_blank",
                            //   rel: "noopener noreferrer",
                            //   whileHover: { scale: 1.08 },
                            //   whileTap: { scale: 0.95 },
                            //   animate: p,
                            //   onClick: () => v(p),
                            //   children: "Buy $PAUL",
                            // }),
                            O.jsx(Be.a, {
                              className: "hero-title-btn secondary",
                              href: "https://dyorswap.org/xswap/?chainId=9745&outputCurrency=0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718&inputCurrency=XPL",
                              whileHover: { scale: 1.08 },
                              whileTap: { scale: 0.95 },
                              animate: m,
                              onClick: () => v(m),
                              children: O.jsx("span", {
                                style: {
                                  color: "#fff",
                                  fontWeight: 700,
                                  fontStyle: "italic",
                                },
                                children: "Buy Now",
                              }),
                            }),
                          ],
                        }),
                        O.jsxs(Be.div, {
                          className: "og-community-icons",
                          initial: { opacity: 0, y: 32 },
                          whileInView: { opacity: 1, y: 0 },
                          viewport: { once: !0, amount: 0.7 },
                          transition: {
                            duration: 0.7,
                            ease: "easeOut",
                            delay: 0.3,
                          },
                          style: {
                            display: "flex",
                            alignItems: "center",
                            gap: "1.2vw",
                            marginTop: "2vw",
                            color: "#b0b6c3",
                            fontSize: "1.15rem",
                            fontWeight: 400,
                          },
                          children: [
                            O.jsx("a", {
                              href: "https://x.com/paulinu_plasma",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              style: {
                                color: "#ffb84c",
                                display: "flex",
                                alignItems: "center",
                              },
                              children: O.jsx(Be.span, {
                                animate: { rotate: [-7, 7, -7] },
                                transition: {
                                  duration: 1.2,
                                  repeat: 1 / 0,
                                  repeatType: "loop",
                                  ease: "easeInOut",
                                },
                                style: { display: "inline-flex" },
                                children: O.jsxs("svg", {
                                  width: "28",
                                  height: "28",
                                  viewBox: "0 0 24 24",
                                  fill: "none",
                                  stroke: "url(#redWhiteSocial)",
                                  strokeWidth: "2",
                                  strokeLinecap: "round",
                                  strokeLinejoin: "round",
                                  style: { opacity: 0.9 },
                                  children: [
                                    O.jsx("defs", {
                                      children: O.jsxs("linearGradient", {
                                        id: "redWhiteSocial",
                                        x1: "0",
                                        y1: "0",
                                        x2: "28",
                                        y2: "0",
                                        gradientUnits: "userSpaceOnUse",
                                        children: [
                                          O.jsx("stop", {
                                            stopColor: "#064e3b",
                                          }),
                                          O.jsx("stop", {
                                            offset: "1",
                                            stopColor: "#fff",
                                          }),
                                        ],
                                      }),
                                    }),
                                    O.jsx("path", {
                                      d: "M23 3a10.9 10.9 0 0 1-3.14 1.53A4.48 4.48 0 0 0 22.4 1.64a9.09 9.09 0 0 1-2.88 1.1A4.48 4.48 0 0 0 16.5 0c-2.5 0-4.5 2.01-4.5 4.5 0 .35.04.7.1 1.03C7.69 5.4 4.07 3.67 1.64 1.15c-.38.65-.6 1.4-.6 2.2 0 1.52.77 2.86 1.95 3.65A4.48 4.48 0 0 1 .96 6v.06c0 2.13 1.52 3.91 3.54 4.31-.37.1-.76.16-1.16.16-.28 0-.55-.03-.81-.08.55 1.72 2.16 2.97 4.07 3A9.05 9.05 0 0 1 0 19.54 12.8 12.8 0 0 0 6.92 21c8.28 0 12.81-6.86 12.81-12.81 0-.2 0-.39-.01-.58A9.22 9.22 0 0 0 23 3z",
                                    }),
                                  ],
                                }),
                              }),
                            }),
                            O.jsx("a", {
                              href: "https://t.me/paulinu_plasma",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              style: {
                                color: "#ffb84c",
                                display: "flex",
                                alignItems: "center",
                              },
                              children: O.jsx(Be.span, {
                                animate: { rotate: [-7, 7, -7] },
                                transition: {
                                  duration: 1.2,
                                  repeat: 1 / 0,
                                  repeatType: "loop",
                                  ease: "easeInOut",
                                },
                                style: { display: "inline-flex" },
                                children: O.jsxs("svg", {
                                  width: "28",
                                  height: "28",
                                  viewBox: "0 0 24 24",
                                  fill: "none",
                                  stroke: "url(#redWhiteSocial2)",
                                  strokeWidth: "2",
                                  strokeLinecap: "round",
                                  strokeLinejoin: "round",
                                  style: { opacity: 0.9 },
                                  children: [
                                    O.jsx("defs", {
                                      children: O.jsxs("linearGradient", {
                                        id: "redWhiteSocial2",
                                        x1: "0",
                                        y1: "0",
                                        x2: "28",
                                        y2: "0",
                                        gradientUnits: "userSpaceOnUse",
                                        children: [
                                          O.jsx("stop", {
                                            stopColor: "#064e3b",
                                          }),
                                          O.jsx("stop", {
                                            offset: "1",
                                            stopColor: "#fff",
                                          }),
                                        ],
                                      }),
                                    }),
                                    O.jsx("path", { d: "M22 2L11 13" }),
                                    O.jsx("path", {
                                      d: "M22 2L15 22L11 13L2 9L22 2Z",
                                    }),
                                  ],
                                }),
                              }),
                            }),
                            O.jsx("span", {
                              style: {
                                height: 28,
                                width: 1,
                                background: "#444",
                                margin: "0 1vw",
                                opacity: 0.5,
                                display: "inline-block",
                              },
                            }),
                            O.jsx("span", {
                              style: {
                                color: "#ffb84c",
                                fontSize: "1.15rem",
                                fontWeight: 400,
                                whiteSpace: "nowrap",
                              },
                              children: O.jsx("span", {
                                style: {
                                  fontWeight: 700,
                                  fontSize: "0.98rem",
                                  fontFamily: "Montserrat, Arial, sans-serif",
                                  letterSpacing: "0.01em",
                                  background:
                                    "linear-gradient(90deg,rgb(246, 247, 251) 0%, #064e3b 100%)",
                                  WebkitBackgroundClip: "text",
                                  WebkitTextFillColor: "transparent",
                                  backgroundClip: "text",
                                  color: "transparent",
                                  whiteSpace: "nowrap",
                                  display: "inline-block",
                                },
                                children: "Follow PAUL",
                              }),
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                  O.jsxs("div", {
                    className: "hero3d-left",
                    style: {
                      flexDirection: "column",
                      alignItems: "center",
                      position: "relative",
                    },
                    children: [
                      O.jsx("div", {
                        className: "animation-controls",
                        children: u.map((x, _) =>
                          O.jsx(
                            "button",
                            {
                              className: `animation-btn${
                                r === _ ? " active" : ""
                              }`,
                              onClick: () => l(_),
                              children: x
                                .replace(/_skeletal.3|_skeletal|\.3/g, "")
                                .replace(/_/g, " ")
                                .replace(/\b\w/g, (M) => M.toUpperCase()),
                            },
                            x
                          )
                        ),
                      }),
                      O.jsxs(uw, {
                        camera: { position: [0, 3.5, 5], fov: 45 },
                        shadows: !0,
                        gl: { preserveDrawingBuffer: !0, alpha: !0 },
                        style: {
                          width: "100%",
                          height: "100%",
                          background: "transparent",
                          display: "block",
                        },
                        children: [
                          O.jsx("ambientLight", { intensity: 0.7 }),
                          O.jsx("directionalLight", {
                            position: [5, 10, 7.5],
                            intensity: 1.2,
                            castShadow: !0,
                            "shadow-mapSize-width": 1024,
                            "shadow-mapSize-height": 1024,
                          }),
                          O.jsxs(bt.Suspense, {
                            fallback: O.jsx(hw, {
                              center: !0,
                              style: { color: "#000", fontWeight: 700 },
                              children: "Loading...",
                            }),
                            children: [
                              O.jsxs("group", {
                                scale: [2.4, 2.4, 2.4],
                                position: [0, -0.7, 0],
                                children: [
                                  O.jsxs("mesh", {
                                    receiveShadow: !0,
                                    rotation: [-Math.PI / 2, 0, 0],
                                    position: [0, 0, 0],
                                    children: [
                                      O.jsx("planeGeometry", { args: [6, 6] }),
                                      O.jsx("shadowMaterial", {
                                        opacity: 0.18,
                                      }),
                                    ],
                                  }),
                                  O.jsx(F2, {
                                    position: [0, 0, 0],
                                    selectedIndex: r,
                                  }),
                                ],
                              }),
                              O.jsx(Sw, { preset: "sunset" }),
                            ],
                          }),
                          O.jsx(bw, {
                            enablePan: !1,
                            enableZoom: !0,
                            minDistance: 3.5,
                            maxDistance: 12,
                            maxPolarAngle: Math.PI / 2,
                            target: [0, 0, 0],
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              })
            : O.jsxs(O.Fragment, {
                children: [
                  O.jsxs("div", {
                    className: "hero3d-left",
                    style: { flexDirection: "column", alignItems: "center" },
                    children: [
                      O.jsxs(uw, {
                        camera: { position: [0, 3.5, 5], fov: 45 },
                        shadows: !0,
                        gl: { preserveDrawingBuffer: !0, alpha: !0 },
                        style: {
                          width: "100%",
                          height: "100%",
                          background: "transparent",
                          display: "block",
                        },
                        children: [
                          O.jsx("ambientLight", { intensity: 0.7 }),
                          O.jsx("directionalLight", {
                            position: [5, 10, 7.5],
                            intensity: 1.2,
                            castShadow: !0,
                            "shadow-mapSize-width": 1024,
                            "shadow-mapSize-height": 1024,
                          }),
                          O.jsxs(bt.Suspense, {
                            fallback: O.jsx(hw, {
                              center: !0,
                              style: { color: "#000", fontWeight: 700 },
                              children: "Loading...",
                            }),
                            children: [
                              O.jsxs("group", {
                                scale: [2.4, 2.4, 2.4],
                                position: [0, -0.7, 0],
                                children: [
                                  O.jsxs("mesh", {
                                    receiveShadow: !0,
                                    rotation: [-Math.PI / 2, 0, 0],
                                    position: [0, 0, 0],
                                    children: [
                                      O.jsx("planeGeometry", { args: [6, 6] }),
                                      O.jsx("shadowMaterial", {
                                        opacity: 0.18,
                                      }),
                                    ],
                                  }),
                                  O.jsx(F2, {
                                    position: [0, 0, 0],
                                    selectedIndex: r,
                                  }),
                                ],
                              }),
                              O.jsx(Sw, { preset: "sunset" }),
                            ],
                          }),
                          O.jsx(bw, {
                            enablePan: !1,
                            enableZoom: !0,
                            minDistance: 3.5,
                            maxDistance: 12,
                            maxPolarAngle: Math.PI / 2,
                            target: [0, 0, 0],
                          }),
                        ],
                      }),
                      O.jsx("div", {
                        className: "animation-controls",
                        children: u.map((x, _) =>
                          O.jsx(
                            "button",
                            {
                              className: `animation-btn${
                                r === _ ? " active" : ""
                              }`,
                              onClick: () => l(_),
                              children: x
                                .replace(/_skeletal.3|_skeletal|\.3/g, "")
                                .replace(/_/g, " ")
                                .replace(/\b\w/g, (M) => M.toUpperCase()),
                            },
                            x
                          )
                        ),
                      }),
                    ],
                  }),
                  O.jsx("div", {
                    className: "hero3d-right",
                    children: O.jsxs(Be.div, {
                      className: "hero-title-content",
                      initial: { opacity: 0, y: 40 },
                      animate: { opacity: 1, y: 0 },
                      transition: { duration: 0.7, delay: 0.2 },
                      style: { position: "relative" },
                      children: [
                        O.jsxs("div", {
                          className: "hero-logo-wrapper",
                          style: {
                            position: "relative",
                            width: "fit-content",
                            margin: "0 auto 1.5vw auto",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                          },
                          children: [
                            O.jsxs("div", {
                              style: {
                                position: "relative",
                                width: "110px",
                                height: "110px",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                              },
                              children: [
                                O.jsx("style", {
                                  children: `
                      @keyframes logo-pulse {
                        0% { opacity: 0.7; transform: scale(1); }
                        50% { opacity: 1; transform: scale(1.12); }
                        100% { opacity: 0.7; transform: scale(1); }
                      }
                    `,
                                }),
                                O.jsx("div", {
                                  style: {
                                    position: "absolute",
                                    top: "-10px",
                                    left: 0,
                                    width: "110px",
                                    height: "110px",
                                    background:
                                      "radial-gradient(circle, #ffb84c55 0%, #ffb84c22 70%, transparent 100%)",
                                    borderRadius: "50%",
                                    filter: "blur(6px)",
                                    zIndex: 0,
                                    animation:
                                      "logo-pulse 3.5s ease-in-out infinite",
                                    pointerEvents: "none",
                                  },
                                }),
                                O.jsx(Be.img, {
                                  className: "hero-title-logo",
                                  src: z2,
                                  alt: "$PAUL Logo",
                                  initial: h.initial,
                                  animate: h.animate,
                                  transition: h.transition || {
                                    duration: 0.8,
                                    ease: "easeOut",
                                  },
                                  style: {
                                    backfaceVisibility: "hidden",
                                    display: "block",
                                    position: "relative",
                                    zIndex: 1,
                                    width: "110px",
                                    height: "110px",
                                  },
                                }),
                              ],
                            }),
                            O.jsx("div", {
                              style: {
                                position: "absolute",
                                top: "1px",
                                right: "-50px",
                                width: "36px",
                                height: "36px",
                                background: "rgba(24,25,28,0.75)",
                                borderRadius: "50%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                boxShadow: "0 4px 16px #0008",
                                backdropFilter: "blur(2px)",
                                zIndex: 2,
                                animation:
                                  "paw-float 2.5s ease-in-out infinite",
                              },
                              children: O.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: "22",
                                height: "22",
                                viewBox: "0 0 24 24",
                                fill: "none",
                                stroke: "url(#redWhiteGradient)",
                                strokeWidth: "2",
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                style: {
                                  opacity: 0.9,
                                  transform: "rotate(-15deg)",
                                },
                                children: [
                                  O.jsx("defs", {
                                    children: O.jsxs("linearGradient", {
                                      id: "redWhiteGradient",
                                      x1: "0",
                                      y1: "0",
                                      x2: "24",
                                      y2: "24",
                                      gradientUnits: "userSpaceOnUse",
                                      children: [
                                        O.jsx("stop", { stopColor: "#064e3b" }),
                                        O.jsx("stop", {
                                          offset: "1",
                                          stopColor: "#fff",
                                        }),
                                      ],
                                    }),
                                  }),
                                  O.jsx("circle", {
                                    cx: "11",
                                    cy: "4",
                                    r: "2",
                                  }),
                                  O.jsx("circle", {
                                    cx: "18",
                                    cy: "8",
                                    r: "2",
                                  }),
                                  O.jsx("circle", {
                                    cx: "20",
                                    cy: "16",
                                    r: "2",
                                  }),
                                  O.jsx("path", {
                                    d: "M9 10a5 5 0 0 1 5 5v3.5a3.5 3.5 0 0 1-6.84 1.045Q6.52 17.48 4.46 16.84A3.5 3.5 0 0 1 5.5 10Z",
                                  }),
                                ],
                              }),
                            }),
                            O.jsx("div", {
                              style: {
                                position: "absolute",
                                bottom: "1px",
                                left: "-50px",
                                width: "40px",
                                height: "40px",
                                background: "rgba(100,180,255,0.18)",
                                borderRadius: "50%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                boxShadow: "0 4px 16px #0008",
                                color: "#5ec6fa",
                                zIndex: 2,
                                opacity: 0.7,
                                animation:
                                  "bone-float 2.5s ease-in-out infinite",
                                animationDirection: "reverse",
                              },
                              children: O.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: "22",
                                height: "22",
                                viewBox: "0 0 24 24",
                                fill: "none",
                                stroke: "url(#redWhiteGradient2)",
                                strokeWidth: "2",
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                style: {
                                  opacity: 0.8,
                                  transform: "rotate(20deg)",
                                },
                                children: [
                                  O.jsx("defs", {
                                    children: O.jsxs("linearGradient", {
                                      id: "redWhiteGradient2",
                                      x1: "0",
                                      y1: "0",
                                      x2: "24",
                                      y2: "24",
                                      gradientUnits: "userSpaceOnUse",
                                      children: [
                                        O.jsx("stop", { stopColor: "#064e3b" }),
                                        O.jsx("stop", {
                                          offset: "1",
                                          stopColor: "#fff",
                                        }),
                                      ],
                                    }),
                                  }),
                                  O.jsx("path", {
                                    d: "M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5Z",
                                  }),
                                ],
                              }),
                            }),
                            O.jsx("style", {
                              children: `
                    @keyframes bone-float {
                      0% { transform: translateY(0); }
                      50% { transform: translateY(12px); }
                      100% { transform: translateY(0); }
                    }
                  `,
                            }),
                          ],
                        }),
                        O.jsxs(Be.div, {
                          className: "meet-taiki-heading",
                          initial: { opacity: 0, filter: "blur(8px)" },
                          animate: e ? { opacity: 1, filter: "blur(0px)" } : {},
                          transition: { duration: 0.7, delay: 0.1 },
                          style: {
                            color: "#fff",
                            fontWeight: 900,
                            fontSize: "2.3vw",
                            textAlign: "center",
                            marginBottom: "1vw",
                            marginTop: "-0.5vw",
                            letterSpacing: "0.01em",
                            textShadow: "0 0.1vw 0.5vw #000",
                          },
                          children: [
                            O.jsx("span", {
                              style: { color: "#fff" },
                              children: "Meet ",
                            }),
                            O.jsx("span", {
                              style: { color: "#064e3b" },
                              children: "$PAUL",
                            }),
                          ],
                        }),
                        O.jsx(Be.div, {
                          className: "hero-title-main",
                          initial: { opacity: 0, y: 40 },
                          animate: a,
                          transition: { duration: 0.7, delay: 0.7 },
                          style: {
                            background:
                              "linear-gradient(90deg, #fff 0%, #064e3b 100%)",
                            WebkitBackgroundClip: "text",
                            WebkitTextFillColor: "transparent",
                            backgroundClip: "text",
                            color: "transparent",
                            fontWeight: 900,
                            fontSize: "1.7vw",
                            textAlign: "center",
                            marginBottom: "0.7vw",
                          },
                          children: "The OG Dog Meme",
                        }),
                        O.jsx(Be.div, {
                          className: "hero-title-sub",
                          initial: { opacity: 0 },
                          animate: { opacity: 1 },
                          transition: { duration: 0.7, delay: 1.2 },
                          style: { minHeight: 0, paddingBottom: 0 },
                          children: O.jsx(P2.Typewriter, {
                            words: [
                              `Before Doge, before SHIB. There was PAUL. 
In 2008, a single photo captured the soul of the Shiba Inu: calm, proud, timeless. 
That image became the face of Shiba Inu online, from Wikipedia to meme forums, and even earned a nod from Plasma himself. 
But Paul was never given a token. Until now.`,
                            ],
                            loop: 1,
                            cursor: !0,
                            cursorStyle: "|",
                            typeSpeed: 18,
                            deleteSpeed: 0,
                            delaySpeed: 1e3,
                          }),
                        }),
                        O.jsxs(Be.div, {
                          className: "hero-title-btns",
                          initial: { opacity: 0, scale: 0.7 },
                          animate: { opacity: 1, scale: 1 },
                          transition: { duration: 0.5, delay: 2.7 },
                          style: {
                            display: "flex",
                            gap: "1vw",
                            marginTop: 0,
                            paddingTop: 0,
                          },
                          children: [
                            O.jsx(Be.a, {
                              className: "hero-title-btn",
                              href: "https://dyorswap.org/xswap/?chainId=9745&outputCurrency=0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718&inputCurrency=XPL",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              whileHover: { scale: 1.08 },
                              whileTap: { scale: 0.95 },
                              animate: p,
                              onClick: () => v(p),
                              children: "Buy $PAUL",
                            }),
                            O.jsx(Be.a, {
                              className: "hero-title-btn secondary",
                              href: "https://dexscreener.com/plasma/0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
                              whileHover: { scale: 1.08 },
                              whileTap: { scale: 0.95 },
                              animate: m,
                              onClick: () => v(m),
                              children: O.jsx("span", {
                                style: {
                                  color: "#fff",
                                  fontWeight: 700,
                                  fontStyle: "italic",
                                },
                                children: "Chart",
                              }),
                            }),
                          ],
                        }),
                        O.jsxs(Be.div, {
                          className: "og-community-icons",
                          initial: { opacity: 0, y: 32 },
                          whileInView: { opacity: 1, y: 0 },
                          viewport: { once: !0, amount: 0.7 },
                          transition: {
                            duration: 0.7,
                            ease: "easeOut",
                            delay: 0.3,
                          },
                          style: {
                            display: "flex",
                            alignItems: "center",
                            gap: "1.2vw",
                            marginTop: "2vw",
                            color: "#b0b6c3",
                            fontSize: "1.15rem",
                            fontWeight: 400,
                          },
                          children: [
                            O.jsx("a", {
                              href: "https://x.com/paulinu_plasma",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              style: {
                                color: "#ffb84c",
                                display: "flex",
                                alignItems: "center",
                              },
                              children: O.jsx(Be.span, {
                                animate: { rotate: [-7, 7, -7] },
                                transition: {
                                  duration: 1.2,
                                  repeat: 1 / 0,
                                  repeatType: "loop",
                                  ease: "easeInOut",
                                },
                                style: { display: "inline-flex" },
                                children: O.jsxs("svg", {
                                  width: "28",
                                  height: "28",
                                  viewBox: "0 0 24 24",
                                  fill: "none",
                                  stroke: "url(#redWhiteSocial)",
                                  strokeWidth: "2",
                                  strokeLinecap: "round",
                                  strokeLinejoin: "round",
                                  style: { opacity: 0.9 },
                                  children: [
                                    O.jsx("defs", {
                                      children: O.jsxs("linearGradient", {
                                        id: "redWhiteSocial",
                                        x1: "0",
                                        y1: "0",
                                        x2: "28",
                                        y2: "0",
                                        gradientUnits: "userSpaceOnUse",
                                        children: [
                                          O.jsx("stop", {
                                            stopColor: "#064e3b",
                                          }),
                                          O.jsx("stop", {
                                            offset: "1",
                                            stopColor: "#fff",
                                          }),
                                        ],
                                      }),
                                    }),
                                    O.jsx("path", {
                                      d: "M23 3a10.9 10.9 0 0 1-3.14 1.53A4.48 4.48 0 0 0 22.4 1.64a9.09 9.09 0 0 1-2.88 1.1A4.48 4.48 0 0 0 16.5 0c-2.5 0-4.5 2.01-4.5 4.5 0 .35.04.7.1 1.03C7.69 5.4 4.07 3.67 1.64 1.15c-.38.65-.6 1.4-.6 2.2 0 1.52.77 2.86 1.95 3.65A4.48 4.48 0 0 1 .96 6v.06c0 2.13 1.52 3.91 3.54 4.31-.37.1-.76.16-1.16.16-.28 0-.55-.03-.81-.08.55 1.72 2.16 2.97 4.07 3A9.05 9.05 0 0 1 0 19.54 12.8 12.8 0 0 0 6.92 21c8.28 0 12.81-6.86 12.81-12.81 0-.2 0-.39-.01-.58A9.22 9.22 0 0 0 23 3z",
                                    }),
                                  ],
                                }),
                              }),
                            }),
                            O.jsx("a", {
                              href: "https://t.me/paulinu_plasma",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              style: {
                                color: "#ffb84c",
                                display: "flex",
                                alignItems: "center",
                              },
                              children: O.jsx(Be.span, {
                                animate: { rotate: [-7, 7, -7] },
                                transition: {
                                  duration: 1.2,
                                  repeat: 1 / 0,
                                  repeatType: "loop",
                                  ease: "easeInOut",
                                },
                                style: { display: "inline-flex" },
                                children: O.jsxs("svg", {
                                  width: "28",
                                  height: "28",
                                  viewBox: "0 0 24 24",
                                  fill: "none",
                                  stroke: "url(#redWhiteSocial2)",
                                  strokeWidth: "2",
                                  strokeLinecap: "round",
                                  strokeLinejoin: "round",
                                  style: { opacity: 0.9 },
                                  children: [
                                    O.jsx("defs", {
                                      children: O.jsxs("linearGradient", {
                                        id: "redWhiteSocial2",
                                        x1: "0",
                                        y1: "0",
                                        x2: "28",
                                        y2: "0",
                                        gradientUnits: "userSpaceOnUse",
                                        children: [
                                          O.jsx("stop", {
                                            stopColor: "#064e3b",
                                          }),
                                          O.jsx("stop", {
                                            offset: "1",
                                            stopColor: "#fff",
                                          }),
                                        ],
                                      }),
                                    }),
                                    O.jsx("path", { d: "M22 2L11 13" }),
                                    O.jsx("path", {
                                      d: "M22 2L15 22L11 13L2 9L22 2Z",
                                    }),
                                  ],
                                }),
                              }),
                            }),
                            O.jsx("span", {
                              style: {
                                height: 28,
                                width: 1,
                                background: "#444",
                                margin: "0 1vw",
                                opacity: 0.5,
                                display: "inline-block",
                              },
                            }),
                            O.jsx("span", {
                              style: {
                                color: "#ffb84c",
                                fontSize: "1.15rem",
                                fontWeight: 400,
                                whiteSpace: "nowrap",
                              },
                              children: O.jsx("span", {
                                style: {
                                  fontWeight: 700,
                                  fontSize: "0.98rem",
                                  fontFamily: "Montserrat, Arial, sans-serif",
                                  letterSpacing: "0.01em",
                                  background:
                                    "linear-gradient(90deg,rgb(246, 247, 251) 0%, #064e3b 100%)",
                                  WebkitBackgroundClip: "text",
                                  WebkitTextFillColor: "transparent",
                                  backgroundClip: "text",
                                  color: "transparent",
                                  whiteSpace: "nowrap",
                                  display: "inline-block",
                                },
                                children: "Follow PAUL",
                              }),
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                ],
              }),
        }),
        O.jsx("style", {
          children: `
        @media (max-width: 900px) {
          html, body, #root {
            background: linear-gradient(135deg, #ffb3b3 0%, #2cb979 60%, #ffb3b3 100%);
            overflow-x: hidden !important;
            max-width: 100vw !important;
          }
          .hero-title-content {
            background: none !important;
            box-shadow: none !important;
            border: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            padding: 0 !important;
          }
          .hero-logo-wrapper {
            margin-top: 180px !important;
          }
          .hero-title-logo {
            margin-top: 0 !important;
            margin-bottom: 2vw !important;
          }
          .hero-title-main {
            font-size: clamp(0.7rem, 3.8vw, 1.3rem) !important;
          }
          .hero-title-sub {
            margin-bottom: 3vw !important;
          }
          .hero-title-btns {
            margin-top: 0 !important;
          }
          .meet-taiki-heading {
            font-size: clamp(0.9rem, 4vw, 1.8rem) !important;
            margin-bottom: 0 !important;
          }
          .og-community-icons svg {
            stroke: #18191c !important;
          }
          .hero-title-main {
            margin: 0 !important;
          }
          .og-community-icons {
            margin-bottom: 36vw !important;
            margin-top: 0 !important;
            flex-wrap: wrap;
            font-size: 0.95rem !important;
            gap: 0.7vw !important;
            justify-content: center;
            align-items: center;
            text-align: center;
          }
          .og-community-icons svg {
            width: 22px !important;
            height: 22px !important;
          }
          .og-community-icons span:last-child {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
          }
          .animation-controls {
            position: absolute;
            top: 2vw;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
          }
          .animation-btn.active {
            background: linear-gradient(120deg, #2cb979 0%, #ff6a6a 60%, #ff8a8a 100%) !important;
            color: #fff !important;
            border: 1px solid #000 !important;
          }
          /* Make paw and bone SVGs solid red in mobile view */
          .hero-logo-wrapper svg {
            stroke: #064e3b !important;
          }
          .og-community-icons a,
          .og-community-icons span {
            display: none !important;
          }
        }
        @media (min-width: 1600px) {
          .hero3d-flex {
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
          }
        }
        @media (min-width: 1200px) and (max-width: 1599px) {
          .hero3d-flex {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
          }
          .hero-title-content {
            max-width: 480px;
          }
          .hero-title-main {
            font-size: 2.2vw;
          }
          .hero-title-sub {
            font-size: 1.1vw;
          }
        }
      `,
        }),
      ],
    })
  );
}
const OV =
  "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/bd16ebd32caee97543484bec8e7922a8.png";
function NV() {
  const [i, t] = bt.useState(!1),
    [e, n] = bt.useState(!1);
  return (
    bt.useEffect(() => {
      const a = () => {
        t(window.scrollY > 10);
      };
      return (
        window.addEventListener("scroll", a),
        () => window.removeEventListener("scroll", a)
      );
    }, []),
    O.jsxs("header", {
      className: `navbar${i ? " navbar--scrolled" : ""}`,
      children: [
        O.jsxs("div", {
          className: "navbar-left",
          children: [
            O.jsx("img", {
              src: OV,
              alt: "$PAUL Logo",
              className: "navbar-logo",
            }),
            O.jsx("span", { className: "navbar-title", children: "$PAUL" }),
          ],
        }),
        O.jsxs("div", {
          style: { display: "flex", alignItems: "center", gap: "0.5rem" },
          children: [
            O.jsxs("nav", {
              className: "navbar-links",
              children: [
                O.jsx("a", { href: "#home", children: "Home" }),
                O.jsx("a", { href: "#about", children: "About" }),
                O.jsx("a", { href: "#tokenomics", children: "Tokenomics" }),
                O.jsx("a", { href: "#team", children: "Team" }),
                O.jsx("a", { href: "#community", children: "Community" }),
              ],
            }),
            // O.jsx("a", {
            //   href: "https://app.uniswap.org/#/swap?inputCurrency=eth&outputCurrency=0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
            //   target: "_blank",
            //   rel: "noopener noreferrer",
            //   className: "navbar-buy",
            //   "data-text": "Buy $PAUL",
            //   children: "Buy $PAUL",
            // }),
          ],
        }),
        O.jsxs("div", {
          className: `navbar-mobile-menu${e ? " open" : ""}`,
          children: [
            O.jsx("a", {
              href: "#home",
              onClick: () => n(!1),
              children: "Home",
            }),
            O.jsx("a", {
              href: "#about",
              onClick: () => n(!1),
              children: "About",
            }),
            O.jsx("a", {
              href: "#tokenomics",
              onClick: () => n(!1),
              children: "Tokenomics",
            }),
            O.jsx("a", {
              href: "#team",
              onClick: () => n(!1),
              children: "Team",
            }),
            O.jsx("a", {
              href: "#community",
              onClick: () => n(!1),
              children: "Community",
            }),
            // O.jsx("a", {
            //   href: "https://app.uniswap.org/#/swap?inputCurrency=eth&outputCurrency=0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
            //   target: "_blank",
            //   rel: "noopener noreferrer",
            //   className: "navbar-buy",
            //   "data-text": "Buy $PAUL",
            //   onClick: () => n(!1),
            //   children: "Buy $PAUL",
            // }),
          ],
        }),
        O.jsxs("button", {
          className: `navbar-hamburger${e ? " open" : ""}`,
          onClick: () => n(!e),
          "aria-label": e ? "Close menu" : "Open menu",
          children: [
            O.jsx("span", { className: "bar bar1" }),
            O.jsx("span", { className: "bar bar2" }),
            O.jsx("span", { className: "bar bar3" }),
          ],
        }),
        e &&
          O.jsx("div", {
            className: "navbar-mobile-backdrop",
            onClick: () => n(!1),
          }),
      ],
    })
  );
}
function LV() {
  return O.jsxs("section", {
    style: {
      width: "100%",
      overflowX: "hidden",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      margin: "1.5vw 0 1vw 0",
      boxSizing: "border-box",
    },
    children: [
      O.jsx("style", {
        children: `
        @media (max-width: 900px) {
          .stats-flex {
            flex-direction: column !important;
            gap: 3vw !important;
            align-items: center !important;
          }
          .stats-card {
            width: 260px !important;
            min-width: 260px !important;
            max-width: 260px !important;
            height: 100px !important;
            padding: 3vw 0 !important;
            border-radius: 2vw !important;
            box-sizing: border-box !important;
          }
        }
        @media (min-width: 1200px) and (max-width: 1599px) {
          .stats-card {
            height: 140px !important;
            padding: 1.5vw 0 !important;
          }
          .stats-flex {
            gap: 1.5vw !important;
          }
        }
        @media (min-width: 1600px) {
          .stats-card {
            height: 150px !important;
            padding: 1.8vw 0 !important;
          }
          .stats-flex {
            gap: 2vw !important;
          }
        }
        
        /* iPad Mini responsive styles (768x1024) */
        @media (min-width: 768px) and (max-width: 900px) {
          .stats-flex {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            grid-template-rows: auto auto !important;
            gap: clamp(12px, 1.8vw, 20px) !important;
            justify-items: center !important;
            align-items: start !important;
            max-width: 700px !important;
            margin: 0 auto !important;
          }
          .stats-card:nth-child(1) {
            grid-column: 1 !important;
            grid-row: 1 !important;
            width: clamp(250px, 32vw, 320px) !important;
            min-width: clamp(250px, 32vw, 320px) !important;
            max-width: clamp(250px, 32vw, 320px) !important;
            height: auto !important;
            min-height: clamp(120px, 15vh, 160px) !important;
            padding: clamp(15px, 2vw, 25px) 0 !important;
            border-radius: clamp(8px, 1vw, 12px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(2) {
            grid-column: 2 !important;
            grid-row: 1 !important;
            width: clamp(250px, 32vw, 320px) !important;
            min-width: clamp(250px, 32vw, 320px) !important;
            max-width: clamp(250px, 32vw, 320px) !important;
            height: auto !important;
            min-height: clamp(120px, 15vh, 160px) !important;
            padding: clamp(15px, 2vw, 25px) 0 !important;
            border-radius: clamp(8px, 1vw, 12px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(3) {
            grid-column: 1 / -1 !important;
            grid-row: 2 !important;
            width: clamp(250px, 32vw, 320px) !important;
            min-width: clamp(250px, 32vw, 320px) !important;
            max-width: clamp(250px, 32vw, 320px) !important;
            height: auto !important;
            min-height: clamp(120px, 15vh, 160px) !important;
            padding: clamp(15px, 2vw, 25px) 0 !important;
            border-radius: clamp(8px, 1vw, 12px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
            justify-self: center !important;
          }
          .stats-card svg {
            width: clamp(24px, 3vw, 28px) !important;
            height: clamp(24px, 3vw, 28px) !important;
            margin-bottom: clamp(5px, 0.5vw, 10px) !important;
          }
          .stats-card > div:nth-child(2) {
            font-size: clamp(1.1rem, 2.5vw, 1.4rem) !important;
            margin-bottom: clamp(3px, 0.3vw, 8px) !important;
            color: #064e3b !important;
            font-weight: 700 !important;
          }
          .stats-card > div:nth-child(3) {
            font-size: clamp(0.9rem, 2vw, 1.1rem) !important;
            line-height: 1.3 !important;
            text-align: center !important;
            padding: clamp(5px, 0.5vw, 10px) !important;
            color: #fff !important;
            font-weight: 700 !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: auto !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
          }
        }

        /* iPad Air responsive styles (820x1180) */
        @media (min-width: 820px) and (max-width: 900px) {
          .stats-flex {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            grid-template-rows: auto auto !important;
            gap: clamp(14px, 2vw, 22px) !important;
            justify-items: center !important;
            align-items: start !important;
            max-width: 750px !important;
            margin: 0 auto !important;
          }
          .stats-card:nth-child(1) {
            grid-column: 1 !important;
            grid-row: 1 !important;
            width: clamp(260px, 33vw, 330px) !important;
            min-width: clamp(260px, 33vw, 330px) !important;
            max-width: clamp(260px, 33vw, 330px) !important;
            height: auto !important;
            min-height: clamp(125px, 15.5vh, 165px) !important;
            padding: clamp(16px, 2.1vw, 26px) 0 !important;
            border-radius: clamp(9px, 1.1vw, 13px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(2) {
            grid-column: 2 !important;
            grid-row: 1 !important;
            width: clamp(260px, 33vw, 330px) !important;
            min-width: clamp(260px, 33vw, 330px) !important;
            max-width: clamp(260px, 33vw, 330px) !important;
            height: auto !important;
            min-height: clamp(125px, 15.5vh, 165px) !important;
            padding: clamp(16px, 2.1vw, 26px) 0 !important;
            border-radius: clamp(9px, 1.1vw, 13px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(3) {
            grid-column: 1 / -1 !important;
            grid-row: 2 !important;
            width: clamp(260px, 33vw, 330px) !important;
            min-width: clamp(260px, 33vw, 330px) !important;
            max-width: clamp(260px, 33vw, 330px) !important;
            height: auto !important;
            min-height: clamp(125px, 15.5vh, 165px) !important;
            padding: clamp(16px, 2.1vw, 26px) 0 !important;
            border-radius: clamp(9px, 1.1vw, 13px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
            justify-self: center !important;
          }
          .stats-card svg {
            width: clamp(25px, 3.1vw, 29px) !important;
            height: clamp(25px, 3.1vw, 29px) !important;
            margin-bottom: clamp(5.5px, 0.55vw, 11px) !important;
          }
          .stats-card > div:nth-child(2) {
            font-size: clamp(1.15rem, 2.6vw, 1.45rem) !important;
            margin-bottom: clamp(3.5px, 0.35vw, 9px) !important;
            color: #064e3b !important;
            font-weight: 700 !important;
          }
          .stats-card > div:nth-child(3) {
            font-size: clamp(0.95rem, 2.1vw, 1.15rem) !important;
            line-height: 1.35 !important;
            text-align: center !important;
            padding: clamp(5.5px, 0.55vw, 11px) !important;
            color: #fff !important;
            font-weight: 700 !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: auto !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
          }
        }

        /* Tablet and iPad responsive styles */
        @media (min-width: 901px) and (max-width: 1024px) {
          .stats-flex {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            grid-template-rows: auto auto !important;
            gap: clamp(15px, 2vw, 25px) !important;
            justify-items: center !important;
            align-items: start !important;
            max-width: 800px !important;
            margin: 0 auto !important;
          }
          .stats-card:nth-child(1) {
            grid-column: 1 !important;
            grid-row: 1 !important;
            width: clamp(280px, 35vw, 350px) !important;
            min-width: clamp(280px, 35vw, 350px) !important;
            max-width: clamp(280px, 35vw, 350px) !important;
            height: auto !important;
            min-height: clamp(130px, 16vh, 170px) !important;
            padding: clamp(18px, 2.2vw, 28px) 0 !important;
            border-radius: clamp(10px, 1.2vw, 14px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(2) {
            grid-column: 2 !important;
            grid-row: 1 !important;
            width: clamp(280px, 35vw, 350px) !important;
            min-width: clamp(280px, 35vw, 350px) !important;
            max-width: clamp(280px, 35vw, 350px) !important;
            height: auto !important;
            min-height: clamp(130px, 16vh, 170px) !important;
            padding: clamp(18px, 2.2vw, 28px) 0 !important;
            border-radius: clamp(10px, 1.2vw, 14px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(3) {
            grid-column: 1 / -1 !important;
            grid-row: 2 !important;
            width: clamp(280px, 35vw, 350px) !important;
            min-width: clamp(280px, 35vw, 350px) !important;
            max-width: clamp(280px, 35vw, 350px) !important;
            height: auto !important;
            min-height: clamp(130px, 16vh, 170px) !important;
            padding: clamp(18px, 2.2vw, 28px) 0 !important;
            border-radius: clamp(10px, 1.2vw, 14px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
            justify-self: center !important;
          }
          .stats-card svg {
            width: clamp(26px, 3.2vw, 30px) !important;
            height: clamp(26px, 3.2vw, 30px) !important;
            margin-bottom: clamp(6px, 0.6vw, 12px) !important;
          }
          .stats-card > div:nth-child(2) {
            font-size: clamp(1.2rem, 2.8vw, 1.5rem) !important;
            margin-bottom: clamp(4px, 0.4vw, 10px) !important;
            color: #064e3b !important;
            font-weight: 700 !important;
          }
          .stats-card > div:nth-child(3) {
            font-size: clamp(1rem, 2.2vw, 1.2rem) !important;
            line-height: 1.4 !important;
            text-align: center !important;
            padding: clamp(6px, 0.6vw, 12px) !important;
            color: #fff !important;
            font-weight: 700 !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: auto !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
          }
        }
        
        /* Large tablet and small laptop styles */
        @media (min-width: 1025px) and (max-width: 1200px) {
          .stats-flex {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            grid-template-rows: auto auto !important;
            gap: clamp(18px, 2.5vw, 30px) !important;
            justify-items: center !important;
            align-items: start !important;
            max-width: 900px !important;
            margin: 0 auto !important;
          }
          .stats-card:nth-child(1) {
            grid-column: 1 !important;
            grid-row: 1 !important;
            width: clamp(300px, 38vw, 380px) !important;
            min-width: clamp(300px, 38vw, 380px) !important;
            max-width: clamp(300px, 38vw, 380px) !important;
            height: auto !important;
            min-height: clamp(140px, 17vh, 180px) !important;
            padding: clamp(20px, 2.5vw, 32px) 0 !important;
            border-radius: clamp(12px, 1.5vw, 16px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(2) {
            grid-column: 2 !important;
            grid-row: 1 !important;
            width: clamp(300px, 38vw, 380px) !important;
            min-width: clamp(300px, 38vw, 380px) !important;
            max-width: clamp(300px, 38vw, 380px) !important;
            height: auto !important;
            min-height: clamp(140px, 17vh, 180px) !important;
            padding: clamp(20px, 2.5vw, 32px) 0 !important;
            border-radius: clamp(12px, 1.5vw, 16px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
          }
          .stats-card:nth-child(3) {
            grid-column: 1 / -1 !important;
            grid-row: 2 !important;
            width: clamp(300px, 38vw, 380px) !important;
            min-width: clamp(300px, 38vw, 380px) !important;
            max-width: clamp(300px, 38vw, 380px) !important;
            height: auto !important;
            min-height: clamp(140px, 17vh, 180px) !important;
            padding: clamp(20px, 2.5vw, 32px) 0 !important;
            border-radius: clamp(12px, 1.5vw, 16px) !important;
            overflow: visible !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: space-between !important;
            justify-self: center !important;
          }
          .stats-card svg {
            width: clamp(28px, 3.5vw, 32px) !important;
            height: clamp(28px, 3.5vw, 32px) !important;
            margin-bottom: clamp(8px, 0.8vw, 14px) !important;
          }
          .stats-card > div:nth-child(2) {
            font-size: clamp(1.3rem, 3vw, 1.6rem) !important;
            margin-bottom: clamp(5px, 0.5vw, 12px) !important;
            color: #064e3b !important;
            font-weight: 700 !important;
          }
          .stats-card > div:nth-child(3) {
            font-size: clamp(1.1rem, 2.4vw, 1.3rem) !important;
            line-height: 1.5 !important;
            text-align: center !important;
            padding: clamp(8px, 0.8vw, 14px) !important;
            color: #fff !important;
            font-weight: 700 !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: auto !important;
            overflow: visible !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
          }
        }
        .stats-card {
          border: 2px solid transparent;
          transition: border-color 0.22s cubic-bezier(.4,0,.2,1);
        }
        .stats-card:hover,
        .stats-card:focus,
        .stats-card:active {
          border-color: #064e3b;
        }
        @media (hover: none) and (pointer: coarse) {
          .stats-card:active {
            border-color: #064e3b;
          }
        }
      `,
      }),
      O.jsxs("div", {
        className: "stats-flex",
        style: {
          display: "flex",
          gap: "1vw",
          width: "100%",
          justifyContent: "center",
          alignItems: "center",
          flexWrap: "wrap",
          boxSizing: "border-box",
          margin: 0,
          flexDirection: "row",
        },
        children: [
          O.jsxs("div", {
            className: "stats-card",
            style: {
              width: "clamp(250px, 25vw, 300px)",
              minWidth: "clamp(250px, 25vw, 300px)",
              maxWidth: "clamp(250px, 25vw, 300px)",
              height: "auto",
              minHeight: "clamp(120px, 15vh, 160px)",
              background: "#181a1f",
              borderRadius: "clamp(8px, 1vw, 12px)",
              boxShadow: "0 2px 14px #0002",
              padding: "clamp(15px, 2vw, 25px) 0",
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              boxSizing: "border-box",
              overflow: "visible",
            },
            children: [
              O.jsx(Be.span, {
                animate: { rotate: [-4, 4, -4] },
                transition: {
                  duration: 0.8,
                  repeat: 1 / 0,
                  repeatType: "loop",
                  ease: "easeInOut",
                },
                style: { display: "inline-flex" },
                children: O.jsxs("svg", {
                  width: "28",
                  height: "28",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "#064e3b",
                  strokeWidth: "2.2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  style: { marginBottom: "0.4vw", opacity: 0.9 },
                  children: [
                    O.jsx("line", { x1: "4", y1: "20", x2: "4", y2: "14" }),
                    O.jsx("line", { x1: "9", y1: "20", x2: "9", y2: "10" }),
                    O.jsx("line", { x1: "14", y1: "20", x2: "14", y2: "6" }),
                    O.jsx("line", { x1: "19", y1: "20", x2: "19", y2: "2" }),
                  ],
                }),
              }),
              O.jsx(Be.div, {
                initial: { opacity: 0, y: 24 },
                whileInView: { opacity: 1, y: 0 },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.6, ease: "easeOut" },
                style: {
                  color: "#064e3b",
                  fontWeight: 700,
                  fontSize: "1.3rem",
                  marginBottom: "0.1vw",
                  letterSpacing: "1px",
                },
                children: "2008",
              }),
              O.jsx(Be.div, {
                initial: { opacity: 0, filter: "blur(8px)" },
                whileInView: { opacity: 1, filter: "blur(0px)" },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.7, ease: "easeOut" },
                style: {
                  color: "#fff",
                  fontSize: "clamp(0.9rem, 2vw, 1.1rem)",
                  fontWeight: 700,
                  textAlign: "center",
                  lineHeight: "1.3",
                  padding: "clamp(5px, 0.5vw, 10px)",
                  wordWrap: "break-word",
                  overflowWrap: "break-word",
                  display: "block",
                  visibility: "visible",
                  opacity: 1,
                  height: "auto",
                  overflow: "visible",
                },
                children: "Original Photo Year",
              }),
            ],
          }),
          O.jsxs("div", {
            className: "stats-card",
            style: {
              width: "clamp(250px, 25vw, 300px)",
              minWidth: "clamp(250px, 25vw, 300px)",
              maxWidth: "clamp(250px, 25vw, 300px)",
              height: "auto",
              minHeight: "clamp(120px, 15vh, 160px)",
              background: "#181a1f",
              borderRadius: "clamp(8px, 1vw, 12px)",
              boxShadow: "0 2px 14px #0002",
              padding: "clamp(15px, 2vw, 25px) 0",
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              boxSizing: "border-box",
              overflow: "visible",
            },
            children: [
              O.jsx(Be.span, {
                animate: { rotate: [-4, 4, -4] },
                transition: {
                  duration: 0.8,
                  repeat: 1 / 0,
                  repeatType: "loop",
                  ease: "easeInOut",
                },
                style: { display: "inline-flex" },
                children: O.jsxs("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "28",
                  height: "28",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "#064e3b",
                  strokeWidth: "2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  style: { marginBottom: "0.4vw", opacity: 0.9 },
                  children: [
                    O.jsx("path", {
                      d: "M10 5.172C10 3.782 8.423 2.679 6.5 3c-2.823.47-4.113 6.006-4 7 .08.703 1.725 1.722 3.656 1 1.261-.472 1.96-1.45 2.344-2.5",
                    }),
                    O.jsx("path", {
                      d: "M14.267 5.172c0-1.39 1.577-2.493 3.5-2.172 2.823.47 4.113 6.006 4 7-.08.703-1.725 1.722-3.656 1-1.261-.472-1.855-1.45-2.239-2.5",
                    }),
                    O.jsx("path", { d: "M8 14v.5" }),
                    O.jsx("path", { d: "M16 14v.5" }),
                    O.jsx("path", { d: "M11.25 16.25h1.5L12 17l-.75-.75Z" }),
                    O.jsx("path", {
                      d: "M4.42 11.247A13.152 13.152 0 0 0 4 14.556C4 18.728 7.582 21 12 21s8-2.272 8-6.444c0-1.061-.162-2.2-.493-3.309m-9.243-6.082A8.801 8.801 0 0 1 12 5c.78 0 1.5.108 2.161.306",
                    }),
                  ],
                }),
              }),
              O.jsx(Be.div, {
                initial: { opacity: 0, y: 24 },
                whileInView: { opacity: 1, y: 0 },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.6, ease: "easeOut" },
                style: {
                  color: "#064e3b",
                  fontWeight: 700,
                  fontSize: "1.3rem",
                  marginBottom: "0.1vw",
                  letterSpacing: "1px",
                },
                children: "1B",
              }),
              O.jsx(Be.div, {
                initial: { opacity: 0, filter: "blur(8px)" },
                whileInView: { opacity: 1, filter: "blur(0px)" },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.7, ease: "easeOut" },
                style: {
                  color: "#fff",
                  fontSize: "clamp(0.9rem, 2vw, 1.1rem)",
                  fontWeight: 700,
                  textAlign: "center",
                  lineHeight: "1.3",
                  padding: "clamp(5px, 0.5vw, 10px)",
                  wordWrap: "break-word",
                  overflowWrap: "break-word",
                  display: "block",
                  visibility: "visible",
                  opacity: 1,
                  height: "auto",
                  overflow: "visible",
                },
                children: "Total Token Supply",
              }),
            ],
          }),
          O.jsxs("div", {
            className: "stats-card",
            style: {
              width: "clamp(250px, 25vw, 300px)",
              minWidth: "clamp(250px, 25vw, 300px)",
              maxWidth: "clamp(250px, 25vw, 300px)",
              height: "auto",
              minHeight: "clamp(120px, 15vh, 160px)",
              background: "#181a1f",
              borderRadius: "clamp(8px, 1vw, 12px)",
              boxShadow: "0 2px 14px #0002",
              padding: "clamp(15px, 2vw, 25px) 0",
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              boxSizing: "border-box",
              overflow: "visible",
            },
            children: [
              O.jsx(Be.span, {
                animate: { rotate: [-4, 4, -4] },
                transition: {
                  duration: 0.8,
                  repeat: 1 / 0,
                  repeatType: "loop",
                  ease: "easeInOut",
                },
                style: { display: "inline-flex" },
                children: O.jsx("svg", {
                  width: "28",
                  height: "28",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "#064e3b",
                  strokeWidth: "2.2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  style: { marginBottom: "0.4vw", opacity: 0.9 },
                  children: O.jsx("path", {
                    d: "M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5Z",
                  }),
                }),
              }),
              O.jsx(Be.div, {
                initial: { opacity: 0, y: 24 },
                whileInView: { opacity: 1, y: 0 },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.6, ease: "easeOut" },
                style: {
                  color: "#064e3b",
                  fontWeight: 700,
                  fontSize: "1.3rem",
                  marginBottom: "0.1vw",
                  letterSpacing: "1px",
                },
                children: "0%",
              }),
              O.jsx(Be.div, {
                initial: { opacity: 0, filter: "blur(8px)" },
                whileInView: { opacity: 1, filter: "blur(0px)" },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.7, ease: "easeOut" },
                style: {
                  color: "#fff",
                  fontSize: "clamp(0.9rem, 2vw, 1.1rem)",
                  fontWeight: 700,
                  textAlign: "center",
                  lineHeight: "1.3",
                  padding: "clamp(5px, 0.5vw, 10px)",
                  wordWrap: "break-word",
                  overflowWrap: "break-word",
                  display: "block",
                  visibility: "visible",
                  opacity: 1,
                  height: "auto",
                  overflow: "visible",
                },
                children: "Buy/Sell Tax",
              }),
            ],
          }),
        ],
      }),
    ],
  });
}
const IV =
    "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/ac48d7046512ad9ecfa0b6566460ee72.jpg",
  PV = [
    {
      icon: O.jsxs("svg", {
        width: "24",
        height: "24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2.2",
        viewBox: "0 0 24 24",
        children: [
          O.jsx("circle", {
            cx: "12",
            cy: "12",
            r: "10",
            stroke: "#064e3b",
            strokeWidth: "2.2",
            fill: "none",
          }),
          O.jsx("path", {
            d: "M12 6v6l4 2",
            stroke: "#064e3b",
            strokeWidth: "2.2",
            strokeLinecap: "round",
          }),
        ],
      }),
      text: "One of the oldest Shiba images on the internet",
    },
    {
      icon: O.jsxs("svg", {
        width: "24",
        height: "24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2.2",
        viewBox: "0 0 24 24",
        children: [
          O.jsx("circle", {
            cx: "12",
            cy: "12",
            r: "10",
            stroke: "#064e3b",
            strokeWidth: "2.2",
            fill: "none",
          }),
          O.jsx("ellipse", {
            cx: "12",
            cy: "12",
            rx: "10",
            ry: "4",
            stroke: "#064e3b",
            strokeWidth: "2.2",
            fill: "none",
          }),
          O.jsx("ellipse", {
            cx: "12",
            cy: "12",
            rx: "4",
            ry: "10",
            stroke: "#064e3b",
            strokeWidth: "2.2",
            fill: "none",
          }),
        ],
      }),
      text: "Used on Wikipedia and early meme sites",
    },
    {
      icon: O.jsx("svg", {
        width: "24",
        height: "24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2.2",
        viewBox: "0 0 24 24",
        children: O.jsx("path", {
          d: "M12 3l8 4v5c0 5-3.8 9.7-8 11-4.2-1.3-8-6-8-11V7l8-4z",
          stroke: "#064e3b",
          strokeWidth: "2.2",
          fill: "none",
        }),
      }),
      text: "The Image is public domain. No copyright. No IP infringement.",
    },
    {
      icon: O.jsx("svg", {
        width: "24",
        height: "24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2.2",
        viewBox: "0 0 24 24",
        children: O.jsx("polygon", {
          points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2",
          stroke: "#064e3b",
          strokeWidth: "2.2",
          fill: "none",
        }),
      }),
      text: "Referenced by Plasma on his blog in 2018.",
    },
    {
      icon: O.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14" }),
          O.jsx("polyline", { points: "22 4 12 14.01 9 11.01" }),
        ],
      }),
      text: "The OG dog meme since 2008",
    },
    {
      icon: O.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("path", { d: "M17 8h1a4 4 0 1 1 0 8h-1" }),
          O.jsx("path", { d: "M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z" }),
          O.jsx("line", { x1: "6", x2: "6", y1: "2", y2: "4" }),
          O.jsx("line", { x1: "10", x2: "10", y1: "2", y2: "4" }),
          O.jsx("line", { x1: "14", x2: "14", y1: "2", y2: "4" }),
        ],
      }),
      text: "No dev wallets. No team tax. Just vibes.",
    },
  ],
  V2 = [
    { initial: { opacity: 0, y: 40 }, whileInView: { opacity: 1, y: 0 } },
    { initial: { opacity: 0, x: -60 }, whileInView: { opacity: 1, x: 0 } },
    { initial: { opacity: 0, x: 60 }, whileInView: { opacity: 1, x: 0 } },
    {
      initial: { opacity: 0, scale: 0.7 },
      whileInView: { opacity: 1, scale: 1 },
    },
    {
      initial: { opacity: 0, rotate: -30 },
      whileInView: { opacity: 1, rotate: 0 },
    },
    {
      initial: { opacity: 0, rotate: 30 },
      whileInView: { opacity: 1, rotate: 0 },
    },
    {
      initial: { opacity: 0, y: 60, scale: 0.8 },
      whileInView: { opacity: 1, y: 0, scale: 1 },
      transition: { type: "spring", bounce: 0.4, duration: 1 },
    },
  ];
function zV() {
  const i = bt.useMemo(() => {
    const t = Math.floor(Math.random() * V2.length);
    return V2[t];
  }, []);
  return O.jsxs(O.Fragment, {
    children: [
      O.jsxs("section", {
        id: "about",
        style: {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          margin: "4vw 0 2vw 0",
          boxSizing: "border-box",
          animation: "about-fadein 1.2s cubic-bezier(.4,0,.2,1)",
          scrollMarginTop: "90px",
          scrollMarginBlockStart: "90px",
        },
        children: [
          O.jsx("style", {
            children: `
          @keyframes about-fadein {
            0% { opacity: 0; transform: translateY(40px) scale(0.98); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
          }
          @media (max-width: 900px) {
            .about-main {
              flex-direction: column !important;
              gap: 3vw !important;
              padding: 4vw 2vw !important;
            }
            .about-img-card {
              width: 100% !important;
              margin: 0 auto 2vw auto !important;
            }
            .about-why {
              width: 100% !important;
              margin: 0 auto !important;
            }
            /* Make Why PAUL cards use Vitalik gradient in mobile */
            .about-why-card {
              background: linear-gradient(120deg, #e5e7eb 0%, #ffb3b3 60%, #2cb979 100%) !important;
              border: 2px solid #000 !important;
              box-shadow: 0 4px 32px #2cb97922 !important;
            }
            /* Make SVG icons red and text black in mobile */
            .about-why-card svg {
              stroke: #064e3b !important;
              fill: none !important;
            }
            .about-why-card svg path,
            .about-why-card svg circle,
            .about-why-card svg polygon,
            .about-why-card svg polyline,
            .about-why-card svg ellipse {
              stroke: #064e3b !important;
              fill: none !important;
            }
            .about-why-card span:last-child {
              color: #000 !important;
            }
          }
          @media (min-width: 1600px) {
            .about-main {
              max-width: 1400px;
              margin-left: auto;
              margin-right: auto;
            }
          }
          @media (min-width: 1200px) and (max-width: 1599px) {
            .about-main, .about-section, .vitalik-main-card {
              max-width: 1200px;
              margin-left: auto;
              margin-right: auto;
            }
            .about-content {
              max-width: 1100px;
            }
            .about-title {
              font-size: 2.2rem;
            }
            .about-sub {
              font-size: 1.1rem;
            }
          }
        `,
          }),
          O.jsxs("div", {
            style: { width: "100%" },
            children: [
              O.jsxs(Be.h2, {
                initial: { opacity: 0, y: 40 },
                whileInView: { opacity: 1, y: 0 },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.7, ease: "easeOut" },
                style: {
                  color: "#fff",
                  fontWeight: 800,
                  fontSize: "2.2rem",
                  textAlign: "center",
                  margin: 0,
                  marginBottom: "0.5vw",
                },
                children: [
                  "The Story of ",
                  O.jsx("span", {
                    style: { color: "#18191c" },
                    children: "$PAUL",
                  }),
                ],
              }),
              O.jsx(Be.div, {
                initial: { opacity: 0, filter: "blur(8px)" },
                whileInView: { opacity: 1, filter: "blur(0px)" },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 1, ease: "easeOut" },
                style: {
                  color: "#fff",
                  textAlign: "center",
                  fontSize: "1.1rem",
                  marginBottom: "2vw",
                },
                children:
                  "Paul isnt just a dog. Hes history. Hes public domain. Hes the real Shiba from the webs earliest days  the photo your favorite meme tokens built themselves on.",
              }),
              O.jsxs("div", {
                className: "about-main",
                style: {
                  display: "flex",
                  flexDirection: "row",
                  gap: "4vw",
                  alignItems: "center",
                  justifyContent: "center",
                  padding: "2vw 0",
                  maxWidth: 1200,
                  margin: "0 auto",
                  flexWrap: "wrap",
                },
                children: [
                  O.jsxs("div", {
                    className: "about-img-card",
                    style: {
                      background: "#181a1f",
                      borderRadius: 24,
                      boxShadow: "0 2px 24px #0004",
                      padding: "2vw",
                      width: "100%",
                      maxWidth: 500,
                      minWidth: 0,
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      position: "relative",
                      overflow: "visible",
                      boxSizing: "border-box",
                    },
                    children: [
                      O.jsx(Be.img, {
                        src: IV,
                        alt: "Paul Shiba Inu",
                        initial: i.initial,
                        whileInView: i.whileInView,
                        viewport: { once: !0, amount: 0.5 },
                        transition: i.transition || {
                          duration: 0.8,
                          ease: "easeOut",
                        },
                        style: {
                          width: "100%",
                          maxWidth: 420,
                          height: "auto",
                          objectFit: "contain",
                          borderRadius: 24,
                          marginBottom: "0.7vw",
                          boxShadow: "0 0 32px 0 #064e3b33",
                          position: "relative",
                          zIndex: 1,
                          background: "#181a1f",
                        },
                      }),
                      O.jsx("div", {
                        style: {
                          color: "#fff",
                          fontWeight: 700,
                          fontSize: "1.1rem",
                          marginTop: "2.5vw",
                          marginBottom: "0.5vw",
                          zIndex: 2,
                          position: "relative",
                        },
                        children: "The OG Dog Meme",
                      }),
                      O.jsx("div", {
                        style: {
                          color: "#b0b6c3",
                          fontSize: "1rem",
                          marginBottom: "1vw",
                          textAlign: "center",
                          zIndex: 2,
                          position: "relative",
                        },
                        children:
                          "$PAUL is a tribute to memes history. A project run by the community, fueled by nostalgia, powered by a fantastic narrative.",
                      }),
                      O.jsx("div", {
                        style: {
                          background: "#064e3b",
                          color: "#fff",
                          fontWeight: 700,
                          fontSize: "0.95rem",
                          borderRadius: 8,
                          padding: "0.3vw 1vw",
                          display: "inline-block",
                          zIndex: 2,
                          position: "relative",
                        },
                        children: "Est. 2008. Tokenized 2025.",
                      }),
                    ],
                  }),
                  O.jsxs("div", {
                    className: "about-why",
                    style: {
                      flex: 1,
                      minWidth: 0,
                      maxWidth: 520,
                      width: "100%",
                      marginLeft: "auto",
                      marginRight: "auto",
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      boxSizing: "border-box",
                    },
                    children: [
                      O.jsxs("div", {
                        style: {
                          color: "#18191c",
                          fontWeight: 800,
                          fontSize: "1.7rem",
                          marginBottom: "1vw",
                          textAlign: "center",
                        },
                        children: [
                          "Why ",
                          O.jsx("span", {
                            style: { color: "#fff" },
                            children: "$PAUL",
                          }),
                          "?",
                        ],
                      }),
                      O.jsx("div", {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          gap: "1.5vw",
                          width: "100%",
                        },
                        children: PV.map((t, e) =>
                          O.jsxs(
                            Be.div,
                            {
                              className: "about-why-card",
                              initial: { opacity: 0, y: 40 },
                              whileInView: { opacity: 1, y: 0 },
                              viewport: { once: !0, amount: 0.4 },
                              transition: {
                                duration: 0.7,
                                delay: e * 0.12,
                                ease: "easeOut",
                              },
                              style: {
                                display: "flex",
                                alignItems: "center",
                                background: "#181a1f",
                                borderRadius: 16,
                                padding: "1vw 1.5vw",
                                color: "#fff",
                                fontSize: "1.18rem",
                                fontWeight: 500,
                                boxShadow: "0 2px 12px #0002",
                                gap: 24,
                                margin: "0 auto",
                                width: "100%",
                                maxWidth: 420,
                                minWidth: 0,
                              },
                              children: [
                                O.jsx("span", {
                                  style: {
                                    display: "flex",
                                    alignItems: "center",
                                    justifyContent: "center",
                                    minWidth: 38,
                                    fontSize: 0,
                                  },
                                  children: O.jsx(Be.span, {
                                    animate: { rotate: [-7, 7, -7] },
                                    transition: {
                                      duration: 1.2,
                                      repeat: 1 / 0,
                                      repeatType: "loop",
                                      ease: "easeInOut",
                                    },
                                    style: { display: "inline-flex" },
                                    children: RA.cloneElement(t.icon, {
                                      width: 32,
                                      height: 32,
                                    }),
                                  }),
                                }),
                                O.jsx("span", {
                                  style: {
                                    fontSize: "1.18rem",
                                    lineHeight: 1.35,
                                  },
                                  children: t.text,
                                }),
                              ],
                            },
                            e
                          )
                        ),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      O.jsxs("section", {
        style: {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          margin: "0 0 4vw 0",
          boxSizing: "border-box",
        },
        children: [
          O.jsx("style", {
            children: `
          @media (max-width: 900px) {
            .vitalik-main-card {
              max-width: 98vw !important;
              padding: 2vw 2vw 2vw 2vw !important;
            }
            .vitalik-white-card {
              max-width: 98vw !important;
              min-width: 220px !important;
              min-height: 70px !important;
              max-height: none !important;
              overflow: visible !important;
              padding: 1vw 4vw !important;
              font-size: 0.55rem !important;
              display: flex !important;
              flex-direction: column !important;
              align-items: center !important;
              justify-content: center !important;
            }
            .vitalik-img {
              width: 40px !important;
              height: 40px !important;
            }
            .vitalik-white-card a {
              font-size: 0.7rem !important;
              padding: 0.4em 1.2em !important;
              border-radius: 6px !important;
            }
            .vitalik-heading {
              font-size: 1.1rem !important;
              margin-bottom: 1vw !important;
              margin-top: 0.5vw !important;
            }
            .vitalik-subtitle {
              font-size: 0.92rem !important;
              margin-bottom: 1.5vw !important;
            }
          }
        `,
          }),
          O.jsxs("div", {
            className: "vitalik-main-card",
            style: {
              width: "95%",
              maxWidth: 1400,
              background:
                "linear-gradient(120deg, #3d947dff 0%, #177058ff 60%, #064e3b 100%)",
              borderRadius: 28,
              margin: "0 auto",
              padding: "3vw 2vw 2vw 2vw",
              boxSizing: "border-box",
              boxShadow: "0 4px 32px #2cb97922",
              position: "relative",
              minHeight: 320,
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
            },
            children: [
              O.jsxs(Be.div, {
                className: "vitalik-heading",
                initial: { opacity: 0, y: 32 },
                whileInView: { opacity: 1, y: 0 },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.8, ease: "easeOut" },
                style: {
                  fontWeight: 800,
                  fontSize: "2.3rem",
                  textAlign: "center",
                  marginBottom: "0.7vw",
                  marginTop: "0.5vw",
                  color: "#fff",
                  letterSpacing: "0.01em",
                },
                children: [
                  O.jsx("span", {
                    style: { color: "#064e3b" },
                    children: "Plasma",
                  }),
                  " & PAUL",
                ],
              }),
              O.jsx(Be.div, {
                className: "vitalik-subtitle",
                initial: { opacity: 0, y: 32, filter: "blur(8px)" },
                whileInView: { opacity: 1, y: 0, filter: "blur(0px)" },
                viewport: { once: !0, amount: 0.7 },
                transition: { duration: 0.9, ease: "easeOut" },
                style: {
                  color: "#18191c",
                  fontWeight: 500,
                  fontSize: "1.25rem",
                  textAlign: "center",
                  marginBottom: "2vw",
                  maxWidth: 900,
                  marginLeft: "auto",
                  marginRight: "auto",
                },
                children:
                  'In an iconic 2018 article titled "On Radical Markets", Vitalik used PAUL image talking about online culture and values.',
              }),
              O.jsxs("div", {
                className: "vitalik-white-card",
                style: {
                  background: "#fff",
                  borderRadius: 16,
                  boxShadow: "0 2px 16px #0002",
                  padding: "0.7vw 2vw",
                  width: "100%",
                  maxWidth: 700,
                  minHeight: 180,
                  margin: "0 auto",
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  fontSize: "1.05rem",
                },
                children: [
                  O.jsx(FV, {}),
                  O.jsx("img", {
                    className: "vitalik-img",
                    src: "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/ac48d7046512ad9ecfa0b6566460ee72.jpg",
                    alt: "A doge.",
                    style: {
                      width: 180,
                      height: 180,
                      objectFit: "cover",
                      borderRadius: 12,
                      margin: "0 auto",
                    },
                    loading: "lazy",
                  }),
                  O.jsx("div", {
                    style: {
                      color: "#064e3b",
                      fontSize: "1rem",
                      fontStyle: "italic",
                      textAlign: "center",
                      marginTop: 8,
                    },
                    children: "A doge.",
                  }),
                  // O.jsx("a", {
                  //   href: "https://vitalik.eth.limo/general/2018/04/20/radical_markets.html",
                  //   target: "_blank",
                  //   rel: "noopener noreferrer",
                  //   style: {
                  //     background:
                  //       "linear-gradient(90deg, #064e3b 60%, #399e70 100%)",
                  //     color: "#fff",
                  //     fontWeight: 700,
                  //     fontSize: "1.08rem",
                  //     fontStyle: "italic",
                  //     border: "none",
                  //     borderRadius: 8,
                  //     padding: "0.7em 2.2em",
                  //     marginTop: "1.5vw",
                  //     textDecoration: "none",
                  //     display: "inline-block",
                  //     cursor: "pointer",
                  //     boxShadow: "0 2px 12px #064e3b33",
                  //     transition: "background 0.2s, color 0.2s",
                  //   },
                  //   children: "Read More",
                  // }),
                ],
              }),
            ],
          }),
        ],
      }),
    ],
  });
}
function FV() {
  return O.jsx("div", {
    style: {
      color: "#18191c",
      fontSize: "1.05rem",
      fontWeight: 700,
      fontStyle: "italic",
      textAlign: "left",
      marginBottom: "1.5vw",
      lineHeight: 1.6,
      minHeight: 80,
    },
    children:
      "One of the more interesting ideas from the 19th century economists, and specifically Henry George, was a kind of property tax that did not have this problem: land value tax. The idea is to charge tax on the value of land, but not the improvements to the land; if you own a $100,000 plot of dirt you would have to pay $5,000 per year taxes on it regardless of whether you used the land to build a condominium or simply as a place to walk your pet doge.",
  });
}
const HV = [
    {
      icon: O.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("path", { d: "m7.5 4.27 9 5.15" }),
          O.jsx("path", {
            d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
          }),
          O.jsx("path", { d: "m3.3 7 8.7 5 8.7-5" }),
          O.jsx("path", { d: "M12 22V12" }),
        ],
      }),
      title: "Total Supply",
      value: "1,000,000,000 $PAUL",
    },
    {
      icon: O.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: O.jsx("polygon", {
          points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2",
        }),
      }),
      title: "Fair Launch",
      value: "100% Publicly Available",
    },
    {
      icon: O.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("path", { d: "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10" }),
          O.jsx("path", { d: "m9 12 2 2 4-4" }),
        ],
      }),
      title: "Liquidity",
      value: "LP Tokens Burned",
    },
    {
      icon: O.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17" }),
          O.jsx("polyline", { points: "16 7 22 7 22 13" }),
        ],
      }),
      title: "Taxes",
      value: "0% Buy / 0% Sell",
    },
    {
      icon: O.jsx("img", {
        src: "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/bd16ebd32caee97543484bec8e7922a8.png",
        alt: "Meme",
        style: { width: 32, height: 32, borderRadius: 8 },
        loading: "lazy",
      }),
      title: "Pure Meme Energy",
      value: "No Presale. No VCs involved.",
    },
    {
      icon: O.jsxs("svg", {
        width: "32",
        height: "32",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2.2",
        viewBox: "0 0 24 24",
        children: [
          O.jsx("path", { d: "M17 21v-2a4 4 0 0 0-4-4H7a4 4 0 0 0-4 4v2" }),
          O.jsx("circle", { cx: "9", cy: "7", r: "4" }),
          O.jsx("path", { d: "M23 21v-2a4 4 0 0 0-3-3.87" }),
          O.jsx("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }),
        ],
      }),
      title: "Community First",
      value: "Plasma Ceo Paul.",
    },
  ],
  Ub = "0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718";
function GV() {
  return O.jsxs("section", {
    id: "tokenomics",
    style: {
      width: "100%",
      background: "none",
      margin: "0 auto",
      padding: "0 0 4vw 0",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      scrollMarginTop: 90,
      scrollMarginBlockStart: 90,
    },
    children: [
      O.jsx("style", {
        children: `
        .tokenomics-title {
          color: #fff;
          font-size: 2.3rem;
          font-weight: 800;
          text-align: center;
          margin-top: 2vw;
          margin-bottom: 0.5vw;
        }
        .tokenomics-title span {
          color: #18191c;
        }
        .tokenomics-desc {
          color: #b0b6c3;
          font-size: 1.15rem;
          text-align: center;
          margin-bottom: 2vw;
        }
        .tokenomics-grid {
          display: flex;
          flex-wrap: wrap;
          gap: 2vw;
          justify-content: center;
          margin-bottom: 2vw;
          width: 100%;
          max-width: 1200px;
        }
        .tokenomics-card {
          background: #18191c;
          border-radius: 1vw;
          box-shadow: 0 2px 14px #0002;
          padding: 2vw 2vw 1.2vw 2vw;
          min-width: 280px;
          max-width: 340px;
          flex: 1 1 280px;
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 0.7vw;
          min-height: 120px;
        }
        .tokenomics-card svg, .tokenomics-card img {
          margin-bottom: 0.2vw;
        }
        .tokenomics-card-title {
          color: #fff;
          font-size: 1.18rem;
          font-weight: 700;
        }
        .tokenomics-card-value {
          color: #064e3b;
          font-size: 1.08rem;
          font-weight: 900;
          font-style: italic;
        }
        .tokenomics-contract {
          background: #18191c;
          border-radius: 1vw;
          box-shadow: 0 2px 14px #0002;
          padding: 2vw 2vw 1vw 2vw;
          margin-top: 2vw;
          width: 100%;
          max-width: 900px;
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        .tokenomics-contract-label {
          color: #064e3b;
          font-size: 1.25rem;
          font-weight: 700;
          margin-bottom: 0.7vw;
        }
        .tokenomics-contract-address {
          background: #3a1818;
          color: #fff;
          font-size: 1.1rem;
          font-family: monospace;
          border-radius: 0.5vw;
          padding: 0.7vw 2vw;
          margin-bottom: 0.7vw;
          width: 100%;
          text-align: center;
          letter-spacing: 0.5px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .tokenomics-contract-link {
          color: #064e3b;
          font-size: 1.05rem;
          text-align: center;
          text-decoration: none;
          margin-top: 0.2vw;
          transition: text-decoration 0.2s;
        }
        .tokenomics-contract-link:hover {
          text-decoration: underline;
        }
        @media (max-width: 900px) {
          .tokenomics-title {
            font-size: 1.5rem;
            margin-top: 5vw;
          }
          .tokenomics-desc {
            font-size: 0.98rem;
          }
          .tokenomics-grid {
            gap: 3vw;
          }
          .tokenomics-card {
            min-width: 280px;
            max-width: 320px;
            width: fit-content;
            padding: 4vw 3vw 2.5vw 3vw;
            border-radius: 4vw;
            min-height: 90px;
            align-items: center !important;
            text-align: center !important;
            margin: 0 auto;
            background: linear-gradient(120deg, #e5e7eb 0%, #ffb3b3 60%, #2cb979 100%) !important;
            border: 2px solid #000 !important;
            box-shadow: 0 4px 32px #2cb97922 !important;
          }
          .tokenomics-card svg, .tokenomics-card img {
            margin: 0 auto 0.5vw auto !important;
            display: block !important;
          }
          .tokenomics-card svg {
            stroke: #064e3b !important;
            fill: none !important;
          }
          .tokenomics-card svg path,
          .tokenomics-card svg circle,
          .tokenomics-card svg polygon,
          .tokenomics-card svg polyline,
          .tokenomics-card svg ellipse {
            stroke: #064e3b !important;
            fill: none !important;
          }
          .tokenomics-card-title {
            text-align: center !important;
            width: 100% !important;
            color: #000 !important;
          }
          .tokenomics-card-value {
            text-align: center !important;
            width: 100% !important;
            color: #000 !important;
          }
          .tokenomics-contract {
            max-width: 98vw;
            padding: 4vw 2vw 2vw 2vw;
            border-radius: 4vw;
            margin-top: 5vw;
            background: rgba(24, 26, 31, 0.8) !important;
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3) !important;
          }
          .tokenomics-contract-label {
            font-size: 0.98rem;
            color: #fff !important;
          }
          .tokenomics-contract-label svg {
            stroke: #fff !important;
            fill: none !important;
          }
          .tokenomics-contract-address {
            font-size: 0.82rem;
            padding: 2vw 2vw;
            border-radius: 2vw;
            flex-wrap: wrap;
            word-break: break-all;
            gap: 4px;
            color: #fff !important;
          }
          .tokenomics-contract-link {
            color: #fff !important;
          }
          .tokenomics-contract-link svg {
            stroke: #fff !important;
            fill: none !important;
          }
          .tokenomics-contract-label {
            font-size: 0.98rem;
          }
          .tokenomics-contract-address {
            font-size: 0.82rem;
            padding: 2vw 2vw;
            border-radius: 2vw;
            flex-wrap: wrap;
            word-break: break-all;
            gap: 4px;
          }
        }
        @media (min-width: 1600px) {
          .tokenomics-grid {
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
          }
        }
        @media (min-width: 1200px) and (max-width: 1599px) {
          .tokenomics-main, .tokenomics-section {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
          }
          .tokenomics-content {
            max-width: 1100px;
          }
          .tokenomics-title {
            font-size: 2.2rem;
          }
          .tokenomics-sub {
            font-size: 1.1rem;
          }
        }
      `,
      }),
      O.jsxs(Be.div, {
        className: "tokenomics-title",
        initial: { opacity: 0, y: 32 },
        whileInView: { opacity: 1, y: 0 },
        viewport: { once: !0, amount: 0.7 },
        transition: { duration: 0.7, ease: "easeOut" },
        children: ["$PAUL ", O.jsx("span", { children: "Tokenomics" })],
      }),
      O.jsx(Be.div, {
        className: "tokenomics-desc",
        initial: { opacity: 0, y: 32, filter: "blur(8px)" },
        whileInView: { opacity: 1, y: 0, filter: "blur(0px)" },
        viewport: { once: !0, amount: 0.7 },
        transition: { duration: 0.9, ease: "easeOut" },
        style: { color: "#fff" },
        children:
          "PAUL token supply is 100% market available. No VCs were involved and there was no Presale. The token is only held by the community",
      }),
      O.jsx("div", {
        className: "tokenomics-grid",
        children: HV.map((i, t) =>
          O.jsxs(
            Be.div,
            {
              className: "tokenomics-card",
              initial: { opacity: 0, y: 40 },
              whileInView: { opacity: 1, y: 0 },
              viewport: { once: !0, amount: 0.4 },
              transition: { duration: 0.7, delay: t * 0.12, ease: "easeOut" },
              children: [
                O.jsx(Be.div, {
                  animate: { y: [0, -8, 8, 0], rotate: [0, 7, -7, 0] },
                  transition: {
                    duration: 1.2,
                    repeat: 1 / 0,
                    repeatType: "loop",
                    ease: "easeInOut",
                    delay: t * 0.15,
                  },
                  style: { display: "inline-flex" },
                  children: i.icon,
                }),
                O.jsx(Be.div, {
                  className: "tokenomics-card-title",
                  initial: { opacity: 0, y: 24 },
                  whileInView: { opacity: 1, y: 0 },
                  viewport: { once: !0, amount: 0.7 },
                  transition: {
                    duration: 0.6,
                    delay: 0.2 + t * 0.08,
                    ease: "easeOut",
                  },
                  children: i.title,
                }),
                O.jsx(Be.div, {
                  className: "tokenomics-card-value",
                  initial: { opacity: 0, filter: "blur(8px)" },
                  whileInView: { opacity: 1, filter: "blur(0px)" },
                  viewport: { once: !0, amount: 0.7 },
                  transition: {
                    duration: 0.7,
                    delay: 0.32 + t * 0.08,
                    ease: "easeOut",
                  },
                  children: i.value,
                }),
              ],
            },
            t
          )
        ),
      }),
      O.jsxs(Be.div, {
        className: "tokenomics-contract",
        initial: { opacity: 0, y: 40 },
        whileInView: { opacity: 1, y: 0 },
        viewport: { once: !0, amount: 0.4 },
        transition: { duration: 0.7, ease: "easeOut" },
        children: [
          O.jsxs("div", {
            className: "tokenomics-contract-label",
            children: [
              O.jsxs("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "32",
                height: "32",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "#064e3b",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                style: {
                  display: "block",
                  margin: "0 auto 0.5vw auto",
                  opacity: 0.7,
                },
                children: [
                  O.jsx("rect", {
                    x: "4",
                    y: "4",
                    width: "16",
                    height: "16",
                    rx: "2",
                  }),
                  O.jsx("rect", { x: "9", y: "9", width: "6", height: "6" }),
                  O.jsx("path", { d: "M15 2v2" }),
                  O.jsx("path", { d: "M15 20v2" }),
                  O.jsx("path", { d: "M2 15h2" }),
                  O.jsx("path", { d: "M2 9h2" }),
                  O.jsx("path", { d: "M20 15h2" }),
                  O.jsx("path", { d: "M20 9h2" }),
                  O.jsx("path", { d: "M9 2v2" }),
                  O.jsx("path", { d: "M9 20v2" }),
                ],
              }),
              "Contract Address",
            ],
          }),
          O.jsxs("div", {
            className: "tokenomics-contract-address",
            style: {
              position: "relative",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: 8,
            },
            children: [Ub, O.jsx(VV, { value: Ub })],
          }),
          // O.jsxs("a", {
          //   className: "tokenomics-contract-link",
          //   href: `https://etherscan.io/address/${Ub}`,
          //   target: "_blank",
          //   rel: "noopener noreferrer",
          //   children: [
          //     "View on Etherscan",
          //     O.jsx("span", {
          //       style: {
          //         display: "inline-flex",
          //         alignItems: "center",
          //         justifyContent: "center",
          //         marginLeft: 8,
          //         verticalAlign: "middle",
          //       },
          //       children: O.jsxs("svg", {
          //         xmlns: "http://www.w3.org/2000/svg",
          //         width: "20",
          //         height: "20",
          //         viewBox: "0 0 24 24",
          //         fill: "none",
          //         stroke: "#064e3b",
          //         strokeWidth: "2",
          //         strokeLinecap: "round",
          //         strokeLinejoin: "round",
          //         style: { display: "block" },
          //         children: [
          //           O.jsx("path", {
          //             d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
          //           }),
          //           O.jsx("polyline", { points: "15 3 21 3 21 9" }),
          //           O.jsx("line", { x1: "10", x2: "21", y1: "14", y2: "3" }),
          //         ],
          //       }),
          //     }),
          //   ],
          // }),
        ],
      }),
    ],
  });
}
function VV({ value: i }) {
  const [t, e] = bt.useState(!1),
    n = () => {
      navigator.clipboard.writeText(i), e(!0), setTimeout(() => e(!1), 1200);
    };
  return O.jsxs("span", {
    style: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
    },
    children: [
      O.jsx("button", {
        onClick: n,
        "aria-label": "Copy contract address",
        style: {
          background: "none",
          border: "none",
          padding: 0,
          marginLeft: 8,
          cursor: "pointer",
          display: "inline-flex",
          alignItems: "center",
        },
        children: O.jsxs("svg", {
          width: "22",
          height: "22",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "#064e3b",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          style: { opacity: 0.8 },
          children: [
            O.jsx("rect", {
              x: "9",
              y: "9",
              width: "13",
              height: "13",
              rx: "2",
            }),
            O.jsx("rect", {
              x: "2",
              y: "2",
              width: "13",
              height: "13",
              rx: "2",
            }),
          ],
        }),
      }),
      t &&
        O.jsx("span", {
          style: {
            position: "absolute",
            top: "-1.8em",
            left: "50%",
            transform: "translateX(-50%)",
            background: "#18191c",
            color: "#064e3b",
            fontSize: "0.85em",
            padding: "2px 8px",
            borderRadius: 6,
            boxShadow: "0 2px 8px #0006",
            whiteSpace: "nowrap",
            zIndex: 10,
          },
          children: "Copied!",
        }),
    ],
  });
}
const Ob = "0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
  kV = [
    {
      icon: O.jsxs("svg", {
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("path", { d: "M21 12V7H5a2 2 0 0 1 0-4h14v4" }),
          O.jsx("path", { d: "M3 5v14a2 2 0 0 0 2 2h16v-5" }),
          O.jsx("path", { d: "M18 12a2 2 0 0 0 0 4h4v-4Z" }),
        ],
      }),
      title: "Prepare Your Wallet",
      desc: "Add ETH to your MetaMask, Trust Wallet, or any ERC-20 compatible wallet.",
    },
    {
      icon: O.jsxs("svg", {
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("circle", { cx: "8", cy: "21", r: "1" }),
          O.jsx("circle", { cx: "19", cy: "21", r: "1" }),
          O.jsx("path", {
            d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
          }),
        ],
      }),
      title: "Go to Uniswap",
      desc: "Click the 'Buy on Uniswap' button below to open the official Uniswap interface with $PAUL pre-loaded.",
    },
    {
      icon: O.jsx("svg", {
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: O.jsx("polyline", { points: "20 6 9 17 4 12" }),
      }),
      title: "Verify Contract",
      desc: "Double-check the contract address matches our official one and verify on Etherscan.",
    },
    {
      icon: O.jsxs("svg", {
        width: "32",
        height: "32",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "#064e3b",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          O.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "4" }),
          O.jsx("path", { d: "M8 12h8" }),
          O.jsx("path", { d: "M12 8v8" }),
        ],
      }),
      title: "Swap. Hold. Meme.",
      desc: "Swap your ETH for $PAUL. Confirm the transaction, and welcome to the OG club!",
    },
  ];
function jV() {
  const [i, t] = bt.useState(!1),
    e = () => {
      navigator.clipboard.writeText(Ob), t(!0), setTimeout(() => t(!1), 1200);
    };
  return O.jsxs("section", {
    id: "howtobuy",
    style: {
      width: "100%",
      background: "none",
      margin: "0 auto",
      padding: "0 0 4vw 0",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      scrollMarginTop: 90,
      scrollMarginBlockStart: 90,
      display: 'none',
    },
    children: [
      O.jsx("style", {
        children: `
        .howtobuy-title {
          color: #fff;
          font-size: 2.3rem;
          font-weight: 800;
          text-align: center;
          margin-top: 2vw;
          margin-bottom: 0.5vw;
        }
        .howtobuy-title span {
          color: #18191c;
        }
        .howtobuy-desc {
          color: #b0b6c3;
          font-size: 1.15rem;
          text-align: center;
          margin-bottom: 2vw;
        }
        .howtobuy-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 2vw;
          justify-content: center;
          margin-bottom: 2vw;
          width: 100%;
          max-width: 1200px;
        }
        .howtobuy-card {
          background: #18191c;
          border-radius: 1vw;
          box-shadow: 0 2px 14px #0002;
          padding: 2vw 2vw 1.2vw 2vw;
          min-width: 340px;
          max-width: 480px;
          flex: 1 1 340px;
          display: flex;
          flex-direction: row;
          align-items: flex-start;
          gap: 1.2vw;
          min-height: 90px;
        }
        .howtobuy-card svg {
          margin-top: 2px;
          flex-shrink: 0;
        }
        .howtobuy-card-content {
          display: flex;
          flex-direction: column;
        }
        .howtobuy-card-title {
          color: #fff;
          font-size: 1.18rem;
          font-weight: 700;
          margin-bottom: 0.2vw;
        }
        .howtobuy-card-desc {
          color: #b0b6c3;
          font-size: 1.05rem;
          font-weight: 400;
        }
        .howtobuy-contract {
          background: #18191c;
          border-radius: 1vw;
          box-shadow: 0 2px 14px #0002;
          padding: 2vw 2vw 1vw 2vw;
          margin-top: 2vw;
          width: 100%;
          max-width: 900px;
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        .howtobuy-contract-label {
          color: #fff;
          font-size: 1.25rem;
          font-weight: 700;
          margin-bottom: 0.7vw;
        }
        .howtobuy-contract-address {
          background: #3a1818;
          color: #064e3b;
          font-size: 1.1rem;
          font-family: monospace;
          border-radius: 0.5vw;
          padding: 0.7vw 2vw;
          margin-bottom: 0.7vw;
          width: 100%;
          text-align: center;
          letter-spacing: 0.5px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .howtobuy-contract-copy {
          margin-left: 8px;
          cursor: pointer;
          display: inline-flex;
          align-items: center;
        }
        .howtobuy-contract-link {
          color: #064e3b;
          font-size: 1.05rem;
          text-align: center;
          text-decoration: none;
          margin-top: 0.2vw;
          transition: text-decoration 0.2s;
        }
        .howtobuy-contract-link:hover {
          text-decoration: underline;
        }
        .howtobuy-uniswap-btn {
          background: rgba(24, 25, 28, 0.65);
          color: #fff;
          font-weight: 700;
          font-size: 1.25rem;
          border: 1.5px solid rgba(255,255,255,0.10);
          border-radius: 0.7vw;
          padding: 1vw 4vw;
          cursor: pointer;
          box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.18);
          text-decoration: none;
          margin: 3vw auto 0 auto;
          display: flex;
          align-items: center;
          gap: 0.7vw;
          backdrop-filter: blur(12px);
          -webkit-backdrop-filter: blur(12px);
          transition: background 0.2s, transform 0.2s;
        }
        .howtobuy-uniswap-btn:hover {
          background: rgba(24, 25, 28, 0.85);
          color: #fff;
          transform: scale(1.04);
        }
        .howtobuy-uniswap-btn svg {
          margin-left: 0.5vw;
        }
        .howtobuy-disclaimer-gradient {
          font-size: 0.95rem;
          margin-top: 18px;
          text-align: center;
          opacity: 0.95;
          font-weight: 600;
          color: #18191c;
          padding: 0 2vw;
        }
        .howtobuy-deximg-row {
          display: flex;
          flex-direction: row;
          justify-content: center;
          gap: 2vw;
          margin: 2vw 0 0.5vw 0;
          align-items: center;
        }
        .howtobuy-deximg-link {
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 999px;
          transition: border 0.22s, box-shadow 0.22s;
          border: 2.5px solid transparent;
          cursor: pointer;
          width: 260px;
          height: 100px;
          box-shadow: 0 2px 14px #0002;
        }
        .howtobuy-deximg-link.dex {
          background: #fff;
          border: 2.5px solid #18191c;
        }
        .howtobuy-deximg-link.screener {
          background: #000000;
          border: 2.5px solid #fff;
        }
        .howtobuy-deximg-link:hover {
          border: 2.5px solid #064e3b;
          box-shadow: 0 4px 24px #064e3b33;
        }
        .howtobuy-deximg {
          width: 80%;
          height: 80%;
          object-fit: contain;
          border-radius: 0;
          background: none;
          box-shadow: none;
          display: block;
        }
        @media (max-width: 900px) {
          .howtobuy-grid {
            grid-template-columns: 1fr;
          }
          .howtobuy-title {
            font-size: 1.15rem;
            margin-top: 5vw;
            margin-bottom: 2vw;
          }
          .howtobuy-desc {
            font-size: 0.98rem;
            margin-bottom: 4vw;
            line-height: 1.5;
            max-width: 98vw;
            padding: 0 2vw;
          }
          .howtobuy-card {
            min-width: 90vw;
            max-width: 98vw;
            padding: 5vw 4vw 3vw 4vw;
            border-radius: 4vw;
            min-height: 90px;
            flex-direction: column;
            gap: 2vw;
            background: linear-gradient(120deg, #e5e7eb 0%, #ffb3b3 60%, #2cb979 100%) !important;
            border: 2px solid #000 !important;
            box-shadow: 0 4px 32px #2cb97922 !important;
            align-items: center !important;
            text-align: center !important;
          }
          .howtobuy-contract {
            max-width: 98vw;
            padding: 4vw 2vw 2vw 2vw;
            border-radius: 4vw;
            margin-top: 5vw;
            background: rgba(24, 26, 31, 0.8) !important;
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3) !important;
          }
          .howtobuy-contract-label {
            font-size: 0.98rem;
            color: #fff !important;
          }
          .howtobuy-contract-label svg {
            stroke: #fff !important;
            fill: none !important;
          }
          .howtobuy-contract-address {
            font-size: 0.82rem;
            padding: 2vw 2vw;
            border-radius: 2vw;
            flex-wrap: wrap;
            word-break: break-all;
            gap: 4px;
            color: #fff !important;
          }
          .howtobuy-contract a {
            color: #fff !important;
          }
          .howtobuy-contract a svg {
            stroke: #fff !important;
            fill: none !important;
          }
          .howtobuy-contract-label {
            font-size: 0.98rem;
          }
          .howtobuy-contract-address {
            font-size: 0.82rem;
            padding: 2vw 2vw;
            border-radius: 2vw;
            flex-wrap: wrap;
            word-break: break-all;
            gap: 4px;
          }
          .howtobuy-uniswap-btn {
            font-size: 1.05rem;
            padding: 3vw 6vw;
            border-radius: 2vw;
          }
          .howtobuy-deximg-row {
            flex-direction: column;
            gap: 4vw;
            align-items: center;
          }
          .howtobuy-deximg-link {
            width: 80vw;
            height: 80px;
          }
          /* Make SVG icons red and text black in mobile */
          .howtobuy-card svg {
            stroke: #064e3b !important;
            fill: none !important;
          }
          .howtobuy-card svg path,
          .howtobuy-card svg circle,
          .howtobuy-card svg polygon,
          .howtobuy-card svg polyline,
          .howtobuy-card svg ellipse {
            stroke: #064e3b !important;
            fill: none !important;
          }
          .howtobuy-card-title {
            color: #000 !important;
            font-weight: 700 !important;
          }
          .howtobuy-card-desc {
            color: #000 !important;
          }
          .howtobuy-card svg {
            margin: 0 auto 0.5vw auto !important;
            display: block !important;
          }
          .howtobuy-card-title {
            text-align: center !important;
            width: 100% !important;
          }
          .howtobuy-card-desc {
            text-align: center !important;
            width: 100% !important;
            font-style: italic !important;
            font-weight: 700 !important;
          }
        }
        @media (min-width: 1600px) {
          .howtobuy-grid {
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
          }
        }
        @media (min-width: 1200px) and (max-width: 1599px) {
          .howtobuy-grid {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
          }
          .howtobuy-title {
            font-size: 2.2rem;
          }
          .howtobuy-desc {
            font-size: 1.1rem;
          }
        }
      `,
      }),
      O.jsxs(Be.div, {
        className: "howtobuy-title",
        initial: { opacity: 0, y: 32 },
        whileInView: { opacity: 1, y: 0 },
        viewport: { once: !0, amount: 0.7 },
        transition: { duration: 0.7, ease: "easeOut" },
        style: {
          color: "#fff",
          fontWeight: 800,
          fontSize: "2.3rem",
          textAlign: "center",
          marginTop: "2vw",
          marginBottom: "0.5vw",
          letterSpacing: "0.01em",
        },
        children: [
          "How to Buy ",
          O.jsx("span", { style: { color: "#18191c" }, children: "$PAUL" }),
        ],
      }),
      O.jsx(Be.div, {
        className: "howtobuy-desc",
        initial: { opacity: 0, y: 32, filter: "blur(8px)" },
        whileInView: { opacity: 1, y: 0, filter: "blur(0px)" },
        viewport: { once: !0, amount: 0.7 },
        transition: { duration: 0.9, ease: "easeOut" },
        style: {
          color: "#fff",
          fontSize: "1.15rem",
          textAlign: "center",
          marginBottom: "2vw",
          fontWeight: 500,
          lineHeight: 1.5,
          maxWidth: 700,
          marginLeft: "auto",
          marginRight: "auto",
        },
        children:
          "Joining the PAUL community is easy. Follow these simple steps to get your paws on the original Shiba meme token!",
      }),
      O.jsx("div", {
        className: "howtobuy-grid",
        children: kV.map((n, a) =>
          O.jsxs(
            Be.div,
            {
              className: "howtobuy-card",
              initial: { opacity: 0, y: 40 },
              whileInView: { opacity: 1, y: 0 },
              viewport: { once: !0, amount: 0.4 },
              transition: { duration: 0.7, delay: a * 0.12, ease: "easeOut" },
              children: [
                O.jsx(Be.div, {
                  animate: { y: [0, -8, 8, 0], rotate: [0, 7, -7, 0] },
                  transition: {
                    duration: 1.2,
                    repeat: 1 / 0,
                    repeatType: "loop",
                    ease: "easeInOut",
                    delay: a * 0.15,
                  },
                  style: { display: "inline-flex" },
                  children: n.icon,
                }),
                O.jsxs("div", {
                  className: "howtobuy-card-content",
                  children: [
                    O.jsx(Be.div, {
                      className: "howtobuy-card-title",
                      initial: { opacity: 0, y: 24 },
                      whileInView: { opacity: 1, y: 0 },
                      viewport: { once: !0, amount: 0.7 },
                      transition: {
                        duration: 0.6,
                        delay: 0.2 + a * 0.08,
                        ease: "easeOut",
                      },
                      children: n.title,
                    }),
                    O.jsx(Be.div, {
                      className: "howtobuy-card-desc",
                      initial: { opacity: 0, filter: "blur(8px)" },
                      whileInView: { opacity: 1, filter: "blur(0px)" },
                      viewport: { once: !0, amount: 0.7 },
                      transition: {
                        duration: 0.7,
                        delay: 0.32 + a * 0.08,
                        ease: "easeOut",
                      },
                      children: n.desc,
                    }),
                  ],
                }),
              ],
            },
            a
          )
        ),
      }),
      O.jsxs(Be.div, {
        className: "howtobuy-contract",
        initial: { opacity: 0, y: 40 },
        whileInView: { opacity: 1, y: 0 },
        viewport: { once: !0, amount: 0.4 },
        transition: { duration: 0.7, ease: "easeOut" },
        children: [
          O.jsx("div", {
            className: "howtobuy-contract-label",
            children: "Official Contract Address:",
          }),
          O.jsxs("div", {
            className: "howtobuy-contract-address",
            style: {
              background: "#3a1818",
              fontSize: "1.1rem",
              fontFamily: "monospace",
              borderRadius: "0.5vw",
              padding: "0.7vw 2vw",
              marginBottom: "0.7vw",
              width: "100%",
              textAlign: "center",
              letterSpacing: "0.5px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              backgroundClip: "padding-box",
            },
            children: [
              O.jsx("span", {
                style: {
                  background: "linear-gradient(90deg, #fff 0%, #064e3b 100%)",
                  WebkitBackgroundClip: "text",
                  WebkitTextFillColor: "transparent",
                  backgroundClip: "text",
                  color: "transparent",
                  fontWeight: 700,
                  fontFamily: "monospace",
                  fontSize: "1.1rem",
                  letterSpacing: "0.5px",
                  userSelect: "all",
                },
                children: Ob,
              }),
              O.jsxs("span", {
                style: {
                  position: "relative",
                  display: "inline-flex",
                  alignItems: "center",
                },
                children: [
                  O.jsx("button", {
                    onClick: e,
                    "aria-label": "Copy contract address",
                    style: {
                      background: "none",
                      border: "none",
                      padding: 0,
                      marginLeft: 8,
                      cursor: "pointer",
                      display: "inline-flex",
                      alignItems: "center",
                    },
                    children: O.jsxs("svg", {
                      width: "22",
                      height: "22",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "#064e3b",
                      strokeWidth: "2",
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      style: { opacity: 0.8 },
                      children: [
                        O.jsx("rect", {
                          x: "9",
                          y: "9",
                          width: "13",
                          height: "13",
                          rx: "2",
                        }),
                        O.jsx("rect", {
                          x: "2",
                          y: "2",
                          width: "13",
                          height: "13",
                          rx: "2",
                        }),
                      ],
                    }),
                  }),
                  i &&
                    O.jsx("span", {
                      style: {
                        position: "absolute",
                        top: "-1.8em",
                        left: "50%",
                        transform: "translateX(-50%)",
                        background: "#18191c",
                        color: "#ffb84c",
                        fontSize: "0.85em",
                        padding: "2px 8px",
                        borderRadius: 6,
                        boxShadow: "0 2px 8px #0006",
                        whiteSpace: "nowrap",
                        zIndex: 10,
                      },
                      children: "Copied!",
                    }),
                ],
              }),
            ],
          }),
          // O.jsxs("a", {
          //   className: "howtobuy-contract-link",
          //   href: `https://etherscan.io/address/${Ob}`,
          //   target: "_blank",
          //   rel: "noopener noreferrer",
          //   children: [
          //     "View on Etherscan",
          //     O.jsx("span", {
          //       style: {
          //         display: "inline-flex",
          //         alignItems: "center",
          //         marginLeft: 8,
          //         verticalAlign: "middle",
          //       },
          //       children: O.jsxs("svg", {
          //         xmlns: "http://www.w3.org/2000/svg",
          //         width: "20",
          //         height: "20",
          //         viewBox: "0 0 24 24",
          //         fill: "none",
          //         stroke: "#064e3b",
          //         strokeWidth: "2",
          //         strokeLinecap: "round",
          //         strokeLinejoin: "round",
          //         style: { display: "block" },
          //         children: [
          //           O.jsx("path", {
          //             d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
          //           }),
          //           O.jsx("polyline", { points: "15 3 21 3 21 9" }),
          //           O.jsx("line", { x1: "10", x2: "21", y1: "14", y2: "3" }),
          //         ],
          //       }),
          //     }),
          //   ],
          // }),
          O.jsx("div", {
            style: {
              color: "#b0b6c3",
              fontSize: "0.98rem",
              marginTop: 8,
              textAlign: "center",
            },
            children:
              "Always verify the contract address matches this one before interacting!",
          }),
        ],
      }),
      O.jsxs("a", {
        className: "howtobuy-uniswap-btn",
        href: "https://app.uniswap.org/#/swap?outputCurrency=0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
        target: "_blank",
        rel: "noopener noreferrer",
        children: [
          "Buy on Uniswap",
          O.jsxs("svg", {
            width: "22",
            height: "22",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "#064e3b",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              O.jsx("polyline", { points: "15 3 21 3 21 9" }),
              O.jsx("line", { x1: "10", x2: "21", y1: "14", y2: "3" }),
              O.jsx("path", {
                d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
              }),
            ],
          }),
        ],
      }),
      O.jsxs("div", {
        className: "howtobuy-deximg-row",
        children: [
          O.jsx(Be.a, {
            href: "https://dexscreener.com/ethereum/0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
            target: "_blank",
            rel: "noopener noreferrer",
            className: "howtobuy-deximg-link screener",
            initial: { opacity: 0, scale: 0.8 },
            whileInView: { opacity: 1, scale: 1 },
            transition: { duration: 0.6, ease: "easeOut" },
            viewport: { once: !0, amount: 0.5 },
            children: O.jsx("img", {
              src: "/i.postimg.cc/SKxWrMyG/download-2.png",
              alt: "DexScreener",
              className: "howtobuy-deximg",
              loading: "lazy",
            }),
          }),
        ],
      }),
      O.jsx("div", {
        className: "howtobuy-disclaimer-gradient",
        children:
          "Remember, $PAUL is a meme token. Invest responsibly and only what you can afford to lose.",
      }),
    ],
  });
}
const XV = [
  {
    name: "Carlo Moretti",
    subtitle: "CTO Lead",
    img: "/i.postimg.cc/25j7dDy8/j-Oi-z-QR9-400x400.png",
    twitter: "https://x.com/CarloMorettiX",
  },
  {
    name: "Ronak Kacha",
    subtitle: "Co-CTO Lead",
    img: "/i.postimg.cc/YSkMbXBS/image-removebg-preview-1.png",
    twitter: "https://x.com/kacharonak",
  },
  {
    name: "Alex",
    subtitle: "Python & AI Expert",
    img: "/i.postimg.cc/XvHNqwt7/alex-removebg-preview.png",
    twitter: "https://x.com/ChatOfThought",
  },
  {
    name: "Abed Ali",
    subtitle: "Developer & CEO",
    subtitle2: "(Asian Net Labs)",
    img: "/i.postimg.cc/Sx8kqBfd/image-removebg-preview-2.png",
    twitter: "https://twitter.com/asiannetlabs",
  },
];
function WV({ twitter: i }) {
  return O.jsx("div", {
    className: "ctoteam-socials",
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "0.5em",
      margin: "0 auto",
    },
    children: O.jsxs("a", {
      href: i,
      target: "_blank",
      rel: "noopener noreferrer",
      "aria-label": "Twitter",
      className: "twitter-link",
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "0.3em",
        textDecoration: "none",
        color: "#064e3b",
        fontSize: "0.9rem",
        fontWeight: 600,
        lineHeight: 1,
        cursor: "pointer",
        zIndex: 10,
        position: "relative",
      },
      onClick: (t) => {
        t.preventDefault(), window.open(i, "_blank", "noopener,noreferrer");
      },
      children: [
        O.jsx(Be.svg, {
          width: "20",
          height: "20",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "#064e3b",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          style: { opacity: 0.9, flexShrink: 0 },
          animate: { scale: [1, 1.1, 1] },
          transition: {
            duration: 1.5,
            repeat: 1 / 0,
            repeatType: "loop",
            ease: "easeInOut",
          },
          children: O.jsx("path", {
            d: "M23 3a10.9 10.9 0 0 1-3.14 1.53A4.48 4.48 0 0 0 22.4 1.64a9.09 9.09 0 0 1-2.88 1.1A4.48 4.48 0 0 0 16.5 0c-2.5 0-4.5 2.01-4.5 4.5 0 .35.04.7.1 1.03C7.69 5.4 4.07 3.67 1.64 1.15c-.38.65-.6 1.4-.6 2.2 0 1.52.77 2.86 1.95 3.65A4.48 4.48 0 0 1 .96 6v.06c0 2.13 1.52 3.91 3.54 4.31-.37.1-.76.16-1.16.16-.28 0-.55-.03-.81-.08.55 1.72 2.16 2.97 4.07 3A9.05 9.05 0 0 1 0 19.54 12.8 12.8 0 0 0 6.92 21c8.28 0 12.81-6.86 12.81-12.81 0-.2 0-.39-.01-.58A9.22 9.22 0 0 0 23 3z",
          }),
        }),
        O.jsx("span", {
          className: "follow-text",
          style: { lineHeight: 1, display: "inline-block" },
          children: "Follow",
        }),
      ],
    }),
  });
}
function YV() {
  return O.jsxs("section", {
    id: "team",
    style: {
      width: "100%",
      background: "none",
      margin: "0 auto",
      padding: "0 0 4vw 0",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
    },
    children: [
      O.jsx("style", {
        children: `
        .ctoteam-title {
          color: #fff;
          font-size: 2.3rem;
          font-weight: 800;
          text-align: center;
          margin-top: 2vw;
          margin-bottom: 2vw;
        }
        .ctoteam-title span {
          color: #18191c;
        }
        .ctoteam-grid {
          display: grid;
          grid-template-columns: repeat(4, 1fr);
          gap: 2vw;
          width: 100%;
          max-width: 1200px;
          margin-bottom: 2vw;
        }
        .ctoteam-card {
          background: #18191c;
          border-radius: 2vw;
          box-shadow: 0 2px 14px #0002;
          padding: 2vw 1vw 1.5vw 1vw;
          display: flex;
          flex-direction: column;
          align-items: center;
          min-width: 0;
          width: 220px;
          height: 290px;
          max-width: 220px;
          max-height: 290px;
          box-sizing: border-box;
        }
        .ctoteam-img {
          width: 110px;
          height: 110px;
          border-radius: 1.2vw;
          object-fit: cover;
          margin-bottom: 1vw;
        }
        .ctoteam-name {
          color: #fff;
          font-size: 1.15rem;
          font-weight: 700;
          margin-bottom: 0.2vw;
          text-align: center;
        }
        .ctoteam-subtitle {
          color: #064e3b;
          font-size: 1.02rem;
          font-weight: 600;
          margin-bottom: 0.5vw;
          text-align: center;
        }
        .ctoteam-socials {
          display: flex;
          gap: 1.2vw;
          align-items: center;
          justify-content: center;
        }
        .ctoteam-socials a {
          color: #064e3b;
          font-size: 1.7rem;
          transition: color 0.2s;
        }
        .ctoteam-socials a:hover {
          color: #fff;
        }
        .ctoteam-desc {
          color: #fff;
          font-size: 1.15rem;
          text-align: center;
          margin-bottom: 2vw;
          font-weight: 500;
          line-height: 1.5;
          max-width: 700px;
          margin-left: auto;
          margin-right: auto;
        }
        @media (max-width: 900px) {
          .ctoteam-title {
            font-size: 1.3rem;
            margin-top: 5vw;
            margin-bottom: 4vw;
          }
          .ctoteam-grid {
            grid-template-columns: 1fr 1fr;
            gap: 4vw;
            max-width: 98vw;
          }
          .ctoteam-card {
            padding: 5vw 2vw 3vw 2vw;
            border-radius: 4vw;
            width: 100%;
            max-width: 98vw;
            min-width: 0;
            height: auto;
            max-height: none;
            box-sizing: border-box;
            background: linear-gradient(120deg, #e5e7eb 0%, #ffb3b3 60%, #2cb979 100%) !important;
            border: 2px solid #000 !important;
            box-shadow: 0 4px 32px #2cb97922 !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            text-align: center !important;
            gap: 1vw !important;
          }
          .ctoteam-img {
            width: 80px;
            height: 80px;
            border-radius: 3vw;
            margin-bottom: 2vw;
          }
          .ctoteam-name {
            font-size: 1rem;
            margin-bottom: 2vw;
          }
          .ctoteam-socials a {
            font-size: 1.3rem;
          }
          .ctoteam-desc {
            font-size: 0.98rem;
            margin-bottom: 4vw;
            line-height: 1.5;
            max-width: 98vw;
            padding: 0 2vw;
            font-size: 0.85rem;
          }
          .ctoteam-follow-text-solid {
            font-size: 0.85rem !important;
          }
          /* Make CTO titles black and italic in mobile */
          .ctoteam-subtitle {
            color: #000 !important;
            font-style: italic !important;
            margin-bottom: 2vw !important;
          }
          .ctoteam-name {
            margin-bottom: 0.5vw !important;
            font-weight: 700 !important;
          }
          .ctoteam-socials {
            margin-top: auto !important;
            padding-top: 2vw !important;
          }
                  .ctoteam-subtitle2 {
          color: #000 !important;
          font-style: italic !important;
          font-size: 0.8rem !important;
          margin-top: 0.5vw !important;
          text-align: center !important;
        }
      }
      /* Twitter link hover effects - works on all screen sizes */
      .twitter-link:hover .follow-text {
        color: #fff !important;
        transition: color 0.3s ease;
      }
      .twitter-link:active .follow-text {
        color: #fff !important;
      }
      @media (min-width: 1600px) {
          .ctoteam-main, .ctoteam-section {
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
          }
        }
        @media (min-width: 1200px) and (max-width: 1599px) {
          .ctoteam-main, .ctoteam-section {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
          }
          .ctoteam-grid {
            max-width: 1100px;
            gap: 1.5vw;
          }
          .ctoteam-title {
            font-size: 2.2rem;
          }
        }
        
        /* Tablet and iPad responsive styles */
        @media (min-width: 901px) and (max-width: 1024px) {
          .ctoteam-title {
            font-size: 2rem;
            margin-top: 1.5vw;
            margin-bottom: 1.5vw;
          }
          .ctoteam-desc {
            font-size: 1.05rem;
            margin-bottom: 1.5vw;
            max-width: 600px;
          }
          .ctoteam-grid {
            grid-template-columns: repeat(2, 1fr);
            gap: 2.5vw;
            max-width: 800px;
          }
          .ctoteam-card {
            width: 200px;
            height: 260px;
            max-width: 200px;
            max-height: 260px;
            padding: 1.5vw 0.8vw 1vw 0.8vw;
          }
          .ctoteam-img {
            width: 100px;
            height: 100px;
            border-radius: 1vw;
            margin-bottom: 0.8vw;
          }
          .ctoteam-name {
            font-size: 1.1rem;
            margin-bottom: 0.2vw;
          }
          .ctoteam-subtitle {
            font-size: 0.95rem;
            margin-bottom: 0.4vw;
          }
        }
        
        /* Large tablet and small laptop styles */
        @media (min-width: 1025px) and (max-width: 1200px) {
          .ctoteam-title {
            font-size: 2.1rem;
            margin-top: 1.2vw;
            margin-bottom: 1.2vw;
          }
          .ctoteam-desc {
            font-size: 1.1rem;
            margin-bottom: 1.2vw;
            max-width: 650px;
          }
          .ctoteam-grid {
            grid-template-columns: repeat(3, 1fr);
            gap: 2vw;
            max-width: 900px;
          }
          .ctoteam-card {
            width: 220px;
            height: 280px;
            max-width: 220px;
            max-height: 280px;
            padding: 1.8vw 1vw 1.2vw 1vw;
          }
          .ctoteam-img {
            width: 110px;
            height: 110px;
            border-radius: 1.2vw;
            margin-bottom: 1vw;
          }
          .ctoteam-name {
            font-size: 1.15rem;
            margin-bottom: 0.2vw;
          }
          .ctoteam-subtitle {
            font-size: 1rem;
            margin-bottom: 0.5vw;
          }
        }
      `,
      }),

      O.jsxs("div", {
        className: "ctoteam-follow-text-solid",
        style: {
          color: "#fff",
          fontWeight: 700,
          fontStyle: "italic",
          fontSize: "1.12rem",
          textAlign: "center",
          margin: "2vw auto 0 auto",
          maxWidth: 700,
          lineHeight: 1.5,
          letterSpacing: "0.01em",
          padding: "0 2vw",
        },
        children: [
          "Follow our Lead Team on X (Twitter) and connect on Telegram to discuss all things about Paul!",
          O.jsx("br", {}),
          "Interested in collaborating or partnering with the Dev Team? Reach out and join the movement!",
        ],
      }),
    ],
  });
}
function qV() {
  return O.jsxs("section", {
    id: "community",
    style: {
      width: "100%",
      background: "none",
      margin: "0 auto",
      padding: "0 0 0 0",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      scrollMarginTop: 90,
      scrollMarginBlockStart: 90,
    },
    children: [
      O.jsx("style", {
        children: `
        .community-icon {
          display: flex;
          justify-content: center;
          align-items: center;
          margin-top: 3vw;
          margin-bottom: 1vw;
        }
        .community-title {
          color: #fff;
          font-size: 2.3rem;
          font-weight: 800;
          text-align: center;
          margin-bottom: 0.5vw;
        }
        .community-title span {
          color: #18191c;
        }
        .community-sub {
          color: #b0b6c3;
          font-size: 1.15rem;
          text-align: center;
          margin-bottom: 2vw;
          max-width: 700px;
          margin-left: auto;
          margin-right: auto;
        }
        .community-connect-card {
          background: linear-gradient(90deg, #23221e 60%, #232b2b 100%);
          border: 3px solid #064e3b;
          border-radius: 18px;
          box-shadow: 0 4px 32px #064e3b22;
          padding: 2vw 2vw 2vw 2vw;
          margin: 0 auto 2vw auto;
          width: 100%;
          max-width: 900px;
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 2vw;
          position: relative;
        }
        .community-connect-content {
          flex: 1;
        }
        .community-connect-title {
          color: #fff;
          font-size: 1.5rem;
          font-weight: 700;
          margin-bottom: 0.5vw;
        }
        .community-connect-desc {
          color: #b0b6c3;
          font-size: 1.05rem;
          margin-bottom: 1.2vw;
        }
        .community-connect-btns {
          display: flex;
          gap: 1vw;
        }
        .community-btn-x {
          background: #064e3b;
          color: #fff;
          font-weight: 700;
          border: none;
          border-radius: 8px;
          padding: 0.7em 1.6em;
          font-size: 1.08rem;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 0.5em;
        }
        .community-btn-x svg {
          margin-right: 0.3em;
          stroke: #fff;
        }
        .community-btn-tg {
          background: #fff;
          color: #064e3b;
          font-weight: 700;
          border: none;
          border-radius: 8px;
          padding: 0.7em 1.6em;
          font-size: 1.08rem;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 0.5em;
        }
        .community-btn-tg svg {
          margin-right: 0.3em;
          stroke: #064e3b;
        }
        .community-dog-img {
          width: 120px;
          height: 120px;
          border-radius: 50%;
          object-fit: cover;
          background: #fff;
          box-shadow: 0 0 24px #064e3b55;
          margin-left: 2vw;
        }
        .community-links-row {
          display: flex;
          gap: 1.5vw;
          justify-content: center;
          margin: 2vw 0 2vw 0;
        }
        .community-link-btn {
          background: #fff;
          color: #18191c;
          border: 2px solid #064e3b;
          border-radius: 12px;
          padding: 0.7em 2em;
          font-size: 1.08rem;
          font-weight: 600;
          display: flex;
          align-items: center;
          gap: 0.7em;
          cursor: pointer;
          transition: background 0.2s, color 0.2s, border 0.2s, transform 0.18s cubic-bezier(.4,0,.2,1);
        }
        .community-link-btn svg {
          margin-right: 0.3em;
          stroke: #18191c;
        }
        .community-link-btn:hover {
          transform: scale(1.06);
        }
        .community-footer {
          width: 100%;
          background: none;
          margin-top: 4vw;
          padding: 3vw 0 0 0;
          border-top: 1px solid #222;
          display: flex;
          flex-direction: row;
          justify-content: space-between;
          align-items: flex-start;
          gap: 4vw;
          color: #b0b6c3;
        }
        .community-footer-col {
          flex: 1;
          min-width: 180px;
          max-width: 300px;
          display: flex;
          flex-direction: column;
          gap: 1vw;
        }
        .community-footer-logo-section {
          flex: 1;
          min-width: 180px;
          max-width: 300px;
          display: flex;
          flex-direction: column;
          gap: 1vw;
        }
        .community-footer-links-container {
          display: flex;
          flex-direction: row;
          justify-content: space-between;
          gap: 4vw;
          flex: 2;
        }
        .community-footer-logo {
          display: flex;
          align-items: center;
          gap: 0.7em;
          font-size: 1.25rem;
          font-weight: 800;
          color: #18191c;
        }
        .community-footer-socials {
          display: flex;
          gap: 1vw;
          margin-top: 0.7vw;
        }
        .community-footer-socials a {
          color: #18191c;
          font-size: 1.3rem;
          transition: color 0.2s;
        }
        .community-footer-socials a:hover {
          color: #18191c;
        }
        .community-footer-links {
          display: flex;
          flex-direction: column;
          gap: 0.5vw;
        }
        .community-footer-links a {
          color: #fff;
          text-decoration: none;
          font-size: 1rem;
          transition: color 0.2s;
        }
        .community-footer-links a:hover {
          color: #18191c;
        }
        .community-footer-title {
          color: #fff;
          font-weight: 700;
          font-size: 1.1rem;
          margin-bottom: 0.5vw;
        }
        .community-btn-x, .community-btn-tg {
          text-decoration: none !important;
        }
        .community-link-btn, .community-link-btn * {
          text-decoration: none !important;
        }
        @media (max-width: 900px) {
          .community-title {
            font-size: 1.15rem;
            margin-top: 5vw;
            margin-bottom: 2vw;
          }
          .community-sub {
            font-size: 0.98rem;
            margin-bottom: 4vw;
            padding: 0 2vw;
          }
          .community-connect-card {
            flex-direction: column;
            align-items: center;
            padding: 6vw 2vw 4vw 2vw;
            gap: 2vw;
            max-width: 90vw;
            min-width: 0;
            width: 100%;
            box-sizing: border-box;
            box-shadow: none !important;
          }
          .community-connect-title {
            font-size: 1.18rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 2vw;
            line-height: 1.2;
          }
          .community-connect-desc {
            font-size: 0.95rem;
            margin-bottom: 4vw;
            text-align: center;
            max-width: 90vw;
            word-break: break-word;
            line-height: 1.5;
          }
          .community-connect-btns {
            flex-direction: column;
            gap: 2vw;
            width: 100%;
            align-items: center;
            justify-content: center;
          }
          .community-btn-x, .community-btn-tg {
            font-size: 1.02rem;
            padding: 0.9em 0;
            min-width: 0;
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            display: flex;
            justify-content: center;
          }
          .community-dog-img {
            width: 90px;
            height: 90px;
            margin-left: 0;
            margin-top: 5vw;
            align-self: center;
            display: block;
          }
          .community-links-row {
            flex-direction: column;
            gap: 2vw;
            margin: 4vw 0 4vw 0;
          }
          .community-footer {
            flex-direction: column;
            align-items: center;
            gap: 3vw;
          }
          .community-footer-col:first-child {
            order: 1;
            text-align: center;
            max-width: 100%;
          }
          .community-footer-col:nth-child(2) {
            order: 2;
            max-width: 45%;
            min-width: auto;
          }
          .community-footer-col:nth-child(3) {
            order: 3;
            max-width: 45%;
            min-width: auto;
          }
          .community-footer-col:nth-child(2),
          .community-footer-col:nth-child(3) {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 2vw;
          }
          .community-footer-col:nth-child(2) .community-footer-title,
          .community-footer-col:nth-child(3) .community-footer-title {
            text-align: left;
          }
          .community-footer-col:nth-child(2) .community-footer-links,
          .community-footer-col:nth-child(3) .community-footer-links {
            text-align: left;
          }
          .community-footer-col {
            min-width: 0;
            max-width: 98vw;
            gap: 2vw;
            align-items: flex-start;
            margin-bottom: 3vw;
            width: 100%;
            display: block;
          }
          .community-footer-col:nth-child(2),
          .community-footer-col:nth-child(3) {
            display: inline-block;
            width: 50%;
            vertical-align: top;
          }
          .community-footer-logo {
            font-size: 1.15rem;
            margin-bottom: 1vw;
            align-items: center;
            justify-content: flex-start;
            display: flex;
          }
          .community-footer-col > div[style*='fontStyle: italic'] {
            font-size: 0.85rem !important;
            padding: 0;
            text-align: left;
            margin: 1vw 0 0 0 !important;
            word-break: break-word;
            color: #18191c;
          }
          .community-footer-socials {
            margin-top: 1vw;
            gap: 2vw;
            justify-content: flex-start;
            align-items: center;
            display: flex;
          }
          .community-footer-title {
            font-size: 1.05rem;
            margin: 2vw 0 1vw 0;
            text-align: left;
          }
          .community-footer-links {
            gap: 1vw;
            align-items: flex-start;
            text-align: left;
          }
          .community-footer-links a {
            font-size: 0.98rem;
            text-align: left;
            padding: 0;
            margin: 0;
          }
          .community-footer-row {
            display: flex;
            flex-direction: row;
            width: 100%;
          }
          .community-footer-row .community-footer-col {
            width: 50%;
            display: block;
          }
          .community-footer-logo-section {
            order: 1;
            text-align: center;
            max-width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
          }
          .community-footer-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.7em;
            font-size: 1.25rem;
            font-weight: 800;
            color: #18191c;
            text-align: center;
          }
          .community-footer-socials {
            display: flex;
            gap: 1vw;
            margin-top: 0.7vw;
            justify-content: center;
            align-items: center;
          }
          .community-footer-links-container {
            order: 2;
            flex-direction: row;
            justify-content: space-between;
            gap: 4vw;
            width: 100%;
            max-width: 100%;
            padding-left: 4vw;
            padding-right: 4vw;
          }
          .community-footer-links-container .community-footer-col {
            flex: 1;
            max-width: 45%;
            min-width: auto;
          }
        }
        @media (min-width: 1600px) {
          .community-main, .community-connect-card, .community-section {
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
          }
        }
        @media (min-width: 1200px) and (max-width: 1599px) {
          .community-main, .community-connect-card, .community-section {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
          }
          .community-content {
            max-width: 1100px;
          }
          .community-title {
            font-size: 2.2rem;
          }
          .community-sub {
            font-size: 1.1rem;
          }
        }
        @media (min-width: 901px) {
          .community-footer {
            justify-content: space-between;
            gap: 2vw;
            padding-left: 2vw;
            padding-right: 2vw;
          }
          .community-footer-logo-section {
            flex: 0 0 auto;
            max-width: 250px;
            margin-left: 2vw;
          }
          .community-footer-links-container {
            flex: 1;
            justify-content: space-around;
            gap: 0;
            margin-right: 2vw;
          }
          .community-footer-links-container .community-footer-col {
            flex: 0 0 auto;
            max-width: 200px;
          }
        }
        
        /* Tablet and iPad responsive styles */
        @media (min-width: 901px) and (max-width: 1024px) {
          .community-title {
            font-size: 2rem;
            margin-bottom: 0.4vw;
          }
          .community-sub {
            font-size: 1.05rem;
            margin-bottom: 1.5vw;
            max-width: 600px;
          }
          .community-connect-card {
            max-width: 800px;
            padding: 2.5vw 2vw;
            gap: 1.5vw;
          }
          .community-connect-title {
            font-size: 1.3rem;
            margin-bottom: 1vw;
          }
          .community-connect-desc {
            font-size: 1rem;
            margin-bottom: 2vw;
          }
          .community-dog-img {
            width: 100px;
            height: 100px;
          }
          .community-links-row {
            gap: 1.2vw;
            margin: 2vw 0;
          }
          .community-link-btn {
            font-size: 1rem;
            padding: 0.6em 1.5em;
          }
        }
        
        /* Large tablet and small laptop styles */
        @media (min-width: 1025px) and (max-width: 1200px) {
          .community-title {
            font-size: 2.1rem;
            margin-bottom: 0.3vw;
          }
          .community-sub {
            font-size: 1.1rem;
            margin-bottom: 1.2vw;
            max-width: 650px;
          }
          .community-connect-card {
            max-width: 850px;
            padding: 2.2vw 1.8vw;
            gap: 1.2vw;
          }
          .community-connect-title {
            font-size: 1.4rem;
            margin-bottom: 0.8vw;
          }
          .community-connect-desc {
            font-size: 1.05rem;
            margin-bottom: 1.5vw;
          }
          .community-dog-img {
            width: 110px;
            height: 110px;
          }
          .community-links-row {
            gap: 1vw;
            margin: 1.8vw 0;
          }
          .community-link-btn {
            font-size: 1.05rem;
            padding: 0.65em 1.6em;
          }
        }
      `,
      }),
      O.jsx("div", {
        className: "community-icon",
        children: O.jsxs("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          width: "48",
          height: "48",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "url(#blackWhiteGradient)",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          style: { opacity: 0.8 },
          children: [
            O.jsx("defs", {
              children: O.jsxs("linearGradient", {
                id: "blackWhiteGradient",
                x1: "0",
                y1: "0",
                x2: "48",
                y2: "0",
                gradientUnits: "userSpaceOnUse",
                children: [
                  O.jsx("stop", { stopColor: "#18191c" }),
                  O.jsx("stop", { offset: "1", stopColor: "#fff" }),
                ],
              }),
            }),
            O.jsx("path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }),
            O.jsx("circle", { cx: "9", cy: "7", r: "4" }),
            O.jsx("path", { d: "M22 21v-2a4 4 0 0 0-3-3.87" }),
            O.jsx("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }),
          ],
        }),
      }),
      O.jsxs(Be.div, {
        className: "community-title",
        initial: { opacity: 0, y: 32 },
        whileInView: { opacity: 1, y: 0 },
        viewport: { once: !0, amount: 0.7 },
        transition: { duration: 0.7, ease: "easeOut" },
        children: ["Join Our ", O.jsx("span", { children: "Community" })],
      }),
      O.jsx(Be.div, {
        className: "community-sub",
        initial: { opacity: 0, y: 32, filter: "blur(8px)" },
        whileInView: { opacity: 1, y: 0, filter: "blur(0px)" },
        viewport: { once: !0, amount: 0.7 },
        transition: { duration: 0.9, ease: "easeOut" },
        style: { color: "#fff" },
        children:
          "Be part of the growing PAUL family. Connect with fellow OG meme enthusiasts and help shape the future of this historic token. We're all about those digital campfire vibes.",
      }),
      O.jsxs(Be.div, {
        className: "community-connect-card",
        initial: { opacity: 0, y: 40 },
        whileInView: { opacity: 1, y: 0 },
        viewport: { once: !0, amount: 0.5 },
        transition: { duration: 0.7, ease: "easeOut" },
        children: [
          O.jsxs("div", {
            className: "community-connect-content",
            children: [
              O.jsx("div", {
                className: "community-connect-title",
                children: "Connect with $PAUL",
              }),
              O.jsx("div", {
                className: "community-connect-desc",
                children:
                  "Follow our official channels for the latest updates, announcements, and community vibes. No shills, just Shiba chills.",
              }),
              O.jsxs("div", {
                className: "community-connect-btns",
                children: [
                  O.jsxs(Be.a, {
                    className: "community-btn-x",
                    href: "https://x.com/paulinu_plasma",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    initial: { opacity: 0 },
                    whileInView: { opacity: 1 },
                    viewport: { once: !0, amount: 0.5 },
                    transition: { duration: 0.5, delay: 0.15, ease: "easeOut" },
                    style: { textDecoration: "none" },
                    children: [
                      O.jsx("svg", {
                        width: "22",
                        height: "22",
                        viewBox: "0 0 24 24",
                        fill: "none",
                        stroke: "#18191c",
                        strokeWidth: "2",
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        style: { opacity: 0.9 },
                        children: O.jsx("path", {
                          d: "M23 3a10.9 10.9 0 0 1-3.14 1.53A4.48 4.48 0 0 0 22.4 1.64a9.09 9.09 0 0 1-2.88 1.1A4.48 4.48 0 0 0 16.5 0c-2.5 0-4.5 2.01-4.5 4.5 0 .35.04.7.1 1.03C7.69 5.4 4.07 3.67 1.64 1.15c-.38.65-.6 1.4-.6 2.2 0 1.52.77 2.86 1.95 3.65A4.48 4.48 0 0 1 .96 6v.06c0 2.13 1.52 3.91 3.54 4.31-.37.1-.76.16-1.16.16-.28 0-.55-.03-.81-.08.55 1.72 2.16 2.97 4.07 3A9.05 9.05 0 0 1 0 19.54 12.8 12.8 0 0 0 6.92 21c8.28 0 12.81-6.86 12.81-12.81 0-.2 0-.39-.01-.58A9.22 9.22 0 0 0 23 3z",
                        }),
                      }),
                      "Follow on X",
                    ],
                  }),
                  O.jsxs(Be.a, {
                    className: "community-btn-tg",
                    href: "https://t.me/paulinu_plasma",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    initial: { opacity: 0 },
                    whileInView: { opacity: 1 },
                    viewport: { once: !0, amount: 0.5 },
                    transition: { duration: 0.5, delay: 0.35, ease: "easeOut" },
                    style: { textDecoration: "none" },
                    children: [
                      O.jsxs("svg", {
                        width: "22",
                        height: "22",
                        viewBox: "0 0 24 24",
                        fill: "none",
                        stroke: "#fff",
                        strokeWidth: "2",
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        style: { opacity: 0.9 },
                        children: [
                          O.jsx("path", { d: "M22 2L11 13" }),
                          O.jsx("path", { d: "M22 2L15 22L11 13L2 9L22 2Z" }),
                        ],
                      }),
                      "Join Telegram",
                    ],
                  }),
                ],
              }),
            ],
          }),
          O.jsx(Be.img, {
            className: "community-dog-img",
            src: "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/bd16ebd32caee97543484bec8e7922a8.png",
            alt: "Shiba dog",
            loading: "lazy",
            animate: { scale: [1, 1.08, 1], y: [0, -10, 0] },
            transition: {
              duration: 2.2,
              repeat: 1 / 0,
              repeatType: "loop",
              ease: "easeInOut",
            },
          }),
        ],
      }),
      O.jsxs("div", {
        className: "community-links-row",
        children: [
          O.jsxs(Be.a, {
            className: "community-link-btn",
            href: "https://x.com/paulinu_plasma",
            target: "_blank",
            rel: "noopener noreferrer",
            initial: { opacity: 0 },
            whileInView: { opacity: 1 },
            viewport: { once: !0, amount: 0.5 },
            transition: { duration: 0.5, delay: 0.32, ease: "easeOut" },
            children: [
              O.jsxs("svg", {
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "url(#whiteRedBtnGradient)",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                style: { opacity: 0.9 },
                children: [
                  O.jsx("defs", {
                    children: O.jsxs("linearGradient", {
                      id: "whiteRedBtnGradient",
                      x1: "0",
                      y1: "0",
                      x2: "24",
                      y2: "0",
                      gradientUnits: "userSpaceOnUse",
                      children: [
                        O.jsx("stop", { stopColor: "#fff" }),
                        O.jsx("stop", { offset: "1", stopColor: "#064e3b" }),
                      ],
                    }),
                  }),
                  O.jsx("path", {
                    d: "M23 3a10.9 10.9 0 0 1-3.14 1.53A4.48 4.48 0 0 0 22.4 1.64a9.09 9.09 0 0 1-2.88 1.1A4.48 4.48 0 0 0 16.5 0c-2.5 0-4.5 2.01-4.5 4.5 0 .35.04.7.1 1.03C7.69 5.4 4.07 3.67 1.64 1.15c-.38.65-.6 1.4-.6 2.2 0 1.52.77 2.86 1.95 3.65A4.48 4.48 0 0 1 .96 6v.06c0 2.13 1.52 3.91 3.54 4.31-.37.1-.76.16-1.16.16-.28 0-.55-.03-.81-.08.55 1.72 2.16 2.97 4.07 3A9.05 9.05 0 0 1 0 19.54 12.8 12.8 0 0 0 6.92 21c8.28 0 12.81-6.86 12.81-12.81 0-.2 0-.39-.01-.58A9.22 9.22 0 0 0 23 3z",
                  }),
                ],
              }),
              "X (Twitter)",
            ],
          }),
          O.jsxs(Be.a, {
            className: "community-link-btn",
            href: "https://t.me/paulinu_plasma",
            target: "_blank",
            rel: "noopener noreferrer",
            initial: { opacity: 0 },
            whileInView: { opacity: 1 },
            viewport: { once: !0, amount: 0.5 },
            transition: { duration: 0.5, delay: 0.42, ease: "easeOut" },
            children: [
              O.jsxs("svg", {
                width: "20",
                height: "20",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "url(#whiteRedBtnGradient)",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                style: { opacity: 0.9 },
                children: [
                  O.jsx("defs", {
                    children: O.jsxs("linearGradient", {
                      id: "whiteRedBtnGradient",
                      x1: "0",
                      y1: "0",
                      x2: "20",
                      y2: "0",
                      gradientUnits: "userSpaceOnUse",
                      children: [
                        O.jsx("stop", { stopColor: "#fff" }),
                        O.jsx("stop", { offset: "1", stopColor: "#064e3b" }),
                      ],
                    }),
                  }),
                  O.jsx("path", { d: "M22 2L11 13" }),
                  O.jsx("path", { d: "M22 2L15 22L11 13L2 9L22 2Z" }),
                ],
              }),
              "Telegram",
            ],
          }),
        ],
      }),
      O.jsxs("footer", {
        className: "community-footer",
        children: [
          O.jsxs("div", {
            className: "community-footer-col community-footer-logo-section",
            children: [
              O.jsxs("div", {
                className: "community-footer-logo",
                style: { color: "#18191c" },
                children: [
                  O.jsx("img", {
                    src: "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/bd16ebd32caee97543484bec8e7922a8.png",
                    alt: "$PAUL Logo",
                    style: { width: 32, height: 32, borderRadius: "50%" },
                  }),
                  "$PAUL INU",
                ],
              }),
              O.jsx("div", {
                style: {
                  color: "#18191c",
                  fontSize: "1rem",
                  margin: "0.7vw 0 0 0",
                  fontStyle: "italic",
                  fontWeight: 700,
                },
                children: "The OG dog meme. Before DOGE. Before SHIB.",
              }),
              O.jsxs("div", {
                className: "community-footer-socials",
                children: [
                  O.jsx("a", {
                    href: "https://x.com/paulinu_plasma",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    "aria-label": "X (Twitter)",
                    children: O.jsx("svg", {
                      width: "28",
                      height: "28",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "#18191c",
                      strokeWidth: "2",
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      style: { opacity: 0.9 },
                      children: O.jsx("path", {
                        d: "M23 3a10.9 10.9 0 0 1-3.14 1.53A4.48 4.48 0 0 0 22.4 1.64a9.09 9.09 0 0 1-2.88 1.1A4.48 4.48 0 0 0 16.5 0c-2.5 0-4.5 2.01-4.5 4.5 0 .35.04.7.1 1.03C7.69 5.4 4.07 3.67 1.64 1.15c-.38.65-.6 1.4-.6 2.2 0 1.52.77 2.86 1.95 3.65A4.48 4.48 0 0 1 .96 6v.06c0 2.13 1.52 3.91 3.54 4.31-.37.1-.76.16-1.16.16-.28 0-.55-.03-.81-.08.55 1.72 2.16 2.97 4.07 3A9.05 9.05 0 0 1 0 19.54 12.8 12.8 0 0 0 6.92 21c8.28 0 12.81-6.86 12.81-12.81 0-.2 0-.39-.01-.58A9.22 9.22 0 0 0 23 3z",
                      }),
                    }),
                  }),
                  O.jsx("a", {
                    href: "https://t.me/paulinu_plasma",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    "aria-label": "Telegram",
                    children: O.jsxs("svg", {
                      width: "28",
                      height: "28",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "#18191c",
                      strokeWidth: "2",
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      style: { opacity: 0.9 },
                      children: [
                        O.jsx("path", { d: "M22 2L11 13" }),
                        O.jsx("path", { d: "M22 2L15 22L11 13L2 9L22 2Z" }),
                      ],
                    }),
                  }),
                ],
              }),
            ],
          }),
          O.jsxs("div", {
            className: "community-footer-links-container",
            children: [
              O.jsxs("div", {
                className: "community-footer-col",
                children: [
                  O.jsx("div", {
                    className: "community-footer-title",
                    children: "Quick Links",
                  }),
                  O.jsxs("div", {
                    className: "community-footer-links",
                    children: [
                      O.jsx("a", { href: "#home", children: "Home" }),
                      O.jsx("a", { href: "#about", children: "About" }),
                      O.jsx("a", {
                        href: "#tokenomics",
                        children: "Tokenomics",
                      }),
                      O.jsx("a", { href: "#community", children: "Community" }),
                    ],
                  }),
                ],
              }),
              O.jsxs("div", {
                className: "community-footer-col",
                children: [
                  O.jsx("div", {
                    className: "community-footer-title",
                    children: "Resources",
                  }),
                  O.jsxs("div", {
                    className: "community-footer-links",
                    children: [
                      // O.jsxs("a", {
                      //   href: "https://app.uniswap.org/#/swap?inputCurrency=eth&outputCurrency=0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
                      //   target: "_blank",
                      //   rel: "noopener noreferrer",
                      //   children: [
                      //     "Uniswap ",
                      //     O.jsx("span", {
                      //       style: { fontSize: "1rem" },
                      //       children: "",
                      //     }),
                      //   ],
                      // }),
                      // O.jsxs("a", {
                      //   href: "https://etherscan.io/address/0xba51f92DCfe6E771E1Cb9428e0B6897c39bAF718",
                      //   target: "_blank",
                      //   rel: "noopener noreferrer",
                      //   children: [
                      //     "Etherscan ",
                      //     O.jsx("span", {
                      //       style: { fontSize: "1rem" },
                      //       children: "",
                      //     }),
                      //   ],
                      // }),
                      O.jsx("a", {
                        href: "#",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        children: "FAQ (Coming Soon)",
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    ],
  });
}
function KV() {
  return O.jsxs("footer", {
    className: "taiki-footer-glass",
    style: {
      width: "100%",
      margin: "0 auto",
      padding: "0",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      borderTop: "1px solid #222",
      marginTop: "2vw",
    },
    children: [
      O.jsx("style", {
        children: `
        .taiki-footer-glass {
          width: 100%;
          max-width: 1200px;
          margin: 2vw auto 0 auto;
          border-radius: 24px;
          background: #18191c;
          box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.18);
          border: 1.5px solid rgba(255, 255, 255, 0.12);
          overflow: hidden;
          padding: 2vw 0 0 0;
        }
        .taiki-footer-main {
          color: #fff;
          font-size: 1.08rem;
          text-align: center;
          margin: 2vw auto 0 auto;
          font-weight: 400;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 0.5em;
        }
        .taiki-footer-heart {
          color: #2cb979;
          font-size: 1.1em;
          vertical-align: middle;
          margin: 0 0.2em;
          display: inline-block;
          animation: heart-pulse 1.6s infinite;
          animation-timing-function: ease-in-out;
        }
        .taiki-footer-disclaimer {
          color: #888;
          font-size: 0.98rem;
          text-align: center;
          margin: 1vw auto 2vw auto;
          max-width: 900px;
          line-height: 1.5;
        }
        @keyframes heart-pulse {
          0% { transform: scale(1); opacity: 0.8; }
          50% { transform: scale(1.18); opacity: 1; }
          100% { transform: scale(1); opacity: 0.8; }
        }
        @media (max-width: 900px) {
          .taiki-footer-glass {
            border-radius: 12px;
            padding: 4vw 0 0 0;
          }
          .taiki-footer-main {
            font-size: 0.98rem;
            margin: 4vw auto 0 auto;
            flex-direction: column;
            gap: 0.3em;
          }
          .taiki-footer-disclaimer {
            font-size: 0.85rem;
            margin: 2vw auto 4vw auto;
            padding: 0 2vw;
          }
        }
        .footer-asian-link {
          color: #2cb979;
          font-weight: 700;
          text-decoration: none;
          transition: color 0.18s cubic-bezier(.4,0,.2,1);
        }
        .footer-asian-link:hover {
          color: #fff;
        }
      `,
      }),
      O.jsxs("div", {
        className: "taiki-footer-main",
        children: [
          O.jsx("span", { style: { color: "#2cb979" }, children: "" }),
          O.jsx("span", {
            style: { color: "#fff", margin: "0 0.3em 0 0.7em" },
            children: "2025 PAUL Token. All rights reserved.",
          }),
          O.jsx("span", {
            style: { color: "#2cb979", margin: "0 0.7em" },
            children: "|",
          }),
          O.jsxs("span", {
            style: {
              display: "inline-flex",
              alignItems: "center",
              gap: "0.3em",
            },
            children: [
              "This Website is Crafted with",
              O.jsx("span", {
                className: "taiki-footer-heart",
                role: "img",
                "aria-label": "heart",
                style: {
                  display: "inline-flex",
                  alignItems: "center",
                  verticalAlign: "middle",
                  margin: "0 0.1em",
                },
                children: O.jsx("svg", {
                  width: "18",
                  height: "18",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "#2cb979",
                  strokeWidth: "2.2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  style: { display: "inline", verticalAlign: "middle" },
                  children: O.jsx("path", {
                    d: "M12 21C12 21 4 13.5 4 8.5C4 5.42 6.42 3 9.5 3C11.24 3 12.91 3.81 14 5.08C15.09 3.81 16.76 3 18.5 3C21.58 3 24 5.42 24 8.5C24 13.5 16 21 16 21H12Z",
                  }),
                }),
              }),
              "by the ",
              O.jsx("span", {
                style: {
                  display: "inline-flex",
                  alignItems: "center",
                  justifyContent: "center",
                  width: "28px",
                  height: "28px",
                  background: "#fff",
                  borderRadius: "50%",
                  marginRight: "0.3em",
                  boxShadow: "0 2px 8px #0002",
                },
                children: O.jsx("img", {
                  src: "/asiannetlabs.com/assets/img/home.png",
                  alt: "Asian Net Labs Logo",
                  style: {
                    width: "22px",
                    height: "22px",
                    borderRadius: "50%",
                    objectFit: "cover",
                    display: "block",
                  },
                }),
              }),
              O.jsx("a", {
                href: "https://asiannetlabs.com",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "footer-asian-link",
                children: "Asian Net Labs",
              }),
              ".",
            ],
          }),
        ],
      }),
      O.jsx("div", {
        className: "taiki-footer-disclaimer",
        style: { color: "#fff" },
        children:
          "$PAUL is a decentralized meme experiment with no intrinsic value or expectation of financial return. It's for the culture, the lulz, and the nostalgia. Always do your own research (DYOR) and never invest more than you're willing to lose. This is Web3, have fun responsibly.",
      }),
      O.jsx("div", {
        style: { textAlign: "center", marginTop: "2vw", marginBottom: "2vw" },
        children: O.jsx("a", {
          href: "#home",
          style: {
            color: "#2cb979",
            textDecoration: "none",
            fontSize: "0.9rem",
            fontWeight: "600",
            transition: "color 0.3s ease",
          },
          onMouseEnter: (i) => (i.target.style.color = "#fff"),
          onMouseLeave: (i) => (i.target.style.color = "#2cb979"),
          children: " Back to Top",
        }),
      }),
    ],
  });
}
const JV =
  "/storage.googleapis.com/hostinger-horizons-assets-prod/fb94375d-7828-4d1f-b190-7e0a55b32ffc/bd16ebd32caee97543484bec8e7922a8.png";
function ZV({ onFinish: i }) {
  const [t, e] = bt.useState(1);
  return (
    bt.useEffect(() => {
      let n = Date.now(),
        a;
      function r() {
        const l = Date.now() - n,
          u = Math.min(1, l / 5e3);
        e(Math.round(1 + u * 99)),
          u < 1 ? (a = requestAnimationFrame(r)) : i && i();
      }
      return r(), () => a && cancelAnimationFrame(a);
    }, [i]),
    O.jsxs("div", {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        background:
          "linear-gradient(90deg, #99ffd1 0%, #70e6b1 20%, #4cc28c 40%, #27875b 70%, #18191c 100%)",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 9999,
        transition: "opacity 0.5s",
      },
      children: [
        O.jsx(Be.img, {
          src: JV,
          alt: "$PAUL Logo",
          style: {
            width: 90,
            height: 90,
            borderRadius: "50%",
            boxShadow: "0 0 2vw 0.5vw #ffb84c55",
            background: "#18191c",
            marginBottom: 24,
          },
          animate: { scale: [1, 1.15, 1] },
          transition: { duration: 0.9, repeat: 1 / 0, ease: "easeInOut" },
        }),
        O.jsxs("div", {
          style: {
            fontSize: 22,
            fontWeight: 700,
            color: "#000",
            letterSpacing: 1,
          },
          children: ["Loading... ", t, "%"],
        }),
      ],
    })
  );
}
const QV = () => {
  const [i, t] = bt.useState(!0),
    e = () => t(!1);
  return O.jsxs(O.Fragment, {
    children: [
      i && O.jsx(ZV, { onFinish: e }),
      !i &&
        O.jsxs(O.Fragment, {
          children: [
            O.jsx(NV, {}),
            O.jsx(UV, {}),
            O.jsx(zV, {}),
            O.jsx(LV, {}),
            O.jsx(GV, {}),
            O.jsx(jV, {}),
            O.jsx(YV, {}),
            O.jsx(qV, {}),
            O.jsx(KV, {}),
          ],
        }),
    ],
  });
};
j2.createRoot(document.getElementById("root")).render(
  O.jsx(bt.StrictMode, { children: O.jsx(QV, {}) })
);
